[
  {
    "name": "archive/tar",
    "desc": "Package tar implements access to tar archives.  Tape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools.",
    "functions": [
      {
        "name": "Benchmark",
        "desc": ""
      },
      {
        "name": "FileInfoHeader",
        "desc": "FileInfoHeader creates a partially-populated [Header] from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name.  Since fs.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file.  If fi implements [FileInfoNames] Header.Gname and Header.Uname are provided by the methods of the interface."
      },
      {
        "name": "FuzzReader",
        "desc": ""
      },
      {
        "name": "TestDisableInsecurePathCheck",
        "desc": ""
      },
      {
        "name": "TestFileInfoHeader",
        "desc": ""
      },
      {
        "name": "TestFileInfoHeaderDir",
        "desc": ""
      },
      {
        "name": "TestFileInfoHeaderSymlink",
        "desc": ""
      },
      {
        "name": "TestFileInfoHeaderUseFileInfoNames",
        "desc": ""
      },
      {
        "name": "TestFileReader",
        "desc": ""
      },
      {
        "name": "TestFileWriter",
        "desc": ""
      },
      {
        "name": "TestFitsInBase256",
        "desc": ""
      },
      {
        "name": "TestFitsInOctal",
        "desc": ""
      },
      {
        "name": "TestFormatNumeric",
        "desc": ""
      },
      {
        "name": "TestFormatPAXRecord",
        "desc": ""
      },
      {
        "name": "TestFormatPAXTime",
        "desc": ""
      },
      {
        "name": "TestHeaderAllowedFormats",
        "desc": ""
      },
      {
        "name": "TestHeaderRoundTrip",
        "desc": ""
      },
      {
        "name": "TestInsecurePaths",
        "desc": ""
      },
      {
        "name": "TestIssue12594",
        "desc": "TestIssue12594 tests that the Writer does not attempt to populate the prefix field when encoding a header in the GNU format. The prefix field is valid in USTAR and PAX, but not GNU."
      },
      {
        "name": "TestMergePAX",
        "desc": ""
      },
      {
        "name": "TestParseNumeric",
        "desc": ""
      },
      {
        "name": "TestParsePAX",
        "desc": ""
      },
      {
        "name": "TestParsePAXRecord",
        "desc": ""
      },
      {
        "name": "TestParsePAXTime",
        "desc": ""
      },
      {
        "name": "TestPartialRead",
        "desc": ""
      },
      {
        "name": "TestPax",
        "desc": ""
      },
      {
        "name": "TestPaxHeadersSorted",
        "desc": ""
      },
      {
        "name": "TestPaxNonAscii",
        "desc": ""
      },
      {
        "name": "TestPaxSymlink",
        "desc": ""
      },
      {
        "name": "TestPaxXattrs",
        "desc": ""
      },
      {
        "name": "TestReadGNUSparsePAXHeaders",
        "desc": ""
      },
      {
        "name": "TestReadHeaderOnly",
        "desc": "TestReadHeaderOnly tests that Reader does not attempt to read special header-only files."
      },
      {
        "name": "TestReadOldGNUSparseMap",
        "desc": ""
      },
      {
        "name": "TestReadTruncation",
        "desc": "TestReadTruncation test the ending condition on various truncated files and that truncated files are still detected even if the underlying io.Reader satisfies io.Seeker."
      },
      {
        "name": "TestReader",
        "desc": ""
      },
      {
        "name": "TestRoundTrip",
        "desc": ""
      },
      {
        "name": "TestSparseEntries",
        "desc": ""
      },
      {
        "name": "TestSplitUSTARPath",
        "desc": ""
      },
      {
        "name": "TestUSTARLongName",
        "desc": ""
      },
      {
        "name": "TestUninitializedRead",
        "desc": ""
      },
      {
        "name": "TestValidTypeflagWithPAXHeader",
        "desc": ""
      },
      {
        "name": "TestWriteLongHeader",
        "desc": ""
      },
      {
        "name": "TestWriter",
        "desc": ""
      },
      {
        "name": "TestWriterAddFS",
        "desc": ""
      },
      {
        "name": "TestWriterAddFSNonRegularFiles",
        "desc": ""
      },
      {
        "name": "TestWriterErrors",
        "desc": ""
      },
      {
        "name": "blockPadding",
        "desc": "blockPadding computes the number of bytes needed to pad offset up to the nearest block edge where 0 \u003c= n \u003c blockSize."
      },
      {
        "name": "bytediff",
        "desc": ""
      },
      {
        "name": "discard",
        "desc": "discard skips n bytes in r, reporting an error if unable to do so."
      },
      {
        "name": "ensureEOF",
        "desc": "ensureEOF checks whether r is at EOF, reporting ErrWriteTooLong if not so."
      },
      {
        "name": "fitsInBase256",
        "desc": "fitsInBase256 reports whether x can be encoded into n bytes using base-256 encoding. Unlike octal encoding, base-256 encoding does not require that the string ends with a NUL character. Thus, all n bytes are available for output.  If operating in binary mode, this assumes strict GNU binary mode; which means that the first byte can only be either 0x80 or 0xff. Thus, the first byte is equivalent to the sign bit in two's complement form."
      },
      {
        "name": "fitsInOctal",
        "desc": "fitsInOctal reports whether the integer x fits in a field n-bytes long using octal encoding with the appropriate NUL terminator."
      },
      {
        "name": "formatPAXRecord",
        "desc": "formatPAXRecord formats a single PAX record, prefixing it with the appropriate length."
      },
      {
        "name": "formatPAXTime",
        "desc": "formatPAXTime converts ts into a time of the form %d.%d as described in the PAX specification. This function is capable of negative timestamps."
      },
      {
        "name": "hasNUL",
        "desc": "hasNUL reports whether the NUL character exists within s."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "isASCII",
        "desc": "isASCII reports whether the input is an ASCII C-style string."
      },
      {
        "name": "isHeaderOnlyType",
        "desc": "isHeaderOnlyType checks if the given type flag is of the type that has no data section even if a size is specified."
      },
      {
        "name": "mergePAX",
        "desc": "mergePAX merges paxHdrs into hdr for all relevant fields of Header."
      },
      {
        "name": "mustReadFull",
        "desc": "mustReadFull is like io.ReadFull except it returns io.ErrUnexpectedEOF when io.EOF is hit before len(b) bytes are read."
      },
      {
        "name": "parsePAX",
        "desc": "parsePAX parses PAX headers. If an extended header (type 'x') is invalid, ErrHeader is returned."
      },
      {
        "name": "parsePAXRecord",
        "desc": "parsePAXRecord parses the input PAX record string into a key-value pair. If parsing is successful, it will slice off the currently read record and return the remainder as r."
      },
      {
        "name": "parsePAXTime",
        "desc": "parsePAXTime takes a string of the form %d.%d as described in the PAX specification. Note that this implementation allows for negative timestamps, which is allowed for by the PAX specification, but not always portable."
      },
      {
        "name": "readGNUSparseMap0x1",
        "desc": "readGNUSparseMap0x1 reads the sparse map as stored in GNU's PAX sparse format version 0.1. The sparse map is stored in the PAX headers."
      },
      {
        "name": "readGNUSparseMap1x0",
        "desc": "readGNUSparseMap1x0 reads the sparse map as stored in GNU's PAX sparse format version 1.0. The format of the sparse map consists of a series of newline-terminated numeric fields. The first field is the number of entries and is always present. Following this are the entries, consisting of two fields (offset, length). This function must stop reading at the end boundary of the block containing the last newline.  Note that the GNU manual says that numeric values should be encoded in octal format. However, the GNU tar utility itself outputs these values in decimal. As such, this library treats values as being encoded in decimal."
      },
      {
        "name": "readSpecialFile",
        "desc": "readSpecialFile is like io.ReadAll except it returns ErrFieldTooLong if more than maxSpecialFileSize is read."
      },
      {
        "name": "splitUSTARPath",
        "desc": "splitUSTARPath splits a path according to USTAR prefix and suffix rules. If the path is not splittable, then it will return (\"\", \"\", false)."
      },
      {
        "name": "statAtime",
        "desc": ""
      },
      {
        "name": "statCtime",
        "desc": ""
      },
      {
        "name": "statUnix",
        "desc": ""
      },
      {
        "name": "toASCII",
        "desc": "toASCII converts the input to an ASCII C-style string. This is a best effort conversion, so invalid characters are dropped."
      },
      {
        "name": "tryReadFull",
        "desc": "tryReadFull is like io.ReadFull except it returns io.EOF when it is hit before len(b) bytes are read."
      },
      {
        "name": "validPAXRecord",
        "desc": "validPAXRecord reports whether the key-value pair is valid where each record is formatted as:  \t\"%d %s=%s\\n\" % (size, key, value)  Keys and values should be UTF-8, but the number of bad writers out there forces us to be a more liberal. Thus, we only reject all keys with NUL, and only reject NULs in values for the PAX version of the USTAR string fields. The key must not contain an '=' character."
      },
      {
        "name": "validateSparseEntries",
        "desc": "validateSparseEntries reports whether sp is a valid sparse map. It does not matter whether sp represents data fragments or hole fragments."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "has",
        "desc": ""
      },
      {
        "name": "mayBe",
        "desc": ""
      },
      {
        "name": "mayOnlyBe",
        "desc": ""
      },
      {
        "name": "mustNotBe",
        "desc": ""
      },
      {
        "name": "FileInfo",
        "desc": "FileInfo returns an fs.FileInfo for the Header."
      },
      {
        "name": "allowedFormats",
        "desc": "allowedFormats determines which formats can be used. The value returned is the logical OR of multiple possible formats. If the value is FormatUnknown, then the input Header cannot be encoded and an error is returned explaining why.  As a by-product of checking the fields, this function returns paxHdrs, which contain all fields that could not be directly encoded. A value receiver ensures that this method does not mutate the source Header."
      },
      {
        "name": "Next",
        "desc": "Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded. At the end of the archive, Next returns the error io.EOF.  If Next encounters a non-local name (as defined by [filepath.IsLocal]) and the GODEBUG environment variable contains `tarinsecurepath=0`, Next returns the header with an [ErrInsecurePath] error. A future version of Go may introduce this behavior by default. Programs that want to accept non-local names can ignore the [ErrInsecurePath] error and use the returned header."
      },
      {
        "name": "Read",
        "desc": "Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until [Next] is called to advance to the next file.  If the current file is sparse, then the regions marked as a hole are read back as NUL-bytes.  Calling Read on special types like [TypeLink], [TypeSymlink], [TypeChar], [TypeBlock], [TypeDir], and [TypeFifo] returns (0, [io.EOF]) regardless of what the [Header.Size] claims."
      },
      {
        "name": "handleRegularFile",
        "desc": "handleRegularFile sets up the current file reader and padding such that it can only read the following logical data section. It will properly handle special headers that contain no data section."
      },
      {
        "name": "handleSparseFile",
        "desc": "handleSparseFile checks if the current file is a sparse format of any type and sets the curr reader appropriately."
      },
      {
        "name": "next",
        "desc": ""
      },
      {
        "name": "readGNUSparsePAXHeaders",
        "desc": "readGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers. If they are found, then this function reads the sparse map and returns it. This assumes that 0.0 headers have already been converted to 0.1 headers by the PAX header parsing logic."
      },
      {
        "name": "readHeader",
        "desc": "readHeader reads the next block header and assumes that the underlying reader is already aligned to a block boundary. It returns the raw block of the header in case further processing is required.  The err will be set to io.EOF only when one of the following occurs:   - Exactly 0 bytes are read and EOF is hit.   - Exactly 1 block of zeros is read and EOF is hit.   - At least 2 blocks of zeros are read."
      },
      {
        "name": "readOldGNUSparseMap",
        "desc": "readOldGNUSparseMap reads the sparse map from the old GNU sparse format. The sparse map is stored in the tar header if it's small enough. If it's larger than four entries, then one or more extension headers are used to store the rest of the sparse map.  The Header.Size does not reflect the size of any extended headers used. Thus, this function will read from the raw io.Reader to fetch extra headers. This method mutates blk in the process."
      },
      {
        "name": "writeTo",
        "desc": "writeTo writes the content of the current file to w. The bytes written matches the number of remaining bytes in the current file.  If the current file is sparse and w is an io.WriteSeeker, then writeTo uses Seek to skip past holes defined in Header.SparseHoles, assuming that skipped regions are filled with NULs. This always writes the last byte to ensure w is the right size.  TODO(dsnet): Re-export this when adding sparse file support. See https://golang.org/issue/22735"
      },
      {
        "name": "AddFS",
        "desc": "AddFS adds the files from fs.FS to the archive. It walks the directory tree starting at the root of the filesystem adding each file to the tar archive while maintaining the directory structure."
      },
      {
        "name": "Close",
        "desc": "Close closes the tar archive by flushing the padding, and writing the footer. If the current file (from a prior call to [Writer.WriteHeader]) is not fully written, then this returns an error."
      },
      {
        "name": "Flush",
        "desc": "Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called.  This is unnecessary as the next call to [Writer.WriteHeader] or [Writer.Close] will implicitly flush out the file's padding."
      },
      {
        "name": "Write",
        "desc": "Write writes to the current file in the tar archive. Write returns the error [ErrWriteTooLong] if more than Header.Size bytes are written after [Writer.WriteHeader].  Calling Write on special types like [TypeLink], [TypeSymlink], [TypeChar], [TypeBlock], [TypeDir], and [TypeFifo] returns (0, [ErrWriteTooLong]) regardless of what the [Header.Size] claims."
      },
      {
        "name": "WriteHeader",
        "desc": "WriteHeader writes hdr and prepares to accept the file's contents. The Header.Size determines how many bytes can be written for the next file. If the current file is not fully written, then this returns an error. This implicitly flushes any padding necessary before writing the header."
      },
      {
        "name": "readFrom",
        "desc": "readFrom populates the content of the current file by reading from r. The bytes read must match the number of remaining bytes in the current file.  If the current file is sparse and r is an io.ReadSeeker, then readFrom uses Seek to skip past holes defined in Header.SparseHoles, assuming that skipped regions are all NULs. This always reads the last byte to ensure r is the right size.  TODO(dsnet): Re-export this when adding sparse file support. See https://golang.org/issue/22735"
      },
      {
        "name": "templateV7Plus",
        "desc": "templateV7Plus fills out the V7 fields of a block using values from hdr. It also fills out fields (uname, gname, devmajor, devminor) that are shared in the USTAR, PAX, and GNU formats using the provided formatters.  The block returned is only valid until the next call to templateV7Plus or writeRawFile."
      },
      {
        "name": "writeGNUHeader",
        "desc": ""
      },
      {
        "name": "writePAXHeader",
        "desc": ""
      },
      {
        "name": "writeRawFile",
        "desc": "writeRawFile writes a minimal file with the given name and flag type. It uses format to encode the header format and will write data as the body. It uses default values for all of the other fields (as BSD and GNU tar does)."
      },
      {
        "name": "writeRawHeader",
        "desc": "writeRawHeader writes the value of blk, regardless of its value. It sets up the Writer such that it can accept a file of the given size. If the flag is a special header-only flag, then the size is treated as zero."
      },
      {
        "name": "writeUSTARHeader",
        "desc": ""
      },
      {
        "name": "computeChecksum",
        "desc": "computeChecksum computes the checksum for the header block. POSIX specifies a sum of the unsigned byte values, but the Sun tar used signed byte values. We compute and return both."
      },
      {
        "name": "getFormat",
        "desc": "getFormat checks that the block is a valid tar header based on the checksum. It then attempts to guess the specific format based on magic values. If the checksum fails, then FormatUnknown is returned."
      },
      {
        "name": "reset",
        "desc": "reset clears the block with all zeros."
      },
      {
        "name": "setFormat",
        "desc": "setFormat writes the magic values necessary for specified format and then updates the checksum accordingly."
      },
      {
        "name": "toGNU",
        "desc": ""
      },
      {
        "name": "toSTAR",
        "desc": ""
      },
      {
        "name": "toSparse",
        "desc": ""
      },
      {
        "name": "toUSTAR",
        "desc": ""
      },
      {
        "name": "toV7",
        "desc": "Convert block to any number of formats."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Gname",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Uname",
        "desc": ""
      },
      {
        "name": "formatNumeric",
        "desc": "formatNumeric encodes x into b using base-8 (octal) encoding if possible. Otherwise it will attempt to use base-256 (binary) encoding."
      },
      {
        "name": "formatOctal",
        "desc": ""
      },
      {
        "name": "formatString",
        "desc": "formatString copies s into b, NUL-terminating if possible."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": "Mode returns the permission and mode bits for the headerFileInfo."
      },
      {
        "name": "Name",
        "desc": "Name returns the base name of the file."
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "accessTime",
        "desc": ""
      },
      {
        "name": "changeTime",
        "desc": ""
      },
      {
        "name": "devMajor",
        "desc": ""
      },
      {
        "name": "devMinor",
        "desc": ""
      },
      {
        "name": "groupName",
        "desc": ""
      },
      {
        "name": "magic",
        "desc": ""
      },
      {
        "name": "realSize",
        "desc": ""
      },
      {
        "name": "sparse",
        "desc": ""
      },
      {
        "name": "userName",
        "desc": ""
      },
      {
        "name": "v7",
        "desc": ""
      },
      {
        "name": "version",
        "desc": ""
      },
      {
        "name": "accessTime",
        "desc": ""
      },
      {
        "name": "changeTime",
        "desc": ""
      },
      {
        "name": "devMajor",
        "desc": ""
      },
      {
        "name": "devMinor",
        "desc": ""
      },
      {
        "name": "groupName",
        "desc": ""
      },
      {
        "name": "magic",
        "desc": ""
      },
      {
        "name": "prefix",
        "desc": ""
      },
      {
        "name": "trailer",
        "desc": ""
      },
      {
        "name": "userName",
        "desc": ""
      },
      {
        "name": "v7",
        "desc": ""
      },
      {
        "name": "version",
        "desc": ""
      },
      {
        "name": "devMajor",
        "desc": ""
      },
      {
        "name": "devMinor",
        "desc": ""
      },
      {
        "name": "groupName",
        "desc": ""
      },
      {
        "name": "magic",
        "desc": ""
      },
      {
        "name": "prefix",
        "desc": ""
      },
      {
        "name": "userName",
        "desc": ""
      },
      {
        "name": "v7",
        "desc": ""
      },
      {
        "name": "version",
        "desc": ""
      },
      {
        "name": "chksum",
        "desc": ""
      },
      {
        "name": "gid",
        "desc": ""
      },
      {
        "name": "linkName",
        "desc": ""
      },
      {
        "name": "modTime",
        "desc": ""
      },
      {
        "name": "mode",
        "desc": ""
      },
      {
        "name": "name",
        "desc": ""
      },
      {
        "name": "size",
        "desc": ""
      },
      {
        "name": "typeFlag",
        "desc": ""
      },
      {
        "name": "uid",
        "desc": ""
      },
      {
        "name": "parseNumeric",
        "desc": "parseNumeric parses the input as being encoded in either base-256 or octal. This function may return negative numbers. If parsing fails or an integer overflow occurs, err will be set."
      },
      {
        "name": "parseOctal",
        "desc": ""
      },
      {
        "name": "parseString",
        "desc": "parseString parses bytes as a NUL-terminated C-style string. If a NUL byte is not found then the whole slice is returned as a string."
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "WriteTo",
        "desc": ""
      },
      {
        "name": "logicalRemaining",
        "desc": "logicalRemaining implements fileState.logicalRemaining."
      },
      {
        "name": "physicalRemaining",
        "desc": "physicalRemaining implements fileState.physicalRemaining."
      },
      {
        "name": "ReadFrom",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "logicalRemaining",
        "desc": "logicalRemaining implements fileState.logicalRemaining."
      },
      {
        "name": "physicalRemaining",
        "desc": "physicalRemaining implements fileState.physicalRemaining."
      },
      {
        "name": "entry",
        "desc": ""
      },
      {
        "name": "isExtended",
        "desc": ""
      },
      {
        "name": "maxEntries",
        "desc": ""
      },
      {
        "name": "length",
        "desc": ""
      },
      {
        "name": "offset",
        "desc": ""
      },
      {
        "name": "endOffset",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "WriteTo",
        "desc": ""
      },
      {
        "name": "logicalRemaining",
        "desc": ""
      },
      {
        "name": "physicalRemaining",
        "desc": ""
      },
      {
        "name": "ReadFrom",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "logicalRemaining",
        "desc": ""
      },
      {
        "name": "physicalRemaining",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "FileInfoNames",
        "desc": "FileInfoNames extends [fs.FileInfo]. Passing an instance of this to [FileInfoHeader] permits the caller to avoid a system-dependent name lookup by specifying the Uname and Gname directly."
      },
      {
        "name": "Format",
        "desc": "Format represents the tar archive format.  The original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations.  The following table captures the capabilities of each format:  \t                  |  USTAR |       PAX |       GNU \t------------------+--------+-----------+---------- \tName              |   256B | unlimited | unlimited \tLinkname          |   100B | unlimited | unlimited \tSize              | uint33 | unlimited |    uint89 \tMode              | uint21 |    uint21 |    uint57 \tUid/Gid           | uint21 | unlimited |    uint57 \tUname/Gname       |    32B | unlimited |       32B \tModTime           | uint33 | unlimited |     int89 \tAccessTime        |    n/a | unlimited |     int89 \tChangeTime        |    n/a | unlimited |     int89 \tDevmajor/Devminor | uint21 |    uint21 |    uint57 \t------------------+--------+-----------+---------- \tstring encoding   |  ASCII |     UTF-8 |    binary \tsub-second times  |     no |       yes |        no \tsparse files      |     no |       yes |       yes  The table's upper portion shows the [Header] fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch).  The table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files.  The Writer currently provides no support for sparse files."
      },
      {
        "name": "Header",
        "desc": "A Header represents a single header in a tar archive. Some fields may not be populated.  For forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving."
      },
      {
        "name": "Reader",
        "desc": "Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data."
      },
      {
        "name": "Writer",
        "desc": "Writer provides sequential writing of a tar archive. [Writer.WriteHeader] begins a new file with the provided [Header], and then Writer can be treated as an io.Writer to supply that file's data."
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "failOnceWriter",
        "desc": "failOnceWriter fails exactly once and then always reports success."
      },
      {
        "name": "fileInfoNames",
        "desc": ""
      },
      {
        "name": "fileOps",
        "desc": ""
      },
      {
        "name": "fileReader",
        "desc": ""
      },
      {
        "name": "fileState",
        "desc": "fileState tracks the number of logical (includes sparse holes) and physical (actual in tar archive) bytes remaining for the current file.  Invariant: logicalRemaining \u003e= physicalRemaining"
      },
      {
        "name": "fileWriter",
        "desc": ""
      },
      {
        "name": "formatter",
        "desc": ""
      },
      {
        "name": "headerError",
        "desc": ""
      },
      {
        "name": "headerFileInfo",
        "desc": "headerFileInfo implements fs.FileInfo."
      },
      {
        "name": "headerGNU",
        "desc": ""
      },
      {
        "name": "headerRoundTripTest",
        "desc": ""
      },
      {
        "name": "headerSTAR",
        "desc": ""
      },
      {
        "name": "headerUSTAR",
        "desc": ""
      },
      {
        "name": "headerV7",
        "desc": ""
      },
      {
        "name": "numberFormatter",
        "desc": ""
      },
      {
        "name": "parser",
        "desc": ""
      },
      {
        "name": "readBadSeeker",
        "desc": ""
      },
      {
        "name": "readSeeker",
        "desc": ""
      },
      {
        "name": "reader",
        "desc": ""
      },
      {
        "name": "regFileReader",
        "desc": "regFileReader is a fileReader for reading data from a regular file entry."
      },
      {
        "name": "regFileWriter",
        "desc": "regFileWriter is a fileWriter for writing data to a regular file entry."
      },
      {
        "name": "sparseArray",
        "desc": ""
      },
      {
        "name": "sparseDatas",
        "desc": "A sparse file can be represented as either a sparseDatas or a sparseHoles. As long as the total size is known, they are equivalent and one can be converted to the other form and back. The various tar formats with sparse file support represent sparse files in the sparseDatas form. That is, they specify the fragments in the file that has data, and treat everything else as having zero bytes. As such, the encoding and decoding logic in this package deals with sparseDatas.  However, the external API uses sparseHoles instead of sparseDatas because the zero value of sparseHoles logically represents a normal file (i.e., there are no holes in it). On the other hand, the zero value of sparseDatas implies that the file has no data in it, which is rather odd.  As an example, if the underlying raw file contains the 10-byte data:  \tvar compactFile = \"abcdefgh\"  And the sparse map has the following entries:  \tvar spd sparseDatas = []sparseEntry{ \t\t{Offset: 2,  Length: 5},  // Data fragment for 2..6 \t\t{Offset: 18, Length: 3},  // Data fragment for 18..20 \t} \tvar sph sparseHoles = []sparseEntry{ \t\t{Offset: 0,  Length: 2},  // Hole fragment for 0..1 \t\t{Offset: 7,  Length: 11}, // Hole fragment for 7..17 \t\t{Offset: 21, Length: 4},  // Hole fragment for 21..24 \t}  Then the content of the resulting sparse file with a Header.Size of 25 is:  \tvar sparseFile = \"\\x00\"*2 + \"abcde\" + \"\\x00\"*11 + \"fgh\" + \"\\x00\"*4"
      },
      {
        "name": "sparseElem",
        "desc": ""
      },
      {
        "name": "sparseEntry",
        "desc": "sparseEntry represents a Length-sized fragment at Offset in the file."
      },
      {
        "name": "sparseFileReader",
        "desc": "sparseFileReader is a fileReader for reading data from a sparse file entry."
      },
      {
        "name": "sparseFileWriter",
        "desc": "sparseFileWriter is a fileWriter for writing data to a sparse file entry."
      },
      {
        "name": "sparseHoles",
        "desc": "A sparse file can be represented as either a sparseDatas or a sparseHoles. As long as the total size is known, they are equivalent and one can be converted to the other form and back. The various tar formats with sparse file support represent sparse files in the sparseDatas form. That is, they specify the fragments in the file that has data, and treat everything else as having zero bytes. As such, the encoding and decoding logic in this package deals with sparseDatas.  However, the external API uses sparseHoles instead of sparseDatas because the zero value of sparseHoles logically represents a normal file (i.e., there are no holes in it). On the other hand, the zero value of sparseDatas implies that the file has no data in it, which is rather odd.  As an example, if the underlying raw file contains the 10-byte data:  \tvar compactFile = \"abcdefgh\"  And the sparse map has the following entries:  \tvar spd sparseDatas = []sparseEntry{ \t\t{Offset: 2,  Length: 5},  // Data fragment for 2..6 \t\t{Offset: 18, Length: 3},  // Data fragment for 18..20 \t} \tvar sph sparseHoles = []sparseEntry{ \t\t{Offset: 0,  Length: 2},  // Hole fragment for 0..1 \t\t{Offset: 7,  Length: 11}, // Hole fragment for 7..17 \t\t{Offset: 21, Length: 4},  // Hole fragment for 21..24 \t}  Then the content of the resulting sparse file with a Header.Size of 25 is:  \tvar sparseFile = \"\\x00\"*2 + \"abcde\" + \"\\x00\"*11 + \"fgh\" + \"\\x00\"*4"
      },
      {
        "name": "stringFormatter",
        "desc": ""
      },
      {
        "name": "testError",
        "desc": ""
      },
      {
        "name": "testFile",
        "desc": "testFile is an io.ReadWriteSeeker where the IO operations performed on it must match the list of operations in ops."
      },
      {
        "name": "testNonEmptyReader",
        "desc": "testNonEmptyReader wraps an io.Reader and ensures that Read is never called with an empty buffer."
      },
      {
        "name": "testNonEmptyWriter",
        "desc": "testNonEmptyWriter wraps an io.Writer and ensures that Write is never called with an empty buffer."
      },
      {
        "name": "zeroReader",
        "desc": ""
      },
      {
        "name": "zeroWriter",
        "desc": "zeroWriter may only be written with NULs, otherwise it returns errWriteHole."
      }
    ]
  },
  {
    "name": "archive/zip",
    "desc": "",
    "functions": [
      {
        "name": "ExampleReader",
        "desc": ""
      },
      {
        "name": "ExampleWriter",
        "desc": ""
      },
      {
        "name": "ExampleWriter_RegisterCompressor",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "arena",
    "desc": "The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely. The purpose of this functionality is to improve efficiency: manually freeing memory before a garbage collection delays that cycle. Less frequent cycles means the CPU cost of the garbage collector is incurred less frequently.  This functionality in this package is mostly captured in the Arena type. Arenas allocate large chunks of memory for Go values, so they're likely to be inefficient for allocating only small amounts of small Go values. They're best used in bulk, on the order of MiB of memory allocated on each use.  Note that by allowing for this limited form of manual memory allocation that use-after-free bugs are possible with regular Go values. This package limits the impact of these use-after-free bugs by preventing reuse of freed memory regions until the garbage collector is able to determine that it is safe. Typically, a use-after-free bug will result in a fault and a helpful error message, but this package reserves the right to not force a fault on freed memory. That means a valid implementation of this package is to just allocate all memory the way the runtime normally would, and in fact, it reserves the right to occasionally do so for some Go values.",
    "functions": [
      {
        "name": "Clone",
        "desc": "Clone makes a shallow copy of the input value that is no longer bound to any arena it may have been allocated from, returning the copy. If it was not allocated from an arena, it is returned untouched. This function is useful to more easily let an arena-allocated value out-live its arena. T must be a pointer, a slice, or a string, otherwise this function will panic."
      },
      {
        "name": "MakeSlice",
        "desc": "MakeSlice creates a new []T with the provided capacity and length. The []T must not be used after the arena is freed. Accessing the underlying storage of the slice after free may result in a fault, but this fault is also not guaranteed."
      },
      {
        "name": "New",
        "desc": "New creates a new *T in the provided arena. The *T must not be used after the arena is freed. Accessing the value after free may result in a fault, but this fault is also not guaranteed."
      },
      {
        "name": "reflect_arena_New",
        "desc": ""
      },
      {
        "name": "runtime_arena_arena_Free",
        "desc": ""
      },
      {
        "name": "runtime_arena_arena_New",
        "desc": ""
      },
      {
        "name": "runtime_arena_arena_Slice",
        "desc": "Mark as noescape to avoid escaping the slice header."
      },
      {
        "name": "runtime_arena_heapify",
        "desc": ""
      },
      {
        "name": "runtime_arena_newArena",
        "desc": ""
      },
      {
        "name": "Free",
        "desc": "Free frees the arena (and all objects allocated from the arena) so that memory backing the arena can be reused fairly quickly without garbage collection overhead. Applications must not call any method on this arena after it has been freed."
      }
    ],
    "types": [
      {
        "name": "Arena",
        "desc": "Arena represents a collection of Go values allocated and freed together. Arenas are useful for improving efficiency as they may be freed back to the runtime manually, though any memory obtained from freed arenas must not be accessed once that happens. An Arena is automatically freed once it is no longer referenced, so it must be kept alive (see runtime.KeepAlive) until any memory allocated from it is no longer needed.  An Arena must never be used concurrently by multiple goroutines."
      }
    ]
  },
  {
    "name": "bufio",
    "desc": "Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.",
    "functions": [
      {
        "name": "ScanBytes",
        "desc": "ScanBytes is a split function for a [Scanner] that returns each byte as a token."
      },
      {
        "name": "ScanLines",
        "desc": "ScanLines is a split function for a [Scanner] that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\\r?\\n`. The last non-empty line of input will be returned even if it has no newline."
      },
      {
        "name": "ScanRunes",
        "desc": "ScanRunes is a split function for a [Scanner] that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors."
      },
      {
        "name": "ScanWords",
        "desc": "ScanWords is a split function for a [Scanner] that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace."
      },
      {
        "name": "dropCR",
        "desc": "dropCR drops a terminal \\r from the data."
      },
      {
        "name": "isSpace",
        "desc": "isSpace reports whether the character is a Unicode white space character. We avoid dependency on the unicode package, but check validity of the implementation in the tests."
      },
      {
        "name": "Buffered",
        "desc": "Buffered returns the number of bytes that can be read from the current buffer."
      },
      {
        "name": "Discard",
        "desc": "Discard skips the next n bytes, returning the number of bytes discarded.  If Discard skips fewer than n bytes, it also returns an error. If 0 \u003c= n \u003c= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader."
      },
      {
        "name": "Peek",
        "desc": "Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If necessary, Peek will read more bytes into the buffer in order to make n bytes available. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is [ErrBufferFull] if n is larger than b's buffer size.  Calling Peek prevents a [Reader.UnreadByte] or [Reader.UnreadRune] call from succeeding until the next read operation."
      },
      {
        "name": "Read",
        "desc": "Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying [Reader], hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). If the underlying [Reader] can return a non-zero count with io.EOF, then this Read method can do so as well; see the [io.Reader] docs."
      },
      {
        "name": "ReadByte",
        "desc": "ReadByte reads and returns a single byte. If no byte is available, returns an error."
      },
      {
        "name": "ReadBytes",
        "desc": "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient."
      },
      {
        "name": "ReadLine",
        "desc": "ReadLine is a low-level line-reading primitive. Most callers should use [Reader.ReadBytes]('\\n') or [Reader.ReadString]('\\n') instead or use a [Scanner].  ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.  The text returned from ReadLine does not include the line end (\"\\r\\n\" or \"\\n\"). No indication or error is given if the input ends without a final line end. Calling [Reader.UnreadByte] after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine."
      },
      {
        "name": "ReadRune",
        "desc": "ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1."
      },
      {
        "name": "ReadSlice",
        "desc": "ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error [ErrBufferFull] if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use [Reader.ReadBytes] or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim."
      },
      {
        "name": "ReadString",
        "desc": "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient."
      },
      {
        "name": "Reset",
        "desc": "Reset discards any buffered data, resets all state, and switches the buffered reader to read from r. Calling Reset on the zero value of [Reader] initializes the internal buffer to the default size. Calling b.Reset(b) (that is, resetting a [Reader] to itself) does nothing."
      },
      {
        "name": "Size",
        "desc": "Size returns the size of the underlying buffer in bytes."
      },
      {
        "name": "UnreadByte",
        "desc": "UnreadByte unreads the last byte. Only the most recently read byte can be unread.  UnreadByte returns an error if the most recent method called on the [Reader] was not a read operation. Notably, [Reader.Peek], [Reader.Discard], and [Reader.WriteTo] are not considered read operations."
      },
      {
        "name": "UnreadRune",
        "desc": "UnreadRune unreads the last rune. If the most recent method called on the [Reader] was not a [Reader.ReadRune], [Reader.UnreadRune] returns an error. (In this regard it is stricter than [Reader.UnreadByte], which will unread the last byte from any read operation.)"
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo implements io.WriterTo. This may make multiple calls to the [Reader.Read] method of the underlying [Reader]. If the underlying reader supports the [Reader.WriteTo] method, this calls the underlying [Reader.WriteTo] without buffering."
      },
      {
        "name": "collectFragments",
        "desc": "collectFragments reads until the first occurrence of delim in the input. It returns (slice of full buffers, remaining bytes before delim, total number of bytes in the combined first two elements, error). The complete result is equal to `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a length of `totalLen`. The result is structured in this way to allow callers to minimize allocations and copies."
      },
      {
        "name": "fill",
        "desc": "fill reads a new chunk into the buffer."
      },
      {
        "name": "readErr",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "writeBuf",
        "desc": "writeBuf writes the [Reader]'s buffer to the writer."
      },
      {
        "name": "Buffer",
        "desc": "Buffer controls memory allocation by the Scanner. It sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The contents of the buffer are ignored.  The maximum token size must be less than the larger of max and cap(buf). If max \u003c= cap(buf), [Scanner.Scan] will use this buffer only and do no allocation.  By default, [Scanner.Scan] uses an internal buffer and sets the maximum token size to [MaxScanTokenSize].  Buffer panics if it is called after scanning has started."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns the most recent token generated by a call to [Scanner.Scan]. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation."
      },
      {
        "name": "Err",
        "desc": "Err returns the first non-EOF error that was encountered by the [Scanner]."
      },
      {
        "name": "ErrOrEOF",
        "desc": "ErrOrEOF is like Err, but returns EOF. Used to test a corner case."
      },
      {
        "name": "MaxTokenSize",
        "desc": ""
      },
      {
        "name": "Scan",
        "desc": "Scan advances the [Scanner] to the next token, which will then be available through the [Scanner.Bytes] or [Scanner.Text] method. It returns false when there are no more tokens, either by reaching the end of the input or an error. After Scan returns false, the [Scanner.Err] method will return any error that occurred during scanning, except that if it was [io.EOF], [Scanner.Err] will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners."
      },
      {
        "name": "Split",
        "desc": "Split sets the split function for the [Scanner]. The default split function is [ScanLines].  Split panics if it is called after scanning has started."
      },
      {
        "name": "Text",
        "desc": "Text returns the most recent token generated by a call to [Scanner.Scan] as a newly allocated string holding its bytes."
      },
      {
        "name": "advance",
        "desc": "advance consumes n bytes of the buffer. It reports whether the advance was legal."
      },
      {
        "name": "setErr",
        "desc": "setErr records the first error encountered."
      },
      {
        "name": "Available",
        "desc": "Available returns how many bytes are unused in the buffer."
      },
      {
        "name": "AvailableBuffer",
        "desc": "AvailableBuffer returns an empty buffer with b.Available() capacity. This buffer is intended to be appended to and passed to an immediately succeeding [Writer.Write] call. The buffer is only valid until the next write operation on b."
      },
      {
        "name": "Buffered",
        "desc": "Buffered returns the number of bytes that have been written into the current buffer."
      },
      {
        "name": "Flush",
        "desc": "Flush writes any buffered data to the underlying [io.Writer]."
      },
      {
        "name": "ReadFrom",
        "desc": "ReadFrom implements [io.ReaderFrom]. If the underlying writer supports the ReadFrom method, this calls the underlying ReadFrom. If there is buffered data and an underlying ReadFrom, this fills the buffer and writes it before calling ReadFrom."
      },
      {
        "name": "Reset",
        "desc": "Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w. Calling Reset on the zero value of [Writer] initializes the internal buffer to the default size. Calling w.Reset(w) (that is, resetting a [Writer] to itself) does nothing."
      },
      {
        "name": "Size",
        "desc": "Size returns the size of the underlying buffer in bytes."
      },
      {
        "name": "Write",
        "desc": "Write writes the contents of p into the buffer. It returns the number of bytes written. If nn \u003c len(p), it also returns an error explaining why the write is short."
      },
      {
        "name": "WriteByte",
        "desc": "WriteByte writes a single byte."
      },
      {
        "name": "WriteRune",
        "desc": "WriteRune writes a single Unicode code point, returning the number of bytes written and any error."
      },
      {
        "name": "WriteString",
        "desc": "WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short."
      }
    ],
    "types": [
      {
        "name": "ReadWriter",
        "desc": "ReadWriter stores pointers to a [Reader] and a [Writer]. It implements [io.ReadWriter]."
      },
      {
        "name": "Reader",
        "desc": "Reader implements buffering for an io.Reader object. A new Reader is created by calling [NewReader] or [NewReaderSize]; alternatively the zero value of a Reader may be used after calling [Reset] on it."
      },
      {
        "name": "Scanner",
        "desc": "Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the [Scanner.Scan] method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type [SplitFunc]; the default split function breaks the input into lines with line termination stripped. [Scanner.Split] functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.  Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the [Scanner.Buffer]. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use [bufio.Reader] instead."
      },
      {
        "name": "SplitFunc",
        "desc": "SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the [Reader] has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.  Scanning stops if the function returns an error, in which case some of the input may be discarded. If that error is [ErrFinalToken], scanning stops with no error. A non-nil token delivered with [ErrFinalToken] will be the last token, and a nil token with [ErrFinalToken] immediately stops the scanning.  Otherwise, the [Scanner] advances the input. If the token is not nil, the [Scanner] returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the [Scanner] returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a [SplitFunc] can return (0, nil, nil) to signal the [Scanner] to read more data into the slice and try again with a longer slice starting at the same point in the input.  The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text."
      },
      {
        "name": "Writer",
        "desc": "Writer implements buffering for an [io.Writer] object. If an error occurs writing to a [Writer], no more data will be accepted and all subsequent writes, and [Writer.Flush], will return the error. After all data has been written, the client should call the [Writer.Flush] method to guarantee all data has been forwarded to the underlying [io.Writer]."
      }
    ]
  },
  {
    "name": "builtin",
    "desc": "Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.",
    "functions": [
      {
        "name": "clear",
        "desc": "The clear built-in function clears maps and slices. For maps, clear deletes all entries, resulting in an empty map. For slices, clear sets all elements up to the length of the slice to the zero value of the respective element type. If the argument type is a type parameter, the type parameter's type set must contain only map or slice types, and clear performs the operation implied by the type argument. If t is nil, clear is a no-op."
      },
      {
        "name": "close",
        "desc": "The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form  \tx, ok := \u003c-c  will also set ok to false for a closed and empty channel."
      },
      {
        "name": "delete",
        "desc": "The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op."
      },
      {
        "name": "max",
        "desc": "The max built-in function returns the largest value of a fixed number of arguments of [cmp.Ordered] types. There must be at least one argument. If T is a floating-point type and any of the arguments are NaNs, max will return NaN."
      },
      {
        "name": "min",
        "desc": "The min built-in function returns the smallest value of a fixed number of arguments of [cmp.Ordered] types. There must be at least one argument. If T is a floating-point type and any of the arguments are NaNs, min will return NaN."
      },
      {
        "name": "panic",
        "desc": "The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.  Starting in Go 1.21, calling panic with a nil interface value or an untyped nil causes a run-time error (a different panic). The GODEBUG setting panicnil=1 disables the run-time error."
      },
      {
        "name": "print",
        "desc": "The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language."
      },
      {
        "name": "println",
        "desc": "The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language."
      }
    ],
    "types": [
      {
        "name": "ComplexType",
        "desc": "ComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128."
      },
      {
        "name": "FloatType",
        "desc": "FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64."
      },
      {
        "name": "IntegerType",
        "desc": "IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc."
      },
      {
        "name": "Type",
        "desc": "Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation."
      },
      {
        "name": "Type1",
        "desc": "Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation."
      },
      {
        "name": "any",
        "desc": "any is an alias for interface{} and is equivalent to interface{} in all ways."
      },
      {
        "name": "bool",
        "desc": "bool is the set of boolean values, true and false."
      },
      {
        "name": "byte",
        "desc": "byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values."
      },
      {
        "name": "comparable",
        "desc": "comparable is an interface that is implemented by all comparable types (booleans, numbers, strings, pointers, channels, arrays of comparable types, structs whose fields are all comparable types). The comparable interface may only be used as a type parameter constraint, not as the type of a variable."
      },
      {
        "name": "complex128",
        "desc": "complex128 is the set of all complex numbers with float64 real and imaginary parts."
      },
      {
        "name": "complex64",
        "desc": "complex64 is the set of all complex numbers with float32 real and imaginary parts."
      },
      {
        "name": "error",
        "desc": "The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error."
      },
      {
        "name": "float32",
        "desc": "float32 is the set of all IEEE 754 32-bit floating-point numbers."
      },
      {
        "name": "float64",
        "desc": "float64 is the set of all IEEE 754 64-bit floating-point numbers."
      },
      {
        "name": "int",
        "desc": "int is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32."
      },
      {
        "name": "int16",
        "desc": "int16 is the set of all signed 16-bit integers. Range: -32768 through 32767."
      },
      {
        "name": "int32",
        "desc": "int32 is the set of all signed 32-bit integers. Range: -2147483648 through 2147483647."
      },
      {
        "name": "int64",
        "desc": "int64 is the set of all signed 64-bit integers. Range: -9223372036854775808 through 9223372036854775807."
      },
      {
        "name": "int8",
        "desc": "int8 is the set of all signed 8-bit integers. Range: -128 through 127."
      },
      {
        "name": "rune",
        "desc": "rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values."
      },
      {
        "name": "string",
        "desc": "string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable."
      },
      {
        "name": "uint",
        "desc": "uint is an unsigned integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, uint32."
      },
      {
        "name": "uint16",
        "desc": "uint16 is the set of all unsigned 16-bit integers. Range: 0 through 65535."
      },
      {
        "name": "uint32",
        "desc": "uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295."
      },
      {
        "name": "uint64",
        "desc": "uint64 is the set of all unsigned 64-bit integers. Range: 0 through 18446744073709551615."
      },
      {
        "name": "uint8",
        "desc": "uint8 is the set of all unsigned 8-bit integers. Range: 0 through 255."
      },
      {
        "name": "uintptr",
        "desc": "uintptr is an integer type that is large enough to hold the bit pattern of any pointer."
      }
    ]
  },
  {
    "name": "bytes",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkBufferAppendNoCopy",
        "desc": ""
      },
      {
        "name": "BenchmarkBufferFullSmallReads",
        "desc": "Check that we don't compact too often. From Issue 5154."
      },
      {
        "name": "BenchmarkBufferNotEmptyWriteRead",
        "desc": "From Issue 5154."
      },
      {
        "name": "BenchmarkBufferWriteBlock",
        "desc": ""
      },
      {
        "name": "BenchmarkBytesCompare",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesBig",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesBigBothUnaligned",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesBigIdentical",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesBigUnaligned",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesDifferentLength",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesEmpty",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesEqual",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesIdentical",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesSameLength",
        "desc": ""
      },
      {
        "name": "BenchmarkCompareBytesToNil",
        "desc": ""
      },
      {
        "name": "BenchmarkCount",
        "desc": ""
      },
      {
        "name": "BenchmarkCountEasy",
        "desc": ""
      },
      {
        "name": "BenchmarkCountHard1",
        "desc": ""
      },
      {
        "name": "BenchmarkCountHard2",
        "desc": ""
      },
      {
        "name": "BenchmarkCountHard3",
        "desc": ""
      },
      {
        "name": "BenchmarkCountSingle",
        "desc": ""
      },
      {
        "name": "BenchmarkEqual",
        "desc": ""
      },
      {
        "name": "BenchmarkEqualBothUnaligned",
        "desc": ""
      },
      {
        "name": "BenchmarkFields",
        "desc": ""
      },
      {
        "name": "BenchmarkFieldsFunc",
        "desc": ""
      },
      {
        "name": "BenchmarkIndex",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexAnyASCII",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexAnyUTF8",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexByte",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexBytePortable",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexEasy",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexHard1",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexHard2",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexHard3",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexHard4",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexPeriodic",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexRune",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexRuneASCII",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexRuneUnicode",
        "desc": ""
      },
      {
        "name": "BenchmarkLastIndexAnyASCII",
        "desc": ""
      },
      {
        "name": "BenchmarkLastIndexAnyUTF8",
        "desc": ""
      },
      {
        "name": "BenchmarkLastIndexHard1",
        "desc": ""
      },
      {
        "name": "BenchmarkLastIndexHard2",
        "desc": ""
      },
      {
        "name": "BenchmarkLastIndexHard3",
        "desc": ""
      },
      {
        "name": "BenchmarkReadString",
        "desc": ""
      },
      {
        "name": "BenchmarkRepeat",
        "desc": ""
      },
      {
        "name": "BenchmarkRepeatLarge",
        "desc": ""
      },
      {
        "name": "BenchmarkReplace",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitAfterSeqEmptySeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitAfterSeqMultiByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitAfterSeqSingleByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitEmptySeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitMultiByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitNMultiByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitNSingleByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitSeqEmptySeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitSeqMultiByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitSeqSingleByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkSplitSingleByteSeparator",
        "desc": ""
      },
      {
        "name": "BenchmarkToLower",
        "desc": ""
      },
      {
        "name": "BenchmarkToUpper",
        "desc": ""
      },
      {
        "name": "BenchmarkToValidUTF8",
        "desc": ""
      },
      {
        "name": "BenchmarkTrimASCII",
        "desc": ""
      },
      {
        "name": "BenchmarkTrimByte",
        "desc": ""
      },
      {
        "name": "BenchmarkTrimSpace",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteByte",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteRune",
        "desc": ""
      },
      {
        "name": "ExampleBuffer",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_AvailableBuffer",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_Bytes",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_Cap",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_Grow",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_Len",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_Next",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_Read",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_ReadByte",
        "desc": ""
      },
      {
        "name": "ExampleBuffer_reader",
        "desc": ""
      },
      {
        "name": "ExampleClone",
        "desc": ""
      },
      {
        "name": "ExampleCompare",
        "desc": ""
      },
      {
        "name": "ExampleCompare_search",
        "desc": ""
      },
      {
        "name": "ExampleContains",
        "desc": ""
      },
      {
        "name": "ExampleContainsAny",
        "desc": ""
      },
      {
        "name": "ExampleContainsFunc",
        "desc": ""
      },
      {
        "name": "ExampleContainsRune",
        "desc": ""
      },
      {
        "name": "ExampleCount",
        "desc": ""
      },
      {
        "name": "ExampleCut",
        "desc": ""
      },
      {
        "name": "ExampleCutPrefix",
        "desc": ""
      },
      {
        "name": "ExampleCutSuffix",
        "desc": ""
      },
      {
        "name": "ExampleEqual",
        "desc": ""
      },
      {
        "name": "ExampleEqualFold",
        "desc": ""
      },
      {
        "name": "ExampleFields",
        "desc": ""
      },
      {
        "name": "ExampleFieldsFunc",
        "desc": ""
      },
      {
        "name": "ExampleFieldsFuncSeq",
        "desc": ""
      },
      {
        "name": "ExampleFieldsSeq",
        "desc": ""
      },
      {
        "name": "ExampleHasPrefix",
        "desc": ""
      },
      {
        "name": "ExampleHasSuffix",
        "desc": ""
      },
      {
        "name": "ExampleIndex",
        "desc": ""
      },
      {
        "name": "ExampleIndexAny",
        "desc": ""
      },
      {
        "name": "ExampleIndexByte",
        "desc": ""
      },
      {
        "name": "ExampleIndexFunc",
        "desc": ""
      },
      {
        "name": "ExampleIndexRune",
        "desc": ""
      },
      {
        "name": "ExampleJoin",
        "desc": ""
      },
      {
        "name": "ExampleLastIndex",
        "desc": ""
      },
      {
        "name": "ExampleLastIndexAny",
        "desc": ""
      },
      {
        "name": "ExampleLastIndexByte",
        "desc": ""
      },
      {
        "name": "ExampleLastIndexFunc",
        "desc": ""
      },
      {
        "name": "ExampleLines",
        "desc": ""
      },
      {
        "name": "ExampleMap",
        "desc": ""
      },
      {
        "name": "ExampleReader_Len",
        "desc": ""
      },
      {
        "name": "ExampleRepeat",
        "desc": ""
      },
      {
        "name": "ExampleReplace",
        "desc": ""
      },
      {
        "name": "ExampleReplaceAll",
        "desc": ""
      },
      {
        "name": "ExampleRunes",
        "desc": ""
      },
      {
        "name": "ExampleSplit",
        "desc": ""
      },
      {
        "name": "ExampleSplitAfter",
        "desc": ""
      },
      {
        "name": "ExampleSplitAfterN",
        "desc": ""
      },
      {
        "name": "ExampleSplitAfterSeq",
        "desc": ""
      },
      {
        "name": "ExampleSplitN",
        "desc": ""
      },
      {
        "name": "ExampleSplitSeq",
        "desc": ""
      },
      {
        "name": "ExampleTitle",
        "desc": ""
      },
      {
        "name": "ExampleToLower",
        "desc": ""
      },
      {
        "name": "ExampleToLowerSpecial",
        "desc": ""
      },
      {
        "name": "ExampleToTitle",
        "desc": ""
      },
      {
        "name": "ExampleToTitleSpecial",
        "desc": ""
      },
      {
        "name": "ExampleToUpper",
        "desc": ""
      },
      {
        "name": "ExampleToUpperSpecial",
        "desc": ""
      },
      {
        "name": "ExampleToValidUTF8",
        "desc": ""
      },
      {
        "name": "ExampleTrim",
        "desc": ""
      },
      {
        "name": "ExampleTrimFunc",
        "desc": ""
      },
      {
        "name": "ExampleTrimLeft",
        "desc": ""
      },
      {
        "name": "ExampleTrimLeftFunc",
        "desc": ""
      },
      {
        "name": "ExampleTrimPrefix",
        "desc": ""
      },
      {
        "name": "ExampleTrimRight",
        "desc": ""
      },
      {
        "name": "ExampleTrimRightFunc",
        "desc": ""
      },
      {
        "name": "ExampleTrimSpace",
        "desc": ""
      },
      {
        "name": "ExampleTrimSuffix",
        "desc": ""
      },
      {
        "name": "FuzzReplace",
        "desc": ""
      },
      {
        "name": "TestBasicOperations",
        "desc": ""
      },
      {
        "name": "TestBufferGrowNegative",
        "desc": ""
      },
      {
        "name": "TestBufferGrowth",
        "desc": "Tests that we occasionally compact. Issue 5154."
      },
      {
        "name": "TestBufferTruncateNegative",
        "desc": ""
      },
      {
        "name": "TestBufferTruncateOutOfRange",
        "desc": ""
      },
      {
        "name": "TestCapWithPreallocatedSlice",
        "desc": ""
      },
      {
        "name": "TestCapWithSliceAndWrittenData",
        "desc": ""
      },
      {
        "name": "TestClone",
        "desc": ""
      },
      {
        "name": "TestCompare",
        "desc": ""
      },
      {
        "name": "TestCompareBytes",
        "desc": ""
      },
      {
        "name": "TestCompareIdenticalSlice",
        "desc": ""
      },
      {
        "name": "TestContains",
        "desc": ""
      },
      {
        "name": "TestContainsAny",
        "desc": ""
      },
      {
        "name": "TestContainsFunc",
        "desc": ""
      },
      {
        "name": "TestContainsRune",
        "desc": ""
      },
      {
        "name": "TestCountByte",
        "desc": "test count of a single byte across page offsets"
      },
      {
        "name": "TestCountByteNoMatch",
        "desc": "Make sure we don't count bytes outside our window"
      },
      {
        "name": "TestCountNearPageBoundary",
        "desc": ""
      },
      {
        "name": "TestCut",
        "desc": ""
      },
      {
        "name": "TestCutPrefix",
        "desc": ""
      },
      {
        "name": "TestCutSuffix",
        "desc": ""
      },
      {
        "name": "TestEmptyReaderConcurrent",
        "desc": ""
      },
      {
        "name": "TestEndianBaseCompare",
        "desc": ""
      },
      {
        "name": "TestEqual",
        "desc": ""
      },
      {
        "name": "TestEqualExhaustive",
        "desc": ""
      },
      {
        "name": "TestEqualFold",
        "desc": ""
      },
      {
        "name": "TestEqualNearPageBoundary",
        "desc": ""
      },
      {
        "name": "TestFields",
        "desc": ""
      },
      {
        "name": "TestFieldsFunc",
        "desc": ""
      },
      {
        "name": "TestGrow",
        "desc": ""
      },
      {
        "name": "TestGrowOverflow",
        "desc": ""
      },
      {
        "name": "TestIndex",
        "desc": ""
      },
      {
        "name": "TestIndexAny",
        "desc": ""
      },
      {
        "name": "TestIndexByte",
        "desc": ""
      },
      {
        "name": "TestIndexByteBig",
        "desc": "test a larger buffer with different sizes and alignments"
      },
      {
        "name": "TestIndexByteNearPageBoundary",
        "desc": ""
      },
      {
        "name": "TestIndexByteSmall",
        "desc": "test a small index across all page offsets"
      },
      {
        "name": "TestIndexFunc",
        "desc": ""
      },
      {
        "name": "TestIndexNearPageBoundary",
        "desc": ""
      },
      {
        "name": "TestIndexRune",
        "desc": ""
      },
      {
        "name": "TestIssue65571",
        "desc": ""
      },
      {
        "name": "TestLargeByteReads",
        "desc": ""
      },
      {
        "name": "TestLargeByteWrites",
        "desc": ""
      },
      {
        "name": "TestLargeStringReads",
        "desc": ""
      },
      {
        "name": "TestLargeStringWrites",
        "desc": ""
      },
      {
        "name": "TestLastIndex",
        "desc": ""
      },
      {
        "name": "TestLastIndexAny",
        "desc": ""
      },
      {
        "name": "TestLastIndexByte",
        "desc": ""
      },
      {
        "name": "TestLines",
        "desc": ""
      },
      {
        "name": "TestMap",
        "desc": ""
      },
      {
        "name": "TestMixedReadsAndWrites",
        "desc": ""
      },
      {
        "name": "TestNewBuffer",
        "desc": ""
      },
      {
        "name": "TestNewBufferShallow",
        "desc": "Calling NewBuffer and immediately shallow copying the Buffer struct should not result in any allocations. This can be used to reset the underlying []byte of an existing Buffer."
      },
      {
        "name": "TestNewBufferString",
        "desc": ""
      },
      {
        "name": "TestNext",
        "desc": ""
      },
      {
        "name": "TestNil",
        "desc": ""
      },
      {
        "name": "TestNotEqual",
        "desc": "make sure Equal returns false for minimally different strings. The data is all zeros except for a single one in one location."
      },
      {
        "name": "TestReadAfterBigSeek",
        "desc": ""
      },
      {
        "name": "TestReadBytes",
        "desc": ""
      },
      {
        "name": "TestReadEmptyAtEOF",
        "desc": "Was a bug: used to give EOF reading empty slice at EOF."
      },
      {
        "name": "TestReadFrom",
        "desc": ""
      },
      {
        "name": "TestReadFromNegativeReader",
        "desc": ""
      },
      {
        "name": "TestReadFromPanicReader",
        "desc": "Make sure that an empty Buffer remains empty when it is \"grown\" before a Read that panics"
      },
      {
        "name": "TestReadString",
        "desc": ""
      },
      {
        "name": "TestReader",
        "desc": ""
      },
      {
        "name": "TestReaderAt",
        "desc": ""
      },
      {
        "name": "TestReaderAtConcurrent",
        "desc": ""
      },
      {
        "name": "TestReaderCopyNothing",
        "desc": "verify that copying from an empty reader always has the same results, regardless of the presence of a WriteTo method."
      },
      {
        "name": "TestReaderDoubleUnreadRune",
        "desc": ""
      },
      {
        "name": "TestReaderLen",
        "desc": ""
      },
      {
        "name": "TestReaderLenSize",
        "desc": "tests that Len is affected by reads, but Size is not."
      },
      {
        "name": "TestReaderReset",
        "desc": ""
      },
      {
        "name": "TestReaderWriteTo",
        "desc": ""
      },
      {
        "name": "TestReaderZero",
        "desc": ""
      },
      {
        "name": "TestRepeat",
        "desc": ""
      },
      {
        "name": "TestRepeatCatchesOverflow",
        "desc": "See Issue golang.org/issue/16237"
      },
      {
        "name": "TestReplace",
        "desc": ""
      },
      {
        "name": "TestRuneIO",
        "desc": ""
      },
      {
        "name": "TestRunes",
        "desc": ""
      },
      {
        "name": "TestSplit",
        "desc": ""
      },
      {
        "name": "TestSplitAfter",
        "desc": ""
      },
      {
        "name": "TestTitle",
        "desc": ""
      },
      {
        "name": "TestToLower",
        "desc": ""
      },
      {
        "name": "TestToTitle",
        "desc": ""
      },
      {
        "name": "TestToUpper",
        "desc": ""
      },
      {
        "name": "TestToValidUTF8",
        "desc": ""
      },
      {
        "name": "TestTrim",
        "desc": ""
      },
      {
        "name": "TestTrimFunc",
        "desc": ""
      },
      {
        "name": "TestTrimSpace",
        "desc": ""
      },
      {
        "name": "TestUnreadByte",
        "desc": ""
      },
      {
        "name": "TestUnreadRuneError",
        "desc": ""
      },
      {
        "name": "TestWriteAppend",
        "desc": ""
      },
      {
        "name": "TestWriteInvalidRune",
        "desc": ""
      },
      {
        "name": "TestWriteTo",
        "desc": ""
      },
      {
        "name": "benchBytes",
        "desc": ""
      },
      {
        "name": "benchmarkCompareBytesBigBothUnaligned",
        "desc": ""
      },
      {
        "name": "benchmarkCompareBytesBigUnaligned",
        "desc": ""
      },
      {
        "name": "benchmarkCountHard",
        "desc": ""
      },
      {
        "name": "benchmarkIndexHard",
        "desc": ""
      },
      {
        "name": "benchmarkLastIndexHard",
        "desc": ""
      },
      {
        "name": "bmEqual",
        "desc": ""
      },
      {
        "name": "bmIndexByte",
        "desc": ""
      },
      {
        "name": "bmIndexRune",
        "desc": ""
      },
      {
        "name": "bmIndexRuneASCII",
        "desc": ""
      },
      {
        "name": "bmIndexRuneUnicode",
        "desc": ""
      },
      {
        "name": "check",
        "desc": "Verify that contents of buf match the string s."
      },
      {
        "name": "collect",
        "desc": ""
      },
      {
        "name": "dangerousSlice",
        "desc": "dangerousSlice returns a slice which is immediately preceded and followed by a faulting page."
      },
      {
        "name": "empty",
        "desc": "Empty buf through repeated reads into fub. The initial contents of buf corresponds to the string s."
      },
      {
        "name": "fillBytes",
        "desc": "Fill buf through n writes of byte slice fub. The initial contents of buf corresponds to the string s; the result is the final contents of buf returned as a string."
      },
      {
        "name": "fillString",
        "desc": "Fill buf through n writes of string fus. The initial contents of buf corresponds to the string s; the result is the final contents of buf returned as a string."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "makeBenchInputHard",
        "desc": ""
      },
      {
        "name": "repeat",
        "desc": ""
      },
      {
        "name": "rot13",
        "desc": "User-defined self-inverse mapping function"
      },
      {
        "name": "runIndexAnyTests",
        "desc": ""
      },
      {
        "name": "runIndexTests",
        "desc": "Execute f on each test case.  funcName should be the name of f; it's used in failure reports."
      },
      {
        "name": "runStringTests",
        "desc": "Execute f on each test case.  funcName should be the name of f; it's used in failure reports."
      },
      {
        "name": "sliceOfString",
        "desc": ""
      },
      {
        "name": "tenRunes",
        "desc": ""
      },
      {
        "name": "valName",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "BinOpTest",
        "desc": ""
      },
      {
        "name": "FieldsTest",
        "desc": ""
      },
      {
        "name": "IndexFuncTest",
        "desc": ""
      },
      {
        "name": "LinesTest",
        "desc": ""
      },
      {
        "name": "RepeatTest",
        "desc": ""
      },
      {
        "name": "ReplaceTest",
        "desc": ""
      },
      {
        "name": "RunesTest",
        "desc": ""
      },
      {
        "name": "SplitTest",
        "desc": ""
      },
      {
        "name": "StringTest",
        "desc": "Test case for any function which accepts and returns a byte slice. For ease of creation, we write the input byte slice as a string."
      },
      {
        "name": "TitleTest",
        "desc": ""
      },
      {
        "name": "TrimFuncTest",
        "desc": ""
      },
      {
        "name": "TrimNilTest",
        "desc": ""
      },
      {
        "name": "TrimTest",
        "desc": ""
      },
      {
        "name": "negativeReader",
        "desc": ""
      },
      {
        "name": "panicReader",
        "desc": ""
      },
      {
        "name": "predicate",
        "desc": ""
      }
    ]
  },
  {
    "name": "cmp",
    "desc": "",
    "functions": [
      {
        "name": "ExampleCompare",
        "desc": ""
      },
      {
        "name": "ExampleLess",
        "desc": ""
      },
      {
        "name": "ExampleOr",
        "desc": ""
      },
      {
        "name": "ExampleOr_sort",
        "desc": ""
      },
      {
        "name": "TestCompare",
        "desc": ""
      },
      {
        "name": "TestLess",
        "desc": ""
      },
      {
        "name": "TestOr",
        "desc": ""
      },
      {
        "name": "TestSort",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "compress/bzip2",
    "desc": "Package bzip2 implements bzip2 decompression.",
    "functions": [
      {
        "name": "BenchmarkDecodeDigits",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeNewton",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeRand",
        "desc": ""
      },
      {
        "name": "NewReader",
        "desc": "NewReader returns an [io.Reader] which decompresses bzip2 data from r. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r."
      },
      {
        "name": "TestBitReader",
        "desc": ""
      },
      {
        "name": "TestMTF",
        "desc": ""
      },
      {
        "name": "TestReader",
        "desc": ""
      },
      {
        "name": "TestZeroRead",
        "desc": ""
      },
      {
        "name": "benchmarkDecode",
        "desc": ""
      },
      {
        "name": "buildHuffmanNode",
        "desc": "buildHuffmanNode takes a slice of sorted huffmanCodes and builds a node in the Huffman tree at the given level. It returns the index of the newly constructed node."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "inverseBWT",
        "desc": "inverseBWT implements the inverse Burrows-Wheeler transform as described in http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf, section 4.2. In that document, origPtr is called “I” and c is the “C” array after the first pass over the data. It's an argument here because we merge the first pass with the Huffman decoding.  This also implements the “single array” method from the bzip2 source code which leaves the output, still shuffled, in the bottom 8 bits of tt with the index of the next byte in the top 24-bits. The index of the first byte is returned."
      },
      {
        "name": "mustDecodeHex",
        "desc": ""
      },
      {
        "name": "mustLoadFile",
        "desc": ""
      },
      {
        "name": "trim",
        "desc": ""
      },
      {
        "name": "updateCRC",
        "desc": "updateCRC updates the crc value to incorporate the data in b. The initial value is 0."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Err",
        "desc": ""
      },
      {
        "name": "ReadBit",
        "desc": ""
      },
      {
        "name": "ReadBits",
        "desc": ""
      },
      {
        "name": "ReadBits64",
        "desc": "ReadBits64 reads the given number of bits and returns them in the least-significant part of a uint64. In the event of an error, it returns 0 and the error can be obtained by calling bitReader.Err()."
      },
      {
        "name": "Decode",
        "desc": "Decode reads bits from the given bitReader and navigates the tree until a symbol is found."
      },
      {
        "name": "Decode",
        "desc": ""
      },
      {
        "name": "First",
        "desc": "First returns the symbol at the front of the list."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "readBlock",
        "desc": "readBlock reads a bzip2 block. The magic number should already have been consumed."
      },
      {
        "name": "readFromBlock",
        "desc": ""
      },
      {
        "name": "setup",
        "desc": "setup parses the bzip2 header."
      }
    ],
    "types": [
      {
        "name": "StructuralError",
        "desc": "A StructuralError is returned when the bzip2 data is found to be syntactically invalid."
      },
      {
        "name": "bitReader",
        "desc": "bitReader wraps an io.Reader and provides the ability to read values, bit-by-bit, from it. Its Read* methods don't return the usual error because the error handling was verbose. Instead, any error is kept and can be checked afterwards."
      },
      {
        "name": "huffmanCode",
        "desc": "huffmanCode contains a symbol, its code and code length."
      },
      {
        "name": "huffmanNode",
        "desc": "A huffmanNode is a node in the tree. left and right contain indexes into the nodes slice of the tree. If left or right is invalidNodeValue then the child is a left node and its value is in leftValue/rightValue.  The symbols are uint16s because bzip2 encodes not only MTF indexes in the tree, but also two magic values for run-length encoding and an EOF symbol. Thus there are more than 256 possible symbols."
      },
      {
        "name": "huffmanSymbolLengthPair",
        "desc": "huffmanSymbolLengthPair contains a symbol and its code length."
      },
      {
        "name": "huffmanTree",
        "desc": "A huffmanTree is a binary tree which is navigated, bit-by-bit to reach a symbol."
      },
      {
        "name": "moveToFrontDecoder",
        "desc": "moveToFrontDecoder implements a move-to-front list. Such a list is an efficient way to transform a string with repeating elements into one with many small valued numbers, which is suitable for entropy encoding. It works by starting with an initial list of symbols and references symbols by their index into that list. When a symbol is referenced, it's moved to the front of the list. Thus, a repeated symbol ends up being encoded with many zeros, as the symbol will be at the front of the list after the first access."
      },
      {
        "name": "reader",
        "desc": "A reader decompresses bzip2 compressed data."
      }
    ]
  },
  {
    "name": "compress/flate",
    "desc": "Package flate implements the DEFLATE compressed data format, described in RFC 1951.  The [compress/gzip] and [compress/zlib] packages implement access to DEFLATE-based file formats.",
    "functions": [
      {
        "name": "BenchmarkDecode",
        "desc": ""
      },
      {
        "name": "BenchmarkEncode",
        "desc": ""
      },
      {
        "name": "NewReader",
        "desc": "NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r. The reader returns [io.EOF] after the final block in the DEFLATE stream has been encountered. Any trailing data after the final block is ignored.  The [io.ReadCloser] returned by NewReader also implements [Resetter]."
      },
      {
        "name": "NewReaderDict",
        "desc": "NewReaderDict is like [NewReader] but initializes the reader with a preset dictionary. The returned reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by [NewWriterDict].  The ReadCloser returned by NewReaderDict also implements [Resetter]."
      },
      {
        "name": "TestBestSpeed",
        "desc": "TestBestSpeed tests that round-tripping through deflate and then inflate recovers the original input. The Write sizes are near the thresholds in the compressor.encSpeed method (0, 16, 128), as well as near maxStoreBlockSize (65535)."
      },
      {
        "name": "TestBestSpeedMatch",
        "desc": ""
      },
      {
        "name": "TestBestSpeedMaxMatchOffset",
        "desc": ""
      },
      {
        "name": "TestBestSpeedShiftOffsets",
        "desc": ""
      },
      {
        "name": "TestBlockHuff",
        "desc": "TestBlockHuff tests huffman encoding against reference files to detect possible regressions. If encoding/bit allocation changes you can regenerate these files by using the -update flag."
      },
      {
        "name": "TestBulkHash4",
        "desc": ""
      },
      {
        "name": "TestDeflate",
        "desc": ""
      },
      {
        "name": "TestDeflateFast_Reset",
        "desc": "TestDeflateFast_Reset will test that encoding is consistent across a warparound of the table offset. See https://github.com/golang/go/issues/34121"
      },
      {
        "name": "TestDeflateInflate",
        "desc": ""
      },
      {
        "name": "TestDeflateInflateString",
        "desc": ""
      },
      {
        "name": "TestDeterministic",
        "desc": "Test if two runs produce identical results even when writing different sizes to the Writer."
      },
      {
        "name": "TestDictDecoder",
        "desc": ""
      },
      {
        "name": "TestInvalidBits",
        "desc": ""
      },
      {
        "name": "TestInvalidEncoding",
        "desc": ""
      },
      {
        "name": "TestIssue5915",
        "desc": "The following test should not panic."
      },
      {
        "name": "TestIssue5962",
        "desc": "The following test should not panic."
      },
      {
        "name": "TestIssue6255",
        "desc": "The following test should not panic."
      },
      {
        "name": "TestMaxStackSize",
        "desc": ""
      },
      {
        "name": "TestNlitOutOfRange",
        "desc": ""
      },
      {
        "name": "TestReaderDict",
        "desc": ""
      },
      {
        "name": "TestReaderEarlyEOF",
        "desc": "Verify that flate.Reader.Read returns (n, io.EOF) instead of (n, nil) + (0, io.EOF) when possible.  This helps net/http.Transport reuse HTTP/1 connections more aggressively.  See https://github.com/google/go-github/pull/317 for background."
      },
      {
        "name": "TestReaderReusesReaderBuffer",
        "desc": ""
      },
      {
        "name": "TestReaderTruncated",
        "desc": ""
      },
      {
        "name": "TestRegression2508",
        "desc": "See https://golang.org/issue/2508"
      },
      {
        "name": "TestReset",
        "desc": ""
      },
      {
        "name": "TestResetDict",
        "desc": ""
      },
      {
        "name": "TestReverseBits",
        "desc": ""
      },
      {
        "name": "TestStreams",
        "desc": ""
      },
      {
        "name": "TestTruncatedStreams",
        "desc": ""
      },
      {
        "name": "TestVeryLongSparseChunk",
        "desc": ""
      },
      {
        "name": "TestWriteBlock",
        "desc": "TestWriteBlock tests if the writeBlock encoding has changed. To update the reference files use the \"-update\" flag on the test."
      },
      {
        "name": "TestWriteBlockDynamic",
        "desc": "TestWriteBlockDynamic tests if the writeBlockDynamic encoding has changed. To update the reference files use the \"-update\" flag on the test."
      },
      {
        "name": "TestWriteError",
        "desc": "Test if errors from the underlying writer is passed upwards."
      },
      {
        "name": "TestWriterClose",
        "desc": ""
      },
      {
        "name": "TestWriterDict",
        "desc": ""
      },
      {
        "name": "TestWriterPersistentCloseError",
        "desc": ""
      },
      {
        "name": "TestWriterPersistentFlushError",
        "desc": ""
      },
      {
        "name": "TestWriterPersistentWriteError",
        "desc": ""
      },
      {
        "name": "TestWriterReset",
        "desc": ""
      },
      {
        "name": "bulkHash4",
        "desc": "bulkHash4 will compute hashes using the same algorithm as hash4."
      },
      {
        "name": "checkErrors",
        "desc": ""
      },
      {
        "name": "doBench",
        "desc": ""
      },
      {
        "name": "fixedHuffmanDecoderInit",
        "desc": ""
      },
      {
        "name": "hash",
        "desc": ""
      },
      {
        "name": "hash4",
        "desc": "hash4 returns a hash representation of the first 4 bytes of the supplied slice. The caller must ensure that len(b) \u003e= 4."
      },
      {
        "name": "histogram",
        "desc": "histogram accumulates a histogram of b in h.  len(h) must be \u003e= 256, and h's elements must be all zeroes."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "largeDataChunk",
        "desc": ""
      },
      {
        "name": "lengthCode",
        "desc": ""
      },
      {
        "name": "load32",
        "desc": ""
      },
      {
        "name": "load64",
        "desc": ""
      },
      {
        "name": "matchLen",
        "desc": "matchLen returns the number of matching bytes in a and b up to length 'max'. Both slices must be at least 'max' bytes in size."
      },
      {
        "name": "noEOF",
        "desc": "noEOF returns err, unless err == io.EOF, in which case it returns io.ErrUnexpectedEOF."
      },
      {
        "name": "offsetCode",
        "desc": "Returns the offset code corresponding to a specific offset."
      },
      {
        "name": "reverseBits",
        "desc": ""
      },
      {
        "name": "testBlock",
        "desc": "testBlock tests a block against its references, or regenerate the references, if \"-update\" flag is set."
      },
      {
        "name": "testBlockHuff",
        "desc": ""
      },
      {
        "name": "testDeterministic",
        "desc": ""
      },
      {
        "name": "testResetOutput",
        "desc": ""
      },
      {
        "name": "testSync",
        "desc": ""
      },
      {
        "name": "testToFromWithLevelAndLimit",
        "desc": ""
      },
      {
        "name": "testToFromWithLimit",
        "desc": ""
      },
      {
        "name": "testWriterEOF",
        "desc": "testWriterEOF tests if the written block contains an EOF marker."
      },
      {
        "name": "writeToType",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close flushes and closes the writer."
      },
      {
        "name": "Flush",
        "desc": "Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the [Writer] to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error.  In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH."
      },
      {
        "name": "Reset",
        "desc": "Reset discards the writer's state and makes it equivalent to the result of [NewWriter] or [NewWriterDict] called with dst and w's level and dictionary."
      },
      {
        "name": "Write",
        "desc": "Write writes data to w, which will eventually write the compressed form of data to its underlying writer."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "sort",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "sort",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "deflate",
        "desc": ""
      },
      {
        "name": "encSpeed",
        "desc": "encSpeed will compress and store the currently added data, if enough has been accumulated or we at the end of the stream. Any error that occurred will be in d.err"
      },
      {
        "name": "fillDeflate",
        "desc": ""
      },
      {
        "name": "fillStore",
        "desc": ""
      },
      {
        "name": "fillWindow",
        "desc": "fillWindow will fill the current window with the supplied dictionary and calculate all hashes. This is much faster than doing a full encode. Should only be used after a reset."
      },
      {
        "name": "findMatch",
        "desc": "Try to find a match starting at index whose length is greater than prevSize. We only look at chainCount possibilities before giving up."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initDeflate",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "store",
        "desc": ""
      },
      {
        "name": "storeHuff",
        "desc": "storeHuff compresses and stores the currently added data when the d.window is full or we are at the end of the stream. Any error that occurred will be in d.err"
      },
      {
        "name": "syncFlush",
        "desc": ""
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeBlock",
        "desc": ""
      },
      {
        "name": "writeStoredBlock",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "copyData",
        "desc": "copyData copies f.copyLen bytes from the underlying reader into f.hist. It pauses for reads when f.hist is full."
      },
      {
        "name": "dataBlock",
        "desc": "Copy a single uncompressed data block from input to output."
      },
      {
        "name": "finishBlock",
        "desc": ""
      },
      {
        "name": "huffSym",
        "desc": "Read the next Huffman-encoded symbol from f according to h."
      },
      {
        "name": "huffmanBlock",
        "desc": "Decode a single Huffman block from f. hl and hd are the Huffman states for the lit/length values and the distance values, respectively. If hd == nil, using the fixed distance encoding associated with fixed Huffman blocks."
      },
      {
        "name": "makeReader",
        "desc": ""
      },
      {
        "name": "moreBits",
        "desc": ""
      },
      {
        "name": "nextBlock",
        "desc": ""
      },
      {
        "name": "readHuffman",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": "encode encodes a block given in src and appends tokens to dst and returns the result."
      },
      {
        "name": "matchLen",
        "desc": "matchLen returns the match length between src[s:] and src[t:]. t can be negative to indicate the match is starting in e.prev. We assume that src[s-4:s] and src[t-4:t] already match."
      },
      {
        "name": "reset",
        "desc": "Reset resets the encoding history. This ensures that no matches are made to the previous block."
      },
      {
        "name": "shiftOffsets",
        "desc": "shiftOffsets will shift down all match offset. This is only called in rare situations to prevent integer overflow.  See https://golang.org/issue/18636 and https://github.com/golang/go/issues/34121."
      },
      {
        "name": "availRead",
        "desc": "availRead reports the number of bytes that can be flushed by readFlush."
      },
      {
        "name": "availWrite",
        "desc": "availWrite reports the available amount of output buffer space."
      },
      {
        "name": "histSize",
        "desc": "histSize reports the total amount of historical data in the dictionary."
      },
      {
        "name": "init",
        "desc": "init initializes dictDecoder to have a sliding window dictionary of the given size. If a preset dict is provided, it will initialize the dictionary with the contents of dict."
      },
      {
        "name": "readFlush",
        "desc": "readFlush returns a slice of the historical buffer that is ready to be emitted to the user. The data returned by readFlush must be fully consumed before calling any other dictDecoder methods."
      },
      {
        "name": "tryWriteCopy",
        "desc": "tryWriteCopy tries to copy a string at a given (distance, length) to the output. This specialized version is optimized for short distances.  This method is designed to be inlined for performance reasons.  This invariant must be kept: 0 \u003c dist \u003c= histSize()"
      },
      {
        "name": "writeByte",
        "desc": "writeByte writes a single byte to the dictionary.  This invariant must be kept: 0 \u003c availWrite()"
      },
      {
        "name": "writeCopy",
        "desc": "writeCopy copies a string at a given (dist, length) to the output. This returns the number of bytes copied and may be less than the requested length if the available space in the output buffer is too small.  This invariant must be kept: 0 \u003c dist \u003c= histSize()"
      },
      {
        "name": "writeMark",
        "desc": "writeMark advances the writer pointer by cnt.  This invariant must be kept: 0 \u003c= cnt \u003c= availWrite()"
      },
      {
        "name": "writeSlice",
        "desc": "writeSlice returns a slice of the available buffer to write data to.  This invariant will be kept: len(s) \u003c= availWrite()"
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "set",
        "desc": "set sets the code and length of an hcode."
      },
      {
        "name": "dynamicSize",
        "desc": "dynamicSize returns the size of dynamically encoded data in bits."
      },
      {
        "name": "fixedSize",
        "desc": "fixedSize returns the size of dynamically encoded data in bits."
      },
      {
        "name": "flush",
        "desc": ""
      },
      {
        "name": "generateCodegen",
        "desc": "RFC 1951 3.2.7 specifies a special run-length encoding for specifying the literal and offset lengths arrays (which are concatenated into a single array).  This method generates that run-length encoding.  The result is written into the codegen array, and the frequencies of each code is written into the codegenFreq array. Codes 0-15 are single byte codes. Codes 16-18 are followed by additional information. Code badCode is an end marker  \tnumLiterals      The number of literals in literalEncoding \tnumOffsets       The number of offsets in offsetEncoding \tlitenc, offenc   The literal and offset encoder to use"
      },
      {
        "name": "indexTokens",
        "desc": "indexTokens indexes a slice of tokens, and updates literalFreq and offsetFreq, and generates literalEncoding and offsetEncoding. The number of literal and offset tokens is returned."
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "storedSize",
        "desc": "storedSize calculates the stored size, including header. The function returns the size in bits and whether the block fits inside a single block."
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeBits",
        "desc": ""
      },
      {
        "name": "writeBlock",
        "desc": "writeBlock will write a block of tokens with the smallest encoding. The original input can be supplied, and if the huffman encoded data is larger than the original bytes, the data will be written as a stored block. If the input is nil, the tokens will always be Huffman encoded."
      },
      {
        "name": "writeBlockDynamic",
        "desc": "writeBlockDynamic encodes a block using a dynamic Huffman table. This should be used if the symbols used have a disproportionate histogram distribution. If input is supplied and the compression savings are below 1/16th of the input size the block is stored."
      },
      {
        "name": "writeBlockHuff",
        "desc": "writeBlockHuff encodes a block of bytes as either Huffman encoded literals or uncompressed bytes if the results only gains very little from compression."
      },
      {
        "name": "writeBytes",
        "desc": ""
      },
      {
        "name": "writeCode",
        "desc": ""
      },
      {
        "name": "writeDynamicHeader",
        "desc": "Write the header of a dynamic Huffman block to the output stream.  \tnumLiterals  The number of literals specified in codegen \tnumOffsets   The number of offsets specified in codegen \tnumCodegens  The number of codegens used in codegen"
      },
      {
        "name": "writeFixedHeader",
        "desc": ""
      },
      {
        "name": "writeStoredHeader",
        "desc": ""
      },
      {
        "name": "writeTokens",
        "desc": "writeTokens writes a slice of tokens to the output. codes for literal and offset encoding must be supplied."
      },
      {
        "name": "init",
        "desc": "Initialize Huffman decoding tables from array of code lengths. Following this function, h is guaranteed to be initialized into a complete tree (i.e., neither over-subscribed nor under-subscribed). The exception is a degenerate case where the tree has only a single symbol with length 1. Empty trees are permitted."
      },
      {
        "name": "assignEncodingAndSize",
        "desc": "Look at the leaves and assign them a bit count and an encoding as specified in RFC 1951 3.2.2"
      },
      {
        "name": "bitCounts",
        "desc": "bitCounts computes the number of literals assigned to each bit size in the Huffman encoding. It is only called when list.length \u003e= 3. The cases of 0, 1, and 2 literals are handled by special case code.  list is an array of the literals with non-zero frequencies and their associated frequencies. The array is in order of increasing frequency and has as its last element a special element with frequency MaxInt32.  maxBits is the maximum number of bits that should be used to encode any literal. It must be less than 16.  bitCounts returns an integer slice in which slice[i] indicates the number of literals that should be encoded in i bits."
      },
      {
        "name": "bitLength",
        "desc": ""
      },
      {
        "name": "generate",
        "desc": "Update this Huffman Code object to be the minimum code for the specified frequency count.  freq is an array of frequencies, in which freq[i] gives the frequency of literal i. maxBits  The maximum number of bits to use for any literal."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadMode",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteMode",
        "desc": ""
      },
      {
        "name": "signal",
        "desc": ""
      },
      {
        "name": "length",
        "desc": ""
      },
      {
        "name": "literal",
        "desc": "Returns the literal of a literal token."
      },
      {
        "name": "offset",
        "desc": "Returns the extra offset of a match token."
      }
    ],
    "types": [
      {
        "name": "CorruptInputError",
        "desc": "A CorruptInputError reports the presence of corrupt input at a given offset."
      },
      {
        "name": "InternalError",
        "desc": "An InternalError reports an error in the flate code itself."
      },
      {
        "name": "ReadError",
        "desc": "A ReadError reports an error encountered while reading input.  Deprecated: No longer returned."
      },
      {
        "name": "Reader",
        "desc": "The actual read interface needed by [NewReader]. If the passed in [io.Reader] does not also have ReadByte, the [NewReader] will introduce its own buffering."
      },
      {
        "name": "Resetter",
        "desc": "Resetter resets a ReadCloser returned by [NewReader] or [NewReaderDict] to switch to a new underlying [Reader]. This permits reusing a ReadCloser instead of allocating a new one."
      },
      {
        "name": "WriteError",
        "desc": "A WriteError reports an error encountered while writing output.  Deprecated: No longer returned."
      },
      {
        "name": "Writer",
        "desc": "A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see [NewWriter])."
      },
      {
        "name": "byFreq",
        "desc": ""
      },
      {
        "name": "byLiteral",
        "desc": ""
      },
      {
        "name": "compressionLevel",
        "desc": ""
      },
      {
        "name": "compressor",
        "desc": ""
      },
      {
        "name": "decompressor",
        "desc": "Decompress state."
      },
      {
        "name": "deflateFast",
        "desc": "deflateFast maintains the table for matches, and the previous byte block for cross block matching."
      },
      {
        "name": "deflateInflateStringTest",
        "desc": ""
      },
      {
        "name": "deflateInflateTest",
        "desc": ""
      },
      {
        "name": "deflateTest",
        "desc": ""
      },
      {
        "name": "dictDecoder",
        "desc": "dictDecoder implements the LZ77 sliding dictionary as used in decompression. LZ77 decompresses data through sequences of two forms of commands:    - Literal insertions: Runs of one or more symbols are inserted into the data     stream as is. This is accomplished through the writeByte method for a     single symbol, or combinations of writeSlice/writeMark for multiple symbols.     Any valid stream must start with a literal insertion if no preset dictionary     is used.    - Backward copies: Runs of one or more symbols are copied from previously     emitted data. Backward copies come as the tuple (dist, length) where dist     determines how far back in the stream to copy from and length determines how     many bytes to copy. Note that it is valid for the length to be greater than     the distance. Since LZ77 uses forward copies, that situation is used to     perform a form of run-length encoding on repeated runs of symbols.     The writeCopy and tryWriteCopy are used to implement this command.  For performance reasons, this implementation performs little to no sanity checks about the arguments. As such, the invariants documented for each method call must be respected."
      },
      {
        "name": "dictWriter",
        "desc": ""
      },
      {
        "name": "errorWriter",
        "desc": "errorWriter is a writer that fails after N writes."
      },
      {
        "name": "failWriter",
        "desc": "failWriter fails with errIO exactly at the nth call to Write."
      },
      {
        "name": "hcode",
        "desc": "hcode is a huffman code with a bit code and bit length."
      },
      {
        "name": "huffTest",
        "desc": ""
      },
      {
        "name": "huffmanBitWriter",
        "desc": ""
      },
      {
        "name": "huffmanDecoder",
        "desc": ""
      },
      {
        "name": "huffmanEncoder",
        "desc": ""
      },
      {
        "name": "levelInfo",
        "desc": "A levelInfo describes the state of the constructed tree for a given depth."
      },
      {
        "name": "literalNode",
        "desc": ""
      },
      {
        "name": "reverseBitsTest",
        "desc": ""
      },
      {
        "name": "sparseReader",
        "desc": "A sparseReader returns a stream consisting of 0s followed by 1\u003c\u003c16 1s. This tests missing hash references in a very large input."
      },
      {
        "name": "syncBuffer",
        "desc": ""
      },
      {
        "name": "tableEntry",
        "desc": ""
      },
      {
        "name": "token",
        "desc": ""
      }
    ]
  },
  {
    "name": "compress/gzip",
    "desc": "",
    "functions": [
      {
        "name": "ExampleReader_Multistream",
        "desc": ""
      },
      {
        "name": "Example_compressingReader",
        "desc": ""
      },
      {
        "name": "Example_writerReader",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "compress/lzw",
    "desc": "Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19.  In particular, it implements LZW as used by the GIF and PDF file formats, which means variable-width codes up to 12 bits and the first two non-literal codes are a clear code and an EOF code.  The TIFF file format uses a similar but incompatible version of the LZW algorithm. See the [golang.org/x/image/tiff/lzw] package for an implementation.",
    "functions": [
      {
        "name": "BenchmarkDecoder",
        "desc": ""
      },
      {
        "name": "BenchmarkEncoder",
        "desc": ""
      },
      {
        "name": "NewReader",
        "desc": "NewReader creates a new [io.ReadCloser]. Reads from the returned [io.ReadCloser] read and decompress data from r. If r does not also implement [io.ByteReader], the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression.  It is guaranteed that the underlying type of the returned [io.ReadCloser] is a *[Reader]."
      },
      {
        "name": "NewWriter",
        "desc": "NewWriter creates a new [io.WriteCloser]. Writes to the returned [io.WriteCloser] are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1\u003c\u003clitWidth.  It is guaranteed that the underlying type of the returned [io.WriteCloser] is a *[Writer]."
      },
      {
        "name": "TestHiCodeDoesNotOverflow",
        "desc": ""
      },
      {
        "name": "TestNoLongerSavingPriorExpansions",
        "desc": "TestNoLongerSavingPriorExpansions tests the decoder state when codes other than clear codes continue to be seen after decoder.hi and decoder.width reach their maximum values (4095 and 12), i.e. after we no longer save prior expansions. In particular, it tests seeing the highest possible code, 4095."
      },
      {
        "name": "TestReader",
        "desc": ""
      },
      {
        "name": "TestReaderReset",
        "desc": ""
      },
      {
        "name": "TestSmallLitWidth",
        "desc": ""
      },
      {
        "name": "TestStartsWithClearCode",
        "desc": ""
      },
      {
        "name": "TestWriter",
        "desc": ""
      },
      {
        "name": "TestWriterReset",
        "desc": ""
      },
      {
        "name": "TestWriterReturnValues",
        "desc": ""
      },
      {
        "name": "testFile",
        "desc": "testFile tests that compressing and then decompressing the given file with the given options yields equivalent bytes to the original file."
      },
      {
        "name": "Close",
        "desc": "Close closes the [Reader] and returns an error for any future read operation. It does not close the underlying [io.Reader]."
      },
      {
        "name": "Read",
        "desc": "Read implements io.Reader, reading uncompressed bytes from its underlying reader."
      },
      {
        "name": "Reset",
        "desc": "Reset clears the [Reader]'s state and allows it to be reused again as a new [Reader]."
      },
      {
        "name": "decode",
        "desc": "decode decompresses bytes from r and leaves them in d.toRead. read specifies how to decode bytes into codes. litWidth is the width in bits of literal codes."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "readLSB",
        "desc": "readLSB returns the next code for \"Least Significant Bits first\" data."
      },
      {
        "name": "readMSB",
        "desc": "readMSB returns the next code for \"Most Significant Bits first\" data."
      },
      {
        "name": "Close",
        "desc": "Close closes the [Writer], flushing any pending output. It does not close w's underlying writer."
      },
      {
        "name": "Reset",
        "desc": "Reset clears the [Writer]'s state and allows it to be reused again as a new [Writer]."
      },
      {
        "name": "Write",
        "desc": "Write writes a compressed representation of p to w's underlying writer."
      },
      {
        "name": "incHi",
        "desc": "incHi increments e.hi and checks for both overflow and running out of unused codes. In the latter case, incHi sends a clear code, resets the writer state and returns errOutOfCodes."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "writeLSB",
        "desc": "writeLSB writes the code c for \"Least Significant Bits first\" data."
      },
      {
        "name": "writeMSB",
        "desc": "writeMSB writes the code c for \"Most Significant Bits first\" data."
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Order",
        "desc": "Order specifies the bit ordering in an LZW data stream."
      },
      {
        "name": "Reader",
        "desc": "Reader is an [io.Reader] which can be used to read compressed data in the LZW format."
      },
      {
        "name": "Writer",
        "desc": "Writer is an LZW compressor. It writes the compressed form of the data to an underlying writer (see [NewWriter])."
      },
      {
        "name": "devZero",
        "desc": ""
      },
      {
        "name": "lzwTest",
        "desc": ""
      },
      {
        "name": "writer",
        "desc": "A writer is a buffered, flushable writer."
      }
    ]
  },
  {
    "name": "compress/zlib",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNewReader",
        "desc": ""
      },
      {
        "name": "ExampleNewWriter",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "container/heap",
    "desc": "This example demonstrates an integer heap built using the heap interface.  This example demonstrates a priority queue built using the heap interface.",
    "functions": [
      {
        "name": "Example_intHeap",
        "desc": "This example inserts several ints into an IntHeap, checks the minimum, and removes them in order of priority."
      },
      {
        "name": "Example_priorityQueue",
        "desc": "This example creates a PriorityQueue with some items, adds and manipulates an item, and then removes the items in priority order."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Pop",
        "desc": ""
      },
      {
        "name": "Push",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Pop",
        "desc": ""
      },
      {
        "name": "Push",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "update",
        "desc": "update modifies the priority and value of an Item in the queue."
      }
    ],
    "types": [
      {
        "name": "IntHeap",
        "desc": "An IntHeap is a min-heap of ints."
      },
      {
        "name": "Item",
        "desc": "An Item is something we manage in a priority queue."
      },
      {
        "name": "PriorityQueue",
        "desc": "A PriorityQueue implements heap.Interface and holds Items."
      }
    ]
  },
  {
    "name": "container/list",
    "desc": "Package list implements a doubly linked list.  To iterate over a list (where l is a *List):  \tfor e := l.Front(); e != nil; e = e.Next() { \t\t// do something with e.Value \t}",
    "functions": [
      {
        "name": "TestExtending",
        "desc": ""
      },
      {
        "name": "TestInsertAfterUnknownMark",
        "desc": "Test that a list l is not modified when calling InsertAfter with a mark that is not an element of l."
      },
      {
        "name": "TestInsertBeforeUnknownMark",
        "desc": "Test that a list l is not modified when calling InsertBefore with a mark that is not an element of l."
      },
      {
        "name": "TestIssue4103",
        "desc": ""
      },
      {
        "name": "TestIssue6349",
        "desc": ""
      },
      {
        "name": "TestList",
        "desc": ""
      },
      {
        "name": "TestMove",
        "desc": ""
      },
      {
        "name": "TestMoveUnknownMark",
        "desc": "Test that a list l is not modified when calling MoveAfter or MoveBefore with a mark that is not an element of l."
      },
      {
        "name": "TestRemove",
        "desc": ""
      },
      {
        "name": "TestZeroList",
        "desc": "Test PushFront, PushBack, PushFrontList, PushBackList with uninitialized List"
      },
      {
        "name": "checkList",
        "desc": ""
      },
      {
        "name": "checkListLen",
        "desc": ""
      },
      {
        "name": "checkListPointers",
        "desc": ""
      },
      {
        "name": "Next",
        "desc": "Next returns the next list element or nil."
      },
      {
        "name": "Prev",
        "desc": "Prev returns the previous list element or nil."
      },
      {
        "name": "Back",
        "desc": "Back returns the last element of list l or nil if the list is empty."
      },
      {
        "name": "Front",
        "desc": "Front returns the first element of list l or nil if the list is empty."
      },
      {
        "name": "Init",
        "desc": "Init initializes or clears list l."
      },
      {
        "name": "InsertAfter",
        "desc": "InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil."
      },
      {
        "name": "InsertBefore",
        "desc": "InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of elements of list l. The complexity is O(1)."
      },
      {
        "name": "MoveAfter",
        "desc": "MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil."
      },
      {
        "name": "MoveBefore",
        "desc": "MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil."
      },
      {
        "name": "MoveToBack",
        "desc": "MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil."
      },
      {
        "name": "MoveToFront",
        "desc": "MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil."
      },
      {
        "name": "PushBack",
        "desc": "PushBack inserts a new element e with value v at the back of list l and returns e."
      },
      {
        "name": "PushBackList",
        "desc": "PushBackList inserts a copy of another list at the back of list l. The lists l and other may be the same. They must not be nil."
      },
      {
        "name": "PushFront",
        "desc": "PushFront inserts a new element e with value v at the front of list l and returns e."
      },
      {
        "name": "PushFrontList",
        "desc": "PushFrontList inserts a copy of another list at the front of list l. The lists l and other may be the same. They must not be nil."
      },
      {
        "name": "Remove",
        "desc": "Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil."
      },
      {
        "name": "insert",
        "desc": "insert inserts e after at, increments l.len, and returns e."
      },
      {
        "name": "insertValue",
        "desc": "insertValue is a convenience wrapper for insert(\u0026Element{Value: v}, at)."
      },
      {
        "name": "lazyInit",
        "desc": "lazyInit lazily initializes a zero List value."
      },
      {
        "name": "move",
        "desc": "move moves e to next to at."
      },
      {
        "name": "remove",
        "desc": "remove removes e from its list, decrements l.len"
      }
    ],
    "types": [
      {
        "name": "Element",
        "desc": "Element is an element of a linked list."
      },
      {
        "name": "List",
        "desc": "List represents a doubly linked list. The zero value for List is an empty list ready to use."
      }
    ]
  },
  {
    "name": "container/ring",
    "desc": "Package ring implements operations on circular lists.",
    "functions": [
      {
        "name": "TestCornerCases",
        "desc": ""
      },
      {
        "name": "TestLink1",
        "desc": ""
      },
      {
        "name": "TestLink2",
        "desc": ""
      },
      {
        "name": "TestLink3",
        "desc": ""
      },
      {
        "name": "TestLinkUnlink",
        "desc": ""
      },
      {
        "name": "TestMoveEmptyRing",
        "desc": "Test that calling Move() on an empty Ring initializes it."
      },
      {
        "name": "TestNew",
        "desc": ""
      },
      {
        "name": "TestUnlink",
        "desc": ""
      },
      {
        "name": "dump",
        "desc": "For debugging - keep around."
      },
      {
        "name": "sumN",
        "desc": ""
      },
      {
        "name": "verify",
        "desc": ""
      },
      {
        "name": "Do",
        "desc": "Do calls function f on each element of the ring, in forward order. The behavior of Do is undefined if f changes *r."
      },
      {
        "name": "Len",
        "desc": "Len computes the number of elements in ring r. It executes in time proportional to the number of elements."
      },
      {
        "name": "Link",
        "desc": "Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.  If r and s point to the same ring, linking them removes the elements between r and s from the ring. The removed elements form a subring and the result is a reference to that subring (if no elements were removed, the result is still the original value for r.Next(), and not nil).  If r and s point to different rings, linking them creates a single ring with the elements of s inserted after r. The result points to the element following the last element of s after insertion."
      },
      {
        "name": "Move",
        "desc": "Move moves n % r.Len() elements backward (n \u003c 0) or forward (n \u003e= 0) in the ring and returns that ring element. r must not be empty."
      },
      {
        "name": "Next",
        "desc": "Next returns the next ring element. r must not be empty."
      },
      {
        "name": "Prev",
        "desc": "Prev returns the previous ring element. r must not be empty."
      },
      {
        "name": "Unlink",
        "desc": "Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty."
      },
      {
        "name": "init",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Ring",
        "desc": "A Ring is an element of a circular list, or ring. Rings do not have a beginning or end; a pointer to any ring element serves as reference to the entire ring. Empty rings are represented as nil Ring pointers. The zero value for a Ring is a one-element ring with a nil Value."
      }
    ]
  },
  {
    "name": "context",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkCancelTree",
        "desc": ""
      },
      {
        "name": "BenchmarkCheckCanceled",
        "desc": ""
      },
      {
        "name": "BenchmarkCommonParentCancel",
        "desc": ""
      },
      {
        "name": "BenchmarkContextCancelDone",
        "desc": ""
      },
      {
        "name": "BenchmarkDeepValueNewGoRoutine",
        "desc": ""
      },
      {
        "name": "BenchmarkDeepValueSameGoRoutine",
        "desc": ""
      },
      {
        "name": "BenchmarkErrCanceled",
        "desc": ""
      },
      {
        "name": "BenchmarkErrOK",
        "desc": ""
      },
      {
        "name": "BenchmarkWithTimeout",
        "desc": ""
      },
      {
        "name": "ExampleAfterFunc_cond",
        "desc": "This example uses AfterFunc to define a function which waits on a sync.Cond, stopping the wait when a context is canceled."
      },
      {
        "name": "ExampleAfterFunc_connection",
        "desc": "This example uses AfterFunc to define a function which reads from a net.Conn, stopping the read when a context is canceled."
      },
      {
        "name": "ExampleAfterFunc_merge",
        "desc": "This example uses AfterFunc to define a function which combines the cancellation signals of two Contexts."
      },
      {
        "name": "ExampleWithCancel",
        "desc": "This example demonstrates the use of a cancelable context to prevent a goroutine leak. By the end of the example function, the goroutine started by gen will return without leaking."
      },
      {
        "name": "ExampleWithDeadline",
        "desc": "This example passes a context with an arbitrary deadline to tell a blocking function that it should abandon its work as soon as it gets to it."
      },
      {
        "name": "ExampleWithTimeout",
        "desc": "This example passes a context with a timeout to tell a blocking function that it should abandon its work after the timeout elapses."
      },
      {
        "name": "ExampleWithValue",
        "desc": "This example demonstrates how a value can be passed to the context and also how to retrieve it if it exists."
      },
      {
        "name": "TestAfterFuncCalledAfterCancel",
        "desc": ""
      },
      {
        "name": "TestAfterFuncCalledAfterTimeout",
        "desc": ""
      },
      {
        "name": "TestAfterFuncCalledAsynchronously",
        "desc": "This test verifies that canceling a context does not block waiting for AfterFuncs to finish."
      },
      {
        "name": "TestAfterFuncCalledImmediately",
        "desc": ""
      },
      {
        "name": "TestAfterFuncNotCalledAfterStop",
        "desc": ""
      },
      {
        "name": "TestAllocs",
        "desc": ""
      },
      {
        "name": "TestBackground",
        "desc": ""
      },
      {
        "name": "TestCancelRemoves",
        "desc": ""
      },
      {
        "name": "TestCanceledTimeout",
        "desc": ""
      },
      {
        "name": "TestCause",
        "desc": ""
      },
      {
        "name": "TestCauseRace",
        "desc": ""
      },
      {
        "name": "TestChildFinishesFirst",
        "desc": ""
      },
      {
        "name": "TestContextErrDoneRace",
        "desc": "Issue #75533."
      },
      {
        "name": "TestCustomContextAfterFuncAfterFunc",
        "desc": ""
      },
      {
        "name": "TestCustomContextAfterFuncCancel",
        "desc": ""
      },
      {
        "name": "TestCustomContextAfterFuncTimeout",
        "desc": ""
      },
      {
        "name": "TestCustomContextAfterFuncUnregisterAfterFunc",
        "desc": ""
      },
      {
        "name": "TestCustomContextAfterFuncUnregisterCancel",
        "desc": ""
      },
      {
        "name": "TestCustomContextAfterFuncUnregisterTimeout",
        "desc": ""
      },
      {
        "name": "TestCustomContextCause",
        "desc": ""
      },
      {
        "name": "TestCustomContextGoroutines",
        "desc": ""
      },
      {
        "name": "TestCustomContextPropagation",
        "desc": ""
      },
      {
        "name": "TestDeadline",
        "desc": ""
      },
      {
        "name": "TestDeadlineExceededIsNetError",
        "desc": ""
      },
      {
        "name": "TestDeadlineExceededSupportsTimeout",
        "desc": ""
      },
      {
        "name": "TestInterlockedCancels",
        "desc": ""
      },
      {
        "name": "TestInvalidDerivedFail",
        "desc": ""
      },
      {
        "name": "TestLayersCancel",
        "desc": ""
      },
      {
        "name": "TestLayersTimeout",
        "desc": ""
      },
      {
        "name": "TestParentFinishesChild",
        "desc": "Each XTestFoo in context_test.go must be called from a TestFoo here to run."
      },
      {
        "name": "TestSimultaneousCancels",
        "desc": ""
      },
      {
        "name": "TestTODO",
        "desc": ""
      },
      {
        "name": "TestTimeout",
        "desc": ""
      },
      {
        "name": "TestValues",
        "desc": ""
      },
      {
        "name": "TestWithCancel",
        "desc": ""
      },
      {
        "name": "TestWithCancelCanceledParent",
        "desc": ""
      },
      {
        "name": "TestWithCancelSimultaneouslyCanceledParent",
        "desc": ""
      },
      {
        "name": "TestWithValueChecksKey",
        "desc": ""
      },
      {
        "name": "TestWithoutCancel",
        "desc": ""
      },
      {
        "name": "benchmarkWithTimeout",
        "desc": ""
      },
      {
        "name": "buildContextTree",
        "desc": ""
      },
      {
        "name": "newCustomContext",
        "desc": ""
      },
      {
        "name": "quiescent",
        "desc": "quiescent returns an arbitrary duration by which the program should have completed any remaining work and reached a steady (idle) state."
      },
      {
        "name": "recoveredValue",
        "desc": ""
      },
      {
        "name": "testDeadline",
        "desc": ""
      },
      {
        "name": "testLayers",
        "desc": ""
      },
      {
        "name": "AfterFunc",
        "desc": ""
      },
      {
        "name": "Deadline",
        "desc": ""
      },
      {
        "name": "Done",
        "desc": ""
      },
      {
        "name": "Err",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "cancel",
        "desc": ""
      },
      {
        "name": "Deadline",
        "desc": ""
      },
      {
        "name": "Done",
        "desc": ""
      },
      {
        "name": "Err",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "cancel",
        "desc": ""
      },
      {
        "name": "setCancelChild",
        "desc": ""
      },
      {
        "name": "Deadline",
        "desc": ""
      },
      {
        "name": "Done",
        "desc": ""
      },
      {
        "name": "Err",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "Done",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "afterFuncContext",
        "desc": "afterFuncContext is a context that's not one of the types defined in context.go, that supports registering AfterFuncs."
      },
      {
        "name": "customCauseContext",
        "desc": "customCauseContext is a custom Context used to test context.Cause."
      },
      {
        "name": "customContext",
        "desc": "customContext is a custom Context implementation."
      },
      {
        "name": "customDoneContext",
        "desc": ""
      },
      {
        "name": "key1",
        "desc": ""
      },
      {
        "name": "key2",
        "desc": ""
      },
      {
        "name": "otherContext",
        "desc": "otherContext is a Context that's not one of the types defined in context.go. This lets us test code paths that differ based on the underlying type of the Context."
      }
    ]
  },
  {
    "name": "crypto",
    "desc": "Package crypto collects common cryptographic constants.",
    "functions": [
      {
        "name": "RegisterHash",
        "desc": "RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions."
      },
      {
        "name": "SignMessage",
        "desc": "SignMessage signs msg with signer. If signer implements [MessageSigner], [MessageSigner.SignMessage] is called directly. Otherwise, msg is hashed with opts.HashFunc() and signed with [Signer.Sign]."
      },
      {
        "name": "Available",
        "desc": "Available reports whether the given hash function is linked into the binary."
      },
      {
        "name": "HashFunc",
        "desc": "HashFunc simply returns the value of h so that [Hash] implements [SignerOpts]."
      },
      {
        "name": "New",
        "desc": "New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary."
      },
      {
        "name": "Size",
        "desc": "Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program."
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Decrypter",
        "desc": "Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module."
      },
      {
        "name": "DecrypterOpts",
        "desc": ""
      },
      {
        "name": "Hash",
        "desc": "Hash identifies a cryptographic hash function that is implemented in another package."
      },
      {
        "name": "MessageSigner",
        "desc": "MessageSigner is an interface for an opaque private key that can be used for signing operations where the message is not pre-hashed by the caller. It is a superset of the Signer interface so that it can be passed to APIs which accept Signer, which may try to do an interface upgrade.  MessageSigner.SignMessage and MessageSigner.Sign should produce the same result given the same opts. In particular, MessageSigner.SignMessage should only accept a zero opts.HashFunc if the Signer would also accept messages which are not pre-hashed.  Implementations which do not provide the pre-hashed Sign API should implement Signer.Sign by always returning an error."
      },
      {
        "name": "PrivateKey",
        "desc": "PrivateKey represents a private key using an unspecified algorithm.  Although this type is an empty interface for backwards compatibility reasons, all private key types in the standard library implement the following interface  \tinterface{ \t    Public() crypto.PublicKey \t    Equal(x crypto.PrivateKey) bool \t}  as well as purpose-specific interfaces such as [Signer] and [Decrypter], which can be used for increased type safety within applications."
      },
      {
        "name": "PublicKey",
        "desc": "PublicKey represents a public key using an unspecified algorithm.  Although this type is an empty interface for backwards compatibility reasons, all public key types in the standard library implement the following interface  \tinterface{ \t    Equal(x crypto.PublicKey) bool \t}  which can be used for increased type safety within applications."
      },
      {
        "name": "Signer",
        "desc": "Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module."
      },
      {
        "name": "SignerOpts",
        "desc": "SignerOpts contains options for signing with a [Signer]."
      }
    ]
  },
  {
    "name": "crypto/aes",
    "desc": "Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.  The AES operations in this package are not implemented using constant-time algorithms. An exception is when running on systems with enabled hardware support for AES that makes these operations constant-time. Examples include amd64 systems using AES-NI extensions and s390x systems using Message-Security-Assist extensions. On such systems, when the result of NewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also constant-time.",
    "functions": [
      {
        "name": "BenchmarkCreateCipher",
        "desc": ""
      },
      {
        "name": "BenchmarkDecrypt",
        "desc": ""
      },
      {
        "name": "BenchmarkEncrypt",
        "desc": ""
      },
      {
        "name": "NewCipher",
        "desc": "NewCipher creates and returns a new [cipher.Block]. The key argument must be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256."
      },
      {
        "name": "TestAESBlock",
        "desc": "Test AES against the general cipher.Block interface tester"
      },
      {
        "name": "TestCipherDecrypt",
        "desc": "Test Cipher Decrypt against FIPS 197 examples."
      },
      {
        "name": "TestCipherEncrypt",
        "desc": "Test Cipher Encrypt method against FIPS 197 examples."
      },
      {
        "name": "TestExtraMethods",
        "desc": ""
      },
      {
        "name": "benchmarkCreateCipher",
        "desc": ""
      },
      {
        "name": "benchmarkDecrypt",
        "desc": ""
      },
      {
        "name": "benchmarkEncrypt",
        "desc": ""
      },
      {
        "name": "testAESBlock",
        "desc": ""
      },
      {
        "name": "testCipherDecrypt",
        "desc": ""
      },
      {
        "name": "testCipherEncrypt",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "CryptTest",
        "desc": "Appendix B, C of FIPS 197: Cipher examples, Example vectors."
      },
      {
        "name": "KeySizeError",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/boring",
    "desc": "Package boring exposes functions that are only available when building with Go+BoringCrypto. This package is available on all targets as long as the Go+BoringCrypto toolchain is used. Use the Enabled function to determine whether the BoringCrypto core is actually in use.  Any time the Go+BoringCrypto toolchain is used, the \"boringcrypto\" build tag is satisfied, so that applications can tag files that use this package.",
    "functions": [
      {
        "name": "Enabled",
        "desc": "Enabled reports whether BoringCrypto handles supported crypto operations."
      }
    ],
    "types": null
  },
  {
    "name": "crypto/cipher",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkAESCBCDecrypt1K",
        "desc": ""
      },
      {
        "name": "BenchmarkAESCBCEncrypt1K",
        "desc": ""
      },
      {
        "name": "BenchmarkAESCTR",
        "desc": ""
      },
      {
        "name": "BenchmarkAESGCM",
        "desc": ""
      },
      {
        "name": "ExampleNewCBCDecrypter",
        "desc": ""
      },
      {
        "name": "ExampleNewCBCEncrypter",
        "desc": ""
      },
      {
        "name": "ExampleNewCFBDecrypter",
        "desc": ""
      },
      {
        "name": "ExampleNewCFBEncrypter",
        "desc": ""
      },
      {
        "name": "ExampleNewCTR",
        "desc": ""
      },
      {
        "name": "ExampleNewGCM_decrypt",
        "desc": ""
      },
      {
        "name": "ExampleNewGCM_encrypt",
        "desc": ""
      },
      {
        "name": "ExampleNewOFB",
        "desc": ""
      },
      {
        "name": "ExampleStreamReader",
        "desc": ""
      },
      {
        "name": "ExampleStreamWriter",
        "desc": ""
      },
      {
        "name": "TestAESGCM",
        "desc": ""
      },
      {
        "name": "TestCBCAble",
        "desc": ""
      },
      {
        "name": "TestCBCBlockMode",
        "desc": "Test CBC Blockmode against the general cipher.BlockMode interface tester"
      },
      {
        "name": "TestCBCDecrypterAES",
        "desc": ""
      },
      {
        "name": "TestCBCEncrypterAES",
        "desc": ""
      },
      {
        "name": "TestCBCExtraMethods",
        "desc": ""
      },
      {
        "name": "TestCFBInverse",
        "desc": ""
      },
      {
        "name": "TestCFBStream",
        "desc": ""
      },
      {
        "name": "TestCFBVectors",
        "desc": ""
      },
      {
        "name": "TestCTR",
        "desc": ""
      },
      {
        "name": "TestCTRAble",
        "desc": ""
      },
      {
        "name": "TestCTRExtraMethods",
        "desc": ""
      },
      {
        "name": "TestCTRStream",
        "desc": ""
      },
      {
        "name": "TestCTR_AES",
        "desc": ""
      },
      {
        "name": "TestCTR_AES_multiblock_XORKeyStreamAt",
        "desc": "Check that method XORKeyStreamAt works correctly."
      },
      {
        "name": "TestCTR_AES_multiblock_overflow_IV",
        "desc": "Verify that multiblock AES CTR (src/crypto/aes/ctr_*.s) produces the same results as generic single-block implementation. This test runs checks on edge cases (IV overflows)."
      },
      {
        "name": "TestCTR_AES_multiblock_random_IV",
        "desc": "Verify that multiblock AES CTR (src/crypto/aes/ctr_*.s) produces the same results as generic single-block implementation. This test runs checks on random IV."
      },
      {
        "name": "TestFIPSServiceIndicator",
        "desc": ""
      },
      {
        "name": "TestFuzz",
        "desc": ""
      },
      {
        "name": "TestGCM",
        "desc": ""
      },
      {
        "name": "TestGCMAEAD",
        "desc": "Test GCM against the general cipher.AEAD interface tester."
      },
      {
        "name": "TestGCMAsm",
        "desc": ""
      },
      {
        "name": "TestGCMCounterWrap",
        "desc": ""
      },
      {
        "name": "TestGCMExtraMethods",
        "desc": ""
      },
      {
        "name": "TestGCMForSSH",
        "desc": ""
      },
      {
        "name": "TestGCMInvalidTagSize",
        "desc": ""
      },
      {
        "name": "TestNoExtraMethods",
        "desc": "TestNoExtraMethods makes sure we don't accidentally expose methods on the underlying implementations of modes."
      },
      {
        "name": "TestOFB",
        "desc": ""
      },
      {
        "name": "TestOFBStream",
        "desc": ""
      },
      {
        "name": "TestTagFailureOverwrite",
        "desc": ""
      },
      {
        "name": "benchmarkAESGCMOpen",
        "desc": ""
      },
      {
        "name": "benchmarkAESGCMSeal",
        "desc": ""
      },
      {
        "name": "benchmarkAESStream",
        "desc": ""
      },
      {
        "name": "decodeHex",
        "desc": ""
      },
      {
        "name": "exportedMethods",
        "desc": ""
      },
      {
        "name": "inc",
        "desc": ""
      },
      {
        "name": "makeTestingCiphers",
        "desc": ""
      },
      {
        "name": "newRandReader",
        "desc": ""
      },
      {
        "name": "parseHex",
        "desc": ""
      },
      {
        "name": "randBytes",
        "desc": ""
      },
      {
        "name": "testAESGCM",
        "desc": ""
      },
      {
        "name": "testAllImplementations",
        "desc": ""
      },
      {
        "name": "testCBCDecrypterAES",
        "desc": ""
      },
      {
        "name": "testCBCEncrypterAES",
        "desc": ""
      },
      {
        "name": "testCTR_AES",
        "desc": ""
      },
      {
        "name": "testGCMAEAD",
        "desc": ""
      },
      {
        "name": "testGCMCounterWrap",
        "desc": ""
      },
      {
        "name": "testGCMInvalidTagSize",
        "desc": ""
      },
      {
        "name": "testNoExtraMethods",
        "desc": ""
      },
      {
        "name": "testTagFailureOverwrite",
        "desc": ""
      },
      {
        "name": "wrap",
        "desc": "wrap wraps the Block so that it does not type-asserts to *aes.Block."
      },
      {
        "name": "xor",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "NewCBCDecrypter",
        "desc": ""
      },
      {
        "name": "NewCBCEncrypter",
        "desc": ""
      },
      {
        "name": "NewCTR",
        "desc": ""
      },
      {
        "name": "NewGCM",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Decrypt",
        "desc": ""
      },
      {
        "name": "Encrypt",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Decrypt",
        "desc": ""
      },
      {
        "name": "Encrypt",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "ctrAble",
        "desc": ""
      },
      {
        "name": "noopBlock",
        "desc": ""
      },
      {
        "name": "ofbTest",
        "desc": ""
      },
      {
        "name": "specialCBC",
        "desc": ""
      },
      {
        "name": "specialCTR",
        "desc": ""
      },
      {
        "name": "specialGCM",
        "desc": ""
      },
      {
        "name": "wrapper",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/des",
    "desc": "Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.  DES is cryptographically broken and should not be used for secure applications.",
    "functions": [
      {
        "name": "NewCipher",
        "desc": "NewCipher creates and returns a new [cipher.Block]."
      },
      {
        "name": "NewTripleDESCipher",
        "desc": "NewTripleDESCipher creates and returns a new [cipher.Block]."
      },
      {
        "name": "TestFinalPermute",
        "desc": ""
      },
      {
        "name": "TestInitialPermute",
        "desc": ""
      },
      {
        "name": "cryptBlock",
        "desc": ""
      },
      {
        "name": "feistel",
        "desc": "DES Feistel function. feistelBox must be initialized via feistelBoxOnce.Do(initFeistelBox) first."
      },
      {
        "name": "initFeistelBox",
        "desc": ""
      },
      {
        "name": "ksRotate",
        "desc": "creates 16 28-bit blocks rotated according to the rotation schedule."
      },
      {
        "name": "permuteBlock",
        "desc": "general purpose function to perform DES block permutations."
      },
      {
        "name": "permuteFinalBlock",
        "desc": "permuteFinalBlock is equivalent to the permutation defined by finalPermutation."
      },
      {
        "name": "permuteInitialBlock",
        "desc": "permuteInitialBlock is equivalent to the permutation defined by initialPermutation."
      },
      {
        "name": "unpack",
        "desc": "Expand 48-bit input to 64-bit, with each 6-bit block padded by extra two bits at the top. By doing so, we can have the input blocks (four bits each), and the key blocks (six bits each) well-aligned without extra shifts/rotations for alignments."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Decrypt",
        "desc": ""
      },
      {
        "name": "Encrypt",
        "desc": ""
      },
      {
        "name": "generateSubkeys",
        "desc": "creates 16 56-bit subkeys from the original key."
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Decrypt",
        "desc": ""
      },
      {
        "name": "Encrypt",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "KeySizeError",
        "desc": ""
      },
      {
        "name": "desCipher",
        "desc": "desCipher is an instance of DES encryption."
      },
      {
        "name": "tripleDESCipher",
        "desc": "A tripleDESCipher is an instance of TripleDES encryption."
      }
    ]
  },
  {
    "name": "crypto/dsa",
    "desc": "Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.  The DSA operations in this package are not implemented using constant-time algorithms.  Deprecated: DSA is a legacy algorithm, and modern alternatives such as Ed25519 (implemented by package crypto/ed25519) should be used instead. Keys with 1024-bit moduli (L1024N160 parameters) are cryptographically weak, while bigger keys are not widely supported. Note that FIPS 186-5 no longer approves DSA for signature generation.",
    "functions": [
      {
        "name": "GenerateKey",
        "desc": "GenerateKey generates a public\u0026private key pair. The Parameters of the [PrivateKey] must already be valid (see [GenerateParameters])."
      },
      {
        "name": "GenerateParameters",
        "desc": "GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines."
      },
      {
        "name": "Sign",
        "desc": "Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.  Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.  Be aware that calling Sign with an attacker-controlled [PrivateKey] may require an arbitrary amount of CPU."
      },
      {
        "name": "TestParameterGeneration",
        "desc": ""
      },
      {
        "name": "TestSignAndVerify",
        "desc": ""
      },
      {
        "name": "TestSignAndVerifyWithBadPublicKey",
        "desc": ""
      },
      {
        "name": "TestSigningWithDegenerateKeys",
        "desc": ""
      },
      {
        "name": "Verify",
        "desc": "Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.  Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself."
      },
      {
        "name": "fermatInverse",
        "desc": "fermatInverse calculates the inverse of k in GF(P) using Fermat's method. This has better constant-time properties than Euclid's method (implemented in math/big.Int.ModInverse) although math/big itself isn't strictly constant-time so it's not perfect."
      },
      {
        "name": "fromHex",
        "desc": ""
      },
      {
        "name": "testParameterGeneration",
        "desc": ""
      },
      {
        "name": "testSignAndVerify",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ParameterSizes",
        "desc": "ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2."
      },
      {
        "name": "Parameters",
        "desc": "Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8."
      },
      {
        "name": "PrivateKey",
        "desc": "PrivateKey represents a DSA private key."
      },
      {
        "name": "PublicKey",
        "desc": "PublicKey represents a DSA public key."
      }
    ]
  },
  {
    "name": "crypto/ecdh",
    "desc": "Package ecdh implements Elliptic Curve Diffie-Hellman over NIST curves and Curve25519.",
    "functions": [
      {
        "name": "isZero",
        "desc": "isZero reports whether x is all zeroes in constant time."
      },
      {
        "name": "x25519ScalarMult",
        "desc": ""
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns a copy of the encoding of the private key."
      },
      {
        "name": "Curve",
        "desc": ""
      },
      {
        "name": "ECDH",
        "desc": "ECDH performs an ECDH exchange and returns the shared secret. The [PrivateKey] and [PublicKey] must use the same curve.  For NIST curves, this performs ECDH as specified in SEC 1, Version 2.0, Section 3.3.1, and returns the x-coordinate encoded according to SEC 1, Version 2.0, Section 2.3.5. The result is never the point at infinity. This is also known as the Shared Secret Computation of the Ephemeral Unified Model scheme specified in NIST SP 800-56A Rev. 3, Section 6.1.2.2.  For [X25519], this performs ECDH as specified in RFC 7748, Section 6.1. If the result is the all-zero value, ECDH returns an error."
      },
      {
        "name": "Equal",
        "desc": "Equal returns whether x represents the same private key as k.  Note that there can be equivalent private keys with different encodings which would return false from this check but behave the same way as inputs to [ECDH].  This check is performed in constant time as long as the key types and their curve match."
      },
      {
        "name": "Public",
        "desc": "Public implements the implicit interface of all standard library private keys. See the docs of [crypto.PrivateKey]."
      },
      {
        "name": "PublicKey",
        "desc": ""
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns a copy of the encoding of the public key."
      },
      {
        "name": "Curve",
        "desc": ""
      },
      {
        "name": "Equal",
        "desc": "Equal returns whether x represents the same public key as k.  Note that there can be equivalent public keys with different encodings which would return false from this check but behave the same way as inputs to ECDH.  This check is performed in constant time as long as the key types and their curve match."
      },
      {
        "name": "GenerateKey",
        "desc": ""
      },
      {
        "name": "NewPrivateKey",
        "desc": ""
      },
      {
        "name": "NewPublicKey",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "ecdh",
        "desc": ""
      },
      {
        "name": "GenerateKey",
        "desc": ""
      },
      {
        "name": "NewPrivateKey",
        "desc": ""
      },
      {
        "name": "NewPublicKey",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "ecdh",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Curve",
        "desc": ""
      },
      {
        "name": "PrivateKey",
        "desc": "PrivateKey is an ECDH private key, usually kept secret.  These keys can be parsed with [crypto/x509.ParsePKCS8PrivateKey] and encoded with [crypto/x509.MarshalPKCS8PrivateKey]. For NIST curves, they then need to be converted with [crypto/ecdsa.PrivateKey.ECDH] after parsing."
      },
      {
        "name": "PublicKey",
        "desc": "PublicKey is an ECDH public key, usually a peer's ECDH share sent over the wire.  These keys can be parsed with [crypto/x509.ParsePKIXPublicKey] and encoded with [crypto/x509.MarshalPKIXPublicKey]. For NIST curves, they then need to be converted with [crypto/ecdsa.PublicKey.ECDH] after parsing."
      },
      {
        "name": "nistCurve",
        "desc": ""
      },
      {
        "name": "x25519Curve",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/ecdsa",
    "desc": "Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in [FIPS 186-5].  Signatures generated by this package are not deterministic, but entropy is mixed with the private key and the message, achieving the same level of security in case of randomness source failure.  Operations involving private keys are implemented using constant-time algorithms, as long as an [elliptic.Curve] returned by [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521] is used.  [FIPS 186-5]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf",
    "functions": [
      {
        "name": "BenchmarkGenerateKey",
        "desc": ""
      },
      {
        "name": "BenchmarkSign",
        "desc": ""
      },
      {
        "name": "BenchmarkVerify",
        "desc": ""
      },
      {
        "name": "Sign",
        "desc": "Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. Most applications should use [SignASN1] instead of dealing directly with r, s."
      },
      {
        "name": "SignASN1",
        "desc": "SignASN1 signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature.  The signature is randomized. Most applications should use [crypto/rand.Reader] as rand. Note that the returned signature does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions."
      },
      {
        "name": "TestINDCCA",
        "desc": ""
      },
      {
        "name": "TestInvalidPrivateKeys",
        "desc": ""
      },
      {
        "name": "TestInvalidPublicKeys",
        "desc": ""
      },
      {
        "name": "TestKeyGeneration",
        "desc": ""
      },
      {
        "name": "TestNegativeInputs",
        "desc": ""
      },
      {
        "name": "TestNegativeSignature",
        "desc": ""
      },
      {
        "name": "TestNonceSafety",
        "desc": ""
      },
      {
        "name": "TestParseAndBytesRoundTrip",
        "desc": ""
      },
      {
        "name": "TestRFC6979",
        "desc": ""
      },
      {
        "name": "TestRMinusNSignature",
        "desc": ""
      },
      {
        "name": "TestRPlusNSignature",
        "desc": ""
      },
      {
        "name": "TestSignAndVerify",
        "desc": ""
      },
      {
        "name": "TestSignAndVerifyASN1",
        "desc": ""
      },
      {
        "name": "TestVectors",
        "desc": ""
      },
      {
        "name": "TestZeroHashSignature",
        "desc": ""
      },
      {
        "name": "TestZeroSignature",
        "desc": ""
      },
      {
        "name": "Verify",
        "desc": "Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid. Most applications should use VerifyASN1 instead of dealing directly with r, s.  The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs."
      },
      {
        "name": "VerifyASN1",
        "desc": "VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the public key, pub. Its return value records whether the signature is valid.  The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs."
      },
      {
        "name": "addASN1IntBytes",
        "desc": "addASN1IntBytes encodes in ASN.1 a positive integer represented as a big-endian byte slice with zero or more leading zeroes."
      },
      {
        "name": "benchmarkAllCurves",
        "desc": ""
      },
      {
        "name": "bigIntEqual",
        "desc": "bigIntEqual reports whether a and b are equal leaking only their bit length through timing side-channels."
      },
      {
        "name": "boringPrivateKey",
        "desc": ""
      },
      {
        "name": "boringPublicKey",
        "desc": ""
      },
      {
        "name": "curveToECDH",
        "desc": ""
      },
      {
        "name": "encodeSignature",
        "desc": ""
      },
      {
        "name": "fromHex",
        "desc": ""
      },
      {
        "name": "genericParamsForCurve",
        "desc": "genericParamsForCurve returns the dereferenced CurveParams for the specified curve. This is used to avoid the logic for upgrading a curve to its specific implementation, forcing usage of the generic implementation."
      },
      {
        "name": "hashToInt",
        "desc": "hashToInt converts a hash value to an integer. Per FIPS 186-4, Section 6.4, we use the left-most bits of the hash to match the bit-length of the order of the curve. This also performs Step 5 of SEC 1, Version 2.0, Section 4.1.3."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "leftPadBytesEqual",
        "desc": ""
      },
      {
        "name": "parseSignature",
        "desc": ""
      },
      {
        "name": "pointFromAffine",
        "desc": "pointFromAffine is used to convert the PublicKey to a nistec SetBytes input."
      },
      {
        "name": "pointToAffine",
        "desc": "pointToAffine is used to convert a nistec Bytes encoding to a PublicKey."
      },
      {
        "name": "privateKeyBytes",
        "desc": ""
      },
      {
        "name": "privateKeyEqual",
        "desc": ""
      },
      {
        "name": "privateKeyToFIPS",
        "desc": ""
      },
      {
        "name": "publicKeyBytes",
        "desc": ""
      },
      {
        "name": "publicKeyEqual",
        "desc": ""
      },
      {
        "name": "publicKeyToFIPS",
        "desc": ""
      },
      {
        "name": "randFieldElement",
        "desc": "randFieldElement returns a random element of the order of the given curve using the procedure given in FIPS 186-4, Appendix B.5.2."
      },
      {
        "name": "signFIPS",
        "desc": ""
      },
      {
        "name": "signFIPSDeterministic",
        "desc": ""
      },
      {
        "name": "signLegacy",
        "desc": ""
      },
      {
        "name": "signRFC6979",
        "desc": ""
      },
      {
        "name": "testAllCurves",
        "desc": ""
      },
      {
        "name": "testINDCCA",
        "desc": ""
      },
      {
        "name": "testInvalidPrivateKeys",
        "desc": ""
      },
      {
        "name": "testInvalidPublicKeys",
        "desc": ""
      },
      {
        "name": "testKeyGeneration",
        "desc": ""
      },
      {
        "name": "testNegativeInputs",
        "desc": ""
      },
      {
        "name": "testNegativeSignature",
        "desc": ""
      },
      {
        "name": "testNonceSafety",
        "desc": ""
      },
      {
        "name": "testParseAndBytesRoundTrip",
        "desc": ""
      },
      {
        "name": "testRFC6979",
        "desc": ""
      },
      {
        "name": "testRMinusNSignature",
        "desc": ""
      },
      {
        "name": "testRPlusNSignature",
        "desc": ""
      },
      {
        "name": "testSignAndVerify",
        "desc": ""
      },
      {
        "name": "testSignAndVerifyASN1",
        "desc": ""
      },
      {
        "name": "testVectors",
        "desc": ""
      },
      {
        "name": "testZeroHashSignature",
        "desc": ""
      },
      {
        "name": "testZeroSignature",
        "desc": ""
      },
      {
        "name": "verifyFIPS",
        "desc": ""
      },
      {
        "name": "verifyLegacy",
        "desc": ""
      },
      {
        "name": "Bytes",
        "desc": "Bytes encodes the private key as a fixed-length big-endian integer according to SEC 1, Version 2.0, Section 2.3.6 (sometimes referred to as the raw format). It returns an error if the private key is invalid.  PrivateKey.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521], or Bytes returns an error.  Bytes returns the same format as [ecdh.PrivateKey.Bytes] does for NIST curves.  Note that private keys are more commonly encoded in ASN.1 or PKCS#8 format, which can be generated with [crypto/x509.MarshalECPrivateKey] or [crypto/x509.MarshalPKCS8PrivateKey] (and [encoding/pem])."
      },
      {
        "name": "ECDH",
        "desc": "ECDH returns k as a [ecdh.PrivateKey]. It returns an error if the key is invalid according to the definition of [ecdh.Curve.NewPrivateKey], or if the Curve is not supported by [crypto/ecdh]."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether priv and x have the same value.  See [PublicKey.Equal] for details on how Curve is compared."
      },
      {
        "name": "Public",
        "desc": "Public returns the public key corresponding to priv."
      },
      {
        "name": "Sign",
        "desc": "Sign signs a hash (which should be the result of hashing a larger message with opts.HashFunc()) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the ASN.1 encoded signature, like [SignASN1].  If rand is not nil, the signature is randomized. Most applications should use [crypto/rand.Reader] as rand. Note that the returned signature does not depend deterministically on the bytes read from rand, and may change between calls and/or between versions.  If rand is nil, Sign will produce a deterministic signature according to RFC 6979. When producing a deterministic signature, opts.HashFunc() must be the function used to produce digest and priv.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521]."
      },
      {
        "name": "Bytes",
        "desc": "Bytes encodes the public key as an uncompressed point according to SEC 1, Version 2.0, Section 2.3.3 (also known as the X9.62 uncompressed format). It returns an error if the public key is invalid.  PublicKey.Curve must be one of [elliptic.P224], [elliptic.P256], [elliptic.P384], or [elliptic.P521], or Bytes returns an error.  Bytes returns the same format as [ecdh.PublicKey.Bytes] does for NIST curves.  Note that public keys are more commonly encoded in DER (or PEM) format, which can be generated with [crypto/x509.MarshalPKIXPublicKey] (and [encoding/pem])."
      },
      {
        "name": "ECDH",
        "desc": "ECDH returns k as a [ecdh.PublicKey]. It returns an error if the key is invalid according to the definition of [ecdh.Curve.NewPublicKey], or if the Curve is not supported by crypto/ecdh."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether pub and x have the same value.  Two keys are only considered to have the same value if they have the same Curve value. Note that for example [elliptic.P256] and elliptic.P256().Params() are different values, as the latter is a generic not constant time implementation."
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "PrivateKey",
        "desc": "PrivateKey represents an ECDSA private key."
      },
      {
        "name": "PublicKey",
        "desc": "PublicKey represents an ECDSA public key."
      },
      {
        "name": "boringPriv",
        "desc": ""
      },
      {
        "name": "boringPub",
        "desc": ""
      },
      {
        "name": "readerFunc",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/ed25519",
    "desc": "",
    "functions": [
      {
        "name": "TestEd25519Vectors",
        "desc": "TestEd25519Vectors runs a very large set of test vectors that exercise all combinations of low-order points, low-order components, and non-canonical encodings. These vectors lock in unspecified and spec-divergent behaviors in edge cases that are not security relevant in most contexts, but that can cause issues in consensus applications if changed.  Our behavior matches the \"classic\" unwritten verification rules of the \"ref10\" reference implementation.  Note that although we test for these edge cases, they are not covered by the Go 1 Compatibility Promise. Applications that need stable verification rules should use github.com/hdevalence/ed25519consensus.  See https://hdevalence.ca/blog/2020-10-04-its-25519am for more details."
      },
      {
        "name": "decodeHex",
        "desc": ""
      },
      {
        "name": "downloadEd25519Vectors",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/elliptic",
    "desc": "Package elliptic implements the standard NIST P-224, P-256, P-384, and P-521 elliptic curves over prime fields.  Direct use of this package is deprecated, beyond the [P224], [P256], [P384], and [P521] values necessary to use [crypto/ecdsa]. Most other uses should migrate to the more efficient and safer [crypto/ecdh], or to third-party modules for lower-level functionality.",
    "functions": [
      {
        "name": "BenchmarkMarshalUnmarshal",
        "desc": ""
      },
      {
        "name": "BenchmarkScalarBaseMult",
        "desc": ""
      },
      {
        "name": "BenchmarkScalarMult",
        "desc": ""
      },
      {
        "name": "GenerateKey",
        "desc": "GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.  Deprecated: for ECDH, use the GenerateKey methods of the [crypto/ecdh] package; for ECDSA, use the GenerateKey function of the crypto/ecdsa package."
      },
      {
        "name": "Marshal",
        "desc": "Marshal converts a point on the curve into the uncompressed form specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is the conventional point at infinity), the behavior is undefined.  Deprecated: for ECDH, use the crypto/ecdh package. This function returns an encoding equivalent to that of PublicKey.Bytes in crypto/ecdh."
      },
      {
        "name": "MarshalCompressed",
        "desc": "MarshalCompressed converts a point on the curve into the compressed form specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or is the conventional point at infinity), the behavior is undefined."
      },
      {
        "name": "TestInfinity",
        "desc": ""
      },
      {
        "name": "TestInvalidCoordinates",
        "desc": "TestInvalidCoordinates tests big.Int values that are not valid field elements (negative or bigger than P). They are expected to return false from IsOnCurve, all other behavior is undefined."
      },
      {
        "name": "TestIssue52075",
        "desc": ""
      },
      {
        "name": "TestLargeIsOnCurve",
        "desc": ""
      },
      {
        "name": "TestMarshal",
        "desc": ""
      },
      {
        "name": "TestMarshalCompressed",
        "desc": ""
      },
      {
        "name": "TestOffCurve",
        "desc": ""
      },
      {
        "name": "TestOnCurve",
        "desc": ""
      },
      {
        "name": "TestP224BaseMult",
        "desc": ""
      },
      {
        "name": "TestP224GenericBaseMult",
        "desc": ""
      },
      {
        "name": "TestP224Overflow",
        "desc": ""
      },
      {
        "name": "TestP256BaseMult",
        "desc": ""
      },
      {
        "name": "TestP256Mult",
        "desc": ""
      },
      {
        "name": "TestUnmarshalToLargeCoordinates",
        "desc": ""
      },
      {
        "name": "Unmarshal",
        "desc": "Unmarshal converts a point, serialized by [Marshal], into an x, y pair. It is an error if the point is not in uncompressed form, is not on the curve, or is the point at infinity. On error, x = nil.  Deprecated: for ECDH, use the crypto/ecdh package. This function accepts an encoding equivalent to that of the NewPublicKey methods in crypto/ecdh."
      },
      {
        "name": "UnmarshalCompressed",
        "desc": "UnmarshalCompressed converts a point, serialized by [MarshalCompressed], into an x, y pair. It is an error if the point is not in compressed form, is not on the curve, or is the point at infinity. On error, x = nil."
      },
      {
        "name": "benchmarkAllCurves",
        "desc": ""
      },
      {
        "name": "bigFromDecimal",
        "desc": ""
      },
      {
        "name": "bigFromHex",
        "desc": ""
      },
      {
        "name": "initAll",
        "desc": ""
      },
      {
        "name": "initP224",
        "desc": ""
      },
      {
        "name": "initP256",
        "desc": ""
      },
      {
        "name": "initP384",
        "desc": ""
      },
      {
        "name": "initP521",
        "desc": ""
      },
      {
        "name": "isInfinity",
        "desc": ""
      },
      {
        "name": "panicIfNotOnCurve",
        "desc": ""
      },
      {
        "name": "testAllCurves",
        "desc": ""
      },
      {
        "name": "testInfinity",
        "desc": ""
      },
      {
        "name": "testInvalidCoordinates",
        "desc": ""
      },
      {
        "name": "testMarshalCompressed",
        "desc": ""
      },
      {
        "name": "testUnmarshalToLargeCoordinates",
        "desc": ""
      },
      {
        "name": "zForAffine",
        "desc": "zForAffine returns a Jacobian Z value for the affine point (x, y). If x and y are zero, it assumes that they represent the point at infinity because (0, 0) is not on the any of the curves handled here."
      },
      {
        "name": "Add",
        "desc": "Add implements [Curve.Add].  Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to provide any security property. For ECDH, use the [crypto/ecdh] package. For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly from [P224], [P256], [P384], or [P521]."
      },
      {
        "name": "Double",
        "desc": "Double implements [Curve.Double].  Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to provide any security property. For ECDH, use the [crypto/ecdh] package. For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly from [P224], [P256], [P384], or [P521]."
      },
      {
        "name": "IsOnCurve",
        "desc": "IsOnCurve implements [Curve.IsOnCurve].  Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to provide any security property. For ECDH, use the [crypto/ecdh] package. For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly from [P224], [P256], [P384], or [P521]."
      },
      {
        "name": "Params",
        "desc": ""
      },
      {
        "name": "ScalarBaseMult",
        "desc": "ScalarBaseMult implements [Curve.ScalarBaseMult].  Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to provide any security property. For ECDH, use the [crypto/ecdh] package. For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly from [P224], [P256], [P384], or [P521]."
      },
      {
        "name": "ScalarMult",
        "desc": "ScalarMult implements [Curve.ScalarMult].  Deprecated: the [CurveParams] methods are deprecated and are not guaranteed to provide any security property. For ECDH, use the [crypto/ecdh] package. For ECDSA, use the [crypto/ecdsa] package with a [Curve] value returned directly from [P224], [P256], [P384], or [P521]."
      },
      {
        "name": "addJacobian",
        "desc": "addJacobian takes two points in Jacobian coordinates, (x1, y1, z1) and (x2, y2, z2) and returns their sum, also in Jacobian form."
      },
      {
        "name": "affineFromJacobian",
        "desc": "affineFromJacobian reverses the Jacobian transform. See the comment at the top of the file. If the point is ∞ it returns 0, 0."
      },
      {
        "name": "doubleJacobian",
        "desc": "doubleJacobian takes a point in Jacobian coordinates, (x, y, z), and returns its double, also in Jacobian form."
      },
      {
        "name": "polynomial",
        "desc": "polynomial returns x³ - 3x + b."
      },
      {
        "name": "Add",
        "desc": ""
      },
      {
        "name": "Double",
        "desc": ""
      },
      {
        "name": "IsOnCurve",
        "desc": ""
      },
      {
        "name": "Params",
        "desc": ""
      },
      {
        "name": "ScalarBaseMult",
        "desc": ""
      },
      {
        "name": "ScalarMult",
        "desc": ""
      },
      {
        "name": "Unmarshal",
        "desc": ""
      },
      {
        "name": "UnmarshalCompressed",
        "desc": ""
      },
      {
        "name": "normalizeScalar",
        "desc": "normalizeScalar brings the scalar within the byte size of the order of the curve, as expected by the nistec scalar multiplication functions."
      },
      {
        "name": "pointFromAffine",
        "desc": ""
      },
      {
        "name": "pointToAffine",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Curve",
        "desc": "A Curve represents a short-form Weierstrass curve with a=-3.  The behavior of Add, Double, and ScalarMult when the input is not a point on the curve is undefined.  Note that the conventional point at infinity (0, 0) is not considered on the curve, although it can be returned by Add, Double, ScalarMult, or ScalarBaseMult (but not the [Unmarshal] or [UnmarshalCompressed] functions).  Using Curve implementations besides those returned by [P224], [P256], [P384], and [P521] is deprecated."
      },
      {
        "name": "CurveParams",
        "desc": "CurveParams contains the parameters of an elliptic curve and also provides a generic, non-constant time implementation of [Curve].  The generic Curve implementation is deprecated, and using custom curves (those not returned by [P224], [P256], [P384], and [P521]) is not guaranteed to provide any security property."
      },
      {
        "name": "baseMultTest",
        "desc": ""
      },
      {
        "name": "nistCurve",
        "desc": "nistCurve is a Curve implementation based on a nistec Point.  It's a wrapper that exposes the big.Int-based Curve interface and encodes the legacy idiosyncrasies it requires, such as invalid and infinity point handling.  To interact with the nistec package, points are encoded into and decoded from properly formatted byte slices. All big.Int use is limited to this package. Encoding and decoding is 1/1000th of the runtime of a scalar multiplication, so the overhead is acceptable."
      },
      {
        "name": "nistPoint",
        "desc": "nistPoint is a generic constraint for the nistec Point types."
      },
      {
        "name": "scalarMultTest",
        "desc": ""
      },
      {
        "name": "unmarshaler",
        "desc": "unmarshaler is implemented by curves with their own constant-time Unmarshal.  There isn't an equivalent interface for Marshal/MarshalCompressed because that doesn't involve any mathematical operations, only FillBytes and Bit."
      }
    ]
  },
  {
    "name": "crypto/fips140",
    "desc": "",
    "functions": [
      {
        "name": "Enabled",
        "desc": "Enabled reports whether the cryptography libraries are operating in FIPS 140-3 mode.  It can be controlled at runtime using the GODEBUG setting \"fips140\". If set to \"on\", FIPS 140-3 mode is enabled. If set to \"only\", non-approved cryptography functions will additionally return errors or panic.  This can't be changed after the program has started."
      },
      {
        "name": "TestImmutableGODEBUG",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/hkdf",
    "desc": "Package hkdf implements the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) as defined in RFC 5869.  HKDF is a cryptographic key derivation function (KDF) with the goal of expanding limited input keying material into one or more cryptographically strong secret keys.",
    "functions": [
      {
        "name": "Benchmark16ByteMD5Single",
        "desc": ""
      },
      {
        "name": "Benchmark20ByteSHA1Single",
        "desc": ""
      },
      {
        "name": "Benchmark32ByteSHA256Single",
        "desc": ""
      },
      {
        "name": "Benchmark64ByteSHA512Single",
        "desc": ""
      },
      {
        "name": "Expand",
        "desc": "Expand derives a key from the given hash, key, and optional context info, returning a []byte of length keyLength that can be used as cryptographic key. The extraction step is skipped.  The key should have been generated by [Extract], or be a uniformly random or pseudorandom cryptographically strong key. See RFC 5869, Section 3.3. Most common scenarios will want to use [Key] instead."
      },
      {
        "name": "Extract",
        "desc": "Extract generates a pseudorandom key for use with [Expand] from an input secret and an optional independent salt.  Only use this function if you need to reuse the extracted key with multiple Expand invocations and different context values. Most common scenarios, including the generation of multiple keys, should use [Key] instead."
      },
      {
        "name": "Key",
        "desc": "Key derives a key from the given hash, secret, salt and context info, returning a []byte of length keyLength that can be used as cryptographic key. Salt and info can be nil."
      },
      {
        "name": "TestFIPSServiceIndicator",
        "desc": ""
      },
      {
        "name": "TestHKDF",
        "desc": ""
      },
      {
        "name": "TestHKDFLimit",
        "desc": ""
      },
      {
        "name": "benchmarkHKDF",
        "desc": ""
      },
      {
        "name": "checkFIPS140Only",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "hkdfTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/hmac",
    "desc": "Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198. An HMAC is a cryptographic hash that uses a key to sign a message. The receiver verifies the hash by recomputing it using the same key.  Receivers should be careful to use Equal to compare MACs in order to avoid timing side-channels:  \t// ValidMAC reports whether messageMAC is a valid HMAC tag for message. \tfunc ValidMAC(message, messageMAC, key []byte) bool { \t\tmac := hmac.New(sha256.New, key) \t\tmac.Write(message) \t\texpectedMAC := mac.Sum(nil) \t\treturn hmac.Equal(messageMAC, expectedMAC) \t}",
    "functions": [
      {
        "name": "BenchmarkHMACSHA256_1K",
        "desc": ""
      },
      {
        "name": "BenchmarkHMACSHA256_32",
        "desc": ""
      },
      {
        "name": "BenchmarkNewWriteSum",
        "desc": ""
      },
      {
        "name": "Equal",
        "desc": "Equal compares two MACs for equality without leaking timing information."
      },
      {
        "name": "New",
        "desc": "New returns a new HMAC hash using the given [hash.Hash] type and key. New functions like [crypto/sha256.New] can be used as h. h must return a new Hash every time it is called. Note that unlike other hash implementations in the standard library, the returned Hash does not implement [encoding.BinaryMarshaler] or [encoding.BinaryUnmarshaler]."
      },
      {
        "name": "TestEqual",
        "desc": ""
      },
      {
        "name": "TestExtraMethods",
        "desc": ""
      },
      {
        "name": "TestHMAC",
        "desc": ""
      },
      {
        "name": "TestHMACHash",
        "desc": ""
      },
      {
        "name": "TestNoClone",
        "desc": ""
      },
      {
        "name": "TestNonUniqueHash",
        "desc": ""
      },
      {
        "name": "maybeCloner",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "hmacTest",
        "desc": ""
      },
      {
        "name": "justHash",
        "desc": "justHash implements just the hash.Hash methods and nothing else"
      }
    ]
  },
  {
    "name": "crypto/md5",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNew",
        "desc": ""
      },
      {
        "name": "ExampleNew_file",
        "desc": ""
      },
      {
        "name": "ExampleSum",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/mlkem",
    "desc": "",
    "functions": [
      {
        "name": "Bob",
        "desc": ""
      },
      {
        "name": "Example",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/pbkdf2",
    "desc": "Package pbkdf2 implements the key derivation function PBKDF2 as defined in RFC 8018 (PKCS #5 v2.1).  A key derivation function is useful when encrypting data based on a password or any other not-fully-random data. It uses a pseudorandom function to derive a secure encryption key based on the password.",
    "functions": [
      {
        "name": "Key",
        "desc": "Key derives a key from the password, salt and iteration count, returning a []byte of length keyLength that can be used as cryptographic key. The key is derived based on the method described as PBKDF2 with the HMAC variant using the supplied hash function.  For example, to use a HMAC-SHA-1 based PBKDF2 key derivation function, you can get a derived key for e.g. AES-256 (which needs a 32-byte key) by doing:  \tdk := pbkdf2.Key(sha1.New, \"some password\", salt, 4096, 32)  Remember to get a good random salt. At least 8 bytes is recommended by the RFC.  Using a higher iteration count will increase the cost of an exhaustive search but will also make derivation proportionally slower.  keyLength must be a positive integer between 1 and (2^32 - 1) * h.Size(). Setting keyLength to a value outside of this range will result in an error."
      }
    ],
    "types": null
  },
  {
    "name": "crypto/rand",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkPrime",
        "desc": ""
      },
      {
        "name": "ExampleInt",
        "desc": "ExampleInt prints a single cryptographically secure pseudorandom number between 0 and 99 inclusive."
      },
      {
        "name": "ExamplePrime",
        "desc": "ExamplePrime prints a cryptographically secure pseudorandom 64 bit prime number."
      },
      {
        "name": "ExampleRead",
        "desc": "ExampleRead prints a cryptographically secure pseudorandom 32 byte key."
      },
      {
        "name": "ExampleText",
        "desc": "ExampleText prints a random key encoded in base32."
      },
      {
        "name": "TestInt",
        "desc": ""
      },
      {
        "name": "TestIntEmptyMaxPanics",
        "desc": "Test that passing a new big.Int as max causes Int to panic"
      },
      {
        "name": "TestIntMask",
        "desc": "Test that Int does not mask out valid return values"
      },
      {
        "name": "TestIntNegativeMaxPanics",
        "desc": "Test that passing a negative value as max causes Int to panic"
      },
      {
        "name": "TestIntReads",
        "desc": "Test that Int reads only the necessary number of bytes from the reader for max at each bit length"
      },
      {
        "name": "TestPrimeBitsLt2",
        "desc": "Test that passing bits \u003c 2 causes Prime to return nil, error"
      },
      {
        "name": "TestPrimeNondeterministic",
        "desc": ""
      },
      {
        "name": "TestPrimeSmall",
        "desc": "https://golang.org/issue/6849."
      },
      {
        "name": "TestText",
        "desc": ""
      },
      {
        "name": "indexSetTable",
        "desc": ""
      },
      {
        "name": "testIntPanics",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "countingReader",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/rc4",
    "desc": "Package rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied Cryptography.  RC4 is cryptographically broken and should not be used for secure applications.",
    "functions": [
      {
        "name": "BenchmarkRC4_128",
        "desc": ""
      },
      {
        "name": "BenchmarkRC4_1K",
        "desc": ""
      },
      {
        "name": "BenchmarkRC4_8K",
        "desc": ""
      },
      {
        "name": "TestBlock",
        "desc": ""
      },
      {
        "name": "TestGolden",
        "desc": ""
      },
      {
        "name": "TestRC4Stream",
        "desc": ""
      },
      {
        "name": "benchmark",
        "desc": ""
      },
      {
        "name": "testEncrypt",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": "Reset zeros the key data and makes the [Cipher] unusable.  Deprecated: Reset can't guarantee that the key will be entirely removed from the process's memory."
      },
      {
        "name": "XORKeyStream",
        "desc": "XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src must overlap entirely or not at all."
      },
      {
        "name": "Error",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Cipher",
        "desc": "A Cipher is an instance of RC4 using a particular key."
      },
      {
        "name": "KeySizeError",
        "desc": ""
      },
      {
        "name": "rc4Test",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/rsa",
    "desc": "Package rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.  RSA is a single, fundamental operation that is used in this package to implement either public-key encryption or public-key signatures.  The original specification for encryption and signatures with RSA is PKCS #1 and the terms \"RSA encryption\" and \"RSA signatures\" by default refer to PKCS #1 version 1.5. However, that specification has flaws and new designs should use version 2, usually called by just OAEP and PSS, where possible.  Two sets of interfaces are included in this package. When a more abstract interface isn't necessary, there are functions for encrypting/decrypting with v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the public key primitive, the PrivateKey type implements the Decrypter and Signer interfaces from the crypto package.  Operations involving private keys are implemented using constant-time algorithms, except for [GenerateKey] and for some operations involving deprecated multi-prime keys.  # Minimum key size  [GenerateKey] returns an error if a key of less than 1024 bits is requested, and all Sign, Verify, Encrypt, and Decrypt methods return an error if used with a key smaller than 1024 bits. Such keys are insecure and should not be used.  The rsa1024min=0 GODEBUG setting suppresses this error, but we recommend doing so only in tests, if necessary. Tests can set this option using [testing.T.Setenv] or by including \"//go:debug rsa1024min=0\" in a *_test.go source file.  Alternatively, see the [GenerateKey (TestKey)] example for a pregenerated test-only 2048-bit key.  [GenerateKey (TestKey)]: https://pkg.go.dev/crypto/rsa#example-GenerateKey-TestKey",
    "functions": [
      {
        "name": "BenchmarkBoringVerify",
        "desc": ""
      },
      {
        "name": "DecryptOAEP",
        "desc": "DecryptOAEP decrypts ciphertext using RSA-OAEP.  OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.  The random parameter is legacy and ignored, and it can be nil.  The label parameter must match the value given when encrypting. See [EncryptOAEP] for details."
      },
      {
        "name": "DecryptPKCS1v15",
        "desc": "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil.  Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem."
      },
      {
        "name": "DecryptPKCS1v15SessionKey",
        "desc": "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil.  DecryptPKCS1v15SessionKey returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value.  Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This also defeats the point of this function. Using at least a 16-byte key will protect against this attack.  This method implements protections against Bleichenbacher chosen ciphertext attacks [0] described in RFC 3218 Section 2.3.2 [1]. While these protections make a Bleichenbacher attack significantly more difficult, the protections are only effective if the rest of the protocol which uses DecryptPKCS1v15SessionKey is designed with these considerations in mind. In particular, if any subsequent operations which use the decrypted session key leak any information about the key (e.g. whether it is a static or random key) then the mitigations are defeated. This method must be used extremely carefully, and typically should only be used when absolutely necessary for compatibility with an existing protocol (such as TLS) that is designed with these properties in mind.    - [0] “Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption     Standard PKCS #1”, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98)   - [1] RFC 3218, Preventing the Million Message Attack on CMS,     https://www.rfc-editor.org/rfc/rfc3218.html"
      },
      {
        "name": "EncryptOAEP",
        "desc": "EncryptOAEP encrypts the given message with RSA-OAEP.  OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.  The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. Most applications should use [crypto/rand.Reader] as random.  The label parameter may contain arbitrary data that will not be encrypted, but which gives important context to the message. For example, if a given public key is used to encrypt two types of messages then distinct label values could be used to ensure that a ciphertext for one purpose cannot be used for another by an attacker. If not required it can be empty.  The message must be no longer than the length of the public modulus minus twice the hash length, minus a further 2."
      },
      {
        "name": "EncryptPKCS1v15",
        "desc": "EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS #1 v1.5.  The message must be no longer than the length of the public modulus minus 11 bytes.  The random parameter is used as a source of entropy to ensure that encrypting the same message twice doesn't result in the same ciphertext. Most applications should use [crypto/rand.Reader] as random. Note that the returned ciphertext does not depend deterministically on the bytes read from random, and may change between calls and/or between versions.  WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols."
      },
      {
        "name": "SignPKCS1v15",
        "desc": "SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS #1 v1.5.  Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.  The random parameter is legacy and ignored, and it can be nil.  This function is deterministic. Thus, if the set of possible messages is small, an attacker may be able to build a map from messages to signatures and identify the signed messages. As ever, signatures provide authenticity, not confidentiality."
      },
      {
        "name": "SignPSS",
        "desc": "SignPSS calculates the signature of digest using PSS.  digest must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. If opts.Hash is set, it overrides hash.  The signature is randomized depending on the message, key, and salt size, using bytes from rand. Most applications should use [crypto/rand.Reader] as rand."
      },
      {
        "name": "TestBoringASN1Marshal",
        "desc": ""
      },
      {
        "name": "TestBoringFinalizers",
        "desc": ""
      },
      {
        "name": "TestBoringGenerateKey",
        "desc": ""
      },
      {
        "name": "TestBoringVerify",
        "desc": ""
      },
      {
        "name": "VerifyPKCS1v15",
        "desc": "VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.  The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs."
      },
      {
        "name": "VerifyPSS",
        "desc": "VerifyPSS verifies a PSS signature.  A valid signature is indicated by returning a nil error. digest must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used. opts.Hash is ignored.  The inputs are not considered confidential, and may leak through timing side channels, or if an attacker has control of part of the inputs."
      },
      {
        "name": "bigFromHex",
        "desc": ""
      },
      {
        "name": "bigIntEqual",
        "desc": "bigIntEqual reports whether a and b are equal leaking only their bit length through timing side-channels."
      },
      {
        "name": "boringPrivateKey",
        "desc": ""
      },
      {
        "name": "boringPublicKey",
        "desc": ""
      },
      {
        "name": "checkFIPS140OnlyPrivateKey",
        "desc": ""
      },
      {
        "name": "checkFIPS140OnlyPublicKey",
        "desc": ""
      },
      {
        "name": "checkKeySize",
        "desc": ""
      },
      {
        "name": "checkPublicKeySize",
        "desc": ""
      },
      {
        "name": "decryptOAEP",
        "desc": ""
      },
      {
        "name": "decryptPKCS1v15",
        "desc": "decryptPKCS1v15 decrypts ciphertext using priv. It returns one or zero in valid that indicates whether the plaintext was correctly structured. In either case, the plaintext is returned in em so that it may be read independently of whether it was valid in order to maintain constant memory access patterns. If the plaintext was valid then index contains the index of the original message in em, to allow constant time padding removal."
      },
      {
        "name": "fipsError",
        "desc": ""
      },
      {
        "name": "fipsError2",
        "desc": ""
      },
      {
        "name": "fipsPrivateKey",
        "desc": ""
      },
      {
        "name": "fipsPublicKey",
        "desc": ""
      },
      {
        "name": "fromHex",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "nonZeroRandomBytes",
        "desc": "nonZeroRandomBytes fills the given slice with non-zero random octets."
      },
      {
        "name": "privateKeyEqual",
        "desc": ""
      },
      {
        "name": "publicKeyEqual",
        "desc": ""
      },
      {
        "name": "HashFunc",
        "desc": "HashFunc returns opts.Hash so that [PSSOptions] implements [crypto.SignerOpts]."
      },
      {
        "name": "saltLength",
        "desc": ""
      },
      {
        "name": "Decrypt",
        "desc": "Decrypt decrypts ciphertext with priv. If opts is nil or of type *[PKCS1v15DecryptOptions] then PKCS #1 v1.5 decryption is performed. Otherwise opts must have type *[OAEPOptions] and OAEP decryption is done."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether priv and x have equivalent values. It ignores Precomputed values."
      },
      {
        "name": "Precompute",
        "desc": "Precompute performs some calculations that speed up private key operations in the future. It is safe to run on non-validated private keys."
      },
      {
        "name": "Public",
        "desc": "Public returns the public key corresponding to priv."
      },
      {
        "name": "Sign",
        "desc": "Sign signs digest with priv, reading randomness from rand. If opts is a *[PSSOptions] then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will be used. digest must be the result of hashing the input message using opts.HashFunc().  This method implements [crypto.Signer], which is an interface to support keys where the private part is kept in, for example, a hardware module. Common uses should use the Sign* functions in this package directly."
      },
      {
        "name": "Validate",
        "desc": "Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.  It runs faster on valid keys if run after [PrivateKey.Precompute]."
      },
      {
        "name": "precompute",
        "desc": ""
      },
      {
        "name": "precomputeLegacy",
        "desc": ""
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether pub and x have the same value."
      },
      {
        "name": "Size",
        "desc": "Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size."
      }
    ],
    "types": [
      {
        "name": "CRTValue",
        "desc": "CRTValue contains the precomputed Chinese remainder theorem values."
      },
      {
        "name": "OAEPOptions",
        "desc": "OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface."
      },
      {
        "name": "PKCS1v15DecryptOptions",
        "desc": "PKCS1v15DecryptOptions is for passing options to PKCS #1 v1.5 decryption using the [crypto.Decrypter] interface."
      },
      {
        "name": "PSSOptions",
        "desc": "PSSOptions contains options for creating and verifying PSS signatures."
      },
      {
        "name": "PrecomputedValues",
        "desc": ""
      },
      {
        "name": "PrivateKey",
        "desc": "A PrivateKey represents an RSA key"
      },
      {
        "name": "PublicKey",
        "desc": "A PublicKey represents the public part of an RSA key.  The values of N and E are not considered confidential, and may leak through side channels, or could be mathematically derived from other public values."
      },
      {
        "name": "boringPriv",
        "desc": ""
      },
      {
        "name": "boringPub",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/sha1",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNew",
        "desc": ""
      },
      {
        "name": "ExampleNew_file",
        "desc": ""
      },
      {
        "name": "ExampleSum",
        "desc": ""
      },
      {
        "name": "TestOutOfBoundsRead",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/sha256",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNew",
        "desc": ""
      },
      {
        "name": "ExampleNew_file",
        "desc": ""
      },
      {
        "name": "ExampleSum256",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/sha3",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkSha3_224_MTU",
        "desc": ""
      },
      {
        "name": "BenchmarkSha3_256_MTU",
        "desc": ""
      },
      {
        "name": "BenchmarkSha3_384_MTU",
        "desc": ""
      },
      {
        "name": "BenchmarkSha3_512_1MiB",
        "desc": ""
      },
      {
        "name": "BenchmarkSha3_512_MTU",
        "desc": ""
      },
      {
        "name": "BenchmarkShake128_MTU",
        "desc": ""
      },
      {
        "name": "BenchmarkShake256_16x",
        "desc": ""
      },
      {
        "name": "BenchmarkShake256_1MiB",
        "desc": ""
      },
      {
        "name": "BenchmarkShake256_MTU",
        "desc": ""
      },
      {
        "name": "TestAllocations",
        "desc": ""
      },
      {
        "name": "TestAppend",
        "desc": "TestAppend checks that appending works when reallocation is necessary."
      },
      {
        "name": "TestAppendNoRealloc",
        "desc": "TestAppendNoRealloc tests that appending works when no reallocation is necessary."
      },
      {
        "name": "TestCSHAKEAccumulated",
        "desc": ""
      },
      {
        "name": "TestCSHAKELargeS",
        "desc": ""
      },
      {
        "name": "TestMarshalUnmarshal",
        "desc": ""
      },
      {
        "name": "TestReset",
        "desc": ""
      },
      {
        "name": "TestSHA3Hash",
        "desc": ""
      },
      {
        "name": "TestSqueezing",
        "desc": "TestSqueezing checks that squeezing the full output a single time produces the same output as repeatedly squeezing the instance."
      },
      {
        "name": "TestUnalignedWrite",
        "desc": "TestUnalignedWrite tests that writing data in an arbitrary pattern with small input buffers."
      },
      {
        "name": "benchmarkHash",
        "desc": "benchmarkHash tests the speed to hash num buffers of buflen each."
      },
      {
        "name": "benchmarkShake",
        "desc": "benchmarkShake is specialized to the Shake instances, which don't require a copy on reading output."
      },
      {
        "name": "sequentialBytes",
        "desc": "sequentialBytes produces a buffer of size consecutive bytes 0x00, 0x01, ..., used for testing.  The alignment of each slice is intentionally randomized to detect alignment issues in the implementation. See https://golang.org/issue/37644. Ideally, the compiler should fuzz the alignment itself. (See https://golang.org/issue/35128.)"
      },
      {
        "name": "testAppend",
        "desc": ""
      },
      {
        "name": "testAppendNoRealloc",
        "desc": ""
      },
      {
        "name": "testCSHAKEAccumulated",
        "desc": ""
      },
      {
        "name": "testCSHAKELargeS",
        "desc": ""
      },
      {
        "name": "testMarshalUnmarshal",
        "desc": "TODO(filippo): move this to crypto/internal/cryptotest."
      },
      {
        "name": "testMarshalUnmarshalSHAKE",
        "desc": "TODO(filippo): move this to crypto/internal/cryptotest."
      },
      {
        "name": "testReset",
        "desc": ""
      },
      {
        "name": "testSqueezing",
        "desc": ""
      },
      {
        "name": "testUnalignedWrite",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/sha512",
    "desc": "Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.  All the hash.Hash implementations returned by this package also implement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
    "functions": [
      {
        "name": "BenchmarkHash1K",
        "desc": ""
      },
      {
        "name": "BenchmarkHash8Bytes",
        "desc": ""
      },
      {
        "name": "BenchmarkHash8K",
        "desc": ""
      },
      {
        "name": "New",
        "desc": "New returns a new [hash.Hash] computing the SHA-512 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "New384",
        "desc": "New384 returns a new [hash.Hash] computing the SHA-384 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "New512_224",
        "desc": "New512_224 returns a new [hash.Hash] computing the SHA-512/224 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "New512_256",
        "desc": "New512_256 returns a new [hash.Hash] computing the SHA-512/256 checksum. The Hash also implements [encoding.BinaryMarshaler], [encoding.BinaryAppender] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "Sum384",
        "desc": "Sum384 returns the SHA384 checksum of the data."
      },
      {
        "name": "Sum512",
        "desc": "Sum512 returns the SHA512 checksum of the data."
      },
      {
        "name": "Sum512_224",
        "desc": "Sum512_224 returns the Sum512/224 checksum of the data."
      },
      {
        "name": "Sum512_256",
        "desc": "Sum512_256 returns the Sum512/256 checksum of the data."
      },
      {
        "name": "TestAllocations",
        "desc": ""
      },
      {
        "name": "TestBlockSize",
        "desc": ""
      },
      {
        "name": "TestExtraMethods",
        "desc": ""
      },
      {
        "name": "TestGolden",
        "desc": ""
      },
      {
        "name": "TestGoldenMarshal",
        "desc": ""
      },
      {
        "name": "TestHash",
        "desc": ""
      },
      {
        "name": "TestLargeHashes",
        "desc": ""
      },
      {
        "name": "TestMarshalMismatch",
        "desc": ""
      },
      {
        "name": "TestSize",
        "desc": ""
      },
      {
        "name": "benchmarkSize",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "maybeCloner",
        "desc": ""
      },
      {
        "name": "safeSum",
        "desc": ""
      },
      {
        "name": "testGolden",
        "desc": ""
      },
      {
        "name": "testGoldenMarshal",
        "desc": ""
      },
      {
        "name": "testHash",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "sha512Test",
        "desc": ""
      },
      {
        "name": "unmarshalTest",
        "desc": "Tests for unmarshaling hashes that have hashed a large amount of data The initial hash generation is omitted from the test, because it takes a long time. The test contains some already-generated states, and their expected sums Tests a problem that is outlined in GitHub issue #29541 The problem is triggered when an amount of data has been hashed for which the data length has a 1 in the 32nd bit. When casted to int, this changes the sign of the value, and causes the modulus operation to return a different result."
      }
    ]
  },
  {
    "name": "crypto/subtle",
    "desc": "Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.",
    "functions": [
      {
        "name": "BenchmarkConstantTimeByteEq",
        "desc": ""
      },
      {
        "name": "BenchmarkConstantTimeEq",
        "desc": ""
      },
      {
        "name": "BenchmarkConstantTimeLessOrEq",
        "desc": ""
      },
      {
        "name": "ConstantTimeByteEq",
        "desc": "ConstantTimeByteEq returns 1 if x == y and 0 otherwise."
      },
      {
        "name": "ConstantTimeCompare",
        "desc": "ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents. If the lengths of x and y do not match it returns 0 immediately."
      },
      {
        "name": "ConstantTimeCopy",
        "desc": "ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value."
      },
      {
        "name": "ConstantTimeEq",
        "desc": "ConstantTimeEq returns 1 if x == y and 0 otherwise."
      },
      {
        "name": "ConstantTimeLessOrEq",
        "desc": "ConstantTimeLessOrEq returns 1 if x \u003c= y and 0 otherwise. Its behavior is undefined if x or y are negative or \u003e 2**31 - 1."
      },
      {
        "name": "ConstantTimeSelect",
        "desc": "ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value."
      },
      {
        "name": "TestConstantTimeByteEq",
        "desc": ""
      },
      {
        "name": "TestConstantTimeCompare",
        "desc": ""
      },
      {
        "name": "TestConstantTimeCopy",
        "desc": ""
      },
      {
        "name": "TestConstantTimeEq",
        "desc": ""
      },
      {
        "name": "TestConstantTimeLessOrEq",
        "desc": ""
      },
      {
        "name": "TestDITPanic",
        "desc": ""
      },
      {
        "name": "TestWithDataIndependentTiming",
        "desc": ""
      },
      {
        "name": "WithDataIndependentTiming",
        "desc": "WithDataIndependentTiming enables architecture specific features which ensure that the timing of specific instructions is independent of their inputs before executing f. On f returning it disables these features.  WithDataIndependentTiming should only be used when f is written to make use of constant-time operations. WithDataIndependentTiming does not make variable-time code constant-time.  WithDataIndependentTiming may lock the current goroutine to the OS thread for the duration of f. Calls to WithDataIndependentTiming may be nested.  On Arm64 processors with FEAT_DIT, WithDataIndependentTiming enables PSTATE.DIT. See https://developer.arm.com/documentation/ka005181/1-0/?lang=en.  Currently, on all other architectures WithDataIndependentTiming executes f immediately with no other side-effects."
      },
      {
        "name": "XORBytes",
        "desc": "XORBytes sets dst[i] = x[i] ^ y[i] for all i \u003c n = min(len(x), len(y)), returning n, the number of bytes written to dst.  If dst does not have length at least n, XORBytes panics without writing anything to dst.  dst and x or y may overlap exactly or not at all, otherwise XORBytes may panic."
      },
      {
        "name": "byteEq",
        "desc": ""
      },
      {
        "name": "constantTimeCopyWrapper",
        "desc": ""
      },
      {
        "name": "eq",
        "desc": ""
      },
      {
        "name": "makeCopy",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "TestConstantTimeByteEqStruct",
        "desc": ""
      },
      {
        "name": "TestConstantTimeCompareStruct",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/tls",
    "desc": "Copyright 2025 The Go Authors. All rights reserved. Use of this source code is governed by a BSD-style license that can be found in the LICENSE file.  Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446.  # FIPS 140-3 mode  When the program is in [FIPS 140-3 mode], this package behaves as if only SP 800-140C and SP 800-140D approved protocol versions, cipher suites, signature algorithms, certificate public key types and sizes, and key exchange and derivation algorithms were implemented. Others are silently ignored and not negotiated, or rejected. This set may depend on the algorithms supported by the FIPS 140-3 Go Cryptographic Module selected with GOFIPS140, and may change across Go versions.  [FIPS 140-3 mode]: https://go.dev/doc/security/fips140",
    "functions": [
      {
        "name": "BenchmarkHandshakeServer",
        "desc": ""
      },
      {
        "name": "BenchmarkLatency",
        "desc": ""
      },
      {
        "name": "BenchmarkThroughput",
        "desc": ""
      },
      {
        "name": "CipherSuiteName",
        "desc": "CipherSuiteName returns the standard name for the passed cipher suite ID (e.g. \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"), or a fallback representation of the ID value if the cipher suite is not implemented by this package."
      },
      {
        "name": "Listen",
        "desc": "Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate."
      },
      {
        "name": "NewListener",
        "desc": "NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with [Server]. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate."
      },
      {
        "name": "TestACVPVectors",
        "desc": ""
      },
      {
        "name": "TestAESCipherReordering",
        "desc": ""
      },
      {
        "name": "TestAESCipherReorderingTLS13",
        "desc": ""
      },
      {
        "name": "TestAlertFlushing",
        "desc": ""
      },
      {
        "name": "TestAlertForwarding",
        "desc": ""
      },
      {
        "name": "TestBogoSuite",
        "desc": ""
      },
      {
        "name": "TestBuffering",
        "desc": ""
      },
      {
        "name": "TestBuildNameToCertificate_doesntModifyCertificates",
        "desc": "Issue 28744: Ensure that we don't modify memory that Config doesn't own such as Certificates."
      },
      {
        "name": "TestCertificateSelection",
        "desc": ""
      },
      {
        "name": "TestCipherSuitePreference",
        "desc": ""
      },
      {
        "name": "TestCipherSuites",
        "desc": ""
      },
      {
        "name": "TestClientAuth",
        "desc": ""
      },
      {
        "name": "TestClientHandshakeContextCancellation",
        "desc": "TestClientHandshakeContextCancellation tests that canceling the context given to the client side conn.HandshakeContext interrupts the in-progress handshake."
      },
      {
        "name": "TestClientHelloInfo_SupportsCertificate",
        "desc": ""
      },
      {
        "name": "TestClientKeyUpdate",
        "desc": ""
      },
      {
        "name": "TestCloneFuncFields",
        "desc": ""
      },
      {
        "name": "TestCloneHash",
        "desc": ""
      },
      {
        "name": "TestCloneNilConfig",
        "desc": ""
      },
      {
        "name": "TestCloneNonFuncFields",
        "desc": ""
      },
      {
        "name": "TestClose",
        "desc": ""
      },
      {
        "name": "TestCloseClientConnectionOnIdleServer",
        "desc": ""
      },
      {
        "name": "TestCloseServerConnectionOnIdleClient",
        "desc": ""
      },
      {
        "name": "TestConnCloseBreakingWrite",
        "desc": ""
      },
      {
        "name": "TestConnCloseWrite",
        "desc": ""
      },
      {
        "name": "TestConnReadNonzeroAndEOF",
        "desc": "tests that Conn.Read returns (non-zero, io.EOF) instead of (non-zero, nil) when a Close (alertCloseNotify) is sitting right behind the application data in the buffer."
      },
      {
        "name": "TestConnectionState",
        "desc": ""
      },
      {
        "name": "TestConnectionStateMarshal",
        "desc": ""
      },
      {
        "name": "TestCrossVersionResume",
        "desc": ""
      },
      {
        "name": "TestDeadlineOnWrite",
        "desc": ""
      },
      {
        "name": "TestDecodeECHConfigLists",
        "desc": ""
      },
      {
        "name": "TestDialTimeout",
        "desc": ""
      },
      {
        "name": "TestDialer",
        "desc": "TestDialer tests that tls.Dialer.DialContext can abort in the middle of a handshake. (The other cases are all handled by the existing dial tests in this package, which all also flow through the same code shared code paths)"
      },
      {
        "name": "TestDontSelectECDSAWithRSAKey",
        "desc": ""
      },
      {
        "name": "TestDontSelectRSAWithECDSAKey",
        "desc": ""
      },
      {
        "name": "TestDowngradeCanary",
        "desc": ""
      },
      {
        "name": "TestDynamicRecordSizingWithAEAD",
        "desc": ""
      },
      {
        "name": "TestDynamicRecordSizingWithCBC",
        "desc": ""
      },
      {
        "name": "TestDynamicRecordSizingWithStreamCipher",
        "desc": ""
      },
      {
        "name": "TestDynamicRecordSizingWithTLSv13",
        "desc": ""
      },
      {
        "name": "TestECH",
        "desc": ""
      },
      {
        "name": "TestECHTLS12Server",
        "desc": ""
      },
      {
        "name": "TestEarlyLargeCertMsg",
        "desc": ""
      },
      {
        "name": "TestFIPSCertAlgs",
        "desc": ""
      },
      {
        "name": "TestFIPSClientHello",
        "desc": ""
      },
      {
        "name": "TestFIPSServerCipherSuites",
        "desc": ""
      },
      {
        "name": "TestFIPSServerCurves",
        "desc": ""
      },
      {
        "name": "TestFIPSServerProtocolVersion",
        "desc": ""
      },
      {
        "name": "TestFIPSServerSignatureAndHash",
        "desc": ""
      },
      {
        "name": "TestFailedWrite",
        "desc": ""
      },
      {
        "name": "TestFallbackSCSV",
        "desc": ""
      },
      {
        "name": "TestFuzz",
        "desc": ""
      },
      {
        "name": "TestGetClientCertificate",
        "desc": ""
      },
      {
        "name": "TestGetConfigForClient",
        "desc": ""
      },
      {
        "name": "TestHairpinInClose",
        "desc": ""
      },
      {
        "name": "TestHandshakClientSCTs",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientAES128CBCSHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientAES128SHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientAES256GCMSHA384",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientAES256SHA384",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientALPNMatch",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientCHACHA20SHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientCertECDSA",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientCertRSA",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientCertRSAPKCS1v15",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientCertRSAPSS",
        "desc": "TestHandshakeClientCertRSAPSS tests rsa_pss_rsae_sha256 signatures from both client and server certificates. It also serves from both sides a certificate signed itself with RSA-PSS, mostly to check that crypto/x509 chain validation works."
      },
      {
        "name": "TestHandshakeClientECDHEECDSAAES",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDHEECDSAAES128CBCSHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDHEECDSAAESGCM",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDHEECDSAChaCha20",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDHERSAAES",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDHERSAAES128CBCSHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDHERSAChaCha20",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientECDSATLS13",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientEd25519",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientExportKeyingMaterial",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientHelloRetryRequest",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientP256",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientRSAAES128GCM",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientRSAAES256GCM",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientRSARC4",
        "desc": ""
      },
      {
        "name": "TestHandshakeClientX25519",
        "desc": ""
      },
      {
        "name": "TestHandshakeContextHierarchy",
        "desc": "TestHandshakeContextHierarchy tests whether the contexts available to GetClientCertificate and GetCertificate are derived from the context provided to HandshakeContext, and that those contexts are canceled after HandshakeContext has returned."
      },
      {
        "name": "TestHandshakeMLKEM",
        "desc": ""
      },
      {
        "name": "TestHandshakeRSATooBig",
        "desc": ""
      },
      {
        "name": "TestHandshakeRace",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerAES128SHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerAES256GCMSHA384",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerAES256SHA384",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerAESGCM",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerALPN",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerALPNFallback",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerALPNNoMatch",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerALPNNotConfigured",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerCHACHA20SHA256",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerECDHEECDSAAES",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerEd25519",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerEmptyCertificates",
        "desc": "TestHandshakeServerEmptyCertificates tests that GetCertificates is called in the case that Certificates is empty, even without SNI."
      },
      {
        "name": "TestHandshakeServerExportKeyingMaterial",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerGetCertificateExtensions",
        "desc": "TestHandshakeServerGetCertificateExtensions tests to make sure that the Extensions passed to GetCertificate match what we expect based on the clientHelloMsg"
      },
      {
        "name": "TestHandshakeServerHelloRetryRequest",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerKeySharePreference",
        "desc": "TestHandshakeServerKeySharePreference checks that we prefer a key share even if it's later in the CurvePreferences order."
      },
      {
        "name": "TestHandshakeServerP256",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerRSA3DES",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerRSAAES",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerRSAPKCS1v15",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerRSAPSS",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerRSARC4",
        "desc": ""
      },
      {
        "name": "TestHandshakeServerSNI",
        "desc": "TestHandshakeServerSNI involves a client sending an SNI extension of \"snitest.com\", which happens to match the CN of testSNICertificate. The test verifies that the server correctly selects that certificate."
      },
      {
        "name": "TestHandshakeServerSNIGetCertificate",
        "desc": "TestHandshakeServerSNIGetCertificate is similar to TestHandshakeServerSNI, but tests the dynamic GetCertificate method"
      },
      {
        "name": "TestHandshakeServerSNIGetCertificateError",
        "desc": "TestHandshakeServerSNIGetCertificateError tests to make sure that errors in GetCertificate result in a tls alert."
      },
      {
        "name": "TestHandshakeServerSNIGetCertificateNotFound",
        "desc": "TestHandshakeServerSNIGetCertificateNotFound is similar to TestHandshakeServerSNICertForName, but tests to make sure that when the GetCertificate method doesn't return a cert, we fall back to what's in the NameToCertificate map."
      },
      {
        "name": "TestHandshakeServerX25519",
        "desc": ""
      },
      {
        "name": "TestHostnameInSNI",
        "desc": ""
      },
      {
        "name": "TestKeyLogTLS12",
        "desc": ""
      },
      {
        "name": "TestKeyLogTLS13",
        "desc": ""
      },
      {
        "name": "TestKeyTooSmallForRSAPSS",
        "desc": ""
      },
      {
        "name": "TestKeysFromPreMasterSecret",
        "desc": ""
      },
      {
        "name": "TestLRUClientSessionCache",
        "desc": ""
      },
      {
        "name": "TestLargeCertMsg",
        "desc": ""
      },
      {
        "name": "TestLegacyTypeAndHash",
        "desc": ""
      },
      {
        "name": "TestLinkerGC",
        "desc": "Tests that the linker is able to remove references to the Client or Server if unused."
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "TestMarshalUnmarshal",
        "desc": ""
      },
      {
        "name": "TestMultipleCertificates",
        "desc": ""
      },
      {
        "name": "TestNoCompressionOverlap",
        "desc": ""
      },
      {
        "name": "TestNoRC4ByDefault",
        "desc": ""
      },
      {
        "name": "TestNoSuiteOverlap",
        "desc": ""
      },
      {
        "name": "TestPKCS1OnlyCert",
        "desc": "TestPKCS1OnlyCert uses a client certificate with a broken crypto.Signer that always makes PKCS #1 v1.5 signatures, so can't be used with RSA-PSS."
      },
      {
        "name": "TestQUICCanceledWaitingForData",
        "desc": ""
      },
      {
        "name": "TestQUICCanceledWaitingForTransportParams",
        "desc": ""
      },
      {
        "name": "TestQUICConnection",
        "desc": ""
      },
      {
        "name": "TestQUICConnectionState",
        "desc": "Test that QUICConn.ConnectionState can be used during the handshake, and that it reports the application protocol as soon as it has been negotiated."
      },
      {
        "name": "TestQUICDelayedTransportParameters",
        "desc": ""
      },
      {
        "name": "TestQUICEarlyData",
        "desc": ""
      },
      {
        "name": "TestQUICEarlyDataDeclined",
        "desc": ""
      },
      {
        "name": "TestQUICEmptyTransportParameters",
        "desc": ""
      },
      {
        "name": "TestQUICFragmentaryData",
        "desc": ""
      },
      {
        "name": "TestQUICHandshakeError",
        "desc": ""
      },
      {
        "name": "TestQUICPostHandshakeClientAuthentication",
        "desc": ""
      },
      {
        "name": "TestQUICPostHandshakeKeyUpdate",
        "desc": ""
      },
      {
        "name": "TestQUICPostHandshakeMessageTooLarge",
        "desc": ""
      },
      {
        "name": "TestQUICSessionResumption",
        "desc": ""
      },
      {
        "name": "TestQUICStartContextPropagation",
        "desc": ""
      },
      {
        "name": "TestRSAPSSKeyError",
        "desc": ""
      },
      {
        "name": "TestRecordBadVersionTLS13",
        "desc": ""
      },
      {
        "name": "TestRejectBadProtocolVersion",
        "desc": ""
      },
      {
        "name": "TestRejectDuplicateExtensions",
        "desc": ""
      },
      {
        "name": "TestRejectEmptySCT",
        "desc": ""
      },
      {
        "name": "TestRejectEmptySCTList",
        "desc": ""
      },
      {
        "name": "TestRejectSNIWithTrailingDot",
        "desc": ""
      },
      {
        "name": "TestRemovePadding",
        "desc": ""
      },
      {
        "name": "TestRenegotiateOnce",
        "desc": ""
      },
      {
        "name": "TestRenegotiateTwice",
        "desc": ""
      },
      {
        "name": "TestRenegotiateTwiceRejected",
        "desc": ""
      },
      {
        "name": "TestRenegotiationExtension",
        "desc": ""
      },
      {
        "name": "TestRenegotiationRejected",
        "desc": ""
      },
      {
        "name": "TestResumption",
        "desc": ""
      },
      {
        "name": "TestResumptionKeepsOCSPAndSCT",
        "desc": ""
      },
      {
        "name": "TestRoundUp",
        "desc": ""
      },
      {
        "name": "TestSCTHandshake",
        "desc": ""
      },
      {
        "name": "TestSNIGivenOnFailure",
        "desc": ""
      },
      {
        "name": "TestServerHandshakeContextCancellation",
        "desc": "TestServerHandshakeContextCancellation tests that canceling the context given to the server side conn.HandshakeContext interrupts the in-progress handshake."
      },
      {
        "name": "TestServerResumption",
        "desc": ""
      },
      {
        "name": "TestServerResumptionDisabled",
        "desc": ""
      },
      {
        "name": "TestServerSelectingUnconfiguredApplicationProtocol",
        "desc": ""
      },
      {
        "name": "TestServerSelectingUnconfiguredCipherSuite",
        "desc": ""
      },
      {
        "name": "TestSignatureSelection",
        "desc": ""
      },
      {
        "name": "TestSimpleError",
        "desc": ""
      },
      {
        "name": "TestSkipBadConfigs",
        "desc": ""
      },
      {
        "name": "TestSplitPreMasterSecret",
        "desc": ""
      },
      {
        "name": "TestSupportedSignatureAlgorithms",
        "desc": "TestSupportedSignatureAlgorithms checks that all supportedSignatureAlgorithms have valid type and hash information."
      },
      {
        "name": "TestTLS12OnlyCipherSuites",
        "desc": ""
      },
      {
        "name": "TestTLS13ECHRejectionCallbacks",
        "desc": ""
      },
      {
        "name": "TestTLS13OnlyClientHelloCipherSuite",
        "desc": "TestTLS13OnlyClientHelloCipherSuite tests that when a client states that it only supports TLS 1.3, it correctly advertises only TLS 1.3 ciphers."
      },
      {
        "name": "TestTLSPointFormats",
        "desc": ""
      },
      {
        "name": "TestTLSUniqueMatches",
        "desc": ""
      },
      {
        "name": "TestTrafficKey",
        "desc": ""
      },
      {
        "name": "TestVerifyCertificates",
        "desc": ""
      },
      {
        "name": "TestVerifyConnection",
        "desc": ""
      },
      {
        "name": "TestVerifyHostname",
        "desc": ""
      },
      {
        "name": "TestVerifyPeerCertificate",
        "desc": ""
      },
      {
        "name": "TestVersion",
        "desc": ""
      },
      {
        "name": "TestVersionName",
        "desc": ""
      },
      {
        "name": "TestWarningAlertFlood",
        "desc": ""
      },
      {
        "name": "TestWeakCertCache",
        "desc": ""
      },
      {
        "name": "TestX509KeyPair",
        "desc": ""
      },
      {
        "name": "TestX509KeyPairErrors",
        "desc": ""
      },
      {
        "name": "TestX509KeyPairPopulateCertificate",
        "desc": ""
      },
      {
        "name": "TestX509MixedKeyPair",
        "desc": ""
      },
      {
        "name": "VersionName",
        "desc": "VersionName returns the name for the provided TLS version number (e.g. \"TLS 1.3\"), or a fallback representation of the value if the version is not implemented by this package."
      },
      {
        "name": "_",
        "desc": ""
      },
      {
        "name": "addBytesWithLength",
        "desc": "addBytesWithLength appends a sequence of bytes to the cryptobyte.Builder. If the length of the sequence is not the value specified, it produces an error."
      },
      {
        "name": "addUint64",
        "desc": "addUint64 appends a big-endian, 64-bit value to the cryptobyte.Builder."
      },
      {
        "name": "allCipherSuites",
        "desc": ""
      },
      {
        "name": "allCipherSuitesIncludingTLS13",
        "desc": ""
      },
      {
        "name": "benchmarkHandshakeServer",
        "desc": ""
      },
      {
        "name": "bogoShim",
        "desc": ""
      },
      {
        "name": "buildRetryConfigList",
        "desc": ""
      },
      {
        "name": "certificatesToBytesSlice",
        "desc": ""
      },
      {
        "name": "checkALPN",
        "desc": "checkALPN ensure that the server's choice of ALPN protocol is compatible with the protocols that we advertised in the ClientHello."
      },
      {
        "name": "checkKeySize",
        "desc": ""
      },
      {
        "name": "checkOpenSSLVersion",
        "desc": "checkOpenSSLVersion ensures that the version of OpenSSL looks reasonable before updating the test data."
      },
      {
        "name": "cipher3DES",
        "desc": ""
      },
      {
        "name": "cipherAES",
        "desc": ""
      },
      {
        "name": "cipherRC4",
        "desc": ""
      },
      {
        "name": "cloneHash",
        "desc": "cloneHash uses the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces implemented by standard library hashes to clone the state of in to a new instance of h. It returns nil if the operation fails."
      },
      {
        "name": "computeAndUpdateOuterECHExtension",
        "desc": ""
      },
      {
        "name": "computeAndUpdatePSK",
        "desc": ""
      },
      {
        "name": "curveForCurveID",
        "desc": ""
      },
      {
        "name": "decryptECHPayload",
        "desc": ""
      },
      {
        "name": "defaultCipherSuites",
        "desc": ""
      },
      {
        "name": "ekmFromMasterSecret",
        "desc": "ekmFromMasterSecret generates exported keying material as defined in RFC 5705."
      },
      {
        "name": "encodeInnerClientHello",
        "desc": ""
      },
      {
        "name": "expectError",
        "desc": ""
      },
      {
        "name": "extMasterFromPreMasterSecret",
        "desc": "extMasterFromPreMasterSecret generates the extended master secret from the pre-master secret. See RFC 7627."
      },
      {
        "name": "extractPadding",
        "desc": "extractPadding returns, in constant time, the length of the padding to remove from the end of payload. It also returns a byte which is equal to 255 if the padding was valid and 0 otherwise. See RFC 2246, Section 6.2.3.2."
      },
      {
        "name": "fipsAllowChain",
        "desc": ""
      },
      {
        "name": "fipsAllowedChains",
        "desc": "fipsAllowedChains returns chains that are allowed to be used in a TLS connection based on the current fips140tls enforcement setting.  If fips140tls is not required, the chains are returned as-is with no processing. Otherwise, the returned chains are filtered to only those allowed by FIPS 140-3. If this results in no chains it returns an error."
      },
      {
        "name": "fipsECDSAKey",
        "desc": ""
      },
      {
        "name": "fipsHandshake",
        "desc": ""
      },
      {
        "name": "fipsRSAKey",
        "desc": ""
      },
      {
        "name": "fromHex",
        "desc": ""
      },
      {
        "name": "generateECDHEKey",
        "desc": "generateECDHEKey returns a PrivateKey that implements Diffie-Hellman according to RFC 8446, Section 4.2.8.2."
      },
      {
        "name": "generateOuterECHExt",
        "desc": ""
      },
      {
        "name": "hashForServerKeyExchange",
        "desc": "hashForServerKeyExchange hashes the given slices and returns their digest using the given hash function (for TLS 1.2) or using a default based on the sigType (for earlier TLS versions). For Ed25519 signatures, which don't do pre-hashing, it returns the concatenation of the slices."
      },
      {
        "name": "hostnameInSNI",
        "desc": "hostnameInSNI converts name into an appropriate hostname for SNI. Literal IP addresses and absolute FQDNs are not permitted as SNI values. See RFC 6066, Section 3."
      },
      {
        "name": "http2isBadCipher",
        "desc": "http2isBadCipher is copied from net/http. TODO: if it ends up exposed somewhere, use that instead."
      },
      {
        "name": "illegalClientHelloChange",
        "desc": "illegalClientHelloChange reports whether the two ClientHello messages are different, with the exception of the changes allowed before and after a HelloRetryRequest. See RFC 8446, Section 4.1.2."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "isAESGCMPreferred",
        "desc": "isAESGCMPreferred returns whether we have hardware support for AES-GCM, and the first known cipher in the peer's preference list is an AES-GCM cipher, implying the peer also has hardware support for it."
      },
      {
        "name": "isCertificateAllowedFIPS",
        "desc": ""
      },
      {
        "name": "isDisabledSignatureAlgorithm",
        "desc": ""
      },
      {
        "name": "isECDSA",
        "desc": ""
      },
      {
        "name": "isFIPSCipherSuite",
        "desc": ""
      },
      {
        "name": "isFIPSCurve",
        "desc": ""
      },
      {
        "name": "isFIPSSignatureScheme",
        "desc": ""
      },
      {
        "name": "isFIPSVersion",
        "desc": ""
      },
      {
        "name": "isPQKeyExchange",
        "desc": ""
      },
      {
        "name": "isSupportedSignatureAlgorithm",
        "desc": ""
      },
      {
        "name": "isTLS13CipherSuite",
        "desc": ""
      },
      {
        "name": "isTLS13OnlyKeyExchange",
        "desc": ""
      },
      {
        "name": "isTimeoutError",
        "desc": ""
      },
      {
        "name": "keysFromMasterSecret",
        "desc": "keysFromMasterSecret generates the connection keys from the master secret, given the lengths of the MAC key, cipher key and IV, as defined in RFC 2246, Section 6.3."
      },
      {
        "name": "latency",
        "desc": ""
      },
      {
        "name": "legacyTypeAndHashFromPublicKey",
        "desc": "legacyTypeAndHashFromPublicKey returns the fixed signature type and crypto.Hash for a given public key used with TLS 1.0 and 1.1, before the introduction of signature algorithm negotiation."
      },
      {
        "name": "localPipe",
        "desc": ""
      },
      {
        "name": "localServer",
        "desc": ""
      },
      {
        "name": "macSHA1",
        "desc": "macSHA1 returns a SHA-1 based constant time MAC."
      },
      {
        "name": "macSHA256",
        "desc": "macSHA256 returns a SHA-256 based MAC. This is only supported in TLS 1.2 and is currently only used in disabled-by-default cipher suites."
      },
      {
        "name": "marshalCertificate",
        "desc": ""
      },
      {
        "name": "marshalEncryptedClientHelloConfigList",
        "desc": ""
      },
      {
        "name": "masterFromPreMasterSecret",
        "desc": "masterFromPreMasterSecret generates the master secret from the pre-master secret. See RFC 5246, Section 8.1."
      },
      {
        "name": "md5SHA1Hash",
        "desc": "md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the concatenation of an MD5 and SHA1 hash."
      },
      {
        "name": "mustMarshal",
        "desc": ""
      },
      {
        "name": "negotiateALPN",
        "desc": "negotiateALPN picks a shared ALPN protocol that both sides support in server preference order. If ALPN is not configured or the peer doesn't support it, it returns \"\" and no error."
      },
      {
        "name": "newConstantTimeHash",
        "desc": ""
      },
      {
        "name": "newLocalListener",
        "desc": ""
      },
      {
        "name": "noEKMBecauseNoEMS",
        "desc": "noEKMBecauseNoEMS is used as a value of ConnectionState.ekm when Extended Master Secret is not negotiated and thus we wish to fail all key-material export requests."
      },
      {
        "name": "noEKMBecauseRenegotiation",
        "desc": "noEKMBecauseRenegotiation is used as a value of ConnectionState.ekm when renegotiation is enabled and thus we wish to fail all key-material export requests."
      },
      {
        "name": "orderlyShutdown",
        "desc": "If the test case produces an error, we don't want to immediately close the TCP connection after generating an alert. The runner side may try to write additional data to the connection before it reads the alert. If the conn has already been torn down, then these writes will produce an unexpected broken pipe err and fail the test."
      },
      {
        "name": "pHash",
        "desc": "pHash implements the P_hash function, as defined in RFC 4346, Section 5."
      },
      {
        "name": "parseECHConfig",
        "desc": ""
      },
      {
        "name": "parseECHExt",
        "desc": ""
      },
      {
        "name": "parsePrivateKey",
        "desc": "Attempt to parse the given private key DER block. OpenSSL 0.9.8 generates PKCS #1 private keys by default, while OpenSSL 1.0.0 generates PKCS #8 keys. OpenSSL ecparam generates SEC1 EC private keys for ECDSA. We try all three."
      },
      {
        "name": "parseTestData",
        "desc": ""
      },
      {
        "name": "parseVector",
        "desc": ""
      },
      {
        "name": "pauseProcess",
        "desc": ""
      },
      {
        "name": "peekError",
        "desc": "peekError does a read with a short timeout to check if the next read would cause an error, for example if there is an alert waiting on the wire."
      },
      {
        "name": "prf10",
        "desc": "prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, Section 5."
      },
      {
        "name": "quicError",
        "desc": "quicError ensures err is an AlertError. If err is not already, quicError wraps it with alertInternalError."
      },
      {
        "name": "randomBytes",
        "desc": ""
      },
      {
        "name": "randomString",
        "desc": ""
      },
      {
        "name": "readUint16LengthPrefixed",
        "desc": "readUint16LengthPrefixed acts like s.ReadUint16LengthPrefixed, but targets a []byte instead of a cryptobyte.String."
      },
      {
        "name": "readUint24LengthPrefixed",
        "desc": "readUint24LengthPrefixed acts like s.ReadUint24LengthPrefixed, but targets a []byte instead of a cryptobyte.String."
      },
      {
        "name": "readUint64",
        "desc": "readUint64 decodes a big-endian, 64-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "readUint8LengthPrefixed",
        "desc": "readUint8LengthPrefixed acts like s.ReadUint8LengthPrefixed, but targets a []byte instead of a cryptobyte.String."
      },
      {
        "name": "requiresClientCert",
        "desc": "requiresClientCert reports whether the ClientAuthType requires a client certificate to be provided."
      },
      {
        "name": "roundUp",
        "desc": ""
      },
      {
        "name": "runClientTestForVersion",
        "desc": ""
      },
      {
        "name": "runClientTestTLS10",
        "desc": ""
      },
      {
        "name": "runClientTestTLS11",
        "desc": ""
      },
      {
        "name": "runClientTestTLS12",
        "desc": ""
      },
      {
        "name": "runClientTestTLS13",
        "desc": ""
      },
      {
        "name": "runDynamicRecordSizingTest",
        "desc": "Run with multiple crypto configs to test the logic for computing TLS record overheads."
      },
      {
        "name": "runMain",
        "desc": ""
      },
      {
        "name": "runServerTestForVersion",
        "desc": ""
      },
      {
        "name": "runServerTestTLS10",
        "desc": ""
      },
      {
        "name": "runServerTestTLS11",
        "desc": ""
      },
      {
        "name": "runServerTestTLS12",
        "desc": ""
      },
      {
        "name": "runServerTestTLS13",
        "desc": ""
      },
      {
        "name": "runTestAndUpdateIfNeeded",
        "desc": ""
      },
      {
        "name": "runTestQUICConnection",
        "desc": ""
      },
      {
        "name": "runWithFIPSDisabled",
        "desc": ""
      },
      {
        "name": "runWithFIPSEnabled",
        "desc": ""
      },
      {
        "name": "sha1Hash",
        "desc": "sha1Hash calculates a SHA1 hash over the given byte slices."
      },
      {
        "name": "signedMessage",
        "desc": "signedMessage returns the pre-hashed (if necessary) message to be signed by certificate keys in TLS 1.3. See RFC 8446, Section 4.4.3."
      },
      {
        "name": "skipFIPS",
        "desc": ""
      },
      {
        "name": "skipUint16LengthPrefixed",
        "desc": ""
      },
      {
        "name": "skipUint8LengthPrefixed",
        "desc": ""
      },
      {
        "name": "sliceForAppend",
        "desc": "sliceForAppend extends the input slice by n bytes. head is the full extended slice, while tail is the appended part. If the original slice has sufficient capacity no allocation is performed."
      },
      {
        "name": "splitPreMasterSecret",
        "desc": "Split a premaster secret in two as specified in RFC 4346, Section 5."
      },
      {
        "name": "supportedCipherSuites",
        "desc": ""
      },
      {
        "name": "supportedVersionsFromMax",
        "desc": "supportedVersionsFromMax returns a list of supported versions derived from a legacy maximum version value. Note that only versions supported by this library are returned. Any newer peer will use supportedVersions anyway."
      },
      {
        "name": "supportsECDHE",
        "desc": "supportsECDHE returns whether ECDHE key exchanges can be used with this pre-TLS 1.3 client."
      },
      {
        "name": "tempFile",
        "desc": "tempFile creates a temp file containing contents and returns its path."
      },
      {
        "name": "testBuffering",
        "desc": ""
      },
      {
        "name": "testClientHello",
        "desc": ""
      },
      {
        "name": "testClientHelloFailure",
        "desc": ""
      },
      {
        "name": "testConnReadNonzeroAndEOF",
        "desc": ""
      },
      {
        "name": "testCrossVersionResume",
        "desc": ""
      },
      {
        "name": "testDowngradeCanary",
        "desc": ""
      },
      {
        "name": "testFIPSClientHello",
        "desc": ""
      },
      {
        "name": "testFatal",
        "desc": "testFatal is a hack to prevent the compiler from complaining that there is a call to t.Fatal from a non-test goroutine"
      },
      {
        "name": "testGetClientCertificate",
        "desc": ""
      },
      {
        "name": "testQUICEarlyDataDeclined",
        "desc": ""
      },
      {
        "name": "testResumption",
        "desc": ""
      },
      {
        "name": "testResumptionKeepsOCSPAndSCT",
        "desc": ""
      },
      {
        "name": "testSCTHandshake",
        "desc": ""
      },
      {
        "name": "testTLS13OnlyClientHelloCipherSuite",
        "desc": ""
      },
      {
        "name": "testVerifyCertificates",
        "desc": ""
      },
      {
        "name": "testVerifyConnection",
        "desc": ""
      },
      {
        "name": "testVerifyPeerCertificate",
        "desc": ""
      },
      {
        "name": "testingKey",
        "desc": ""
      },
      {
        "name": "throughput",
        "desc": ""
      },
      {
        "name": "tls10MAC",
        "desc": "tls10MAC implements the TLS 1.0 MAC function. RFC 2246, Section 6.2.3."
      },
      {
        "name": "transcriptMsg",
        "desc": "transcriptMsg is a helper used to hash messages which are not hashed when they are read from, or written to, the wire. This is typically the case for messages which are either not sent, or need to be hashed out of order from when they are read/written.  For most messages, the message is marshalled using their marshal method, since their wire representation is idempotent. For clientHelloMsg and serverHelloMsg, we store the original wire representation of the message and use that for hashing, since unmarshal/marshal are not idempotent due to extension ordering and other malleable fields, which may cause differences between what was received and what we marshal."
      },
      {
        "name": "typeAndHashFromSignatureScheme",
        "desc": "typeAndHashFromSignatureScheme returns the corresponding signature type and crypto.Hash for a given TLS SignatureScheme."
      },
      {
        "name": "unexpectedMessageError",
        "desc": ""
      },
      {
        "name": "unmarshalCertificate",
        "desc": ""
      },
      {
        "name": "unsupportedCertificateError",
        "desc": "unsupportedCertificateError returns a helpful error for certificates with an unsupported private key."
      },
      {
        "name": "validDNSName",
        "desc": "validDNSName is a rather rudimentary check for the validity of a DNS name. This is used to check if the public_name in a ECHConfig is valid when we are picking a config. This can be somewhat lax because even if we pick a valid-looking name, the DNS layer will later reject it anyway."
      },
      {
        "name": "verifyHandshakeSignature",
        "desc": "verifyHandshakeSignature verifies a signature against pre-hashed (if required) handshake contents."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "leaf",
        "desc": "leaf returns the parsed leaf certificate, either from c.Leaf or by parsing the corresponding c.Certificate[0]."
      },
      {
        "name": "Context",
        "desc": "Context returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes."
      },
      {
        "name": "SupportsCertificate",
        "desc": "SupportsCertificate returns nil if the provided certificate is supported by the server that sent the CertificateRequest. Otherwise, it returns an error describing the reason for the incompatibility."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Context",
        "desc": "Context returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes."
      },
      {
        "name": "SupportsCertificate",
        "desc": "SupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility.  If this [ClientHelloInfo] was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated [Config]. Note that if GetConfigForClient returns a different [Config], the change can't be accounted for by this method.  This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost."
      },
      {
        "name": "ResumptionState",
        "desc": "ResumptionState returns the session ticket sent by the server (also known as the session's identity) and the state necessary to resume this session.  It can be called by [ClientSessionCache.Put] to serialize (with [SessionState.Bytes]) and store the session."
      },
      {
        "name": "BuildNameToCertificate",
        "desc": "BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates.  Deprecated: NameToCertificate only allows associating a single certificate with a given name. Leave that field nil to let the library select the first compatible chain from Certificates."
      },
      {
        "name": "Clone",
        "desc": "Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a [Config] that is being used concurrently by a TLS client or server."
      },
      {
        "name": "DecryptTicket",
        "desc": "DecryptTicket decrypts a ticket encrypted by [Config.EncryptTicket]. It can be used as a [Config.UnwrapSession] implementation.  If the ticket can't be decrypted or parsed, DecryptTicket returns (nil, nil)."
      },
      {
        "name": "EncryptTicket",
        "desc": "EncryptTicket encrypts a ticket with the [Config]'s configured (or default) session ticket keys. It can be used as a [Config.WrapSession] implementation."
      },
      {
        "name": "SetSessionTicketKeys",
        "desc": "SetSessionTicketKeys updates the session ticket keys for a server.  The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.  Calling this function will turn off automatic session ticket key rotation.  If multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised."
      },
      {
        "name": "cipherSuites",
        "desc": ""
      },
      {
        "name": "curvePreferences",
        "desc": ""
      },
      {
        "name": "decryptTicket",
        "desc": ""
      },
      {
        "name": "encryptTicket",
        "desc": ""
      },
      {
        "name": "getCertificate",
        "desc": "getCertificate returns the best certificate for the given ClientHelloInfo, defaulting to the first element of c.Certificates."
      },
      {
        "name": "initLegacySessionTicketKeyRLocked",
        "desc": "initLegacySessionTicketKeyRLocked ensures the legacy SessionTicketKey field is randomized if empty, and that sessionTicketKeys is populated from it otherwise."
      },
      {
        "name": "maxSupportedVersion",
        "desc": ""
      },
      {
        "name": "mutualVersion",
        "desc": "mutualVersion returns the protocol version to use given the advertised versions of the peer. The highest supported version is preferred."
      },
      {
        "name": "rand",
        "desc": ""
      },
      {
        "name": "supportedCipherSuites",
        "desc": "supportedCipherSuites returns the supported TLS 1.0–1.2 cipher suites in an undefined order. For preference ordering, use [Config.cipherSuites]."
      },
      {
        "name": "supportedVersions",
        "desc": "supportedVersions returns the list of supported TLS versions, sorted from highest to lowest (and hence also in preference order)."
      },
      {
        "name": "supportsCurve",
        "desc": ""
      },
      {
        "name": "ticketKeyFromBytes",
        "desc": "ticketKeyFromBytes converts from the external representation of a session ticket key to a ticketKey. Externally, session ticket keys are 32 random bytes and this function expands that into sufficient name and key material."
      },
      {
        "name": "ticketKeys",
        "desc": "ticketKeys returns the ticketKeys for this connection. If configForClient has explicitly set keys, those will be returned. Otherwise, the keys on c will be used and may be rotated if auto-managed. During rotation, any expired session ticket keys are deleted from c.sessionTicketKeys. If the session ticket key that is currently encrypting tickets (ie. the first ticketKey in c.sessionTicketKeys) is not fresh, then a new session ticket key will be created and prepended to c.sessionTicketKeys."
      },
      {
        "name": "time",
        "desc": ""
      },
      {
        "name": "writeKeyLog",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "CloseWrite",
        "desc": "CloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use [Conn.Close]."
      },
      {
        "name": "ConnectionState",
        "desc": "ConnectionState returns basic TLS details about the connection."
      },
      {
        "name": "Handshake",
        "desc": "Handshake runs the client or server handshake protocol if it has not yet been run.  Most uses of this package need not call Handshake explicitly: the first [Conn.Read] or [Conn.Write] will call it automatically.  For control over canceling or setting a timeout on a handshake, use [Conn.HandshakeContext] or the [Dialer]'s DialContext method instead.  In order to avoid denial of service attacks, the maximum RSA key size allowed in certificates sent by either the TLS server or client is limited to 8192 bits. This limit can be overridden by setting tlsmaxrsasize in the GODEBUG environment variable (e.g. GODEBUG=tlsmaxrsasize=4096)."
      },
      {
        "name": "HandshakeContext",
        "desc": "HandshakeContext runs the client or server handshake protocol if it has not yet been run.  The provided Context must be non-nil. If the context is canceled before the handshake is complete, the handshake is interrupted and an error is returned. Once the handshake has completed, cancellation of the context will not affect the connection.  Most uses of this package need not call HandshakeContext explicitly: the first [Conn.Read] or [Conn.Write] will call it automatically."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address."
      },
      {
        "name": "NetConn",
        "desc": "NetConn returns the underlying connection that is wrapped by c. Note that writing to or reading from this connection directly will corrupt the TLS session."
      },
      {
        "name": "OCSPResponse",
        "desc": "OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.)"
      },
      {
        "name": "Read",
        "desc": "Read reads data from the connection.  As Read calls [Conn.Handshake], in order to prevent indefinite blocking a deadline must be set for both Read and [Conn.Write] before Read is called when the handshake has not yet completed. See [Conn.SetDeadline], [Conn.SetReadDeadline], and [Conn.SetWriteDeadline]."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means [Conn.Read] and [Conn.Write] will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means [Conn.Read] will not time out."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means [Conn.Write] will not time out. After a [Conn.Write] has timed out, the TLS state is corrupt and all future writes will return the same error."
      },
      {
        "name": "VerifyHostname",
        "desc": "VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem."
      },
      {
        "name": "Write",
        "desc": "Write writes data to the connection.  As Write calls [Conn.Handshake], in order to prevent indefinite blocking a deadline must be set for both [Conn.Read] and Write before Write is called when the handshake has not yet completed. See [Conn.SetDeadline], [Conn.SetReadDeadline], and [Conn.SetWriteDeadline]."
      },
      {
        "name": "clientHandshake",
        "desc": ""
      },
      {
        "name": "clientSessionCacheKey",
        "desc": "clientSessionCacheKey returns a key used to cache sessionTickets that could be used to resume previously negotiated TLS sessions with a server."
      },
      {
        "name": "closeNotify",
        "desc": ""
      },
      {
        "name": "connectionStateLocked",
        "desc": ""
      },
      {
        "name": "flush",
        "desc": ""
      },
      {
        "name": "getClientCertificate",
        "desc": ""
      },
      {
        "name": "handleKeyUpdate",
        "desc": ""
      },
      {
        "name": "handleNewSessionTicket",
        "desc": ""
      },
      {
        "name": "handlePostHandshakeMessage",
        "desc": "handlePostHandshakeMessage processes a handshake message arrived after the handshake is complete. Up to TLS 1.2, it indicates the start of a renegotiation."
      },
      {
        "name": "handleRenegotiation",
        "desc": "handleRenegotiation processes a HelloRequest handshake message."
      },
      {
        "name": "handshakeContext",
        "desc": ""
      },
      {
        "name": "loadSession",
        "desc": ""
      },
      {
        "name": "makeClientHello",
        "desc": ""
      },
      {
        "name": "maxPayloadSizeForWrite",
        "desc": "maxPayloadSizeForWrite returns the maximum TLS payload size to use for the next application data record. There is the following trade-off:    - For latency-sensitive applications, such as web browsing, each TLS     record should fit in one TCP segment.   - For throughput-sensitive applications, such as large file transfers,     larger TLS records better amortize framing and encryption overheads.  A simple heuristic that works well in practice is to use small records for the first 1MB of data, then use larger records for subsequent data, and reset back to smaller records after the connection becomes idle. See \"High Performance Web Networking\", Chapter 4, or: https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/  In the interests of simplicity and determinism, this code does not attempt to reset the record size once the connection is idle, however."
      },
      {
        "name": "newRecordHeaderError",
        "desc": ""
      },
      {
        "name": "pickTLSVersion",
        "desc": ""
      },
      {
        "name": "processCertsFromClient",
        "desc": "processCertsFromClient takes a chain of client certificates either from a certificateMsg message or a certificateMsgTLS13 message and verifies them."
      },
      {
        "name": "processECHClientHello",
        "desc": ""
      },
      {
        "name": "quicGetTransportParameters",
        "desc": ""
      },
      {
        "name": "quicHandshakeComplete",
        "desc": ""
      },
      {
        "name": "quicReadHandshakeBytes",
        "desc": ""
      },
      {
        "name": "quicRejectedEarlyData",
        "desc": ""
      },
      {
        "name": "quicResumeSession",
        "desc": ""
      },
      {
        "name": "quicSetReadSecret",
        "desc": ""
      },
      {
        "name": "quicSetTransportParameters",
        "desc": ""
      },
      {
        "name": "quicSetWriteSecret",
        "desc": ""
      },
      {
        "name": "quicStoreSession",
        "desc": ""
      },
      {
        "name": "quicWaitForSignal",
        "desc": "quicWaitForSignal notifies the QUICConn that handshake progress is blocked, and waits for a signal that the handshake should proceed.  The handshake may become blocked waiting for handshake bytes or for the user to provide transport parameters."
      },
      {
        "name": "quicWriteCryptoData",
        "desc": ""
      },
      {
        "name": "readChangeCipherSpec",
        "desc": ""
      },
      {
        "name": "readClientHello",
        "desc": "readClientHello reads a ClientHello message and selects the protocol version."
      },
      {
        "name": "readFromUntil",
        "desc": "readFromUntil reads from r into c.rawInput until c.rawInput contains at least n bytes or else returns an error."
      },
      {
        "name": "readHandshake",
        "desc": "readHandshake reads the next handshake message from the record layer. If transcript is non-nil, the message is written to the passed transcriptHash."
      },
      {
        "name": "readHandshakeBytes",
        "desc": "readHandshakeBytes reads handshake data until c.hand contains at least n bytes."
      },
      {
        "name": "readRecord",
        "desc": ""
      },
      {
        "name": "readRecordOrCCS",
        "desc": "readRecordOrCCS reads one or more TLS records from the connection and updates the record layer state. Some invariants:   - c.in must be locked   - c.input must be empty  During the handshake one and only one of the following will happen:   - c.hand grows   - c.in.changeCipherSpec is called   - an error is returned  After the handshake one and only one of the following will happen:   - c.hand grows   - c.input is set   - an error is returned"
      },
      {
        "name": "retryReadRecord",
        "desc": "retryReadRecord recurs into readRecordOrCCS to drop a non-advancing record, like a warning alert, empty application_data, or a change_cipher_spec in TLS 1.3."
      },
      {
        "name": "sendAlert",
        "desc": "sendAlert sends a TLS alert message."
      },
      {
        "name": "sendAlertLocked",
        "desc": "sendAlertLocked sends a TLS alert message."
      },
      {
        "name": "sendSessionTicket",
        "desc": ""
      },
      {
        "name": "serverHandshake",
        "desc": "serverHandshake performs a TLS handshake as a server."
      },
      {
        "name": "sessionState",
        "desc": "sessionState returns a partially filled-out [SessionState] with information from the current connection."
      },
      {
        "name": "unmarshalHandshakeMessage",
        "desc": ""
      },
      {
        "name": "verifyServerCertificate",
        "desc": "verifyServerCertificate parses and verifies the provided chain, setting c.verifiedChains and c.peerCertificates or sending the appropriate alert."
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeChangeCipherRecord",
        "desc": "writeChangeCipherRecord writes a ChangeCipherSpec message to the connection and updates the record layer state."
      },
      {
        "name": "writeHandshakeRecord",
        "desc": "writeHandshakeRecord writes a handshake message to the connection and updates the record layer state. If transcript is non-nil the marshaled message is written to it."
      },
      {
        "name": "writeRecordLocked",
        "desc": "writeRecordLocked writes a TLS record with the given type and payload to the connection and updates the record layer state."
      },
      {
        "name": "ExportKeyingMaterial",
        "desc": "ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, or if the connections supports neither TLS 1.3 nor Extended Master Secret, this function will return an error.  Exporting key material without Extended Master Secret or TLS 1.3 was disabled in Go 1.22 due to security issues (see the Security Considerations sections of RFC 5705 and RFC 7627), but can be re-enabled with the GODEBUG setting tlsunsafeekm=1."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Dial",
        "desc": "Dial connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection.  The returned [Conn], if any, will always be of type *[Conn].  Dial uses context.Background internally; to specify the context, use [Dialer.DialContext]."
      },
      {
        "name": "DialContext",
        "desc": "DialContext connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection.  The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.  The returned [Conn], if any, will always be of type *[Conn]."
      },
      {
        "name": "netDialer",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection and stops any in-progress handshake."
      },
      {
        "name": "ConnectionState",
        "desc": "ConnectionState returns basic TLS details about the connection."
      },
      {
        "name": "HandleData",
        "desc": "HandleData handles handshake bytes received from the peer. It may produce connection events, which may be read with [QUICConn.NextEvent]."
      },
      {
        "name": "NextEvent",
        "desc": "NextEvent returns the next event occurring on the connection. It returns an event with a Kind of [QUICNoEvent] when no events are available."
      },
      {
        "name": "SendSessionTicket",
        "desc": "SendSessionTicket sends a session ticket to the client. It produces connection events, which may be read with [QUICConn.NextEvent]. Currently, it can only be called once."
      },
      {
        "name": "SetTransportParameters",
        "desc": "SetTransportParameters sets the transport parameters to send to the peer.  Server connections may delay setting the transport parameters until after receiving the client's transport parameters. See [QUICTransportParametersRequired]."
      },
      {
        "name": "Start",
        "desc": "Start starts the client or server handshake protocol. It may produce connection events, which may be read with [QUICConn.NextEvent].  Start must be called at most once."
      },
      {
        "name": "StoreSession",
        "desc": "StoreSession stores a session previously received in a QUICStoreSession event in the ClientSessionCache. The application may process additional events or modify the SessionState before storing the session."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Bytes",
        "desc": "Bytes encodes the session, including any private fields, so that it can be parsed by [ParseSessionState]. The encoding contains secret values critical to the security of future and possibly past sessions.  The specific encoding should be considered opaque and may change incompatibly between Go versions."
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Sign",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "exportKeyingMaterial",
        "desc": "exportKeyingMaterial implements RFC5705 exporters for TLS 1.3 according to RFC 8446, Section 7.5."
      },
      {
        "name": "finishedHash",
        "desc": "finishedHash generates the Finished verify_data or PskBinderEntry according to RFC 8446, Section 4.4.4. See sections 4.4 and 4.2.11.2 for the baseKey selection."
      },
      {
        "name": "nextTrafficSecret",
        "desc": "nextTrafficSecret generates the next traffic secret, given the current one, according to RFC 8446, Section 7.2."
      },
      {
        "name": "trafficKey",
        "desc": "trafficKey generates traffic keys according to RFC 8446, Section 7.3."
      },
      {
        "name": "doFullHandshake",
        "desc": ""
      },
      {
        "name": "establishKeys",
        "desc": ""
      },
      {
        "name": "handshake",
        "desc": "Does the handshake, either a full one or resumes old session. Requires hs.c, hs.hello, hs.serverHello, and, optionally, hs.session to be set."
      },
      {
        "name": "pickCipherSuite",
        "desc": ""
      },
      {
        "name": "processServerHello",
        "desc": ""
      },
      {
        "name": "readFinished",
        "desc": ""
      },
      {
        "name": "readSessionTicket",
        "desc": ""
      },
      {
        "name": "saveSessionTicket",
        "desc": ""
      },
      {
        "name": "sendFinished",
        "desc": ""
      },
      {
        "name": "serverResumedSession",
        "desc": ""
      },
      {
        "name": "checkServerHelloOrHRR",
        "desc": "checkServerHelloOrHRR does validity checks that apply to both ServerHello and HelloRetryRequest messages. It sets hs.suite."
      },
      {
        "name": "establishHandshakeKeys",
        "desc": ""
      },
      {
        "name": "handshake",
        "desc": "handshake requires hs.c, hs.hello, hs.serverHello, hs.keyShareKeys, and, optionally, hs.session, hs.earlySecret and hs.binderKey to be set."
      },
      {
        "name": "processHelloRetryRequest",
        "desc": "processHelloRetryRequest handles the HRR in hs.serverHello, modifies and resends hs.hello, and reads the new ServerHello into hs.serverHello."
      },
      {
        "name": "processServerHello",
        "desc": ""
      },
      {
        "name": "readServerCertificate",
        "desc": ""
      },
      {
        "name": "readServerFinished",
        "desc": ""
      },
      {
        "name": "readServerParameters",
        "desc": ""
      },
      {
        "name": "sendClientCertificate",
        "desc": ""
      },
      {
        "name": "sendClientFinished",
        "desc": ""
      },
      {
        "name": "sendDummyChangeCipherSpec",
        "desc": "sendDummyChangeCipherSpec sends a ChangeCipherSpec record for compatibility with middleboxes that didn't implement TLS correctly. See RFC 8446, Appendix D.4."
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "clone",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "marshalMsg",
        "desc": ""
      },
      {
        "name": "marshalWithoutBinders",
        "desc": "marshalWithoutBinders returns the ClientHello through the PreSharedKeyExtension.identities field, according to RFC 8446, Section 4.2.11.2. Note that m.pskBinders must be set to slices of the correct length."
      },
      {
        "name": "originalBytes",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "updateBinders",
        "desc": "updateBinders updates the m.pskBinders field. The supplied binders must have the same length as the current m.pskBinders."
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "connFromCommand",
        "desc": "connFromCommand starts the reference server process, connects to it and returns a recordingConn for the connection. The stdin return value is an opensslInput for the stdin of the child process. It must be closed before Waiting for child."
      },
      {
        "name": "dataPath",
        "desc": ""
      },
      {
        "name": "loadData",
        "desc": ""
      },
      {
        "name": "run",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "generateClientKeyExchange",
        "desc": ""
      },
      {
        "name": "generateServerKeyExchange",
        "desc": ""
      },
      {
        "name": "processClientKeyExchange",
        "desc": ""
      },
      {
        "name": "processServerKeyExchange",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "clientSum",
        "desc": "clientSum returns the contents of the verify_data member of a client's Finished message."
      },
      {
        "name": "discardHandshakeBuffer",
        "desc": "discardHandshakeBuffer is called when there is no more need to buffer the entirety of the handshake messages."
      },
      {
        "name": "hashForClientCertificate",
        "desc": "hashForClientCertificate returns the handshake messages so far, pre-hashed if necessary, suitable for signing by a TLS client certificate."
      },
      {
        "name": "serverSum",
        "desc": "serverSum returns the contents of the verify_data member of a server's Finished message."
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "changeCipherSpec",
        "desc": "changeCipherSpec changes the encryption and MAC states to the ones previously passed to prepareCipherSpec."
      },
      {
        "name": "decrypt",
        "desc": "decrypt authenticates and decrypts the record if protection is active at this stage. The returned plaintext might overlap with the input."
      },
      {
        "name": "encrypt",
        "desc": "encrypt encrypts payload, adding the appropriate nonce and/or MAC, and appends it to record, which must already contain the record header."
      },
      {
        "name": "explicitNonceLen",
        "desc": "explicitNonceLen returns the number of bytes of explicit nonce or IV included in each record. Explicit nonces are present only in CBC modes after TLS 1.0 and in certain AEAD modes in TLS 1.2."
      },
      {
        "name": "incSeq",
        "desc": "incSeq increments the sequence number."
      },
      {
        "name": "prepareCipherSpec",
        "desc": "prepareCipherSpec sets the encryption and MAC states that a subsequent changeCipherSpec will use."
      },
      {
        "name": "setErrorLocked",
        "desc": ""
      },
      {
        "name": "setTrafficSecret",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": "Accept waits for and returns the next incoming TLS connection. The returned connection is of type *Conn."
      },
      {
        "name": "Get",
        "desc": "Get returns the [ClientSessionState] value associated with a given key. It returns (nil, false) if no value is found."
      },
      {
        "name": "Put",
        "desc": "Put adds the provided (sessionKey, cs) pair to the cache. If cs is nil, the entry corresponding to sessionKey is removed from the cache instead."
      },
      {
        "name": "Marshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "NonceSize",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Overhead",
        "desc": ""
      },
      {
        "name": "Seal",
        "desc": ""
      },
      {
        "name": "explicitNonceLen",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo writes Go source code to w that contains the recorded traffic."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "generateClientKeyExchange",
        "desc": ""
      },
      {
        "name": "generateServerKeyExchange",
        "desc": ""
      },
      {
        "name": "processClientKeyExchange",
        "desc": ""
      },
      {
        "name": "processServerKeyExchange",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Put",
        "desc": ""
      },
      {
        "name": "checkForResumption",
        "desc": "checkForResumption reports whether we should perform resumption on this connection."
      },
      {
        "name": "cipherSuiteOk",
        "desc": ""
      },
      {
        "name": "doFullHandshake",
        "desc": ""
      },
      {
        "name": "doResumeHandshake",
        "desc": ""
      },
      {
        "name": "establishKeys",
        "desc": ""
      },
      {
        "name": "handshake",
        "desc": ""
      },
      {
        "name": "pickCipherSuite",
        "desc": ""
      },
      {
        "name": "processClientHello",
        "desc": ""
      },
      {
        "name": "readFinished",
        "desc": ""
      },
      {
        "name": "sendFinished",
        "desc": ""
      },
      {
        "name": "sendSessionTicket",
        "desc": ""
      },
      {
        "name": "checkForResumption",
        "desc": ""
      },
      {
        "name": "doHelloRetryRequest",
        "desc": ""
      },
      {
        "name": "handshake",
        "desc": ""
      },
      {
        "name": "pickCertificate",
        "desc": ""
      },
      {
        "name": "processClientHello",
        "desc": ""
      },
      {
        "name": "readClientCertificate",
        "desc": ""
      },
      {
        "name": "readClientFinished",
        "desc": ""
      },
      {
        "name": "requestClientCert",
        "desc": ""
      },
      {
        "name": "sendDummyChangeCipherSpec",
        "desc": "sendDummyChangeCipherSpec sends a ChangeCipherSpec record for compatibility with middleboxes that didn't implement TLS correctly. See RFC 8446, Appendix D.4."
      },
      {
        "name": "sendServerCertificate",
        "desc": ""
      },
      {
        "name": "sendServerFinished",
        "desc": ""
      },
      {
        "name": "sendServerParameters",
        "desc": ""
      },
      {
        "name": "sendSessionTickets",
        "desc": ""
      },
      {
        "name": "shouldSendSessionTickets",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "originalBytes",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "connFromCommand",
        "desc": "connFromCommand starts opens a listening socket and starts the reference client to connect to it. It returns a recordingConn that wraps the resulting connection."
      },
      {
        "name": "dataPath",
        "desc": ""
      },
      {
        "name": "loadData",
        "desc": ""
      },
      {
        "name": "run",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "setReadSecret",
        "desc": ""
      },
      {
        "name": "setWriteSecret",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "newCert",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "NonceSize",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Overhead",
        "desc": ""
      },
      {
        "name": "Seal",
        "desc": ""
      },
      {
        "name": "explicitNonceLen",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "AlertError",
        "desc": "An AlertError is a TLS alert.  When using a QUIC transport, QUICConn methods will return an error which wraps AlertError rather than sending a TLS alert."
      },
      {
        "name": "Certificate",
        "desc": "A Certificate is a chain of one or more certificates, leaf first."
      },
      {
        "name": "CertificateRequestInfo",
        "desc": "CertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client."
      },
      {
        "name": "CertificateVerificationError",
        "desc": "CertificateVerificationError is returned when certificate verification fails during the handshake."
      },
      {
        "name": "CipherSuite",
        "desc": "CipherSuite is a TLS cipher suite. Note that most functions in this package accept and expose cipher suite IDs instead of this type."
      },
      {
        "name": "ClientAuthType",
        "desc": "ClientAuthType declares the policy the server will follow for TLS Client Authentication."
      },
      {
        "name": "ClientHelloInfo",
        "desc": "ClientHelloInfo contains information from a ClientHello message in order to guide application logic in the GetCertificate and GetConfigForClient callbacks."
      },
      {
        "name": "ClientSessionCache",
        "desc": "ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which are supported via this interface."
      },
      {
        "name": "ClientSessionState",
        "desc": "ClientSessionState contains the state needed by a client to resume a previous TLS session."
      },
      {
        "name": "Config",
        "desc": "A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it."
      },
      {
        "name": "Conn",
        "desc": "A Conn represents a secured connection. It implements the net.Conn interface."
      },
      {
        "name": "ConnectionState",
        "desc": "ConnectionState records basic TLS details about the connection."
      },
      {
        "name": "CurveID",
        "desc": "CurveID is the type of a TLS identifier for a key exchange mechanism. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8.  In TLS 1.2, this registry used to support only elliptic curves. In TLS 1.3, it was extended to other groups and renamed NamedGroup. See RFC 8446, Section 4.2.7. It was then also extended to other mechanisms, such as hybrid post-quantum KEMs."
      },
      {
        "name": "Dialer",
        "desc": "Dialer dials TLS connections given a configuration and a Dialer for the underlying connection."
      },
      {
        "name": "ECHRejectionError",
        "desc": "ECHRejectionError is the error type returned when ECH is rejected by a remote server. If the server offered a ECHConfigList to use for retries, the RetryConfigList field will contain this list.  The client may treat an ECHRejectionError with an empty set of RetryConfigs as a secure signal from the server."
      },
      {
        "name": "EncryptedClientHelloKey",
        "desc": "EncryptedClientHelloKey holds a private key that is associated with a specific ECH config known to a client."
      },
      {
        "name": "QUICConfig",
        "desc": "A QUICConfig configures a [QUICConn]."
      },
      {
        "name": "QUICConn",
        "desc": "A QUICConn represents a connection which uses a QUIC implementation as the underlying transport as described in RFC 9001.  Methods of QUICConn are not safe for concurrent use."
      },
      {
        "name": "QUICEncryptionLevel",
        "desc": "QUICEncryptionLevel represents a QUIC encryption level used to transmit handshake messages."
      },
      {
        "name": "QUICEvent",
        "desc": "A QUICEvent is an event occurring on a QUIC connection.  The type of event is specified by the Kind field. The contents of the other fields are kind-specific."
      },
      {
        "name": "QUICEventKind",
        "desc": "A QUICEventKind is a type of operation on a QUIC connection."
      },
      {
        "name": "QUICSessionTicketOptions",
        "desc": ""
      },
      {
        "name": "RecordHeaderError",
        "desc": "RecordHeaderError is returned when a TLS record header is invalid."
      },
      {
        "name": "RenegotiationSupport",
        "desc": "RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.  Even when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS.  Renegotiation is not defined in TLS 1.3."
      },
      {
        "name": "SessionState",
        "desc": "A SessionState is a resumable session."
      },
      {
        "name": "SignatureScheme",
        "desc": "SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3."
      },
      {
        "name": "aead",
        "desc": ""
      },
      {
        "name": "alert",
        "desc": ""
      },
      {
        "name": "atLeastReader",
        "desc": "atLeastReader reads from R, stopping with EOF once at least N bytes have been read. It is different from an io.LimitedReader in that it doesn't cut short the last Read call, and in that it considers an early EOF an error."
      },
      {
        "name": "base64Flag",
        "desc": ""
      },
      {
        "name": "bogoResults",
        "desc": "bogoResults is a copy of boringssl.googlesource.com/boringssl/testresults.Results"
      },
      {
        "name": "brokenConn",
        "desc": "brokenConn wraps a net.Conn and causes all Writes after a certain number to fail with brokenConnErr."
      },
      {
        "name": "brokenSigner",
        "desc": ""
      },
      {
        "name": "cbcMode",
        "desc": "cbcMode is an interface for block ciphers using cipher block chaining."
      },
      {
        "name": "certificateMsg",
        "desc": ""
      },
      {
        "name": "certificateMsgTLS13",
        "desc": ""
      },
      {
        "name": "certificateRequestMsg",
        "desc": ""
      },
      {
        "name": "certificateRequestMsgTLS13",
        "desc": ""
      },
      {
        "name": "certificateStatusMsg",
        "desc": ""
      },
      {
        "name": "certificateVerifyMsg",
        "desc": ""
      },
      {
        "name": "changeImplConn",
        "desc": "changeImplConn is a net.Conn which can change its Write and Close methods."
      },
      {
        "name": "cipherSuite",
        "desc": "A cipherSuite is a TLS 1.0–1.2 cipher suite, and defines the key exchange mechanism, as well as the cipher+MAC pair or the AEAD."
      },
      {
        "name": "cipherSuiteTLS13",
        "desc": "A cipherSuiteTLS13 defines only the pair of the AEAD algorithm and hash algorithm to be used with HKDF. See RFC 8446, Appendix B.4."
      },
      {
        "name": "clientHandshakeState",
        "desc": ""
      },
      {
        "name": "clientHandshakeStateTLS13",
        "desc": ""
      },
      {
        "name": "clientHelloMsg",
        "desc": ""
      },
      {
        "name": "clientKeyExchangeMsg",
        "desc": ""
      },
      {
        "name": "clientTest",
        "desc": "clientTest represents a test of the TLS client handshake against a reference implementation."
      },
      {
        "name": "constantTimeHash",
        "desc": ""
      },
      {
        "name": "cthWrapper",
        "desc": "cthWrapper wraps any hash.Hash that implements ConstantTimeSum, and replaces with that all calls to Sum. It's used to obtain a ConstantTimeSum-based HMAC."
      },
      {
        "name": "discardConn",
        "desc": "discardConn wraps a net.Conn but discards all writes, but reports that they happened."
      },
      {
        "name": "ecdheKeyAgreement",
        "desc": "ecdheKeyAgreement implements a TLS key agreement where the server generates an ephemeral EC public/private key pair and signs it. The pre-master secret is then calculated using ECDH. The signature may be ECDSA, Ed25519 or RSA."
      },
      {
        "name": "echCipher",
        "desc": ""
      },
      {
        "name": "echClientContext",
        "desc": ""
      },
      {
        "name": "echConfig",
        "desc": ""
      },
      {
        "name": "echConfigErr",
        "desc": ""
      },
      {
        "name": "echExtType",
        "desc": ""
      },
      {
        "name": "echExtension",
        "desc": ""
      },
      {
        "name": "echServerContext",
        "desc": ""
      },
      {
        "name": "encryptedExtensionsMsg",
        "desc": ""
      },
      {
        "name": "endOfEarlyDataMsg",
        "desc": ""
      },
      {
        "name": "finishedHash",
        "desc": "A finishedHash calculates the hash of a set of handshake messages suitable for including in a Finished message."
      },
      {
        "name": "finishedMsg",
        "desc": ""
      },
      {
        "name": "fipsCertificate",
        "desc": ""
      },
      {
        "name": "hairpinConn",
        "desc": "hairpinConn is a net.Conn that makes a “hairpin” call when closed, back into the tls.Conn which is calling it."
      },
      {
        "name": "halfConn",
        "desc": "A halfConn represents one direction of the record layer connection, either sending or receiving."
      },
      {
        "name": "handshakeMessage",
        "desc": ""
      },
      {
        "name": "handshakeMessageWithOriginalBytes",
        "desc": ""
      },
      {
        "name": "helloRequestMsg",
        "desc": ""
      },
      {
        "name": "intSlice",
        "desc": ""
      },
      {
        "name": "keyAgreement",
        "desc": "A keyAgreement implements the client and server side of a TLS 1.0–1.2 key agreement protocol by generating and processing key exchange messages."
      },
      {
        "name": "keyShare",
        "desc": "TLS 1.3 Key Share. See RFC 8446, Section 4.2.8."
      },
      {
        "name": "keySharePrivateKeys",
        "desc": ""
      },
      {
        "name": "keyUpdateMsg",
        "desc": ""
      },
      {
        "name": "listener",
        "desc": "A listener implements a network listener (net.Listener) for TLS connections."
      },
      {
        "name": "lruSessionCache",
        "desc": "lruSessionCache is a ClientSessionCache implementation that uses an LRU caching strategy."
      },
      {
        "name": "lruSessionCacheEntry",
        "desc": ""
      },
      {
        "name": "marshalingFunction",
        "desc": "The marshalingFunction type is an adapter to allow the use of ordinary functions as cryptobyte.MarshalingValue."
      },
      {
        "name": "newSessionTicketMsg",
        "desc": ""
      },
      {
        "name": "newSessionTicketMsgTLS13",
        "desc": ""
      },
      {
        "name": "opensslInput",
        "desc": ""
      },
      {
        "name": "opensslInputEvent",
        "desc": "opensslInputEvent enumerates possible inputs that can be sent to an `openssl s_client` process."
      },
      {
        "name": "opensslOutputSink",
        "desc": "opensslOutputSink is an io.Writer that receives the stdout and stderr from an `openssl` process and sends a value to handshakeComplete or readKeyUpdate when certain messages are seen."
      },
      {
        "name": "permanentError",
        "desc": ""
      },
      {
        "name": "prefixNonceAEAD",
        "desc": "prefixNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to each call."
      },
      {
        "name": "prfFunc",
        "desc": ""
      },
      {
        "name": "pskIdentity",
        "desc": "TLS 1.3 PSK Identity. Can be a Session Ticket, or a reference to a saved session. See RFC 8446, Section 4.2.11."
      },
      {
        "name": "quicState",
        "desc": ""
      },
      {
        "name": "rawExtension",
        "desc": ""
      },
      {
        "name": "readerFunc",
        "desc": ""
      },
      {
        "name": "recordType",
        "desc": "TLS record types."
      },
      {
        "name": "recordingConn",
        "desc": "recordingConn is a net.Conn that records the traffic that passes through it. WriteTo can be used to produce output that can be later be loaded with ParseTestData."
      },
      {
        "name": "replayingConn",
        "desc": "replayingConn is a net.Conn that replays flows recorded by recordingConn."
      },
      {
        "name": "rsaKeyAgreement",
        "desc": "rsaKeyAgreement implements the standard TLS key agreement where the client encrypts the pre-master secret to the server's public key."
      },
      {
        "name": "serializingClientCache",
        "desc": ""
      },
      {
        "name": "serverHandshakeState",
        "desc": "serverHandshakeState contains details of a server handshake in progress. It's discarded once the handshake has completed."
      },
      {
        "name": "serverHandshakeStateTLS13",
        "desc": ""
      },
      {
        "name": "serverHelloDoneMsg",
        "desc": ""
      },
      {
        "name": "serverHelloMsg",
        "desc": ""
      },
      {
        "name": "serverKeyExchangeMsg",
        "desc": ""
      },
      {
        "name": "serverTest",
        "desc": "serverTest represents a test of the TLS server handshake against a reference implementation."
      },
      {
        "name": "slowConn",
        "desc": ""
      },
      {
        "name": "stringSlice",
        "desc": ""
      },
      {
        "name": "suiteSecret",
        "desc": ""
      },
      {
        "name": "testKeysFromTest",
        "desc": ""
      },
      {
        "name": "testQUICConn",
        "desc": ""
      },
      {
        "name": "testSplitPreMasterSecretTest",
        "desc": ""
      },
      {
        "name": "ticketKey",
        "desc": "ticketKey is the internal representation of a session ticket key."
      },
      {
        "name": "timeoutError",
        "desc": ""
      },
      {
        "name": "transcriptHash",
        "desc": ""
      },
      {
        "name": "weakCertCache",
        "desc": "weakCertCache provides a cache of *x509.Certificates, allowing multiple connections to reuse parsed certificates, instead of re-parsing the certificate for every connection, which is an expensive operation."
      },
      {
        "name": "writeCountingConn",
        "desc": "writeCountingConn wraps a net.Conn and counts the number of Write calls."
      },
      {
        "name": "xorNonceAEAD",
        "desc": "xorNonceAEAD wraps an AEAD by XORing in a fixed pattern to the nonce before each call."
      },
      {
        "name": "zeroSource",
        "desc": "zeroSource is an io.Reader that returns an unlimited number of zero bytes."
      }
    ]
  },
  {
    "name": "crypto/tls/fipsonly",
    "desc": "Package fipsonly restricts all TLS configuration to FIPS-approved settings.  The effect is triggered by importing the package anywhere in a program, as in:  \timport _ \"crypto/tls/fipsonly\"  This package only exists when using Go compiled with GOEXPERIMENT=boringcrypto.",
    "functions": [
      {
        "name": "Test",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "crypto/x509",
    "desc": "Package x509 implements a subset of the X.509 standard.  It allows parsing and generating certificates, certificate signing requests, certificate revocation lists, and encoded public and private keys. It provides a certificate verifier, complete with a chain builder.  The package targets the X.509 technical profile defined by the IETF (RFC 2459/3280/5280), and as further restricted by the CA/Browser Forum Baseline Requirements. There is minimal support for features outside of these profiles, as the primary goal of the package is to provide compatibility with the publicly trusted TLS certificate ecosystem and its policies and constraints.  On macOS and Windows, certificate verification is handled by system APIs, but the package aims to apply consistent validation rules across operating systems.",
    "functions": [
      {
        "name": "BenchmarkCreateCertificate",
        "desc": ""
      },
      {
        "name": "BenchmarkOIDMarshalUnmarshalText",
        "desc": ""
      },
      {
        "name": "BenchmarkParseCertificate",
        "desc": ""
      },
      {
        "name": "CreateCertificate",
        "desc": "CreateCertificate creates a new X.509 v3 certificate based on a template. The following members of template are currently used:    - AuthorityKeyId   - BasicConstraintsValid   - CRLDistributionPoints   - DNSNames   - EmailAddresses   - ExcludedDNSDomains   - ExcludedEmailAddresses   - ExcludedIPRanges   - ExcludedURIDomains   - ExtKeyUsage   - ExtraExtensions   - IPAddresses   - IsCA   - IssuingCertificateURL   - KeyUsage   - MaxPathLen   - MaxPathLenZero   - NotAfter   - NotBefore   - OCSPServer   - PermittedDNSDomains   - PermittedDNSDomainsCritical   - PermittedEmailAddresses   - PermittedIPRanges   - PermittedURIDomains   - PolicyIdentifiers (see note below)   - Policies (see note below)   - SerialNumber   - SignatureAlgorithm   - Subject   - SubjectKeyId   - URIs   - UnknownExtKeyUsage  The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the certificate to be generated and priv is the private key of the signer.  The returned slice is the certificate in DER encoding.  The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and ed25519.PublicKey. pub must be a supported key type, and priv must be a crypto.Signer or crypto.MessageSigner with a supported public key.  The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used.  If SubjectKeyId from template is empty and the template is a CA, SubjectKeyId will be generated from the hash of the public key.  If template.SerialNumber is nil, a serial number will be generated which conforms to RFC 5280, Section 4.1.2.2 using entropy from rand.  The PolicyIdentifier and Policies fields can both be used to marshal certificate policy OIDs. By default, only the Policies is marshaled, but if the GODEBUG setting \"x509usepolicies\" has the value \"0\", the PolicyIdentifiers field will be marshaled instead of the Policies field. This changed in Go 1.24. The Policies field can be used to marshal policy OIDs which have components that are larger than 31 bits."
      },
      {
        "name": "CreateCertificateRequest",
        "desc": "CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used:    - SignatureAlgorithm   - Subject   - DNSNames   - EmailAddresses   - IPAddresses   - URIs   - ExtraExtensions   - Attributes (deprecated)  priv is the private key to sign the CSR with, and the corresponding public key will be included in the CSR. It must implement crypto.Signer or crypto.MessageSigner and its Public() method must return a *rsa.PublicKey or a *ecdsa.PublicKey or a ed25519.PublicKey. (A *rsa.PrivateKey, *ecdsa.PrivateKey or ed25519.PrivateKey satisfies this.)  The returned slice is the certificate request in DER encoding."
      },
      {
        "name": "CreateRevocationList",
        "desc": "CreateRevocationList creates a new X.509 v2 [Certificate] Revocation List, according to RFC 5280, based on template.  The CRL is signed by priv which should be a crypto.Signer or crypto.MessageSigner associated with the public key in the issuer certificate.  The issuer may not be nil, and the crlSign bit must be set in [KeyUsage] in order to use it as a CRL issuer.  The issuer distinguished name CRL field and authority key identifier extension are populated using the issuer certificate. issuer must have SubjectKeyId set."
      },
      {
        "name": "DecryptPEMBlock",
        "desc": "DecryptPEMBlock takes a PEM block encrypted according to RFC 1423 and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an [IncorrectPasswordError] is returned. Because of deficiencies in the format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise.  Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext."
      },
      {
        "name": "EncryptPEMBlock",
        "desc": "EncryptPEMBlock returns a PEM block of the specified type holding the given DER encoded data encrypted with the specified algorithm and password according to RFC 1423.  Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext."
      },
      {
        "name": "FuzzDomainNameValid",
        "desc": ""
      },
      {
        "name": "IsEncryptedPEMBlock",
        "desc": "IsEncryptedPEMBlock returns whether the PEM block is password encrypted according to RFC 1423.  Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by design. Since it does not authenticate the ciphertext, it is vulnerable to padding oracle attacks that can let an attacker recover the plaintext."
      },
      {
        "name": "MarshalECPrivateKey",
        "desc": "MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.  This kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\". For a more flexible key format which is not EC specific, use [MarshalPKCS8PrivateKey]."
      },
      {
        "name": "MarshalPKCS1PrivateKey",
        "desc": "MarshalPKCS1PrivateKey converts an [RSA] private key to PKCS #1, ASN.1 DER form.  This kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE KEY\". For a more flexible key format which is not [RSA] specific, use [MarshalPKCS8PrivateKey].  The key must have passed validation by calling [rsa.PrivateKey.Validate] first. MarshalPKCS1PrivateKey calls [rsa.PrivateKey.Precompute], which may modify the key if not already precomputed."
      },
      {
        "name": "MarshalPKCS1PublicKey",
        "desc": "MarshalPKCS1PublicKey converts an [RSA] public key to PKCS #1, ASN.1 DER form.  This kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\"."
      },
      {
        "name": "MarshalPKCS8PrivateKey",
        "desc": "MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form.  The following key types are currently supported: *[rsa.PrivateKey], *[ecdsa.PrivateKey], [ed25519.PrivateKey] (not a pointer), and *[ecdh.PrivateKey]. Unsupported key types result in an error.  This kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\".  MarshalPKCS8PrivateKey runs [rsa.PrivateKey.Precompute] on RSA keys."
      },
      {
        "name": "MarshalPKIXPublicKey",
        "desc": "MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).  The following key types are currently supported: *[rsa.PublicKey], *[ecdsa.PublicKey], [ed25519.PublicKey] (not a pointer), and *[ecdh.PublicKey]. Unsupported key types result in an error.  This kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\"."
      },
      {
        "name": "ParseCRL",
        "desc": "ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.  Deprecated: Use [ParseRevocationList] instead."
      },
      {
        "name": "ParseDERCRL",
        "desc": "ParseDERCRL parses a DER encoded CRL from the given bytes.  Deprecated: Use [ParseRevocationList] instead."
      },
      {
        "name": "ParseECPrivateKey",
        "desc": "ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form.  This kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\"."
      },
      {
        "name": "ParsePKCS1PrivateKey",
        "desc": "ParsePKCS1PrivateKey parses an [RSA] private key in PKCS #1, ASN.1 DER form.  This kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE KEY\".  Before Go 1.24, the CRT parameters were ignored and recomputed. To restore the old behavior, use the GODEBUG=x509rsacrt=0 environment variable."
      },
      {
        "name": "ParsePKCS1PublicKey",
        "desc": "ParsePKCS1PublicKey parses an [RSA] public key in PKCS #1, ASN.1 DER form.  This kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\"."
      },
      {
        "name": "ParsePKCS8PrivateKey",
        "desc": "ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER form.  It returns a *[rsa.PrivateKey], an *[ecdsa.PrivateKey], an [ed25519.PrivateKey] (not a pointer), or an *[ecdh.PrivateKey] (for X25519). More types might be supported in the future.  This kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\".  Before Go 1.24, the CRT parameters of RSA keys were ignored and recomputed. To restore the old behavior, use the GODEBUG=x509rsacrt=0 environment variable."
      },
      {
        "name": "ParsePKIXPublicKey",
        "desc": "ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).  It returns a *[rsa.PublicKey], *[dsa.PublicKey], *[ecdsa.PublicKey], [ed25519.PublicKey] (not a pointer), or *[ecdh.PublicKey] (for X25519). More types might be supported in the future.  This kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\"."
      },
      {
        "name": "SetFallbackRoots",
        "desc": "SetFallbackRoots sets the roots to use during certificate verification, if no custom roots are specified and a platform verifier or a system certificate pool is not available (for instance in a container which does not have a root certificate bundle). SetFallbackRoots will panic if roots is nil.  SetFallbackRoots may only be called once, if called multiple times it will panic.  The fallback behavior can be forced on all platforms, even when there is a system certificate pool, by setting GODEBUG=x509usefallbackroots=1 (note that on Windows and macOS this will disable usage of the platform verification APIs and cause the pure Go verifier to be used). Setting x509usefallbackroots=1 without calling SetFallbackRoots has no effect."
      },
      {
        "name": "TestASN1BitLength",
        "desc": ""
      },
      {
        "name": "TestAdditionFieldsInGeneralSubtree",
        "desc": ""
      },
      {
        "name": "TestAuthKeyIdOptional",
        "desc": ""
      },
      {
        "name": "TestBadIPMask",
        "desc": ""
      },
      {
        "name": "TestBadNamesInConstraints",
        "desc": ""
      },
      {
        "name": "TestBadNamesInSANs",
        "desc": ""
      },
      {
        "name": "TestCRLCreation",
        "desc": ""
      },
      {
        "name": "TestCRLWithoutExpiry",
        "desc": ""
      },
      {
        "name": "TestCertPoolEqual",
        "desc": ""
      },
      {
        "name": "TestCertificateChainSignedByECDSA",
        "desc": ""
      },
      {
        "name": "TestCertificateEqualOnNil",
        "desc": ""
      },
      {
        "name": "TestCertificateOIDPoliciesGODEBUG",
        "desc": ""
      },
      {
        "name": "TestCertificateParse",
        "desc": ""
      },
      {
        "name": "TestCertificatePolicies",
        "desc": ""
      },
      {
        "name": "TestCertificateRequestOverrides",
        "desc": ""
      },
      {
        "name": "TestCertificateRequestRoundtripFields",
        "desc": ""
      },
      {
        "name": "TestConstraintCases",
        "desc": ""
      },
      {
        "name": "TestCreateCertificateBrokenSigner",
        "desc": ""
      },
      {
        "name": "TestCreateCertificateLegacy",
        "desc": ""
      },
      {
        "name": "TestCreateCertificateNegativeMaxPathLength",
        "desc": ""
      },
      {
        "name": "TestCreateCertificateRequest",
        "desc": ""
      },
      {
        "name": "TestCreateNegativeSerial",
        "desc": ""
      },
      {
        "name": "TestCreateRevocationList",
        "desc": ""
      },
      {
        "name": "TestCreateSelfSignedCertificate",
        "desc": ""
      },
      {
        "name": "TestCriticalFlagInCSRRequestedExtensions",
        "desc": ""
      },
      {
        "name": "TestCriticalNameConstraintWithUnknownType",
        "desc": ""
      },
      {
        "name": "TestDecrypt",
        "desc": ""
      },
      {
        "name": "TestDisableSHA1ForCertOnly",
        "desc": ""
      },
      {
        "name": "TestDomainNameValid",
        "desc": ""
      },
      {
        "name": "TestDuplicateAttributesCSR",
        "desc": ""
      },
      {
        "name": "TestDuplicateExtensionsCSR",
        "desc": ""
      },
      {
        "name": "TestDuplicateExtensionsCert",
        "desc": ""
      },
      {
        "name": "TestECDSA",
        "desc": ""
      },
      {
        "name": "TestECMismatchKeyFormat",
        "desc": ""
      },
      {
        "name": "TestEKUEnforcement",
        "desc": ""
      },
      {
        "name": "TestEd25519SelfSigned",
        "desc": ""
      },
      {
        "name": "TestEmptyNameConstraints",
        "desc": ""
      },
      {
        "name": "TestEmptySerialNumber",
        "desc": ""
      },
      {
        "name": "TestEmptySubject",
        "desc": ""
      },
      {
        "name": "TestEncrypt",
        "desc": ""
      },
      {
        "name": "TestEnvVars",
        "desc": ""
      },
      {
        "name": "TestFallback",
        "desc": ""
      },
      {
        "name": "TestFallbackPanic",
        "desc": ""
      },
      {
        "name": "TestGoVerify",
        "desc": ""
      },
      {
        "name": "TestGob",
        "desc": ""
      },
      {
        "name": "TestIA5SANEnforcement",
        "desc": ""
      },
      {
        "name": "TestISOOIDInCertificate",
        "desc": ""
      },
      {
        "name": "TestImports",
        "desc": ""
      },
      {
        "name": "TestIncompleteBlock",
        "desc": ""
      },
      {
        "name": "TestInsecureAlgorithmErrorString",
        "desc": ""
      },
      {
        "name": "TestInvalidOID",
        "desc": ""
      },
      {
        "name": "TestInvalidPolicyWithAnyKeyUsage",
        "desc": ""
      },
      {
        "name": "TestIssue51759",
        "desc": ""
      },
      {
        "name": "TestLargeOID",
        "desc": ""
      },
      {
        "name": "TestLoadSystemCertsLoadColonSeparatedDirs",
        "desc": "Ensure that \"SSL_CERT_DIR\" when used as the environment variable delimited by colons, allows loadSystemRoots to load all the roots from the respective directories. See https://golang.org/issue/35325."
      },
      {
        "name": "TestLongChain",
        "desc": ""
      },
      {
        "name": "TestMD5",
        "desc": ""
      },
      {
        "name": "TestMarshalInvalidPublicKey",
        "desc": ""
      },
      {
        "name": "TestMarshalRSAPrivateKey",
        "desc": ""
      },
      {
        "name": "TestMarshalRSAPrivateKeyInvalid",
        "desc": ""
      },
      {
        "name": "TestMarshalRSAPublicKey",
        "desc": ""
      },
      {
        "name": "TestMatchHostnames",
        "desc": ""
      },
      {
        "name": "TestMatchIP",
        "desc": ""
      },
      {
        "name": "TestMaxPathLen",
        "desc": ""
      },
      {
        "name": "TestMaxPathLenNotCA",
        "desc": ""
      },
      {
        "name": "TestMessageSigner",
        "desc": ""
      },
      {
        "name": "TestMismatchedSignatureAlgorithm",
        "desc": ""
      },
      {
        "name": "TestMultipleRDN",
        "desc": ""
      },
      {
        "name": "TestMultipleURLsInCRLDP",
        "desc": ""
      },
      {
        "name": "TestNISTPKITSPolicy",
        "desc": ""
      },
      {
        "name": "TestNameConstraints",
        "desc": ""
      },
      {
        "name": "TestNoAuthorityKeyIdInSelfSignedCert",
        "desc": ""
      },
      {
        "name": "TestNoSubjectKeyIdInCert",
        "desc": ""
      },
      {
        "name": "TestOID",
        "desc": ""
      },
      {
        "name": "TestOIDEqual",
        "desc": ""
      },
      {
        "name": "TestOIDEqualASN1OID",
        "desc": ""
      },
      {
        "name": "TestOIDMarshal",
        "desc": ""
      },
      {
        "name": "TestOIDUnmarshalBinary",
        "desc": ""
      },
      {
        "name": "TestOmitEmptyExtensions",
        "desc": ""
      },
      {
        "name": "TestPKCS1MismatchKeyFormat",
        "desc": ""
      },
      {
        "name": "TestPKCS1MismatchPublicKeyFormat",
        "desc": ""
      },
      {
        "name": "TestPKCS8",
        "desc": ""
      },
      {
        "name": "TestPKCS8MismatchKeyFormat",
        "desc": ""
      },
      {
        "name": "TestPKIXMismatchPublicKeyFormat",
        "desc": ""
      },
      {
        "name": "TestPKIXNameString",
        "desc": ""
      },
      {
        "name": "TestParseASN1String",
        "desc": ""
      },
      {
        "name": "TestParseCertificateNegativeMaxPathLength",
        "desc": ""
      },
      {
        "name": "TestParseCertificateRawEquals",
        "desc": ""
      },
      {
        "name": "TestParseCertificateRequest",
        "desc": ""
      },
      {
        "name": "TestParseCertificateWithDSASignatureAlgorithm",
        "desc": ""
      },
      {
        "name": "TestParseCertificateWithDsaPublicKey",
        "desc": ""
      },
      {
        "name": "TestParseDERCRL",
        "desc": ""
      },
      {
        "name": "TestParseECPrivateKey",
        "desc": ""
      },
      {
        "name": "TestParseNegativeSerial",
        "desc": ""
      },
      {
        "name": "TestParsePEMCRL",
        "desc": ""
      },
      {
        "name": "TestParsePKCS1PrivateKey",
        "desc": ""
      },
      {
        "name": "TestParsePKIXPublicKey",
        "desc": ""
      },
      {
        "name": "TestParsePolicies",
        "desc": ""
      },
      {
        "name": "TestParseRevocationList",
        "desc": ""
      },
      {
        "name": "TestParseUniqueID",
        "desc": ""
      },
      {
        "name": "TestPathBuilding",
        "desc": ""
      },
      {
        "name": "TestPathologicalChain",
        "desc": ""
      },
      {
        "name": "TestPlatformVerifier",
        "desc": ""
      },
      {
        "name": "TestPoliciesValid",
        "desc": ""
      },
      {
        "name": "TestPolicyParse",
        "desc": ""
      },
      {
        "name": "TestRDNSequenceString",
        "desc": ""
      },
      {
        "name": "TestRFC2821Parsing",
        "desc": ""
      },
      {
        "name": "TestRSAMissingNULLParameters",
        "desc": ""
      },
      {
        "name": "TestRSAPSAParameters",
        "desc": ""
      },
      {
        "name": "TestRSAPSSSelfSigned",
        "desc": ""
      },
      {
        "name": "TestReadUniqueDirectoryEntries",
        "desc": ""
      },
      {
        "name": "TestRejectCriticalAIA",
        "desc": ""
      },
      {
        "name": "TestRejectCriticalAKI",
        "desc": ""
      },
      {
        "name": "TestRejectCriticalSKI",
        "desc": ""
      },
      {
        "name": "TestRevocationListCheckSignatureFrom",
        "desc": ""
      },
      {
        "name": "TestRoundtripWeirdSANs",
        "desc": ""
      },
      {
        "name": "TestSHA1",
        "desc": ""
      },
      {
        "name": "TestSigAlgMismatch",
        "desc": ""
      },
      {
        "name": "TestSystemCertPool",
        "desc": ""
      },
      {
        "name": "TestSystemRootsError",
        "desc": ""
      },
      {
        "name": "TestSystemRootsErrorUnwrap",
        "desc": ""
      },
      {
        "name": "TestSystemVerify",
        "desc": ""
      },
      {
        "name": "TestUnknownAuthorityError",
        "desc": ""
      },
      {
        "name": "TestUnknownExtKey",
        "desc": ""
      },
      {
        "name": "TestValidHostname",
        "desc": ""
      },
      {
        "name": "TestVerifyBareWildcard",
        "desc": ""
      },
      {
        "name": "TestVerifyCertificateWithDSASignature",
        "desc": ""
      },
      {
        "name": "TestVerifyEKURootAsLeaf",
        "desc": ""
      },
      {
        "name": "TestVerifyEmptyCertificate",
        "desc": ""
      },
      {
        "name": "TestVerifyNilPubKey",
        "desc": ""
      },
      {
        "name": "addConstraintsToTemplate",
        "desc": ""
      },
      {
        "name": "alreadyInChain",
        "desc": "alreadyInChain checks whether a candidate certificate is present in a chain. Rather than doing a direct byte for byte equivalency check, we check if the subject, public key, and SAN, if present, are equal. This prevents loops that are created by mutual cross-signatures, or other cross-signature bridge oddities."
      },
      {
        "name": "appendBase128BigInt",
        "desc": ""
      },
      {
        "name": "appendBase128Int",
        "desc": ""
      },
      {
        "name": "asn1BitLength",
        "desc": "asn1BitLength returns the bit-length of bitString by considering the most-significant bit in a byte to be the \"first\" bit. This convention matches ASN.1, but differs from almost everything else."
      },
      {
        "name": "base128BigIntLength",
        "desc": ""
      },
      {
        "name": "base128IntLength",
        "desc": ""
      },
      {
        "name": "bigFromHexString",
        "desc": ""
      },
      {
        "name": "bigFromString",
        "desc": ""
      },
      {
        "name": "buildCSRExtensions",
        "desc": ""
      },
      {
        "name": "buildCertExtensions",
        "desc": ""
      },
      {
        "name": "buildTrustGraph",
        "desc": ""
      },
      {
        "name": "certPoolEqual",
        "desc": "certPoolEqual reports whether a and b are equal, except for the function pointers."
      },
      {
        "name": "chainToDebugString",
        "desc": ""
      },
      {
        "name": "chainsToStrings",
        "desc": ""
      },
      {
        "name": "checkChainForKeyUsage",
        "desc": ""
      },
      {
        "name": "checkChainSSLServerPolicy",
        "desc": "checkChainSSLServerPolicy checks that the certificate chain in chainCtx is valid for use as a certificate chain for a SSL/TLS server."
      },
      {
        "name": "checkChainTrustStatus",
        "desc": "checkChainTrustStatus checks the trust status of the certificate chain, translating any errors it finds into Go errors in the process."
      },
      {
        "name": "checkSignature",
        "desc": "checkSignature verifies that signature is a valid signature over signed from a crypto.PublicKey."
      },
      {
        "name": "createStoreContext",
        "desc": "Creates a new *syscall.CertContext representing the leaf certificate in an in-memory certificate store containing itself and all of the intermediate certificates specified in the opts.Intermediates CertPool.  A pointer to the in-memory store is available in the returned CertContext's Store field. The store is automatically freed when the CertContext is freed using syscall.CertFreeCertificateContext."
      },
      {
        "name": "customConstraintsExtension",
        "desc": ""
      },
      {
        "name": "domainNameValid",
        "desc": "domainNameValid is an alloc-less version of the checks that domainToReverseLabels does."
      },
      {
        "name": "domainToReverseLabels",
        "desc": "domainToReverseLabels converts a textual domain name like foo.example.com to the list of labels in reverse order, e.g. [\"com\", \"example\", \"foo\"]."
      },
      {
        "name": "dsaSelfSignedCNX",
        "desc": "dsaSelfSignedCNX produces DER-encoded certificate with the properties:  \tSubject=Issuer=CN=X \tDSA SPKI \tMatching inner/outer signature OIDs \tDummy ECDSA signature"
      },
      {
        "name": "expectAuthorityUnknown",
        "desc": ""
      },
      {
        "name": "expectExpired",
        "desc": ""
      },
      {
        "name": "expectHashError",
        "desc": ""
      },
      {
        "name": "expectHostnameError",
        "desc": ""
      },
      {
        "name": "expectNameConstraintsError",
        "desc": ""
      },
      {
        "name": "expectNotAuthorizedError",
        "desc": ""
      },
      {
        "name": "expectUnhandledCriticalExtension",
        "desc": ""
      },
      {
        "name": "expectUsageError",
        "desc": ""
      },
      {
        "name": "forEachSAN",
        "desc": ""
      },
      {
        "name": "fromBase10",
        "desc": ""
      },
      {
        "name": "fromBase64",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initSystemRoots",
        "desc": ""
      },
      {
        "name": "isIA5String",
        "desc": ""
      },
      {
        "name": "isPrintable",
        "desc": "isPrintable reports whether the given b is in the ASN.1 PrintableString set. This is a simplified version of encoding/asn1.isPrintable."
      },
      {
        "name": "isSameDirSymlink",
        "desc": "isSameDirSymlink reports whether fi in dir is a symlink with a target not containing a slash."
      },
      {
        "name": "isValidIPMask",
        "desc": "isValidIPMask reports whether mask consists of zero or more 1 bits, followed by zero bits."
      },
      {
        "name": "macosMajorVersion",
        "desc": ""
      },
      {
        "name": "marshalBasicConstraints",
        "desc": ""
      },
      {
        "name": "marshalCertificatePolicies",
        "desc": ""
      },
      {
        "name": "marshalECDHPrivateKey",
        "desc": "marshalECDHPrivateKey marshals an EC private key into ASN.1, DER format suitable for NIST curves."
      },
      {
        "name": "marshalECPrivateKeyWithOID",
        "desc": "marshalECPrivateKeyWithOID marshals an EC private key into ASN.1, DER format and sets the curve ID to the given OID, or omits it if OID is nil."
      },
      {
        "name": "marshalExtKeyUsage",
        "desc": ""
      },
      {
        "name": "marshalKeyUsage",
        "desc": ""
      },
      {
        "name": "marshalPublicKey",
        "desc": ""
      },
      {
        "name": "marshalSANs",
        "desc": "marshalSANs marshals a list of addresses into a the contents of an X.509 SubjectAlternativeName extension."
      },
      {
        "name": "matchDomainConstraint",
        "desc": ""
      },
      {
        "name": "matchEmailConstraint",
        "desc": ""
      },
      {
        "name": "matchExactly",
        "desc": ""
      },
      {
        "name": "matchHostnames",
        "desc": ""
      },
      {
        "name": "matchIPConstraint",
        "desc": ""
      },
      {
        "name": "matchURIConstraint",
        "desc": ""
      },
      {
        "name": "nameToKey",
        "desc": ""
      },
      {
        "name": "namedCurveFromOID",
        "desc": ""
      },
      {
        "name": "newRawAttributes",
        "desc": "newRawAttributes converts AttributeTypeAndValueSETs from a template CertificateRequest's Attributes into tbsCertificateRequest RawAttributes."
      },
      {
        "name": "oidFromECDHCurve",
        "desc": ""
      },
      {
        "name": "oidFromExtKeyUsage",
        "desc": ""
      },
      {
        "name": "oidFromNamedCurve",
        "desc": ""
      },
      {
        "name": "oidInExtensions",
        "desc": "oidInExtensions reports whether an extension with the given oid exists in extensions."
      },
      {
        "name": "parseAI",
        "desc": ""
      },
      {
        "name": "parseASN1String",
        "desc": "parseASN1String parses the ASN.1 string types T61String, PrintableString, UTF8String, BMPString, IA5String, and NumericString. This is mostly copied from the respective encoding/asn1.parse... methods, rather than just increasing the API surface of that package."
      },
      {
        "name": "parseAuthorityKeyIdentifier",
        "desc": ""
      },
      {
        "name": "parseBase128Int",
        "desc": ""
      },
      {
        "name": "parseBasicConstraintsExtension",
        "desc": ""
      },
      {
        "name": "parseCIDR",
        "desc": ""
      },
      {
        "name": "parseCSRExtensions",
        "desc": "parseCSRExtensions parses the attributes from a CSR and extracts any requested extensions."
      },
      {
        "name": "parseECPrivateKey",
        "desc": "parseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure. The OID for the named curve may be provided from another source (such as the PKCS8 container) - if it is provided then use this instead of the OID that may exist in the EC private key structure."
      },
      {
        "name": "parseExtension",
        "desc": ""
      },
      {
        "name": "parseName",
        "desc": "parseName parses a DER encoded Name as defined in RFC 5280. We may want to export this function in the future for use in crypto/tls."
      },
      {
        "name": "parseNameConstraintsExtension",
        "desc": ""
      },
      {
        "name": "parsePublicKey",
        "desc": ""
      },
      {
        "name": "parseRawAttributes",
        "desc": "parseRawAttributes Unmarshals RawAttributes into AttributeTypeAndValueSETs."
      },
      {
        "name": "parseSANExtension",
        "desc": ""
      },
      {
        "name": "parseTime",
        "desc": ""
      },
      {
        "name": "parseURI",
        "desc": ""
      },
      {
        "name": "parseValidity",
        "desc": ""
      },
      {
        "name": "policiesValid",
        "desc": ""
      },
      {
        "name": "processExtensions",
        "desc": ""
      },
      {
        "name": "readUniqueDirectoryEntries",
        "desc": "readUniqueDirectoryEntries is like os.ReadDir but omits symlinks that point within the directory."
      },
      {
        "name": "reverseBitsInAByte",
        "desc": ""
      },
      {
        "name": "signTBS",
        "desc": ""
      },
      {
        "name": "signaturePublicKeyAlgoMismatchError",
        "desc": ""
      },
      {
        "name": "subjectBytes",
        "desc": ""
      },
      {
        "name": "testChainAgainstOpenSSL",
        "desc": ""
      },
      {
        "name": "testParsePKIXPublicKey",
        "desc": ""
      },
      {
        "name": "testVerify",
        "desc": ""
      },
      {
        "name": "testingKey",
        "desc": ""
      },
      {
        "name": "toLowerCaseASCII",
        "desc": "toLowerCaseASCII returns a lower-case version of in. See RFC 6125 6.4.1. We use an explicitly ASCII function to avoid any sharp corners resulting from performing Unicode operations on DNS labels."
      },
      {
        "name": "validHostname",
        "desc": "validHostname reports whether host is a valid hostname that can be matched or matched against according to RFC 6125 2.2, with some leniency to accommodate legacy values."
      },
      {
        "name": "validHostnameInput",
        "desc": ""
      },
      {
        "name": "validHostnamePattern",
        "desc": ""
      },
      {
        "name": "writePEMsToTempFile",
        "desc": ""
      },
      {
        "name": "AddCert",
        "desc": "AddCert adds a certificate to a pool."
      },
      {
        "name": "AddCertWithConstraint",
        "desc": "AddCertWithConstraint adds a certificate to the pool with the additional constraint. When Certificate.Verify builds a chain which is rooted by cert, it will additionally pass the whole chain to constraint to determine its validity. If constraint returns a non-nil error, the chain will be discarded. constraint may be called concurrently from multiple goroutines."
      },
      {
        "name": "AppendCertsFromPEM",
        "desc": "AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed.  On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function."
      },
      {
        "name": "Clone",
        "desc": "Clone returns a copy of s."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether s and other are equal."
      },
      {
        "name": "Subjects",
        "desc": "Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.  Deprecated: if s was returned by [SystemCertPool], Subjects will not include the system roots."
      },
      {
        "name": "addCertFunc",
        "desc": "addCertFunc adds metadata about a certificate to a pool, along with a func to fetch that certificate later when needed.  The rawSubject is Certificate.RawSubject and must be non-empty. The getCert func may be called 0 or more times."
      },
      {
        "name": "cert",
        "desc": "cert returns cert index n in s."
      },
      {
        "name": "contains",
        "desc": ""
      },
      {
        "name": "findPotentialParents",
        "desc": "findPotentialParents returns the certificates in s which might have signed cert."
      },
      {
        "name": "len",
        "desc": "len returns the number of certs in the set. A nil set is a valid empty set."
      },
      {
        "name": "mustCert",
        "desc": ""
      },
      {
        "name": "CheckCRLSignature",
        "desc": "CheckCRLSignature checks that the signature in crl is from c.  Deprecated: Use [RevocationList.CheckSignatureFrom] instead."
      },
      {
        "name": "CheckSignature",
        "desc": "CheckSignature verifies that signature is a valid signature over signed from c's public key.  This is a low-level API that performs no validity checks on the certificate.  [MD5WithRSA] signatures are rejected, while [SHA1WithRSA] and [ECDSAWithSHA1] signatures are currently accepted."
      },
      {
        "name": "CheckSignatureFrom",
        "desc": "CheckSignatureFrom verifies that the signature on c is a valid signature from parent.  This is a low-level API that performs very limited checks, and not a full path verifier. Most users should use [Certificate.Verify] instead."
      },
      {
        "name": "CreateCRL",
        "desc": "CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates.  Deprecated: this method does not generate an RFC 5280 conformant X.509 v2 CRL. To generate a standards compliant CRL, use [CreateRevocationList] instead."
      },
      {
        "name": "Equal",
        "desc": ""
      },
      {
        "name": "Verify",
        "desc": "Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.  If opts.Roots is nil, the platform verifier might be used, and verification details might differ from what is described below. If system roots are unavailable the returned error will be of type SystemRootsError.  Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn't permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported.  Name constraint validation follows the rules from RFC 5280, with the addition that DNS name constraints may use the leading period format defined for emails and URIs. When a constraint has a leading period it indicates that at least one additional label must be prepended to the constrained name to be considered valid.  Extended Key Usage values are enforced nested down a chain, so an intermediate or root that enumerates EKUs prevents a leaf from asserting an EKU not in that list. (While this is not specified, it is common practice in order to limit the types of certificates a CA can issue.)  Certificates that use SHA1WithRSA and ECDSAWithSHA1 signatures are not supported, and will not be used to build chains.  Certificates other than c in the returned chains should not be modified.  WARNING: this function doesn't do any revocation checking."
      },
      {
        "name": "VerifyHostname",
        "desc": "VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.  IP addresses can be optionally enclosed in square brackets and are checked against the IPAddresses field. Other names are checked case insensitively against the DNSNames field. If the names are valid hostnames, the certificate fields can have a wildcard as the complete left-most label (e.g. *.example.com).  Note that the legacy Common Name field is ignored."
      },
      {
        "name": "buildChains",
        "desc": ""
      },
      {
        "name": "checkNameConstraints",
        "desc": "checkNameConstraints checks that c permits a child certificate to claim the given name, of type nameType. The argument parsedName contains the parsed form of name, suitable for passing to the match function. The total number of comparisons is tracked in the given count and should not exceed the given limit."
      },
      {
        "name": "getSANExtension",
        "desc": ""
      },
      {
        "name": "hasNameConstraints",
        "desc": ""
      },
      {
        "name": "hasSANExtension",
        "desc": ""
      },
      {
        "name": "isValid",
        "desc": "isValid performs validity checks on c given that it is a candidate to append to the chain in currentChain."
      },
      {
        "name": "systemVerify",
        "desc": "systemVerify is like Verify, except that it uses CryptoAPI calls to build certificate chains and verify them."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "CheckSignature",
        "desc": "CheckSignature reports whether the signature on c is valid."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": "AppendBinary implements [encoding.BinaryAppender]"
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements [encoding.TextAppender]"
      },
      {
        "name": "Equal",
        "desc": "Equal returns true when oid and other represents the same Object Identifier."
      },
      {
        "name": "EqualASN1OID",
        "desc": "EqualASN1OID returns whether an OID equals an asn1.ObjectIdentifier. If asn1.ObjectIdentifier cannot represent the OID specified by oid, because a component of OID requires more than 31 bits, it returns false."
      },
      {
        "name": "MarshalBinary",
        "desc": "MarshalBinary implements [encoding.BinaryMarshaler]"
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements [encoding.TextMarshaler]"
      },
      {
        "name": "String",
        "desc": "Strings returns the string representation of the Object Identifier."
      },
      {
        "name": "UnmarshalBinary",
        "desc": "UnmarshalBinary implements [encoding.BinaryUnmarshaler]"
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements [encoding.TextUnmarshaler]"
      },
      {
        "name": "toASN1OID",
        "desc": ""
      },
      {
        "name": "unmarshalOIDText",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "CheckSignatureFrom",
        "desc": "CheckSignatureFrom verifies that the signature on rl is a valid signature from issuer."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "hashFunc",
        "desc": ""
      },
      {
        "name": "isRSAPSS",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Public",
        "desc": ""
      },
      {
        "name": "Sign",
        "desc": ""
      },
      {
        "name": "Public",
        "desc": ""
      },
      {
        "name": "Sign",
        "desc": ""
      },
      {
        "name": "SignMessage",
        "desc": ""
      },
      {
        "name": "deleteLeaf",
        "desc": ""
      },
      {
        "name": "incrDepth",
        "desc": ""
      },
      {
        "name": "insert",
        "desc": ""
      },
      {
        "name": "leafWithPolicy",
        "desc": ""
      },
      {
        "name": "leaves",
        "desc": ""
      },
      {
        "name": "parentWithAnyPolicy",
        "desc": ""
      },
      {
        "name": "parents",
        "desc": ""
      },
      {
        "name": "parentsWithExpected",
        "desc": ""
      },
      {
        "name": "prune",
        "desc": ""
      },
      {
        "name": "validPolicyNodes",
        "desc": ""
      },
      {
        "name": "deriveKey",
        "desc": "deriveKey uses a key derivation function to stretch the password into a key with the number of bits our cipher requires. This algorithm was derived from the OpenSSL source."
      }
    ],
    "types": [
      {
        "name": "CertPool",
        "desc": "CertPool is a set of certificates."
      },
      {
        "name": "Certificate",
        "desc": "A Certificate represents an X.509 certificate."
      },
      {
        "name": "CertificateInvalidError",
        "desc": "CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly."
      },
      {
        "name": "CertificateRequest",
        "desc": "CertificateRequest represents a PKCS #10, certificate signature request."
      },
      {
        "name": "ConstraintViolationError",
        "desc": "ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key."
      },
      {
        "name": "ExtKeyUsage",
        "desc": "ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action."
      },
      {
        "name": "HostnameError",
        "desc": "HostnameError results when the set of authorized names doesn't match the requested name."
      },
      {
        "name": "InsecureAlgorithmError",
        "desc": "An InsecureAlgorithmError indicates that the [SignatureAlgorithm] used to generate the signature is not secure, and the signature has been rejected."
      },
      {
        "name": "InvalidReason",
        "desc": ""
      },
      {
        "name": "KeyUsage",
        "desc": "KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants."
      },
      {
        "name": "OID",
        "desc": "An OID represents an ASN.1 OBJECT IDENTIFIER."
      },
      {
        "name": "PEMCipher",
        "desc": ""
      },
      {
        "name": "PolicyMapping",
        "desc": "PolicyMapping represents a policy mapping entry in the policyMappings extension."
      },
      {
        "name": "PublicKeyAlgorithm",
        "desc": ""
      },
      {
        "name": "RevocationList",
        "desc": "RevocationList represents a [Certificate] Revocation List (CRL) as specified by RFC 5280."
      },
      {
        "name": "RevocationListEntry",
        "desc": "RevocationListEntry represents an entry in the revokedCertificates sequence of a CRL."
      },
      {
        "name": "SignatureAlgorithm",
        "desc": ""
      },
      {
        "name": "SystemRootsError",
        "desc": "SystemRootsError results when we fail to load the system root certificates."
      },
      {
        "name": "UnhandledCriticalExtension",
        "desc": ""
      },
      {
        "name": "UnknownAuthorityError",
        "desc": "UnknownAuthorityError results when the certificate issuer is unknown"
      },
      {
        "name": "VerifyOptions",
        "desc": "VerifyOptions contains parameters for Certificate.Verify."
      },
      {
        "name": "authKeyId",
        "desc": "RFC 5280,  4.2.1.1"
      },
      {
        "name": "authorityInfoAccess",
        "desc": "RFC 5280, 4.2.2.1"
      },
      {
        "name": "basicConstraints",
        "desc": ""
      },
      {
        "name": "brokenSigner",
        "desc": ""
      },
      {
        "name": "certificate",
        "desc": ""
      },
      {
        "name": "certificateList",
        "desc": "These structures reflect the ASN.1 structure of X.509 CRLs better than the existing crypto/x509/pkix variants do. These mirror the existing certificate structs in this file.  Notably, we include issuer as an asn1.RawValue, mirroring the behavior of tbsCertificate and allowing raw (unparsed) subjects to be passed cleanly."
      },
      {
        "name": "certificateRequest",
        "desc": ""
      },
      {
        "name": "constraintsSpec",
        "desc": ""
      },
      {
        "name": "distributionPoint",
        "desc": "RFC 5280, 4.2.1.14"
      },
      {
        "name": "distributionPointName",
        "desc": ""
      },
      {
        "name": "dsaAlgorithmParameters",
        "desc": ""
      },
      {
        "name": "ecPrivateKey",
        "desc": "ecPrivateKey reflects an ASN.1 Elliptic Curve Private Key Structure. References:  \tRFC 5915 \tSEC1 - http://www.secg.org/sec1-v2.pdf  Per RFC 5915 the NamedCurveOID is marked as ASN.1 OPTIONAL, however in most cases it is not."
      },
      {
        "name": "lazyCert",
        "desc": "lazyCert is minimal metadata about a Cert and a func to retrieve it in its normal expanded *Certificate form."
      },
      {
        "name": "leafSpec",
        "desc": ""
      },
      {
        "name": "matchHostnamesTest",
        "desc": ""
      },
      {
        "name": "messageSigner",
        "desc": ""
      },
      {
        "name": "nameConstraintsTest",
        "desc": ""
      },
      {
        "name": "pkcs1AdditionalRSAPrime",
        "desc": ""
      },
      {
        "name": "pkcs1PrivateKey",
        "desc": "pkcs1PrivateKey is a structure which mirrors the PKCS #1 ASN.1 for an RSA private key."
      },
      {
        "name": "pkcs1PublicKey",
        "desc": "pkcs1PublicKey reflects the ASN.1 structure of a PKCS #1 public key."
      },
      {
        "name": "pkcs8",
        "desc": "pkcs8 reflects an ASN.1, PKCS #8 PrivateKey. See ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-8/pkcs-8v1_2.asn and RFC 5208."
      },
      {
        "name": "pkixPublicKey",
        "desc": "pkixPublicKey reflects a PKIX public key structure. See SubjectPublicKeyInfo in RFC 3280."
      },
      {
        "name": "policyGraph",
        "desc": ""
      },
      {
        "name": "policyGraphNode",
        "desc": ""
      },
      {
        "name": "policyInformation",
        "desc": "RFC 5280 4.2.1.4"
      },
      {
        "name": "potentialParent",
        "desc": ""
      },
      {
        "name": "pssParameters",
        "desc": "pssParameters reflects the parameters in an AlgorithmIdentifier that specifies RSA PSS. See RFC 3447, Appendix A.2.3."
      },
      {
        "name": "publicKeyInfo",
        "desc": ""
      },
      {
        "name": "rfc1423Algo",
        "desc": "rfc1423Algo holds a method for enciphering a PEM block."
      },
      {
        "name": "rfc2821Mailbox",
        "desc": "rfc2821Mailbox represents a “mailbox” (which is an email address to most people) by breaking it into the “local” (i.e. before the '@') and “domain” parts."
      },
      {
        "name": "rootDescription",
        "desc": ""
      },
      {
        "name": "sum224",
        "desc": ""
      },
      {
        "name": "tbsCertificate",
        "desc": ""
      },
      {
        "name": "tbsCertificateList",
        "desc": ""
      },
      {
        "name": "tbsCertificateRequest",
        "desc": ""
      },
      {
        "name": "trustGraphDescription",
        "desc": ""
      },
      {
        "name": "trustGraphEdge",
        "desc": ""
      },
      {
        "name": "validity",
        "desc": ""
      },
      {
        "name": "verifyTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "crypto/x509/pkix",
    "desc": "Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.",
    "functions": [
      {
        "name": "oidInAttributeTypeAndValue",
        "desc": "oidInAttributeTypeAndValue reports whether a type with the given OID exists in atv."
      },
      {
        "name": "HasExpired",
        "desc": "HasExpired reports whether certList should have been updated by now."
      },
      {
        "name": "FillFromRDNSequence",
        "desc": "FillFromRDNSequence populates n from the provided [RDNSequence]. Multi-entry RDNs are flattened, all entries are added to the relevant n fields, and the grouping is not preserved."
      },
      {
        "name": "String",
        "desc": "String returns the string form of n, roughly following the RFC 2253 Distinguished Names syntax."
      },
      {
        "name": "ToRDNSequence",
        "desc": "ToRDNSequence converts n into a single [RDNSequence]. The following attributes are encoded as multi-value RDNs:    - Country   - Organization   - OrganizationalUnit   - Locality   - Province   - StreetAddress   - PostalCode  Each ExtraNames entry is encoded as an individual RDN."
      },
      {
        "name": "appendRDNs",
        "desc": "appendRDNs appends a relativeDistinguishedNameSET to the given RDNSequence and returns the new value. The relativeDistinguishedNameSET contains an attributeTypeAndValue for each of the given values. See RFC 5280, A.1, and search for AttributeTypeAndValue."
      },
      {
        "name": "String",
        "desc": "String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax."
      }
    ],
    "types": [
      {
        "name": "AlgorithmIdentifier",
        "desc": "AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC 5280, section 4.1.1.2."
      },
      {
        "name": "AttributeTypeAndValue",
        "desc": "AttributeTypeAndValue mirrors the ASN.1 structure of the same name in RFC 5280, Section 4.1.2.4."
      },
      {
        "name": "AttributeTypeAndValueSET",
        "desc": "AttributeTypeAndValueSET represents a set of ASN.1 sequences of [AttributeTypeAndValue] sequences from RFC 2986 (PKCS #10)."
      },
      {
        "name": "CertificateList",
        "desc": "CertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the signature.  Deprecated: x509.RevocationList should be used instead."
      },
      {
        "name": "Extension",
        "desc": "Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2."
      },
      {
        "name": "Name",
        "desc": "Name represents an X.509 distinguished name. This only includes the common elements of a DN. Note that Name is only an approximation of the X.509 structure. If an accurate representation is needed, asn1.Unmarshal the raw subject or issuer as an [RDNSequence]."
      },
      {
        "name": "RDNSequence",
        "desc": ""
      },
      {
        "name": "RelativeDistinguishedNameSET",
        "desc": ""
      },
      {
        "name": "RevokedCertificate",
        "desc": "RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1."
      },
      {
        "name": "TBSCertificateList",
        "desc": "TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.  Deprecated: x509.RevocationList should be used instead."
      }
    ]
  },
  {
    "name": "database/sql",
    "desc": "Package sql provides a generic interface around SQL (or SQL-like) databases.  The sql package must be used in conjunction with a database driver. See https://golang.org/s/sqldrivers for a list of drivers.  Drivers that do not support context cancellation will not return until after the query is completed.  For usage examples, see the wiki page at https://golang.org/s/sqlwiki.",
    "functions": [
      {
        "name": "BenchmarkConcurrentDBExec",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentRandom",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentStmtExec",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentStmtQuery",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentTxExec",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentTxQuery",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentTxStmtExec",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrentTxStmtQuery",
        "desc": ""
      },
      {
        "name": "BenchmarkConnRequestSet",
        "desc": ""
      },
      {
        "name": "BenchmarkGrabConn",
        "desc": ""
      },
      {
        "name": "BenchmarkManyConcurrentQueries",
        "desc": ""
      },
      {
        "name": "Drivers",
        "desc": "Drivers returns a sorted list of the names of the registered drivers."
      },
      {
        "name": "Register",
        "desc": "Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics."
      },
      {
        "name": "TestBadDriver",
        "desc": "Issue 15901."
      },
      {
        "name": "TestBogusPreboundParameters",
        "desc": "just a test of fakedb itself"
      },
      {
        "name": "TestCloseConnBeforeStmts",
        "desc": "golang.org/issue/5046"
      },
      {
        "name": "TestCloseStmtBeforeRows",
        "desc": "From golang.org/issue/3865"
      },
      {
        "name": "TestConcurrency",
        "desc": ""
      },
      {
        "name": "TestConnExpiresFreshOutOfPool",
        "desc": "Issue32530 encounters an issue where a connection may expire right after it comes out of a used connection pool even when a new connection is requested."
      },
      {
        "name": "TestConnIsValid",
        "desc": "TestConnIsValid verifies that a database connection that should be discarded, is actually discarded and does not re-enter the connection pool. If the IsValid method from *fakeConn is removed, this test will fail."
      },
      {
        "name": "TestConnMaxLifetime",
        "desc": ""
      },
      {
        "name": "TestConnQuery",
        "desc": ""
      },
      {
        "name": "TestConnRaw",
        "desc": ""
      },
      {
        "name": "TestConnRequestSet",
        "desc": ""
      },
      {
        "name": "TestConnTx",
        "desc": ""
      },
      {
        "name": "TestConnectionLeak",
        "desc": ""
      },
      {
        "name": "TestContextCancelBetweenNextAndErr",
        "desc": ""
      },
      {
        "name": "TestContextCancelDuringRawBytesScan",
        "desc": ""
      },
      {
        "name": "TestContextCancelDuringScan",
        "desc": ""
      },
      {
        "name": "TestConversions",
        "desc": ""
      },
      {
        "name": "TestCursorFake",
        "desc": ""
      },
      {
        "name": "TestDecimal",
        "desc": ""
      },
      {
        "name": "TestDriverArgs",
        "desc": ""
      },
      {
        "name": "TestDriverArgsWrapsErrors",
        "desc": "Issue 64707: Ensure that Stmt.Exec and Stmt.Query properly wraps underlying errors."
      },
      {
        "name": "TestDriverPanic",
        "desc": ""
      },
      {
        "name": "TestDrivers",
        "desc": ""
      },
      {
        "name": "TestErrBadConnReconnect",
        "desc": "golang.org/issue/5718"
      },
      {
        "name": "TestExec",
        "desc": ""
      },
      {
        "name": "TestGenericNullStringParam",
        "desc": ""
      },
      {
        "name": "TestGrabConnAllocs",
        "desc": ""
      },
      {
        "name": "TestInvalidNilValues",
        "desc": ""
      },
      {
        "name": "TestIssue18429",
        "desc": "TestIssue18429 attempts to stress rolling back the transaction from a context cancel while simultaneously calling Tx.Rollback. Rolling back from a context happens concurrently so tx.rollback and tx.Commit must guard against double entry.  In the test, a context is canceled while the query is in process so the internal rollback will run concurrently with the explicitly called Tx.Rollback.  The addition of calling rows.Next also tests Issue 21117."
      },
      {
        "name": "TestIssue18719",
        "desc": "TestIssue18719 closes the context right before use. The sql.driverConn will nil out the ci on close in a lock, but if another process uses it right after it will panic with on the nil ref.  See https://golang.org/cl/35550 ."
      },
      {
        "name": "TestIssue20160",
        "desc": "TestIssue20160 attempts to test a short context life on a stmt Query."
      },
      {
        "name": "TestIssue20575",
        "desc": "TestIssue20575 ensures the Rows from query does not block closing a transaction. Ensure Rows is closed while closing a transaction."
      },
      {
        "name": "TestIssue20622",
        "desc": "TestIssue20622 tests closing the transaction before rows is closed, requires the race detector to fail."
      },
      {
        "name": "TestIssue20647",
        "desc": ""
      },
      {
        "name": "TestIssue2542Deadlock",
        "desc": "Tests fix for issue 2542, that we release a lock when querying on a closed connection."
      },
      {
        "name": "TestIssue4902",
        "desc": ""
      },
      {
        "name": "TestIssue6081",
        "desc": ""
      },
      {
        "name": "TestIssue6651",
        "desc": "Test issue 6651"
      },
      {
        "name": "TestIssue69728",
        "desc": ""
      },
      {
        "name": "TestIssue69837",
        "desc": ""
      },
      {
        "name": "TestManyErrBadConn",
        "desc": "Test cases where there's more than maxBadConnRetries bad connections in the pool (issue 8834)"
      },
      {
        "name": "TestMaxIdleConns",
        "desc": ""
      },
      {
        "name": "TestMaxIdleTime",
        "desc": ""
      },
      {
        "name": "TestMaxOpenConns",
        "desc": ""
      },
      {
        "name": "TestMaxOpenConnsOnBusy",
        "desc": "Issue 9453: tests that SetMaxOpenConns can be lowered at runtime and affects the subsequent release of connections."
      },
      {
        "name": "TestMultiResultSetQuery",
        "desc": ""
      },
      {
        "name": "TestNamedValueChecker",
        "desc": ""
      },
      {
        "name": "TestNamedValueCheckerSkip",
        "desc": ""
      },
      {
        "name": "TestNilErrorAfterClose",
        "desc": ""
      },
      {
        "name": "TestNullBoolParam",
        "desc": ""
      },
      {
        "name": "TestNullByteParam",
        "desc": ""
      },
      {
        "name": "TestNullByteSlice",
        "desc": "Tests fix for issue 2788, that we bind nil to a []byte if the value in the column is sql null"
      },
      {
        "name": "TestNullFloat64Param",
        "desc": ""
      },
      {
        "name": "TestNullInt16Param",
        "desc": ""
      },
      {
        "name": "TestNullInt32Param",
        "desc": ""
      },
      {
        "name": "TestNullInt64Param",
        "desc": ""
      },
      {
        "name": "TestNullString",
        "desc": ""
      },
      {
        "name": "TestNullStringParam",
        "desc": ""
      },
      {
        "name": "TestNullTimeParam",
        "desc": ""
      },
      {
        "name": "TestOpenConnector",
        "desc": ""
      },
      {
        "name": "TestOpenDB",
        "desc": ""
      },
      {
        "name": "TestParentStmtOutlivesTxStmt",
        "desc": ""
      },
      {
        "name": "TestPendingConnsAfterErr",
        "desc": "Issue 10886: tests that all connection attempts return when more than DB.maxOpen connections are in flight and the first DB.maxOpen fail."
      },
      {
        "name": "TestPing",
        "desc": ""
      },
      {
        "name": "TestPointerParamsAndScans",
        "desc": ""
      },
      {
        "name": "TestPoolExhaustOnCancel",
        "desc": ""
      },
      {
        "name": "TestQuery",
        "desc": ""
      },
      {
        "name": "TestQueryContext",
        "desc": "TestQueryContext tests canceling the context while scanning the rows."
      },
      {
        "name": "TestQueryContextWait",
        "desc": "TestQueryContextWait ensures that rows and all internal statements are closed when a query context is closed during execution."
      },
      {
        "name": "TestQueryExecContextOnly",
        "desc": "TestQueryExecContextOnly ensures drivers only need to implement QueryContext and ExecContext methods."
      },
      {
        "name": "TestQueryNamedArg",
        "desc": ""
      },
      {
        "name": "TestQueryRow",
        "desc": ""
      },
      {
        "name": "TestQueryRowClosingStmt",
        "desc": ""
      },
      {
        "name": "TestQueryRowNilScanDest",
        "desc": "golang.org/issue/4859"
      },
      {
        "name": "TestRawBytesAllocs",
        "desc": "Tests that assigning to RawBytes doesn't allocate (and also works)."
      },
      {
        "name": "TestRawBytesReuse",
        "desc": "Issue #65201.  If a RawBytes is reused across multiple queries, subsequent queries shouldn't overwrite driver-owned memory from previous queries."
      },
      {
        "name": "TestRowErr",
        "desc": ""
      },
      {
        "name": "TestRowsCloseError",
        "desc": ""
      },
      {
        "name": "TestRowsCloseOrder",
        "desc": "golang.org/issue/5283: don't release the Rows' connection in Close before calling Stmt.Close."
      },
      {
        "name": "TestRowsColumnTypes",
        "desc": ""
      },
      {
        "name": "TestRowsColumns",
        "desc": ""
      },
      {
        "name": "TestRowsImplicitClose",
        "desc": ""
      },
      {
        "name": "TestRowsScanProperlyWrapsErrors",
        "desc": "Issue 38099: Ensure that Rows.Scan properly wraps underlying errors."
      },
      {
        "name": "TestSimultaneousQueries",
        "desc": "Issue 3857 This used to deadlock."
      },
      {
        "name": "TestSingleOpenConn",
        "desc": ""
      },
      {
        "name": "TestStatementClose",
        "desc": "golang.org/issue/12798"
      },
      {
        "name": "TestStatementErrorAfterClose",
        "desc": ""
      },
      {
        "name": "TestStatementQueryRow",
        "desc": ""
      },
      {
        "name": "TestStatementQueryRowConcurrent",
        "desc": "golang.org/issue/3734"
      },
      {
        "name": "TestStats",
        "desc": ""
      },
      {
        "name": "TestStatsMaxIdleClosedTen",
        "desc": ""
      },
      {
        "name": "TestStatsMaxIdleClosedZero",
        "desc": ""
      },
      {
        "name": "TestStmtCloseDeps",
        "desc": "golang.org/issue/5323"
      },
      {
        "name": "TestStmtCloseOrder",
        "desc": ""
      },
      {
        "name": "TestTxCannotCommitAfterRollback",
        "desc": "Issue 34775: Ensure that a Tx cannot commit after a rollback."
      },
      {
        "name": "TestTxContextWait",
        "desc": "TestTxContextWait tests the transaction behavior when the tx context is canceled during execution of the query."
      },
      {
        "name": "TestTxContextWaitNoDiscard",
        "desc": "TestTxContextWaitNoDiscard is the same as TestTxContextWait, but should not discard the final connection."
      },
      {
        "name": "TestTxEndBadConn",
        "desc": "golang.org/issue/11264"
      },
      {
        "name": "TestTxErrBadConn",
        "desc": "Tests fix for issue 4433, that retries in Begin happen when conn.Begin() returns ErrBadConn"
      },
      {
        "name": "TestTxPrepare",
        "desc": ""
      },
      {
        "name": "TestTxQuery",
        "desc": "Issue: https://golang.org/issue/2784 This test didn't fail before because we got lucky with the fakedb driver. It was failing, and now not, in github.com/bradfitz/go-sql-test"
      },
      {
        "name": "TestTxQueryInvalid",
        "desc": ""
      },
      {
        "name": "TestTxRollbackCommitErr",
        "desc": ""
      },
      {
        "name": "TestTxStmt",
        "desc": ""
      },
      {
        "name": "TestTxStmtClosedRePrepares",
        "desc": ""
      },
      {
        "name": "TestTxStmtDeadlock",
        "desc": "Issue 40985 transaction statement deadlock while context cancel."
      },
      {
        "name": "TestTxStmtFromTxStmtRePrepares",
        "desc": "Test that tx.Stmt called with a statement already associated with tx as argument re-prepares the same statement again."
      },
      {
        "name": "TestTxStmtPreparedOnce",
        "desc": ""
      },
      {
        "name": "TestTypedString",
        "desc": "Issue 18101."
      },
      {
        "name": "TestUnsupportedOptions",
        "desc": "TestUnsupportedOptions checks that the database fails when a driver that doesn't implement ConnBeginTx is used with non-default options and an un-cancellable context."
      },
      {
        "name": "TestUserDefinedBytes",
        "desc": "https://golang.org/issues/13905"
      },
      {
        "name": "TestValueConverters",
        "desc": ""
      },
      {
        "name": "asBytes",
        "desc": ""
      },
      {
        "name": "asString",
        "desc": ""
      },
      {
        "name": "callValuerValue",
        "desc": "callValuerValue returns vr.Value(), with one exception: If vr.Value is an auto-generated method on a pointer type and the pointer is nil, it would panic at runtime in the panicwrap method. Treat it like nil instead. Issue 8415.  This is so people can implement driver.Value on value types and still use nil pointers to those types to mean nil/NULL, just like string/*string.  This function is mirrored in the database/sql/driver package."
      },
      {
        "name": "checkSubsetTypes",
        "desc": ""
      },
      {
        "name": "closeDB",
        "desc": ""
      },
      {
        "name": "colTypeToReflectType",
        "desc": ""
      },
      {
        "name": "convertAssign",
        "desc": "convertAssign is the same as convertAssignRows, but without the optional rows argument.  convertAssign should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - ariga.io/entcache  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "convertAssignRows",
        "desc": "convertAssignRows copies to dest the value in src, converting it if possible. An error is returned if the copy would result in loss of information. dest should be a pointer type. If rows is passed in, the rows will be used as the parent for any cursor values converted from a driver.Rows to a *Rows."
      },
      {
        "name": "converterForType",
        "desc": ""
      },
      {
        "name": "ctxDriverBegin",
        "desc": ""
      },
      {
        "name": "ctxDriverExec",
        "desc": ""
      },
      {
        "name": "ctxDriverPrepare",
        "desc": ""
      },
      {
        "name": "ctxDriverQuery",
        "desc": ""
      },
      {
        "name": "ctxDriverStmtExec",
        "desc": ""
      },
      {
        "name": "ctxDriverStmtQuery",
        "desc": ""
      },
      {
        "name": "defaultCheckNamedValue",
        "desc": "defaultCheckNamedValue wraps the default ColumnConverter to have the same function signature as the CheckNamedValue in the driver.NamedValueChecker interface."
      },
      {
        "name": "describeNamedValue",
        "desc": ""
      },
      {
        "name": "doConcurrentTest",
        "desc": ""
      },
      {
        "name": "driverArgsConnLocked",
        "desc": "driverArgsConnLocked converts arguments from callers of Stmt.Exec and Stmt.Query into driver Values.  The statement ds may be nil, if no statement is available.  ci must be locked."
      },
      {
        "name": "errf",
        "desc": ""
      },
      {
        "name": "exec",
        "desc": ""
      },
      {
        "name": "float32Value",
        "desc": ""
      },
      {
        "name": "float64Value",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "intPtrValue",
        "desc": ""
      },
      {
        "name": "intValue",
        "desc": ""
      },
      {
        "name": "namedValueToValue",
        "desc": ""
      },
      {
        "name": "nullTestRun",
        "desc": ""
      },
      {
        "name": "numPrepares",
        "desc": "numPrepares assumes that db has exactly 1 idle conn and returns its count of calls to Prepare"
      },
      {
        "name": "rowsiFromStatement",
        "desc": ""
      },
      {
        "name": "scanArgsContainRawBytes",
        "desc": ""
      },
      {
        "name": "setHookOpenErr",
        "desc": ""
      },
      {
        "name": "setHookpostCloseConn",
        "desc": ""
      },
      {
        "name": "setRowsCloseHook",
        "desc": ""
      },
      {
        "name": "setStrictFakeConnClose",
        "desc": "setStrictFakeConnClose sets the t to Errorf on when fakeConn.Close fails to close. If nil, the check is disabled."
      },
      {
        "name": "stack",
        "desc": ""
      },
      {
        "name": "strconvErr",
        "desc": ""
      },
      {
        "name": "testContextCancelDuringRawBytesScan",
        "desc": "From go.dev/issue/60304"
      },
      {
        "name": "testContextWait",
        "desc": ""
      },
      {
        "name": "testUseConns",
        "desc": "testUseConns uses count concurrent connections with 1 nanosecond apart. Returns the returnedAt time of the final connection."
      },
      {
        "name": "timeValue",
        "desc": ""
      },
      {
        "name": "uintValue",
        "desc": ""
      },
      {
        "name": "unregisterAllDrivers",
        "desc": ""
      },
      {
        "name": "validateNamedValueName",
        "desc": ""
      },
      {
        "name": "valueFromPlaceholderName",
        "desc": ""
      },
      {
        "name": "waitCondition",
        "desc": ""
      },
      {
        "name": "waitForFree",
        "desc": "waitForFree checks db.numFreeConns until either it equals want or the maxWait time elapses."
      },
      {
        "name": "waitForRowsClose",
        "desc": ""
      },
      {
        "name": "withLock",
        "desc": "withLock runs while holding lk."
      },
      {
        "name": "DatabaseTypeName",
        "desc": "DatabaseTypeName returns the database system name of the column type. If an empty string is returned, then the driver type name is not supported. Consult your driver documentation for a list of driver data types. [ColumnType.Length] specifiers are not included. Common type names include \"VARCHAR\", \"TEXT\", \"NVARCHAR\", \"DECIMAL\", \"BOOL\", \"INT\", and \"BIGINT\"."
      },
      {
        "name": "DecimalSize",
        "desc": "DecimalSize returns the scale and precision of a decimal type. If not applicable or if not supported ok is false."
      },
      {
        "name": "Length",
        "desc": "Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be [math.MaxInt64] (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false."
      },
      {
        "name": "Name",
        "desc": "Name returns the name or alias of the column."
      },
      {
        "name": "Nullable",
        "desc": "Nullable reports whether the column may be null. If a driver does not support this property ok will be false."
      },
      {
        "name": "ScanType",
        "desc": "ScanType returns a Go type suitable for scanning into using [Rows.Scan]. If a driver does not support this property ScanType will return the type of an empty interface."
      },
      {
        "name": "BeginTx",
        "desc": "BeginTx starts a transaction.  The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. [Tx.Commit] will return an error if the context provided to BeginTx is canceled.  The provided [TxOptions] is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned."
      },
      {
        "name": "Close",
        "desc": "Close returns the connection to the connection pool. All operations after a Close will return with [ErrConnDone]. Close is safe to call concurrently with other operations and will block until all other operations finish. It may be useful to first cancel any used context and then call close directly after."
      },
      {
        "name": "ExecContext",
        "desc": "ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query."
      },
      {
        "name": "PingContext",
        "desc": "PingContext verifies the connection to the database is still alive."
      },
      {
        "name": "PrepareContext",
        "desc": "PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed.  The provided context is used for the preparation of the statement, not for the execution of the statement."
      },
      {
        "name": "QueryContext",
        "desc": "QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query."
      },
      {
        "name": "QueryRowContext",
        "desc": "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until the [*Row.Scan] method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, the [*Row.Scan] scans the first selected row and discards the rest."
      },
      {
        "name": "Raw",
        "desc": "Raw executes f exposing the underlying driver connection for the duration of f. The driverConn must not be used outside of f.  Once f returns and err is not [driver.ErrBadConn], the [Conn] will continue to be usable until [Conn.Close] is called."
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "closemuRUnlockCondReleaseConn",
        "desc": "closemuRUnlockCondReleaseConn read unlocks closemu as the sql operation is done with the dc."
      },
      {
        "name": "grabConn",
        "desc": "grabConn takes a context to implement stmtConnGrabber but the context is not used."
      },
      {
        "name": "txCtx",
        "desc": ""
      },
      {
        "name": "Begin",
        "desc": "Begin starts a transaction. The default isolation level is dependent on the driver.  Begin uses [context.Background] internally; to specify the context, use [DB.BeginTx]."
      },
      {
        "name": "BeginTx",
        "desc": "BeginTx starts a transaction.  The provided context is used until the transaction is committed or rolled back. If the context is canceled, the sql package will roll back the transaction. [Tx.Commit] will return an error if the context provided to BeginTx is canceled.  The provided [TxOptions] is optional and may be nil if defaults should be used. If a non-default isolation level is used that the driver doesn't support, an error will be returned."
      },
      {
        "name": "Close",
        "desc": "Close closes the database and prevents new queries from starting. Close then waits for all queries that have started processing on the server to finish.  It is rare to Close a [DB], as the [DB] handle is meant to be long-lived and shared between many goroutines."
      },
      {
        "name": "Conn",
        "desc": "Conn returns a single connection by either opening a new connection or returning an existing connection from the connection pool. Conn will block until either a connection is returned or ctx is canceled. Queries run on the same Conn will be run in the same database session.  Every Conn must be returned to the database pool after use by calling [Conn.Close]."
      },
      {
        "name": "Driver",
        "desc": "Driver returns the database's underlying driver."
      },
      {
        "name": "Exec",
        "desc": "Exec executes a query without returning any rows. The args are for any placeholder parameters in the query.  Exec uses [context.Background] internally; to specify the context, use [DB.ExecContext]."
      },
      {
        "name": "ExecContext",
        "desc": "ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query."
      },
      {
        "name": "Ping",
        "desc": "Ping verifies a connection to the database is still alive, establishing a connection if necessary.  Ping uses [context.Background] internally; to specify the context, use [DB.PingContext]."
      },
      {
        "name": "PingContext",
        "desc": "PingContext verifies a connection to the database is still alive, establishing a connection if necessary."
      },
      {
        "name": "Prepare",
        "desc": "Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed.  Prepare uses [context.Background] internally; to specify the context, use [DB.PrepareContext]."
      },
      {
        "name": "PrepareContext",
        "desc": "PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's [*Stmt.Close] method when the statement is no longer needed.  The provided context is used for the preparation of the statement, not for the execution of the statement."
      },
      {
        "name": "Query",
        "desc": "Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.  Query uses [context.Background] internally; to specify the context, use [DB.QueryContext]."
      },
      {
        "name": "QueryContext",
        "desc": "QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query."
      },
      {
        "name": "QueryRow",
        "desc": "QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, [*Row.Scan] scans the first selected row and discards the rest.  QueryRow uses [context.Background] internally; to specify the context, use [DB.QueryRowContext]."
      },
      {
        "name": "QueryRowContext",
        "desc": "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, [*Row.Scan] scans the first selected row and discards the rest."
      },
      {
        "name": "SetConnMaxIdleTime",
        "desc": "SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.  Expired connections may be closed lazily before reuse.  If d \u003c= 0, connections are not closed due to a connection's idle time."
      },
      {
        "name": "SetConnMaxLifetime",
        "desc": "SetConnMaxLifetime sets the maximum amount of time a connection may be reused.  Expired connections may be closed lazily before reuse.  If d \u003c= 0, connections are not closed due to a connection's age."
      },
      {
        "name": "SetMaxIdleConns",
        "desc": "SetMaxIdleConns sets the maximum number of connections in the idle connection pool.  If MaxOpenConns is greater than 0 but less than the new MaxIdleConns, then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.  If n \u003c= 0, no idle connections are retained.  The default max idle connections is currently 2. This may change in a future release."
      },
      {
        "name": "SetMaxOpenConns",
        "desc": "SetMaxOpenConns sets the maximum number of open connections to the database.  If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than MaxIdleConns, then MaxIdleConns will be reduced to match the new MaxOpenConns limit.  If n \u003c= 0, then there is no limit on the number of open connections. The default is 0 (unlimited)."
      },
      {
        "name": "Stats",
        "desc": "Stats returns database statistics."
      },
      {
        "name": "addDep",
        "desc": "addDep notes that x now depends on dep, and x's finalClose won't be called until all of x's dependencies are removed with removeDep."
      },
      {
        "name": "addDepLocked",
        "desc": ""
      },
      {
        "name": "begin",
        "desc": ""
      },
      {
        "name": "beginDC",
        "desc": "beginDC starts a transaction. The provided dc must be valid and ready to use."
      },
      {
        "name": "clearAllConns",
        "desc": "clearAllConns closes all connections in db."
      },
      {
        "name": "conn",
        "desc": "conn returns a newly-opened or cached *driverConn."
      },
      {
        "name": "connectionCleaner",
        "desc": ""
      },
      {
        "name": "connectionCleanerRunLocked",
        "desc": "connectionCleanerRunLocked removes connections that should be closed from freeConn and returns them along side an updated duration to the next check if a quicker check is required to ensure connections are checked appropriately."
      },
      {
        "name": "connectionOpener",
        "desc": "Runs in a separate goroutine, opens new connections when requested."
      },
      {
        "name": "dumpDep",
        "desc": ""
      },
      {
        "name": "dumpDeps",
        "desc": ""
      },
      {
        "name": "exec",
        "desc": ""
      },
      {
        "name": "execDC",
        "desc": ""
      },
      {
        "name": "maxIdleConnsLocked",
        "desc": ""
      },
      {
        "name": "maybeOpenNewConnections",
        "desc": "Assumes db.mu is locked. If there are connRequests and the connection limit hasn't been reached, then tell the connectionOpener to open new connections."
      },
      {
        "name": "noteUnusedDriverStatement",
        "desc": "noteUnusedDriverStatement notes that ds is no longer used and should be closed whenever possible (when c is next not in use), unless c is already closed."
      },
      {
        "name": "numDeps",
        "desc": ""
      },
      {
        "name": "numDepsPoll",
        "desc": "Dependencies are closed via a goroutine, so this polls waiting for numDeps to fall to want, waiting up to nearly the test's deadline."
      },
      {
        "name": "numFreeConns",
        "desc": ""
      },
      {
        "name": "numOpenConns",
        "desc": ""
      },
      {
        "name": "openNewConnection",
        "desc": "Open one new connection"
      },
      {
        "name": "pingDC",
        "desc": ""
      },
      {
        "name": "prepare",
        "desc": ""
      },
      {
        "name": "prepareDC",
        "desc": "prepareDC prepares a query on the driverConn and calls release before returning. When cg == nil it implies that a connection pool is used, and when cg != nil only a single driver connection is used."
      },
      {
        "name": "putConn",
        "desc": "putConn adds a connection to the db's free pool. err is optionally the last error that occurred on this connection."
      },
      {
        "name": "putConnDBLocked",
        "desc": "Satisfy a connRequest or put the driverConn in the idle pool and return true or return false. putConnDBLocked will satisfy a connRequest if there is one, or it will return the *driverConn to the freeConn list if err == nil and the idle connection limit will not be exceeded. If err != nil, the value of dc is ignored. If err == nil, then dc must not equal nil. If a connRequest was fulfilled or the *driverConn was placed in the freeConn list, then true is returned, otherwise false is returned."
      },
      {
        "name": "query",
        "desc": ""
      },
      {
        "name": "queryDC",
        "desc": "queryDC executes a query on the given connection. The connection gets released by the releaseConn function. The ctx context is from a query method and the txctx context is from an optional transaction context."
      },
      {
        "name": "removeDep",
        "desc": "removeDep notes that x no longer depends on dep. If x still has dependencies, nil is returned. If x no longer has any dependencies, its finalClose method will be called and its error value will be returned."
      },
      {
        "name": "removeDepLocked",
        "desc": ""
      },
      {
        "name": "retry",
        "desc": ""
      },
      {
        "name": "shortestIdleTimeLocked",
        "desc": ""
      },
      {
        "name": "startCleanerLocked",
        "desc": "startCleanerLocked starts connectionCleaner if needed."
      },
      {
        "name": "String",
        "desc": "String returns the name of the transaction isolation level."
      },
      {
        "name": "Scan",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Scan",
        "desc": "Scan implements the [Scanner] interface."
      },
      {
        "name": "Value",
        "desc": "Value implements the [driver.Valuer] interface."
      },
      {
        "name": "Err",
        "desc": "Err provides a way for wrapping packages to check for query errors without calling [Row.Scan]. Err returns the error, if any, that was encountered while running the query. If this error is not nil, this error will also be returned from [Row.Scan]."
      },
      {
        "name": "Scan",
        "desc": "Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on [Rows.Scan] for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns [ErrNoRows]."
      },
      {
        "name": "Close",
        "desc": "Close closes the [Rows], preventing further enumeration. If [Rows.Next] is called and returns false and there are no further result sets, the [Rows] are closed automatically and it will suffice to check the result of [Rows.Err]. Close is idempotent and does not affect the result of [Rows.Err]."
      },
      {
        "name": "ColumnTypes",
        "desc": "ColumnTypes returns column information such as column type, length, and nullable. Some information may not be available from some drivers."
      },
      {
        "name": "Columns",
        "desc": "Columns returns the column names. Columns returns an error if the rows are closed."
      },
      {
        "name": "Err",
        "desc": "Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit [Rows.Close]."
      },
      {
        "name": "Next",
        "desc": "Next prepares the next result row for reading with the [Rows.Scan] method. It returns true on success, or false if there is no next result row or an error happened while preparing it. [Rows.Err] should be consulted to distinguish between the two cases.  Every call to [Rows.Scan], even the first one, must be preceded by a call to [Rows.Next]."
      },
      {
        "name": "NextResultSet",
        "desc": "NextResultSet prepares the next result set for reading. It reports whether there is further result sets, or false if there is no further result set or if there is an error advancing to it. The [Rows.Err] method should be consulted to distinguish between the two cases.  After calling NextResultSet, the [Rows.Next] method should always be called before scanning. If there are further result sets they may not have rows in the result set."
      },
      {
        "name": "Scan",
        "desc": "Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in [Rows].  Scan converts columns read from the database into the following common Go types and special types provided by the sql package:  \t*string \t*[]byte \t*int, *int8, *int16, *int32, *int64 \t*uint, *uint8, *uint16, *uint32, *uint64 \t*bool \t*float32, *float64 \t*interface{} \t*RawBytes \t*Rows (cursor value) \tany type implementing Scanner (see Scanner docs)  In the most simple case, if the type of the value from the source column is an integer, bool or string type T and dest is of type *T, Scan simply assigns the value through the pointer.  Scan also converts between string and numeric types, as long as no information would be lost. While Scan stringifies all numbers scanned from numeric database columns into *string, scans into numeric types are checked for overflow. For example, a float64 with value 300 or a string with value \"300\" can scan into a uint16, but not into a uint8, though float64(255) or \"255\" can scan into a uint8. One exception is that scans of some float64 numbers to strings may lose information when stringifying. In general, scan floating point columns into *float64.  If a dest argument has type *[]byte, Scan saves in that argument a copy of the corresponding data. The copy is owned by the caller and can be modified and held indefinitely. The copy can be avoided by using an argument of type [*RawBytes] instead; see the documentation for [RawBytes] for restrictions on its use.  If an argument has type *interface{}, Scan copies the value provided by the underlying driver without conversion. When scanning from a source value of type []byte to *interface{}, a copy of the slice is made and the caller owns the result.  Source values of type [time.Time] may be scanned into values of type *time.Time, *interface{}, *string, or *[]byte. When converting to the latter two, [time.RFC3339Nano] is used.  Source values of type bool may be scanned into types *bool, *interface{}, *string, *[]byte, or [*RawBytes].  For scanning into *bool, the source may be true, false, 1, 0, or string inputs parseable by [strconv.ParseBool].  Scan can also convert a cursor returned from a query, such as \"select cursor(select * from my_table) from dual\", into a [*Rows] value that can itself be scanned from. The parent select query will close any cursor [*Rows] if the parent [*Rows] is closed.  If any of the first arguments implementing [Scanner] returns an error, that error will be wrapped in the returned error."
      },
      {
        "name": "awaitDone",
        "desc": "awaitDone blocks until ctx, txctx, or closectx is canceled. The ctx is provided from the query context. If the query was issued in a transaction, the transaction's context is also provided in txctx, to ensure Rows is closed if the Tx is closed. The closectx is closed by an explicit call to rs.Close."
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "closemuRUnlockIfHeldByScan",
        "desc": "closemuRUnlockIfHeldByScan releases any closemu.RLock held open by a previous call to Scan with *RawBytes."
      },
      {
        "name": "initContextClose",
        "desc": ""
      },
      {
        "name": "lasterrOrErrLocked",
        "desc": "lasterrOrErrLocked returns either lasterr or the provided err. rs.closemu must be read-locked."
      },
      {
        "name": "nextLocked",
        "desc": ""
      },
      {
        "name": "rawbuf",
        "desc": "rawbuf returns the buffer to append RawBytes values to. This buffer is reused across calls to Rows.Scan.  Usage:  \trawBytes = rows.setrawbuf(append(rows.rawbuf(), value...))"
      },
      {
        "name": "scanLocked",
        "desc": ""
      },
      {
        "name": "setrawbuf",
        "desc": "setrawbuf updates the RawBytes buffer with the result of appending a new value to it. It returns the new value."
      },
      {
        "name": "Close",
        "desc": "Close closes the statement."
      },
      {
        "name": "Exec",
        "desc": "Exec executes a prepared statement with the given arguments and returns a [Result] summarizing the effect of the statement.  Exec uses [context.Background] internally; to specify the context, use [Stmt.ExecContext]."
      },
      {
        "name": "ExecContext",
        "desc": "ExecContext executes a prepared statement with the given arguments and returns a [Result] summarizing the effect of the statement."
      },
      {
        "name": "Query",
        "desc": "Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.  Query uses [context.Background] internally; to specify the context, use [Stmt.QueryContext]."
      },
      {
        "name": "QueryContext",
        "desc": "QueryContext executes a prepared query statement with the given arguments and returns the query results as a [*Rows]."
      },
      {
        "name": "QueryRow",
        "desc": "QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned [*Row], which is always non-nil. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, the [*Row.Scan] scans the first selected row and discards the rest.  Example usage:  \tvar name string \terr := nameByUseridStmt.QueryRow(id).Scan(\u0026name)  QueryRow uses [context.Background] internally; to specify the context, use [Stmt.QueryRowContext]."
      },
      {
        "name": "QueryRowContext",
        "desc": "QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned [*Row], which is always non-nil. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, the [*Row.Scan] scans the first selected row and discards the rest."
      },
      {
        "name": "connStmt",
        "desc": "connStmt returns a free driver connection on which to execute the statement, a function to call to release the connection, and a statement bound to that connection."
      },
      {
        "name": "finalClose",
        "desc": ""
      },
      {
        "name": "prepareOnConnLocked",
        "desc": "prepareOnConnLocked prepares the query in Stmt s on dc and adds it to the list of open connStmt on the statement. It assumes the caller is holding the lock on dc."
      },
      {
        "name": "removeClosedStmtLocked",
        "desc": "removeClosedStmtLocked removes closed conns in s.css.  To avoid lock contention on DB.mu, we do it only when s.db.numClosed - s.lastNum is large enough."
      },
      {
        "name": "Commit",
        "desc": "Commit commits the transaction."
      },
      {
        "name": "Exec",
        "desc": "Exec executes a query that doesn't return rows. For example: an INSERT and UPDATE.  Exec uses [context.Background] internally; to specify the context, use [Tx.ExecContext]."
      },
      {
        "name": "ExecContext",
        "desc": "ExecContext executes a query that doesn't return rows. For example: an INSERT and UPDATE."
      },
      {
        "name": "Prepare",
        "desc": "Prepare creates a prepared statement for use within a transaction.  The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.  To use an existing prepared statement on this transaction, see [Tx.Stmt].  Prepare uses [context.Background] internally; to specify the context, use [Tx.PrepareContext]."
      },
      {
        "name": "PrepareContext",
        "desc": "PrepareContext creates a prepared statement for use within a transaction.  The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.  To use an existing prepared statement on this transaction, see [Tx.Stmt].  The provided context will be used for the preparation of the context, not for the execution of the returned statement. The returned statement will run in the transaction context."
      },
      {
        "name": "Query",
        "desc": "Query executes a query that returns rows, typically a SELECT.  Query uses [context.Background] internally; to specify the context, use [Tx.QueryContext]."
      },
      {
        "name": "QueryContext",
        "desc": "QueryContext executes a query that returns rows, typically a SELECT."
      },
      {
        "name": "QueryRow",
        "desc": "QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, the [*Row.Scan] scans the first selected row and discards the rest.  QueryRow uses [context.Background] internally; to specify the context, use [Tx.QueryRowContext]."
      },
      {
        "name": "QueryRowContext",
        "desc": "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until [Row]'s Scan method is called. If the query selects no rows, the [*Row.Scan] will return [ErrNoRows]. Otherwise, the [*Row.Scan] scans the first selected row and discards the rest."
      },
      {
        "name": "Rollback",
        "desc": "Rollback aborts the transaction."
      },
      {
        "name": "Stmt",
        "desc": "Stmt returns a transaction-specific prepared statement from an existing statement.  Example:  \tupdateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\") \t... \ttx, err := db.Begin() \t... \tres, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)  The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back.  Stmt uses [context.Background] internally; to specify the context, use [Tx.StmtContext]."
      },
      {
        "name": "StmtContext",
        "desc": "StmtContext returns a transaction-specific prepared statement from an existing statement.  Example:  \tupdateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\") \t... \ttx, err := db.Begin() \t... \tres, err := tx.StmtContext(ctx, updateMoney).Exec(123.45, 98293203)  The provided context is used for the preparation of the statement, not for the execution of the statement.  The returned statement operates within the transaction and will be closed when the transaction has been committed or rolled back."
      },
      {
        "name": "awaitDone",
        "desc": "awaitDone blocks until the context in Tx is canceled and rolls back the transaction if it's not already done."
      },
      {
        "name": "close",
        "desc": "close returns the connection to the pool and must only be called by Tx.rollback or Tx.Commit while tx is already canceled and won't be executed concurrently."
      },
      {
        "name": "closePrepared",
        "desc": "Closes all Stmts prepared for this transaction."
      },
      {
        "name": "closemuRUnlockRelease",
        "desc": "closemuRUnlockRelease is used as a func(error) method value in [DB.ExecContext] and [DB.QueryContext]. Unlocking in the releaseConn keeps the driver conn from being returned to the connection pool until the Rows has been closed."
      },
      {
        "name": "grabConn",
        "desc": ""
      },
      {
        "name": "isDone",
        "desc": ""
      },
      {
        "name": "rollback",
        "desc": "rollback aborts the transaction and optionally forces the pool to discard the connection."
      },
      {
        "name": "txCtx",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "Scan",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "Begin",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": ""
      },
      {
        "name": "Prepare",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "CheckNamedValue",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "finish",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": "Add adds v to the set of waiting requests. The returned connRequestDelHandle can be used to remove the item from the set."
      },
      {
        "name": "CloseAndRemoveAll",
        "desc": "CloseAndRemoveAll closes all channels in the set and clears the set."
      },
      {
        "name": "Delete",
        "desc": "Delete removes an element from the set.  It reports whether the element was deleted. (It can return false if a caller of TakeRandom took it meanwhile, or upon the second call to Delete)"
      },
      {
        "name": "Len",
        "desc": "Len returns the length of the set."
      },
      {
        "name": "TakeRandom",
        "desc": "TakeRandom returns and removes a random element from s and reports whether there was one to take. (It returns ok=false if the set is empty.)"
      },
      {
        "name": "deleteIndex",
        "desc": ""
      },
      {
        "name": "Begin",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ExecContext",
        "desc": ""
      },
      {
        "name": "Prepare",
        "desc": "Prepare is still part of the Conn interface, so while it isn't used must be defined for compatibility."
      },
      {
        "name": "PrepareContext",
        "desc": ""
      },
      {
        "name": "QueryContext",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "getDB",
        "desc": ""
      },
      {
        "name": "Compose",
        "desc": ""
      },
      {
        "name": "Decompose",
        "desc": ""
      },
      {
        "name": "Compose",
        "desc": ""
      },
      {
        "name": "Decompose",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "closeDBLocked",
        "desc": "the dc.db's Mutex is held."
      },
      {
        "name": "expired",
        "desc": ""
      },
      {
        "name": "finalClose",
        "desc": ""
      },
      {
        "name": "prepareLocked",
        "desc": "prepareLocked prepares the query on dc. When cg == nil the dc must keep track of the prepared statements in a pool."
      },
      {
        "name": "releaseConn",
        "desc": ""
      },
      {
        "name": "removeOpenStmt",
        "desc": ""
      },
      {
        "name": "resetSession",
        "desc": "resetSession checks if the driver connection needs the session to be reset and if required, resets it."
      },
      {
        "name": "validateConnection",
        "desc": "validateConnection checks if the connection is valid and can still be used. It also marks the session for reset if required."
      },
      {
        "name": "LastInsertId",
        "desc": ""
      },
      {
        "name": "RowsAffected",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close ensures driver.Stmt is only closed once and always returns the same result."
      },
      {
        "name": "Connect",
        "desc": ""
      },
      {
        "name": "Driver",
        "desc": ""
      },
      {
        "name": "Begin",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": ""
      },
      {
        "name": "ExecContext",
        "desc": ""
      },
      {
        "name": "IsValid",
        "desc": ""
      },
      {
        "name": "Prepare",
        "desc": ""
      },
      {
        "name": "PrepareContext",
        "desc": ""
      },
      {
        "name": "Query",
        "desc": ""
      },
      {
        "name": "QueryContext",
        "desc": ""
      },
      {
        "name": "ResetSession",
        "desc": ""
      },
      {
        "name": "incrStat",
        "desc": ""
      },
      {
        "name": "isBad",
        "desc": ""
      },
      {
        "name": "isDirtyAndMark",
        "desc": ""
      },
      {
        "name": "prepareCreate",
        "desc": "parts are table|col=type,col2=type2"
      },
      {
        "name": "prepareInsert",
        "desc": "parts are table|col=?,col2=val"
      },
      {
        "name": "prepareSelect",
        "desc": "parts are table|selectCol1,selectCol2|whereCol=?,whereCol2=? (note that where columns must always contain ? marks, just a limitation for fakedb)"
      },
      {
        "name": "touchMem",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Connect",
        "desc": ""
      },
      {
        "name": "Driver",
        "desc": ""
      },
      {
        "name": "columnType",
        "desc": ""
      },
      {
        "name": "createTable",
        "desc": ""
      },
      {
        "name": "table",
        "desc": "must be called with db.mu lock held"
      },
      {
        "name": "wipe",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": "Supports dsn forms:  \t\u003cdbname\u003e \t\u003cdbname\u003e;\u003copts\u003e  (only currently supported option is `badConn`, \t                  which causes driver.ErrBadConn to be returned on \t                  every other conn.Begin())"
      },
      {
        "name": "getDB",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": "Supports dsn forms:  \t\u003cdbname\u003e \t\u003cdbname\u003e;\u003copts\u003e  (only currently supported option is `badConn`, \t                  which causes driver.ErrBadConn to be returned on \t                  every other conn.Begin())"
      },
      {
        "name": "OpenConnector",
        "desc": ""
      },
      {
        "name": "getDB",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ColumnConverter",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": ""
      },
      {
        "name": "ExecContext",
        "desc": ""
      },
      {
        "name": "NumInput",
        "desc": ""
      },
      {
        "name": "Query",
        "desc": ""
      },
      {
        "name": "QueryContext",
        "desc": ""
      },
      {
        "name": "execInsert",
        "desc": "When doInsert is true, add the row to the table. When doInsert is false do prep-work and error checking, but don't actually add the row to the table."
      },
      {
        "name": "Commit",
        "desc": ""
      },
      {
        "name": "Rollback",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "Begin",
        "desc": ""
      },
      {
        "name": "CheckNamedValue",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": ""
      },
      {
        "name": "ExecContext",
        "desc": ""
      },
      {
        "name": "IsValid",
        "desc": ""
      },
      {
        "name": "Prepare",
        "desc": ""
      },
      {
        "name": "PrepareContext",
        "desc": ""
      },
      {
        "name": "Query",
        "desc": ""
      },
      {
        "name": "QueryContext",
        "desc": ""
      },
      {
        "name": "ResetSession",
        "desc": ""
      },
      {
        "name": "incrStat",
        "desc": ""
      },
      {
        "name": "isBad",
        "desc": ""
      },
      {
        "name": "isDirtyAndMark",
        "desc": ""
      },
      {
        "name": "prepareCreate",
        "desc": "parts are table|col=type,col2=type2"
      },
      {
        "name": "prepareInsert",
        "desc": "parts are table|col=?,col2=val"
      },
      {
        "name": "prepareSelect",
        "desc": "parts are table|selectCol1,selectCol2|whereCol=?,whereCol2=? (note that where columns must always contain ? marks, just a limitation for fakedb)"
      },
      {
        "name": "touchMem",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "getDB",
        "desc": ""
      },
      {
        "name": "Begin",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": ""
      },
      {
        "name": "Ping",
        "desc": ""
      },
      {
        "name": "Prepare",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ColumnTypeScanType",
        "desc": ""
      },
      {
        "name": "Columns",
        "desc": ""
      },
      {
        "name": "HasNextResultSet",
        "desc": ""
      },
      {
        "name": "Next",
        "desc": ""
      },
      {
        "name": "NextResultSet",
        "desc": ""
      },
      {
        "name": "invalidateDriverOwnedMemory",
        "desc": ""
      },
      {
        "name": "touchMem",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": ""
      },
      {
        "name": "NumInput",
        "desc": ""
      },
      {
        "name": "Query",
        "desc": ""
      },
      {
        "name": "columnIndex",
        "desc": ""
      },
      {
        "name": "Scan",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ColumnType",
        "desc": "ColumnType contains the name and type of a column."
      },
      {
        "name": "Conn",
        "desc": "Conn represents a single database connection rather than a pool of database connections. Prefer running queries from [DB] unless there is a specific need for a continuous single database connection.  A Conn must call [Conn.Close] to return the connection to the database pool and may do so concurrently with a running query.  After a call to [Conn.Close], all operations on the connection fail with [ErrConnDone]."
      },
      {
        "name": "DB",
        "desc": "DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines.  The sql package creates and frees connections automatically; it also maintains a free pool of idle connections. If the database has a concept of per-connection state, such state can be reliably observed within a transaction ([Tx]) or connection ([Conn]). Once [DB.Begin] is called, the returned [Tx] is bound to a single connection. Once [Tx.Commit] or [Tx.Rollback] is called on the transaction, that transaction's connection is returned to [DB]'s idle connection pool. The pool size can be controlled with [DB.SetMaxIdleConns]."
      },
      {
        "name": "DBStats",
        "desc": "DBStats contains database statistics."
      },
      {
        "name": "Dummy",
        "desc": ""
      },
      {
        "name": "IsolationLevel",
        "desc": "IsolationLevel is the transaction isolation level used in [TxOptions]."
      },
      {
        "name": "NamedArg",
        "desc": "A NamedArg is a named argument. NamedArg values may be used as arguments to [DB.Query] or [DB.Exec] and bind to the corresponding named parameter in the SQL statement.  For a more concise way to create NamedArg values, see the [Named] function."
      },
      {
        "name": "Null",
        "desc": "Null represents a value that may be null. Null implements the [Scanner] interface so it can be used as a scan destination:  \tvar s Null[string] \terr := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(\u0026s) \t... \tif s.Valid { \t   // use s.V \t} else { \t   // NULL value \t}  T should be one of the types accepted by [driver.Value]."
      },
      {
        "name": "NullBool",
        "desc": "NullBool represents a bool that may be null. NullBool implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "NullByte",
        "desc": "NullByte represents a byte that may be null. NullByte implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "NullFloat64",
        "desc": "NullFloat64 represents a float64 that may be null. NullFloat64 implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "NullInt16",
        "desc": "NullInt16 represents an int16 that may be null. NullInt16 implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "NullInt32",
        "desc": "NullInt32 represents an int32 that may be null. NullInt32 implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "NullInt64",
        "desc": "NullInt64 represents an int64 that may be null. NullInt64 implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "NullString",
        "desc": "NullString represents a string that may be null. NullString implements the [Scanner] interface so it can be used as a scan destination:  \tvar s NullString \terr := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(\u0026s) \t... \tif s.Valid { \t   // use s.String \t} else { \t   // NULL value \t}"
      },
      {
        "name": "NullTime",
        "desc": "NullTime represents a [time.Time] that may be null. NullTime implements the [Scanner] interface so it can be used as a scan destination, similar to [NullString]."
      },
      {
        "name": "Out",
        "desc": "Out may be used to retrieve OUTPUT value parameters from stored procedures.  Not all drivers and databases support OUTPUT value parameters.  Example usage:  \tvar outArg string \t_, err := db.ExecContext(ctx, \"ProcName\", sql.Named(\"Arg1\", sql.Out{Dest: \u0026outArg}))"
      },
      {
        "name": "RawBytes",
        "desc": "RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a [Rows.Scan] into a RawBytes, the slice is only valid until the next call to [Rows.Next], [Rows.Scan], or [Rows.Close]."
      },
      {
        "name": "Result",
        "desc": "A Result summarizes an executed SQL command."
      },
      {
        "name": "Row",
        "desc": "Row is the result of calling [DB.QueryRow] to select a single row."
      },
      {
        "name": "Rows",
        "desc": "Rows is the result of a query. Its cursor starts before the first row of the result set. Use [Rows.Next] to advance from row to row."
      },
      {
        "name": "Scanner",
        "desc": "Scanner is an interface used by [Rows.Scan]."
      },
      {
        "name": "Stmt",
        "desc": "Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.  If a Stmt is prepared on a [Tx] or [Conn], it will be bound to a single underlying connection forever. If the [Tx] or [Conn] closes, the Stmt will become unusable and all operations will return an error. If a Stmt is prepared on a [DB], it will remain usable for the lifetime of the [DB]. When the Stmt needs to execute on a new underlying connection, it will prepare itself on the new connection automatically."
      },
      {
        "name": "Tx",
        "desc": "Tx is an in-progress database transaction.  A transaction must end with a call to [Tx.Commit] or [Tx.Rollback].  After a call to [Tx.Commit] or [Tx.Rollback], all operations on the transaction fail with [ErrTxDone].  The statements prepared for a transaction by calling the transaction's [Tx.Prepare] or [Tx.Stmt] methods are closed by the call to [Tx.Commit] or [Tx.Rollback]."
      },
      {
        "name": "TxOptions",
        "desc": "TxOptions holds the transaction options to be used in [DB.BeginTx]."
      },
      {
        "name": "Valuer_P",
        "desc": ""
      },
      {
        "name": "Valuer_V",
        "desc": ""
      },
      {
        "name": "alwaysErrScanner",
        "desc": ""
      },
      {
        "name": "alwaysErrValuer",
        "desc": ""
      },
      {
        "name": "anyTypeConverter",
        "desc": ""
      },
      {
        "name": "badConn",
        "desc": "badConn implements a bad driver.Conn, for TestBadDriver. The Exec method panics."
      },
      {
        "name": "badDriver",
        "desc": "badDriver is a driver.Driver that uses badConn."
      },
      {
        "name": "boundCol",
        "desc": ""
      },
      {
        "name": "ccChecker",
        "desc": "ccChecker wraps the driver.ColumnConverter and allows it to be used as if it were a NamedValueChecker. If the driver ColumnConverter is not present then the NamedValueChecker will return driver.ErrSkip."
      },
      {
        "name": "concurrentDBExecTest",
        "desc": ""
      },
      {
        "name": "concurrentDBQueryTest",
        "desc": ""
      },
      {
        "name": "concurrentRandomTest",
        "desc": ""
      },
      {
        "name": "concurrentStmtExecTest",
        "desc": ""
      },
      {
        "name": "concurrentStmtQueryTest",
        "desc": ""
      },
      {
        "name": "concurrentTest",
        "desc": ""
      },
      {
        "name": "concurrentTxExecTest",
        "desc": ""
      },
      {
        "name": "concurrentTxQueryTest",
        "desc": ""
      },
      {
        "name": "concurrentTxStmtExecTest",
        "desc": ""
      },
      {
        "name": "concurrentTxStmtQueryTest",
        "desc": ""
      },
      {
        "name": "connRequest",
        "desc": "connRequest represents one request for a new connection When there are no idle connections available, DB.conn will create a new connRequest and put it on the db.connRequests list."
      },
      {
        "name": "connRequestAndIndex",
        "desc": ""
      },
      {
        "name": "connRequestDelHandle",
        "desc": "connRequestDelHandle is an opaque handle to delete an item from calling Add."
      },
      {
        "name": "connRequestSet",
        "desc": "connRequestSet is a set of chan connRequest that's optimized for:    - adding an element   - removing an element (only by the caller who added it)   - taking (get + delete) a random element  We previously used a map for this but the take of a random element was expensive, making mapiters. This type avoids a map entirely and just uses a slice."
      },
      {
        "name": "connReuseStrategy",
        "desc": "connReuseStrategy determines how (*DB).conn returns database connections."
      },
      {
        "name": "connStmt",
        "desc": "connStmt is a prepared statement on a particular connection."
      },
      {
        "name": "conversionTest",
        "desc": ""
      },
      {
        "name": "ctxOnlyConn",
        "desc": ""
      },
      {
        "name": "ctxOnlyDriver",
        "desc": ""
      },
      {
        "name": "dec",
        "desc": ""
      },
      {
        "name": "decFinite",
        "desc": ""
      },
      {
        "name": "decimal",
        "desc": "decimal composes or decomposes a decimal value to and from individual parts. There are four parts: a boolean negative flag, a form byte with three possible states (finite=0, infinite=1, NaN=2), a base-2 big-endian integer coefficient (also known as a significand) as a []byte, and an int32 exponent. These are composed into a final value as \"decimal = (neg) (form=finite) coefficient * 10 ^ exponent\". A zero length coefficient is a zero value. The big-endian integer coefficient stores the most significant byte first (at coefficient[0]). If the form is not finite the coefficient and exponent should be ignored. The negative parameter may be set to true for any form, although implementations are not required to respect the negative parameter in the non-finite form.  Implementations may choose to set the negative parameter to true on a zero or NaN value, but implementations that do not differentiate between negative and positive zero or NaN values should ignore the negative parameter without error. If an implementation does not support Infinity it may be converted into a NaN without error. If a value is set that is larger than what is supported by an implementation, an error must be returned. Implementations must return an error if a NaN or Infinity is attempted to be set while neither are supported.  NOTE(kardianos): This is an experimental interface. See https://golang.org/issue/30870"
      },
      {
        "name": "decimalCompose",
        "desc": ""
      },
      {
        "name": "decimalDecompose",
        "desc": ""
      },
      {
        "name": "decimalInt",
        "desc": ""
      },
      {
        "name": "depSet",
        "desc": "depSet is a finalCloser's outstanding dependencies"
      },
      {
        "name": "doNotInclude",
        "desc": ""
      },
      {
        "name": "driverConn",
        "desc": "driverConn wraps a driver.Conn with a mutex, to be held during all calls into the Conn. (including any calls onto interfaces returned via that Conn, such as calls on Tx, Stmt, Result, Rows)"
      },
      {
        "name": "driverResult",
        "desc": ""
      },
      {
        "name": "driverStmt",
        "desc": "driverStmt associates a driver.Stmt with the *driverConn from which it came, so the driverConn's lock can be held during calls."
      },
      {
        "name": "dsnConnector",
        "desc": ""
      },
      {
        "name": "fakeConn",
        "desc": ""
      },
      {
        "name": "fakeConnector",
        "desc": ""
      },
      {
        "name": "fakeDB",
        "desc": ""
      },
      {
        "name": "fakeDriver",
        "desc": "fakeDriver is a fake database that implements Go's driver.Driver interface, just for testing.  It speaks a query language that's semantically similar to but syntactically different and simpler than SQL.  The syntax is as follows:  \tWIPE \tCREATE|\u003ctablename\u003e|\u003ccol\u003e=\u003ctype\u003e,\u003ccol\u003e=\u003ctype\u003e,... \t  where types are: \"string\", [u]int{8,16,32,64}, \"bool\" \tINSERT|\u003ctablename\u003e|col=val,col2=val2,col3=? \tSELECT|\u003ctablename\u003e|projectcol1,projectcol2|filtercol=?,filtercol2=? \tSELECT|\u003ctablename\u003e|projectcol1,projectcol2|filtercol=?param1,filtercol2=?param2  Any of these can be preceded by PANIC|\u003cmethod\u003e|, to cause the named method on fakeStmt to panic.  Any of these can be proceeded by WAIT|\u003cduration\u003e|, to cause the named method on fakeStmt to sleep for the specified duration.  Multiple of these can be combined when separated with a semicolon.  When opening a fakeDriver's database, it starts empty with no tables. All tables and data are stored in memory only."
      },
      {
        "name": "fakeDriverCtx",
        "desc": ""
      },
      {
        "name": "fakeDriverString",
        "desc": "fakeDriverString is like driver.String, but indirects pointers like DefaultValueConverter.  This could be surprising behavior to retroactively apply to driver.String now that Go1 is out, but this is convenient for our TestPointerParamsAndScans."
      },
      {
        "name": "fakeError",
        "desc": ""
      },
      {
        "name": "fakeStmt",
        "desc": ""
      },
      {
        "name": "fakeTx",
        "desc": ""
      },
      {
        "name": "finalCloser",
        "desc": "The finalCloser interface is used by (*DB).addDep and related dependency reference counting."
      },
      {
        "name": "issue69728Type",
        "desc": ""
      },
      {
        "name": "memToucher",
        "desc": ""
      },
      {
        "name": "nullTestRow",
        "desc": ""
      },
      {
        "name": "nullTestSpec",
        "desc": ""
      },
      {
        "name": "nvcConn",
        "desc": ""
      },
      {
        "name": "nvcDriver",
        "desc": ""
      },
      {
        "name": "pingConn",
        "desc": ""
      },
      {
        "name": "pingDriver",
        "desc": ""
      },
      {
        "name": "releaseConn",
        "desc": ""
      },
      {
        "name": "row",
        "desc": ""
      },
      {
        "name": "rowsCursor",
        "desc": ""
      },
      {
        "name": "stmtConnGrabber",
        "desc": "stmtConnGrabber represents a Tx or Conn that will return the underlying driverConn and release function."
      },
      {
        "name": "stubDriverStmt",
        "desc": ""
      },
      {
        "name": "table",
        "desc": ""
      },
      {
        "name": "testScanner",
        "desc": ""
      },
      {
        "name": "userDefined",
        "desc": ""
      },
      {
        "name": "userDefinedSlice",
        "desc": ""
      },
      {
        "name": "userDefinedString",
        "desc": ""
      },
      {
        "name": "valueConverterTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "database/sql/driver",
    "desc": "Package driver defines interfaces to be implemented by database drivers as used by package sql.  Most code should use the [database/sql] package.  The driver interface has evolved over time. Drivers should implement [Connector] and [DriverContext] interfaces. The Connector.Connect and Driver.Open methods should never return [ErrBadConn]. [ErrBadConn] should only be returned from [Validator], [SessionResetter], or a query method if the connection is already in an invalid (e.g. closed) state.  All [Conn] implementations should implement the following interfaces: [Pinger], [SessionResetter], and [Validator].  If named parameters or context are supported, the driver's [Conn] should implement: [ExecerContext], [QueryerContext], [ConnPrepareContext], and [ConnBeginTx].  To support custom data types, implement [NamedValueChecker]. [NamedValueChecker] also allows queries to accept per-query options as a parameter by returning [ErrRemoveArgument] from CheckNamedValue.  If multiple result sets are supported, [Rows] should implement [RowsNextResultSet]. If the driver knows how to describe the types present in the returned result it should implement the following interfaces: [RowsColumnTypeScanType], [RowsColumnTypeDatabaseTypeName], [RowsColumnTypeLength], [RowsColumnTypeNullable], and [RowsColumnTypePrecisionScale]. A given row value may also return a [Rows] type, which may represent a database cursor value.  If a [Conn] implements [Validator], then the IsValid method is called before returning the connection to the connection pool. If an entry in the connection pool implements [SessionResetter], then ResetSession is called before reusing the connection for another query. If a connection is never returned to the connection pool but is immediately reused, then ResetSession is called prior to reuse but IsValid is not called.",
    "functions": [
      {
        "name": "IsScanValue",
        "desc": "IsScanValue is equivalent to [IsValue]. It exists for compatibility."
      },
      {
        "name": "IsValue",
        "desc": "IsValue reports whether v is a valid [Value] parameter type."
      },
      {
        "name": "TestValueConverters",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "LastInsertId",
        "desc": ""
      },
      {
        "name": "RowsAffected",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Decompose",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      },
      {
        "name": "LastInsertId",
        "desc": ""
      },
      {
        "name": "RowsAffected",
        "desc": ""
      },
      {
        "name": "ConvertValue",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ColumnConverter",
        "desc": "ColumnConverter may be optionally implemented by [Stmt] if the statement is aware of its own columns' types and can convert from any type to a driver [Value].  Deprecated: Drivers should implement [NamedValueChecker]."
      },
      {
        "name": "Conn",
        "desc": "Conn is a connection to a database. It is not used concurrently by multiple goroutines.  Conn is assumed to be stateful."
      },
      {
        "name": "ConnBeginTx",
        "desc": "ConnBeginTx enhances the [Conn] interface with context and [TxOptions]."
      },
      {
        "name": "ConnPrepareContext",
        "desc": "ConnPrepareContext enhances the [Conn] interface with context."
      },
      {
        "name": "Connector",
        "desc": "A Connector represents a driver in a fixed configuration and can create any number of equivalent Conns for use by multiple goroutines.  A Connector can be passed to [database/sql.OpenDB], to allow drivers to implement their own [database/sql.DB] constructors, or returned by [DriverContext]'s OpenConnector method, to allow drivers access to context and to avoid repeated parsing of driver configuration.  If a Connector implements [io.Closer], the [database/sql.DB.Close] method will call the Close method and return error (if any)."
      },
      {
        "name": "Driver",
        "desc": "Driver is the interface that must be implemented by a database driver.  Database drivers may implement [DriverContext] for access to contexts and to parse the name only once for a pool of connections, instead of once per connection."
      },
      {
        "name": "DriverContext",
        "desc": "If a [Driver] implements DriverContext, then [database/sql.DB] will call OpenConnector to obtain a [Connector] and then invoke that [Connector]'s Connect method to obtain each needed connection, instead of invoking the [Driver]'s Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-[Conn] contexts."
      },
      {
        "name": "Execer",
        "desc": "Execer is an optional interface that may be implemented by a [Conn].  If a [Conn] implements neither [ExecerContext] nor [Execer], the [database/sql.DB.Exec] will first prepare a query, execute the statement, and then close the statement.  Exec may return [ErrSkip].  Deprecated: Drivers should implement [ExecerContext] instead."
      },
      {
        "name": "ExecerContext",
        "desc": "ExecerContext is an optional interface that may be implemented by a [Conn].  If a [Conn] does not implement [ExecerContext], the [database/sql.DB.Exec] will fall back to [Execer]; if the Conn does not implement Execer either, [database/sql.DB.Exec] will first prepare a query, execute the statement, and then close the statement.  ExecContext may return [ErrSkip].  ExecContext must honor the context timeout and return when the context is canceled."
      },
      {
        "name": "IsolationLevel",
        "desc": "IsolationLevel is the transaction isolation level stored in [TxOptions].  This type should be considered identical to [database/sql.IsolationLevel] along with any values defined on it."
      },
      {
        "name": "NamedValue",
        "desc": "NamedValue holds both the value name and value."
      },
      {
        "name": "NamedValueChecker",
        "desc": "NamedValueChecker may be optionally implemented by [Conn] or [Stmt]. It provides the driver more control to handle Go and database types beyond the default [Value] types allowed.  The [database/sql] package checks for value checkers in the following order, stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker, Stmt.ColumnConverter, [DefaultParameterConverter].  If CheckNamedValue returns [ErrRemoveArgument], the [NamedValue] will not be included in the final query arguments. This may be used to pass special options to the query itself.  If [ErrSkip] is returned the column converter error checking path is used for the argument. Drivers may wish to return [ErrSkip] after they have exhausted their own special cases."
      },
      {
        "name": "NotNull",
        "desc": "NotNull is a type that implements [ValueConverter] by disallowing nil values but otherwise delegating to another [ValueConverter]."
      },
      {
        "name": "Null",
        "desc": "Null is a type that implements [ValueConverter] by allowing nil values but otherwise delegating to another [ValueConverter]."
      },
      {
        "name": "Pinger",
        "desc": "Pinger is an optional interface that may be implemented by a [Conn].  If a [Conn] does not implement Pinger, the [database/sql.DB.Ping] and [database/sql.DB.PingContext] will check if there is at least one [Conn] available.  If Conn.Ping returns [ErrBadConn], [database/sql.DB.Ping] and [database/sql.DB.PingContext] will remove the [Conn] from pool."
      },
      {
        "name": "Queryer",
        "desc": "Queryer is an optional interface that may be implemented by a [Conn].  If a [Conn] implements neither [QueryerContext] nor [Queryer], the [database/sql.DB.Query] will first prepare a query, execute the statement, and then close the statement.  Query may return [ErrSkip].  Deprecated: Drivers should implement [QueryerContext] instead."
      },
      {
        "name": "QueryerContext",
        "desc": "QueryerContext is an optional interface that may be implemented by a [Conn].  If a [Conn] does not implement QueryerContext, the [database/sql.DB.Query] will fall back to [Queryer]; if the [Conn] does not implement [Queryer] either, [database/sql.DB.Query] will first prepare a query, execute the statement, and then close the statement.  QueryContext may return [ErrSkip].  QueryContext must honor the context timeout and return when the context is canceled."
      },
      {
        "name": "Result",
        "desc": "Result is the result of a query execution."
      },
      {
        "name": "Rows",
        "desc": "Rows is an iterator over an executed query's results."
      },
      {
        "name": "RowsAffected",
        "desc": "RowsAffected implements [Result] for an INSERT or UPDATE operation which mutates a number of rows."
      },
      {
        "name": "RowsColumnTypeDatabaseTypeName",
        "desc": "RowsColumnTypeDatabaseTypeName may be implemented by [Rows]. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: \"VARCHAR\", \"NVARCHAR\", \"VARCHAR2\", \"CHAR\", \"TEXT\", \"DECIMAL\", \"SMALLINT\", \"INT\", \"BIGINT\", \"BOOL\", \"[]BIGINT\", \"JSONB\", \"XML\", \"TIMESTAMP\"."
      },
      {
        "name": "RowsColumnTypeLength",
        "desc": "RowsColumnTypeLength may be implemented by [Rows]. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return [math.MaxInt64]. The following are examples of returned values for various types:  \tTEXT          (math.MaxInt64, true) \tvarchar(10)   (10, true) \tnvarchar(10)  (10, true) \tdecimal       (0, false) \tint           (0, false) \tbytea(30)     (30, true)"
      },
      {
        "name": "RowsColumnTypeNullable",
        "desc": "RowsColumnTypeNullable may be implemented by [Rows]. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false."
      },
      {
        "name": "RowsColumnTypePrecisionScale",
        "desc": "RowsColumnTypePrecisionScale may be implemented by [Rows]. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:  \tdecimal(38, 4)    (38, 4, true) \tint               (0, 0, false) \tdecimal           (math.MaxInt64, math.MaxInt64, true)"
      },
      {
        "name": "RowsColumnTypeScanType",
        "desc": "RowsColumnTypeScanType may be implemented by [Rows]. It should return the value type that can be used to scan types into. For example, the database column type \"bigint\" this should return \"[reflect.TypeOf](int64(0))\"."
      },
      {
        "name": "RowsNextResultSet",
        "desc": "RowsNextResultSet extends the [Rows] interface by providing a way to signal the driver to advance to the next result set."
      },
      {
        "name": "SessionResetter",
        "desc": "SessionResetter may be implemented by [Conn] to allow drivers to reset the session state associated with the connection and to signal a bad connection."
      },
      {
        "name": "Stmt",
        "desc": "Stmt is a prepared statement. It is bound to a [Conn] and not used by multiple goroutines concurrently."
      },
      {
        "name": "StmtExecContext",
        "desc": "StmtExecContext enhances the [Stmt] interface by providing Exec with context."
      },
      {
        "name": "StmtQueryContext",
        "desc": "StmtQueryContext enhances the [Stmt] interface by providing Query with context."
      },
      {
        "name": "Tx",
        "desc": "Tx is a transaction."
      },
      {
        "name": "TxOptions",
        "desc": "TxOptions holds the transaction options.  This type should be considered identical to [database/sql.TxOptions]."
      },
      {
        "name": "Validator",
        "desc": "Validator may be implemented by [Conn] to allow drivers to signal if a connection is valid or if it should be discarded.  If implemented, drivers may return the underlying error from queries, even if the connection should be discarded by the connection pool."
      },
      {
        "name": "Value",
        "desc": "Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's [NamedValueChecker] interface, or an instance of one of these types:  \tint64 \tfloat64 \tbool \t[]byte \tstring \ttime.Time  If the driver supports cursors, a returned Value may also implement the [Rows] interface in this package. This is used, for example, when a user selects a cursor such as \"select cursor(select * from my_table) from dual\". If the [Rows] from the select is closed, the cursor [Rows] will also be closed."
      },
      {
        "name": "ValueConverter",
        "desc": "ValueConverter is the interface providing the ConvertValue method.  Various implementations of ValueConverter are provided by the driver package to provide consistent implementations of conversions between drivers. The ValueConverters have several uses:    - converting from the [Value] types as provided by the sql package     into a database table's specific column type and making sure it     fits, such as making sure a particular int64 fits in a     table's uint16 column.    - converting a value as given from the database into one of the     driver [Value] types.    - by the [database/sql] package, for converting from a driver's [Value] type     to a user's type in a scan."
      },
      {
        "name": "Valuer",
        "desc": "Valuer is the interface providing the Value method.  Errors returned by the [Value] method are wrapped by the database/sql package. This allows callers to use [errors.Is] for precise error handling after operations like [database/sql.Query], [database/sql.Exec], or [database/sql.QueryRow].  Types implementing Valuer interface are able to convert themselves to a driver [Value]."
      },
      {
        "name": "b",
        "desc": ""
      },
      {
        "name": "boolType",
        "desc": ""
      },
      {
        "name": "bs",
        "desc": ""
      },
      {
        "name": "dec",
        "desc": ""
      },
      {
        "name": "decimalDecompose",
        "desc": ""
      },
      {
        "name": "defaultConverter",
        "desc": ""
      },
      {
        "name": "f",
        "desc": ""
      },
      {
        "name": "i",
        "desc": ""
      },
      {
        "name": "int32Type",
        "desc": ""
      },
      {
        "name": "is",
        "desc": ""
      },
      {
        "name": "noRows",
        "desc": ""
      },
      {
        "name": "s",
        "desc": ""
      },
      {
        "name": "stringType",
        "desc": ""
      },
      {
        "name": "t",
        "desc": ""
      },
      {
        "name": "valueConverterTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "debug/buildinfo",
    "desc": "Package buildinfo provides access to information embedded in a Go binary about how it was built. This includes the Go toolchain version, and the set of modules used (for binaries built in module mode).  Build information is available for the currently running binary in runtime/debug.ReadBuildInfo.",
    "functions": [
      {
        "name": "TestSearchMagic",
        "desc": ""
      },
      {
        "name": "decodeString",
        "desc": ""
      },
      {
        "name": "hasPlan9Magic",
        "desc": ""
      },
      {
        "name": "readData",
        "desc": ""
      },
      {
        "name": "readDataInto",
        "desc": ""
      },
      {
        "name": "readRawBuildInfo",
        "desc": "readRawBuildInfo extracts the Go toolchain version and module information strings from a Go binary. On success, vers should be non-empty. mod is empty if the binary was not built with modules enabled."
      },
      {
        "name": "readString",
        "desc": "readString returns the string at address addr in the executable x."
      },
      {
        "name": "searchMagic",
        "desc": "searchMagic returns the aligned first instance of buildInfoMagic in the data range [addr, addr+size). Returns false if not found."
      },
      {
        "name": "DataReader",
        "desc": ""
      },
      {
        "name": "DataStart",
        "desc": ""
      },
      {
        "name": "DataReader",
        "desc": ""
      },
      {
        "name": "DataStart",
        "desc": ""
      },
      {
        "name": "DataReader",
        "desc": ""
      },
      {
        "name": "DataStart",
        "desc": ""
      },
      {
        "name": "DataReader",
        "desc": ""
      },
      {
        "name": "DataStart",
        "desc": ""
      },
      {
        "name": "imageBase",
        "desc": ""
      },
      {
        "name": "DataReader",
        "desc": ""
      },
      {
        "name": "DataStart",
        "desc": ""
      },
      {
        "name": "DataReader",
        "desc": ""
      },
      {
        "name": "DataStart",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "BuildInfo",
        "desc": "Type alias for build info. We cannot move the types here, since runtime/debug would need to import this package, which would make it a much larger dependency."
      },
      {
        "name": "byteExe",
        "desc": ""
      },
      {
        "name": "elfExe",
        "desc": "elfExe is the ELF implementation of the exe interface."
      },
      {
        "name": "exe",
        "desc": ""
      },
      {
        "name": "machoExe",
        "desc": "machoExe is the Mach-O (Apple macOS/iOS) implementation of the exe interface."
      },
      {
        "name": "peExe",
        "desc": "peExe is the PE (Windows Portable Executable) implementation of the exe interface."
      },
      {
        "name": "plan9objExe",
        "desc": "plan9objExe is the Plan 9 a.out implementation of the exe interface."
      },
      {
        "name": "xcoffExe",
        "desc": "xcoffExe is the XCOFF (AIX eXtended COFF) implementation of the exe interface."
      }
    ]
  },
  {
    "name": "debug/dwarf",
    "desc": "",
    "functions": [
      {
        "name": "Test64Bit",
        "desc": ""
      },
      {
        "name": "TestBitFieldZeroArrayIssue50685",
        "desc": "TestBitFieldZeroArrayIssue50685 checks to make sure that the DWARF type reading code doesn't get confused by the presence of a specifically-sized bitfield member immediately following a field whose type is a zero-length array. Prior to the fix for issue 50685, we would get this type for the case in testdata/bitfields.c:  another_struct {quix short unsigned int@0; xyz [-1]int@4; x unsigned int@4 : 1@31; array [40]long long int@8}  Note the \"-1\" for the xyz field, which should be zero."
      },
      {
        "name": "TestBitOffsetsELF",
        "desc": ""
      },
      {
        "name": "TestBitOffsetsELFDwarf4",
        "desc": ""
      },
      {
        "name": "TestBitOffsetsELFDwarf5",
        "desc": ""
      },
      {
        "name": "TestBitOffsetsMachO",
        "desc": ""
      },
      {
        "name": "TestBitOffsetsMachO4",
        "desc": ""
      },
      {
        "name": "TestIssue51758",
        "desc": ""
      },
      {
        "name": "TestIssue52045",
        "desc": ""
      },
      {
        "name": "TestIssue57046",
        "desc": ""
      },
      {
        "name": "TestLineELFClang",
        "desc": ""
      },
      {
        "name": "TestLineELFGCC",
        "desc": ""
      },
      {
        "name": "TestLineELFGCCZstd",
        "desc": ""
      },
      {
        "name": "TestLineGCCWindows",
        "desc": ""
      },
      {
        "name": "TestLineRnglists",
        "desc": ""
      },
      {
        "name": "TestLineSeek",
        "desc": ""
      },
      {
        "name": "TestPathJoin",
        "desc": ""
      },
      {
        "name": "TestPathLineReaderMalformed",
        "desc": ""
      },
      {
        "name": "TestRangesRnglistx",
        "desc": ""
      },
      {
        "name": "TestRangesSection",
        "desc": ""
      },
      {
        "name": "TestReaderRanges",
        "desc": ""
      },
      {
        "name": "TestReaderSeek",
        "desc": ""
      },
      {
        "name": "TestSplit",
        "desc": ""
      },
      {
        "name": "TestTypedefCycle",
        "desc": ""
      },
      {
        "name": "TestTypedefsELF",
        "desc": ""
      },
      {
        "name": "TestTypedefsELFDwarf4",
        "desc": ""
      },
      {
        "name": "TestTypedefsMachO",
        "desc": ""
      },
      {
        "name": "TestUnitIteration",
        "desc": ""
      },
      {
        "name": "TestUnsupportedTypes",
        "desc": ""
      },
      {
        "name": "compareFiles",
        "desc": ""
      },
      {
        "name": "compareLines",
        "desc": ""
      },
      {
        "name": "dumpFiles",
        "desc": ""
      },
      {
        "name": "dumpLines",
        "desc": ""
      },
      {
        "name": "elfData",
        "desc": ""
      },
      {
        "name": "machoData",
        "desc": ""
      },
      {
        "name": "peData",
        "desc": ""
      },
      {
        "name": "testBitOffsets",
        "desc": ""
      },
      {
        "name": "testLineTable",
        "desc": ""
      },
      {
        "name": "testRanges",
        "desc": ""
      },
      {
        "name": "testTypedefs",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "joinTest",
        "desc": ""
      },
      {
        "name": "wantRange",
        "desc": "wantRange maps from a PC to the ranges of the compilation unit containing that PC."
      }
    ]
  },
  {
    "name": "debug/elf",
    "desc": "Package elf implements access to ELF object files.  # Security  This package is not designed to be hardened against adversarial inputs, and is outside the scope of https://go.dev/security/policy. In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.",
    "functions": [
      {
        "name": "BenchmarkSymbols32",
        "desc": ""
      },
      {
        "name": "BenchmarkSymbols64",
        "desc": ""
      },
      {
        "name": "NewFile",
        "desc": "NewFile creates a new [File] for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt."
      },
      {
        "name": "Open",
        "desc": "Open opens the named file using [os.Open] and prepares it for use as an ELF binary."
      },
      {
        "name": "R_INFO",
        "desc": ""
      },
      {
        "name": "R_INFO32",
        "desc": ""
      },
      {
        "name": "R_SYM32",
        "desc": ""
      },
      {
        "name": "R_SYM64",
        "desc": ""
      },
      {
        "name": "R_TYPE32",
        "desc": ""
      },
      {
        "name": "R_TYPE64",
        "desc": ""
      },
      {
        "name": "ST_INFO",
        "desc": ""
      },
      {
        "name": "TestCompressedDWARF",
        "desc": ""
      },
      {
        "name": "TestCompressedSection",
        "desc": ""
      },
      {
        "name": "TestDWARFRelocations",
        "desc": ""
      },
      {
        "name": "TestDynValue",
        "desc": ""
      },
      {
        "name": "TestIssue10996",
        "desc": ""
      },
      {
        "name": "TestIssue59208",
        "desc": ""
      },
      {
        "name": "TestLargeNumberOfSections",
        "desc": "TestLargeNumberOfSections tests the case that a file has greater than or equal to 65280 (0xff00) sections."
      },
      {
        "name": "TestNames",
        "desc": ""
      },
      {
        "name": "TestNoSectionOverlaps",
        "desc": ""
      },
      {
        "name": "TestNobitsSection",
        "desc": ""
      },
      {
        "name": "TestOpen",
        "desc": ""
      },
      {
        "name": "TestSymbols",
        "desc": "TODO: remove duplicate code"
      },
      {
        "name": "canApplyRelocation",
        "desc": "canApplyRelocation reports whether we should try to apply a relocation to a DWARF data section, given a pointer to the symbol targeted by the relocation. Most relocations in DWARF data tend to be section-relative, but some target non-section symbols (for example, low_PC attrs on subprogram or compilation unit DIEs that target function symbols)."
      },
      {
        "name": "decompress",
        "desc": "elf.NewFile requires io.ReaderAt, which compress/gzip cannot provide. Decompress the file to a bytes.Reader."
      },
      {
        "name": "flagName",
        "desc": ""
      },
      {
        "name": "getString",
        "desc": "getString extracts a string from an ELF string table."
      },
      {
        "name": "stringName",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect."
      },
      {
        "name": "DWARF",
        "desc": ""
      },
      {
        "name": "DynString",
        "desc": "DynString returns the strings listed for the given tag in the file's dynamic section.  The tag must be one that takes string values: [DT_NEEDED], [DT_SONAME], [DT_RPATH], or [DT_RUNPATH]."
      },
      {
        "name": "DynValue",
        "desc": "DynValue returns the values listed for the given tag in the file's dynamic section."
      },
      {
        "name": "DynamicSymbols",
        "desc": "DynamicSymbols returns the dynamic symbol table for f. The symbols will be listed in the order they appear in f.  If f has a symbol version table, the returned [File.Symbols] will have initialized Version and Library fields.  For compatibility with [File.Symbols], [File.DynamicSymbols] omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x]."
      },
      {
        "name": "DynamicVersionNeeds",
        "desc": "DynamicVersionNeeds returns version dependencies for a dynamic object."
      },
      {
        "name": "DynamicVersions",
        "desc": "DynamicVersions returns version information for a dynamic object."
      },
      {
        "name": "ImportedLibraries",
        "desc": "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time."
      },
      {
        "name": "ImportedSymbols",
        "desc": "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols."
      },
      {
        "name": "Section",
        "desc": "Section returns a section with the given name, or nil if no such section exists."
      },
      {
        "name": "SectionByType",
        "desc": "SectionByType returns the first section in f with the given type, or nil if there is no such section."
      },
      {
        "name": "Symbols",
        "desc": "Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f.  For compatibility with Go 1.0, Symbols omits the null symbol at index 0. After retrieving the symbols as symtab, an externally supplied index x corresponds to symtab[x-1], not symtab[x]."
      },
      {
        "name": "applyRelocations",
        "desc": "applyRelocations applies relocations to dst. rels is a relocations section in REL or RELA format."
      },
      {
        "name": "applyRelocations386",
        "desc": ""
      },
      {
        "name": "applyRelocationsAMD64",
        "desc": ""
      },
      {
        "name": "applyRelocationsARM",
        "desc": ""
      },
      {
        "name": "applyRelocationsARM64",
        "desc": ""
      },
      {
        "name": "applyRelocationsLOONG64",
        "desc": ""
      },
      {
        "name": "applyRelocationsMIPS",
        "desc": ""
      },
      {
        "name": "applyRelocationsMIPS64",
        "desc": ""
      },
      {
        "name": "applyRelocationsPPC",
        "desc": ""
      },
      {
        "name": "applyRelocationsPPC64",
        "desc": ""
      },
      {
        "name": "applyRelocationsRISCV64",
        "desc": ""
      },
      {
        "name": "applyRelocationsSPARC64",
        "desc": ""
      },
      {
        "name": "applyRelocationss390x",
        "desc": ""
      },
      {
        "name": "dynamicVersionNeeds",
        "desc": "dynamicVersionNeeds returns version dependencies for a dynamic object."
      },
      {
        "name": "dynamicVersions",
        "desc": "dynamicVersions returns version information for a dynamic object."
      },
      {
        "name": "getSymbols",
        "desc": "getSymbols returns a slice of Symbols from parsing the symbol table with the given type, along with the associated string table."
      },
      {
        "name": "getSymbols32",
        "desc": ""
      },
      {
        "name": "getSymbols64",
        "desc": ""
      },
      {
        "name": "gnuVersion",
        "desc": "gnuVersion adds Library and Version information to sym, which came from offset i of the symbol table."
      },
      {
        "name": "gnuVersionInit",
        "desc": "gnuVersionInit parses the GNU version tables for use by calls to gnuVersion. It reports whether any version tables were found."
      },
      {
        "name": "stringTable",
        "desc": "stringTable reads and returns the string table given by the specified link value."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": "Open returns a new ReadSeeker reading the ELF program body."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Data",
        "desc": "Data reads and returns the contents of the ELF section. Even if the section is stored compressed in the ELF file, Data returns uncompressed data.  For an [SHT_NOBITS] section, Data always returns a non-nil error."
      },
      {
        "name": "Open",
        "desc": "Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data.  For an [SHT_NOBITS] section, all calls to the opened reader will return a non-nil error."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Index",
        "desc": "Index returns the version index. If this is the value 0, it means that the symbol is local, and is not visible externally. If this is the value 1, it means that the symbol is in the base version, and has no specific version; it may or may not match a [DynamicVersion.Index] in the slice returned by [File.DynamicVersions]. Other values will match either [DynamicVersion.Index] in the slice returned by [File.DynamicVersions], or [DynamicVersionDep.Index] in the Needs field of the elements of the slice returned by [File.DynamicVersionNeeds]. In general, a defined symbol will have an index referring to DynamicVersions, and an undefined symbol will have an index referring to some version in DynamicVersionNeeds."
      },
      {
        "name": "IsHidden",
        "desc": "IsHidden reports whether the symbol is hidden within the version. This means that the symbol can only be seen by specifying the exact version."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadAt",
        "desc": ""
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "ReadAt",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "start",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Chdr32",
        "desc": "ELF32 Compression header."
      },
      {
        "name": "Chdr64",
        "desc": "ELF64 Compression header."
      },
      {
        "name": "Class",
        "desc": "Class is found in Header.Ident[EI_CLASS] and Header.Class."
      },
      {
        "name": "CompressionType",
        "desc": "Section compression type."
      },
      {
        "name": "Data",
        "desc": "Data is found in Header.Ident[EI_DATA] and Header.Data."
      },
      {
        "name": "Dyn32",
        "desc": "ELF32 Dynamic structure. The \".dynamic\" section contains an array of them."
      },
      {
        "name": "Dyn64",
        "desc": "ELF64 Dynamic structure. The \".dynamic\" section contains an array of them."
      },
      {
        "name": "DynFlag",
        "desc": "DT_FLAGS values."
      },
      {
        "name": "DynFlag1",
        "desc": "DT_FLAGS_1 values."
      },
      {
        "name": "DynTag",
        "desc": "Dyn.Tag"
      },
      {
        "name": "DynamicVersion",
        "desc": "DynamicVersion is a version defined by a dynamic object. This describes entries in the ELF SHT_GNU_verdef section. We assume that the vd_version field is 1. Note that the name of the version appears here; it is not in the first Deps entry as it is in the ELF file."
      },
      {
        "name": "DynamicVersionDep",
        "desc": "DynamicVersionDep is a version needed from some shared library."
      },
      {
        "name": "DynamicVersionFlag",
        "desc": "Dynamic version flags."
      },
      {
        "name": "DynamicVersionNeed",
        "desc": "DynamicVersionNeed describes a shared library needed by a dynamic object, with a list of the versions needed from that shared library. This describes entries in the ELF SHT_GNU_verneed section. We assume that the vn_version field is 1."
      },
      {
        "name": "File",
        "desc": "A File represents an open ELF file."
      },
      {
        "name": "FileHeader",
        "desc": "A FileHeader represents an ELF file header."
      },
      {
        "name": "FormatError",
        "desc": ""
      },
      {
        "name": "Header32",
        "desc": "ELF32 File header."
      },
      {
        "name": "Header64",
        "desc": "ELF64 file header."
      },
      {
        "name": "ImportedSymbol",
        "desc": ""
      },
      {
        "name": "Machine",
        "desc": "Machine is found in Header.Machine."
      },
      {
        "name": "NType",
        "desc": "NType values; used in core files."
      },
      {
        "name": "OSABI",
        "desc": "OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI."
      },
      {
        "name": "Prog",
        "desc": "A Prog represents a single ELF program header in an ELF binary."
      },
      {
        "name": "Prog32",
        "desc": "ELF32 Program header."
      },
      {
        "name": "Prog64",
        "desc": "ELF64 Program header."
      },
      {
        "name": "ProgFlag",
        "desc": "Prog.Flag"
      },
      {
        "name": "ProgHeader",
        "desc": "A ProgHeader represents a single ELF program header."
      },
      {
        "name": "ProgType",
        "desc": "Prog.Type"
      },
      {
        "name": "R_386",
        "desc": "Relocation types for 386."
      },
      {
        "name": "R_390",
        "desc": "Relocation types for s390x processors."
      },
      {
        "name": "R_AARCH64",
        "desc": "Relocation types for AArch64 (aka arm64)"
      },
      {
        "name": "R_ALPHA",
        "desc": "Relocation types for Alpha."
      },
      {
        "name": "R_ARM",
        "desc": "Relocation types for ARM."
      },
      {
        "name": "R_LARCH",
        "desc": "Relocation types for LoongArch."
      },
      {
        "name": "R_MIPS",
        "desc": "Relocation types for MIPS."
      },
      {
        "name": "R_PPC",
        "desc": "Relocation types for PowerPC.  Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared relocations have been renamed with the prefix R_PPC_. The original name follows the value in a comment."
      },
      {
        "name": "R_PPC64",
        "desc": "Relocation types for 64-bit PowerPC or Power Architecture processors.  Values that are shared by both R_PPC and R_PPC64 are prefixed with R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared relocations have been renamed with the prefix R_PPC64_. The original name follows the value in a comment."
      },
      {
        "name": "R_RISCV",
        "desc": "Relocation types for RISC-V processors."
      },
      {
        "name": "R_SPARC",
        "desc": "Relocation types for SPARC."
      },
      {
        "name": "R_X86_64",
        "desc": "Relocation types for x86-64."
      },
      {
        "name": "Rel32",
        "desc": "ELF32 Relocations that don't need an addend field."
      },
      {
        "name": "Rel64",
        "desc": "ELF64 relocations that don't need an addend field."
      },
      {
        "name": "Rela32",
        "desc": "ELF32 Relocations that need an addend field."
      },
      {
        "name": "Rela64",
        "desc": "ELF64 relocations that need an addend field."
      },
      {
        "name": "Section",
        "desc": "A Section represents a single section in an ELF file."
      },
      {
        "name": "Section32",
        "desc": "ELF32 Section header."
      },
      {
        "name": "Section64",
        "desc": "ELF64 Section header."
      },
      {
        "name": "SectionFlag",
        "desc": "Section flags."
      },
      {
        "name": "SectionHeader",
        "desc": "A SectionHeader represents a single ELF section header."
      },
      {
        "name": "SectionIndex",
        "desc": "Special section indices."
      },
      {
        "name": "SectionType",
        "desc": "Section type."
      },
      {
        "name": "Sym32",
        "desc": "ELF32 Symbol."
      },
      {
        "name": "Sym64",
        "desc": "ELF64 symbol table entries."
      },
      {
        "name": "SymBind",
        "desc": "Symbol Binding - ELFNN_ST_BIND - st_info"
      },
      {
        "name": "SymType",
        "desc": "Symbol type - ELFNN_ST_TYPE - st_info"
      },
      {
        "name": "SymVis",
        "desc": "Symbol visibility - ELFNN_ST_VISIBILITY - st_other"
      },
      {
        "name": "Symbol",
        "desc": "A Symbol represents an entry in an ELF symbol table section."
      },
      {
        "name": "Type",
        "desc": "Type is found in Header.Type."
      },
      {
        "name": "Version",
        "desc": "Version is found in Header.Ident[EI_VERSION] and Header.Version."
      },
      {
        "name": "VersionIndex",
        "desc": "VersionIndex is the type of a [Symbol] version index."
      },
      {
        "name": "errorReader",
        "desc": "errorReader returns error from all operations."
      },
      {
        "name": "fileTest",
        "desc": ""
      },
      {
        "name": "intName",
        "desc": ""
      },
      {
        "name": "nameTest",
        "desc": ""
      },
      {
        "name": "nobitsSectionReader",
        "desc": ""
      },
      {
        "name": "readSeekerFromReader",
        "desc": "readSeekerFromReader converts an io.Reader into an io.ReadSeeker. In general Seek may not be efficient, but it is optimized for common cases such as seeking to the end to find the length of the data."
      },
      {
        "name": "relocationTest",
        "desc": ""
      },
      {
        "name": "relocationTestEntry",
        "desc": ""
      }
    ]
  },
  {
    "name": "debug/gosym",
    "desc": "Package gosym implements access to the Go symbol and line number tables embedded in Go binaries generated by the gc compilers.",
    "functions": [
      {
        "name": "Benchmark115",
        "desc": ""
      },
      {
        "name": "Test115PclnParsing",
        "desc": "Test that we can parse a pclntab from 1.15."
      },
      {
        "name": "TestGenericNames",
        "desc": ""
      },
      {
        "name": "TestIssue29551",
        "desc": ""
      },
      {
        "name": "TestLineAline",
        "desc": ""
      },
      {
        "name": "TestLineFromAline",
        "desc": ""
      },
      {
        "name": "TestPCLine",
        "desc": ""
      },
      {
        "name": "TestRemotePackage",
        "desc": ""
      },
      {
        "name": "TestStandardLibPackage",
        "desc": ""
      },
      {
        "name": "TestStandardLibPathPackage",
        "desc": ""
      },
      {
        "name": "TestSymVersion",
        "desc": ""
      },
      {
        "name": "assertString",
        "desc": ""
      },
      {
        "name": "dotest",
        "desc": ""
      },
      {
        "name": "endtest",
        "desc": ""
      },
      {
        "name": "read115Executable",
        "desc": "read115Executable returns a hello world executable compiled by Go 1.15.  The file was compiled in /tmp/hello.go:  \tpackage main  \tfunc main() { \t\tprintln(\"hello\") \t}"
      },
      {
        "name": "skipIfNotELF",
        "desc": "skipIfNotELF skips the test if we are not running on an ELF system. These tests open and examine the test binary, and use elf.Open to do so."
      },
      {
        "name": "walksymtab",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "LineToPC",
        "desc": "LineToPC returns the program counter for the given line number, considering only program counters before maxpc.  Deprecated: Use Table's LineToPC method instead."
      },
      {
        "name": "PCToLine",
        "desc": "PCToLine returns the line number for the given program counter.  Deprecated: Use Table's PCToLine method instead."
      },
      {
        "name": "findFileLine",
        "desc": "findFileLine scans one function in the binary looking for a program counter in the given file on the given line. It does so by running the pc-value tables mapping program counter to file number. Since most functions come from a single file, these are usually short and quick to scan. If a file match is found, then the code goes to the expense of looking for a simultaneous line number match."
      },
      {
        "name": "findFunc",
        "desc": "findFunc returns the funcData corresponding to the given program counter."
      },
      {
        "name": "funcData",
        "desc": "funcData returns the ith funcData in t.functab."
      },
      {
        "name": "funcName",
        "desc": "funcName returns the name of the function found at off."
      },
      {
        "name": "funcTab",
        "desc": "funcTab returns t's funcTab."
      },
      {
        "name": "functabFieldSize",
        "desc": "functabFieldSize returns the size in bytes of a single functab field."
      },
      {
        "name": "go12Funcs",
        "desc": "go12Funcs returns a slice of Funcs derived from the Go 1.2+ pcln table."
      },
      {
        "name": "go12LineToPC",
        "desc": "go12LineToPC maps a (file, line) pair to a program counter for the Go 1.2+ pcln table."
      },
      {
        "name": "go12MapFiles",
        "desc": "go12MapFiles adds to m a key for every file in the Go 1.2 LineTable. Every key maps to obj. That's not a very interesting map, but it provides a way for callers to obtain the list of files in the program."
      },
      {
        "name": "go12PCToFile",
        "desc": "go12PCToFile maps program counter to file name for the Go 1.2+ pcln table."
      },
      {
        "name": "go12PCToLine",
        "desc": "go12PCToLine maps program counter to line number for the Go 1.2+ pcln table."
      },
      {
        "name": "initFileMap",
        "desc": "initFileMap initializes the map from file name to file number."
      },
      {
        "name": "isGo12",
        "desc": "isGo12 reports whether this is a Go 1.2 (or later) symbol table."
      },
      {
        "name": "parse",
        "desc": ""
      },
      {
        "name": "parsePclnTab",
        "desc": "parsePclnTab parses the pclntab, setting the version."
      },
      {
        "name": "pcvalue",
        "desc": "pcvalue reports the value associated with the target pc. off is the offset to the beginning of the pc-value table, and entry is the start PC for the corresponding function."
      },
      {
        "name": "readvarint",
        "desc": "readvarint reads, removes, and returns a varint from *pp."
      },
      {
        "name": "slice",
        "desc": ""
      },
      {
        "name": "step",
        "desc": "step advances to the next pc, value pair in the encoded table."
      },
      {
        "name": "string",
        "desc": "string returns a Go string found at off."
      },
      {
        "name": "stringFrom",
        "desc": "stringFrom returns a Go string found at off from a position."
      },
      {
        "name": "uintptr",
        "desc": "uintptr returns the pointer-sized value encoded at b. The pointer size is dictated by the table being read."
      },
      {
        "name": "alineFromLine",
        "desc": ""
      },
      {
        "name": "lineFromAline",
        "desc": ""
      },
      {
        "name": "BaseName",
        "desc": "BaseName returns the symbol name without the package or receiver name."
      },
      {
        "name": "PackageName",
        "desc": "PackageName returns the package part of the symbol name, or the empty string if there is none."
      },
      {
        "name": "ReceiverName",
        "desc": "ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.  A receiver name is only detected in the case that s.Name is fully-specified with a package name."
      },
      {
        "name": "Static",
        "desc": "Static reports whether this symbol is static (not visible outside its file)."
      },
      {
        "name": "nameWithoutInst",
        "desc": "nameWithoutInst returns s.Name if s.Name has no brackets (does not reference an instantiated type, function, or method). If s.Name contains brackets, then it returns s.Name with all the contents between (and including) the outermost left and right bracket removed. This is useful to ignore any extra slashes or dots inside the brackets from the string searches below, where needed."
      },
      {
        "name": "LineToPC",
        "desc": "LineToPC looks up the first program counter on the given line in the named file. It returns [UnknownFileError] or [UnknownLineError] if there is an error looking up this line."
      },
      {
        "name": "LookupFunc",
        "desc": "LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found."
      },
      {
        "name": "LookupSym",
        "desc": "LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found."
      },
      {
        "name": "PCToFunc",
        "desc": "PCToFunc returns the function containing the program counter pc, or nil if there is no such function."
      },
      {
        "name": "PCToLine",
        "desc": "PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil."
      },
      {
        "name": "SymByAddr",
        "desc": "SymByAddr returns the text, data, or bss symbol starting at the given address."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": "IsZero reports whether f is the zero value."
      },
      {
        "name": "cuOffset",
        "desc": ""
      },
      {
        "name": "deferreturn",
        "desc": ""
      },
      {
        "name": "entryPC",
        "desc": "entryPC returns the func's entry PC."
      },
      {
        "name": "field",
        "desc": "field returns the nth field of the _func struct. It panics if n == 0 or n \u003e 9; for n == 0, call f.entryPC. Most callers should use a named field accessor (just above)."
      },
      {
        "name": "nameOff",
        "desc": ""
      },
      {
        "name": "pcfile",
        "desc": ""
      },
      {
        "name": "pcln",
        "desc": ""
      },
      {
        "name": "Count",
        "desc": "Count returns the number of func entries in f."
      },
      {
        "name": "funcOff",
        "desc": "funcOff returns the funcdata offset of the i'th func in f."
      },
      {
        "name": "pc",
        "desc": "pc returns the PC of the i'th func in f."
      },
      {
        "name": "uint",
        "desc": "uint returns the uint stored at b."
      }
    ],
    "types": [
      {
        "name": "DecodingError",
        "desc": "DecodingError represents an error during the decoding of the symbol table."
      },
      {
        "name": "Func",
        "desc": "A Func collects information about a single function."
      },
      {
        "name": "LineTable",
        "desc": "A LineTable is a data structure mapping program counters to line numbers.  In Go 1.1 and earlier, each function (represented by a [Func]) had its own LineTable, and the line number corresponded to a numbering of all source lines in the program, across all files. That absolute line number would then have to be converted separately to a file name and line number within the file.  In Go 1.2, the format of the data changed so that there is a single LineTable for the entire program, shared by all Funcs, and there are no absolute line numbers, just line numbers within specific files.  For the most part, LineTable's methods should be treated as an internal detail of the package; callers should use the methods on [Table] instead."
      },
      {
        "name": "Obj",
        "desc": "An Obj represents a collection of functions in a symbol table.  The exact method of division of a binary into separate Objs is an internal detail of the symbol table format.  In early versions of Go each source file became a different Obj.  In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one Obj per C source file.  In Go 1.2, there is a single Obj for the entire program."
      },
      {
        "name": "Sym",
        "desc": "A Sym represents a single symbol table entry."
      },
      {
        "name": "Table",
        "desc": "Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses."
      },
      {
        "name": "UnknownFileError",
        "desc": "UnknownFileError represents a failure to find the specific file in the symbol table."
      },
      {
        "name": "UnknownLineError",
        "desc": "UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line."
      },
      {
        "name": "funcData",
        "desc": "funcData is memory corresponding to an _func struct."
      },
      {
        "name": "funcTab",
        "desc": "funcTab is memory corresponding to a slice of functab structs, followed by an invalid PC. A functab struct is a PC and a func offset."
      },
      {
        "name": "sym",
        "desc": ""
      },
      {
        "name": "version",
        "desc": "version of the pclntab"
      }
    ]
  },
  {
    "name": "debug/macho",
    "desc": "Package macho implements access to Mach-O object files.  # Security  This package is not designed to be hardened against adversarial inputs, and is outside the scope of https://go.dev/security/policy. In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.",
    "functions": [
      {
        "name": "TestOpen",
        "desc": ""
      },
      {
        "name": "TestOpenBadDysymCmd",
        "desc": ""
      },
      {
        "name": "TestOpenFailure",
        "desc": ""
      },
      {
        "name": "TestOpenFat",
        "desc": ""
      },
      {
        "name": "TestOpenFatFailure",
        "desc": ""
      },
      {
        "name": "TestRelocTypeString",
        "desc": ""
      },
      {
        "name": "TestTypeString",
        "desc": ""
      },
      {
        "name": "_",
        "desc": ""
      },
      {
        "name": "cstring",
        "desc": ""
      },
      {
        "name": "readerAtFromObscured",
        "desc": ""
      },
      {
        "name": "stringName",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect."
      },
      {
        "name": "DWARF",
        "desc": "DWARF returns the DWARF debug information for the Mach-O file."
      },
      {
        "name": "ImportedLibraries",
        "desc": "ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time."
      },
      {
        "name": "ImportedSymbols",
        "desc": "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time."
      },
      {
        "name": "Section",
        "desc": "Section returns the first section with the given name, or nil if no such section exists."
      },
      {
        "name": "Segment",
        "desc": "Segment returns the first Segment with the given name, or nil if no such segment exists."
      },
      {
        "name": "parseSymtab",
        "desc": ""
      },
      {
        "name": "pushSection",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Raw",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Data",
        "desc": "Data reads and returns the contents of the Mach-O section."
      },
      {
        "name": "Open",
        "desc": "Open returns a new ReadSeeker reading the Mach-O section."
      },
      {
        "name": "Data",
        "desc": "Data reads and returns the contents of the segment."
      },
      {
        "name": "Open",
        "desc": "Open returns a new ReadSeeker reading the segment."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Cpu",
        "desc": "A Cpu is a Mach-O cpu type."
      },
      {
        "name": "Dylib",
        "desc": "A Dylib represents a Mach-O load dynamic library command."
      },
      {
        "name": "DylibCmd",
        "desc": "A DylibCmd is a Mach-O load dynamic library command."
      },
      {
        "name": "Dysymtab",
        "desc": "A Dysymtab represents a Mach-O dynamic symbol table command."
      },
      {
        "name": "DysymtabCmd",
        "desc": "A DysymtabCmd is a Mach-O dynamic symbol table command."
      },
      {
        "name": "FatArch",
        "desc": "A FatArch is a Mach-O File inside a FatFile."
      },
      {
        "name": "FatArchHeader",
        "desc": "A FatArchHeader represents a fat header for a specific image architecture."
      },
      {
        "name": "FatFile",
        "desc": "A FatFile is a Mach-O universal binary that contains at least one architecture."
      },
      {
        "name": "File",
        "desc": "A File represents an open Mach-O file."
      },
      {
        "name": "FileHeader",
        "desc": "A FileHeader represents a Mach-O file header."
      },
      {
        "name": "FormatError",
        "desc": "FormatError is returned by some operations if the data does not have the correct format for an object file."
      },
      {
        "name": "Load",
        "desc": "A Load represents any Mach-O load command."
      },
      {
        "name": "LoadBytes",
        "desc": "A LoadBytes is the uninterpreted bytes of a Mach-O load command."
      },
      {
        "name": "LoadCmd",
        "desc": "A LoadCmd is a Mach-O load command."
      },
      {
        "name": "Nlist32",
        "desc": "An Nlist32 is a Mach-O 32-bit symbol table entry."
      },
      {
        "name": "Nlist64",
        "desc": "An Nlist64 is a Mach-O 64-bit symbol table entry."
      },
      {
        "name": "Regs386",
        "desc": "Regs386 is the Mach-O 386 register structure."
      },
      {
        "name": "RegsAMD64",
        "desc": "RegsAMD64 is the Mach-O AMD64 register structure."
      },
      {
        "name": "Reloc",
        "desc": "A Reloc represents a Mach-O relocation."
      },
      {
        "name": "RelocTypeARM",
        "desc": ""
      },
      {
        "name": "RelocTypeARM64",
        "desc": ""
      },
      {
        "name": "RelocTypeGeneric",
        "desc": ""
      },
      {
        "name": "RelocTypeX86_64",
        "desc": ""
      },
      {
        "name": "Rpath",
        "desc": "A Rpath represents a Mach-O rpath command."
      },
      {
        "name": "RpathCmd",
        "desc": "A RpathCmd is a Mach-O rpath command."
      },
      {
        "name": "Section",
        "desc": ""
      },
      {
        "name": "Section32",
        "desc": "A Section32 is a 32-bit Mach-O section header."
      },
      {
        "name": "Section64",
        "desc": "A Section64 is a 64-bit Mach-O section header."
      },
      {
        "name": "SectionHeader",
        "desc": ""
      },
      {
        "name": "Segment",
        "desc": "A Segment represents a Mach-O 32-bit or 64-bit load segment command."
      },
      {
        "name": "Segment32",
        "desc": "A Segment32 is a 32-bit Mach-O segment load command."
      },
      {
        "name": "Segment64",
        "desc": "A Segment64 is a 64-bit Mach-O segment load command."
      },
      {
        "name": "SegmentHeader",
        "desc": "A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command."
      },
      {
        "name": "Symbol",
        "desc": "A Symbol is a Mach-O 32-bit or 64-bit symbol table entry."
      },
      {
        "name": "Symtab",
        "desc": "A Symtab represents a Mach-O symbol table command."
      },
      {
        "name": "SymtabCmd",
        "desc": "A SymtabCmd is a Mach-O symbol table command."
      },
      {
        "name": "Thread",
        "desc": "A Thread is a Mach-O thread state command."
      },
      {
        "name": "Type",
        "desc": "A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library."
      },
      {
        "name": "fileTest",
        "desc": ""
      },
      {
        "name": "intName",
        "desc": ""
      },
      {
        "name": "relocInfo",
        "desc": ""
      }
    ]
  },
  {
    "name": "debug/pe",
    "desc": "Package pe implements access to PE (Microsoft Windows Portable Executable) files.  # Security  This package is not designed to be hardened against adversarial inputs, and is outside the scope of https://go.dev/security/policy. In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.",
    "functions": [
      {
        "name": "TestBSSHasZeros",
        "desc": ""
      },
      {
        "name": "TestBuildingWindowsGUI",
        "desc": ""
      },
      {
        "name": "TestDWARF",
        "desc": ""
      },
      {
        "name": "TestDefaultLinkerDWARF",
        "desc": ""
      },
      {
        "name": "TestExternalLinkerDWARF",
        "desc": ""
      },
      {
        "name": "TestImportTableInUnknownSection",
        "desc": ""
      },
      {
        "name": "TestImportedSymbolsNoPanicMissingOptionalHeader",
        "desc": ""
      },
      {
        "name": "TestImportedSymbolsNoPanicWithSliceOutOfBound",
        "desc": ""
      },
      {
        "name": "TestInternalLinkerDWARF",
        "desc": ""
      },
      {
        "name": "TestInvalidOptionalHeaderMagic",
        "desc": ""
      },
      {
        "name": "TestOpen",
        "desc": ""
      },
      {
        "name": "TestOpenFailure",
        "desc": ""
      },
      {
        "name": "TestReadCOFFSymbolAuxInfo",
        "desc": ""
      },
      {
        "name": "cstring",
        "desc": "cstring converts ASCII byte sequence b to string. It stops once it finds 0 or reaches end of b."
      },
      {
        "name": "getImageBase",
        "desc": ""
      },
      {
        "name": "getString",
        "desc": "getString extracts a string from symbol string table."
      },
      {
        "name": "isOptHdrEq",
        "desc": ""
      },
      {
        "name": "isSymNameOffset",
        "desc": "isSymNameOffset checks symbol name if it is encoded as offset into string table."
      },
      {
        "name": "readOptionalHeader",
        "desc": "readOptionalHeader accepts an io.ReadSeeker pointing to optional header in the PE file and its size as seen in the file header. It parses the given size of bytes and returns optional header. It infers whether the bytes being parsed refer to 32 bit or 64 bit version of optional header."
      },
      {
        "name": "testCgoDWARF",
        "desc": ""
      },
      {
        "name": "testDWARF",
        "desc": ""
      },
      {
        "name": "FullName",
        "desc": "FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead."
      },
      {
        "name": "COFFSymbolReadSectionDefAux",
        "desc": "COFFSymbolReadSectionDefAux returns a blob of auxiliary information (including COMDAT info) for a section definition symbol. Here 'idx' is the index of a section symbol in the main [COFFSymbol] array for the File. Return value is a pointer to the appropriate aux symbol struct. For more info, see:  auxiliary symbols: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-symbol-records COMDAT sections: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#comdat-sections-object-only auxiliary info for section definitions: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions"
      },
      {
        "name": "Close",
        "desc": "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect."
      },
      {
        "name": "DWARF",
        "desc": ""
      },
      {
        "name": "ImportedLibraries",
        "desc": "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time."
      },
      {
        "name": "ImportedSymbols",
        "desc": "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols."
      },
      {
        "name": "Section",
        "desc": "Section returns the first section with the given name, or nil if no such section exists."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Data",
        "desc": "Data reads and returns the contents of the PE section s.  If s.Offset is 0, the section has no contents, and Data will always return a non-nil error."
      },
      {
        "name": "Open",
        "desc": "Open returns a new ReadSeeker reading the PE section s.  If s.Offset is 0, the section has no contents, and all calls to the returned reader will return a non-nil error."
      },
      {
        "name": "fullName",
        "desc": "fullName finds real name of section sh. Normally name is stored in sh.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead."
      },
      {
        "name": "String",
        "desc": "String extracts string from COFF string table st at offset start."
      },
      {
        "name": "ReadAt",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "COFFSymbol",
        "desc": "COFFSymbol represents single COFF symbol table record."
      },
      {
        "name": "COFFSymbolAuxFormat5",
        "desc": "COFFSymbolAuxFormat5 describes the expected form of an aux symbol attached to a section definition symbol. The PE format defines a number of different aux symbol formats: format 1 for function definitions, format 2 for .be and .ef symbols, and so on. Format 5 holds extra info associated with a section definition, including number of relocations + line numbers, as well as COMDAT info. See https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions for more on what's going on here."
      },
      {
        "name": "DataDirectory",
        "desc": ""
      },
      {
        "name": "File",
        "desc": "A File represents an open PE file."
      },
      {
        "name": "FileHeader",
        "desc": ""
      },
      {
        "name": "FormatError",
        "desc": "FormatError is unused. The type is retained for compatibility."
      },
      {
        "name": "ImportDirectory",
        "desc": ""
      },
      {
        "name": "OptionalHeader32",
        "desc": ""
      },
      {
        "name": "OptionalHeader64",
        "desc": ""
      },
      {
        "name": "Reloc",
        "desc": "Reloc represents a PE COFF relocation. Each section contains its own relocation list."
      },
      {
        "name": "Section",
        "desc": "Section provides access to PE COFF section."
      },
      {
        "name": "SectionHeader",
        "desc": "SectionHeader is similar to [SectionHeader32] with Name field replaced by Go string."
      },
      {
        "name": "SectionHeader32",
        "desc": "SectionHeader32 represents real PE COFF section header."
      },
      {
        "name": "StringTable",
        "desc": "StringTable is a COFF string table."
      },
      {
        "name": "Symbol",
        "desc": "Symbol is similar to [COFFSymbol] with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols."
      },
      {
        "name": "fileTest",
        "desc": ""
      },
      {
        "name": "nobitsSectionReader",
        "desc": ""
      },
      {
        "name": "testpoint",
        "desc": ""
      }
    ]
  },
  {
    "name": "debug/plan9obj",
    "desc": "Package plan9obj implements access to Plan 9 a.out object files.  # Security  This package is not designed to be hardened against adversarial inputs, and is outside the scope of https://go.dev/security/policy. In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics.",
    "functions": [
      {
        "name": "TestOpen",
        "desc": ""
      },
      {
        "name": "TestOpenFailure",
        "desc": ""
      },
      {
        "name": "parseMagic",
        "desc": ""
      },
      {
        "name": "walksymtab",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the [File]. If the [File] was created using [NewFile] directly instead of [Open], Close has no effect."
      },
      {
        "name": "Section",
        "desc": "Section returns a section with the given name, or nil if no such section exists."
      },
      {
        "name": "Symbols",
        "desc": "Symbols returns the symbol table for f."
      },
      {
        "name": "Data",
        "desc": "Data reads and returns the contents of the Plan 9 a.out section."
      },
      {
        "name": "Open",
        "desc": "Open returns a new ReadSeeker reading the Plan 9 a.out section."
      },
      {
        "name": "Error",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "File",
        "desc": "A File represents an open Plan 9 a.out file."
      },
      {
        "name": "FileHeader",
        "desc": "A FileHeader represents a Plan 9 a.out file header."
      },
      {
        "name": "Section",
        "desc": "A Section represents a single section in a Plan 9 a.out file."
      },
      {
        "name": "SectionHeader",
        "desc": "A SectionHeader represents a single Plan 9 a.out section header. This structure doesn't exist on-disk, but eases navigation through the object file."
      },
      {
        "name": "Sym",
        "desc": "A Symbol represents an entry in a Plan 9 a.out symbol table section."
      },
      {
        "name": "fileTest",
        "desc": ""
      },
      {
        "name": "formatError",
        "desc": "formatError is returned by some operations if the data does not have the correct format for an object file."
      },
      {
        "name": "prog",
        "desc": "Plan 9 Program header."
      },
      {
        "name": "sym",
        "desc": "Plan 9 symbol table entries."
      }
    ]
  },
  {
    "name": "embed",
    "desc": "Package embed provides access to files embedded in the running Go program.  Go source files that import \"embed\" can use the //go:embed directive to initialize a variable of type string, []byte, or [FS] with the contents of files read from the package directory or subdirectories at compile time.  For example, here are three ways to embed a file named hello.txt and then print its contents at run time.  Embedding one file into a string:  \timport _ \"embed\"  \t//go:embed hello.txt \tvar s string \tprint(s)  Embedding one file into a slice of bytes:  \timport _ \"embed\"  \t//go:embed hello.txt \tvar b []byte \tprint(string(b))  Embedded one or more files into a file system:  \timport \"embed\"  \t//go:embed hello.txt \tvar f embed.FS \tdata, _ := f.ReadFile(\"hello.txt\") \tprint(string(data))  # Directives  A //go:embed directive above a variable declaration specifies which files to embed, using one or more path.Match patterns.  The directive must immediately precede a line containing the declaration of a single variable. Only blank lines and ‘//’ line comments are permitted between the directive and the declaration.  The type of the variable must be a string type, or a slice of a byte type, or [FS] (or an alias of [FS]).  For example:  \tpackage server  \timport \"embed\"  \t// content holds our static web server content. \t//go:embed image/* template/* \t//go:embed html/index.html \tvar content embed.FS  The Go build system will recognize the directives and arrange for the declared variable (in the example above, content) to be populated with the matching files from the file system.  The //go:embed directive accepts multiple space-separated patterns for brevity, but it can also be repeated, to avoid very long lines when there are many patterns. The patterns are interpreted relative to the package directory containing the source file. The path separator is a forward slash, even on Windows systems. Patterns may not contain ‘.’ or ‘..’ or empty path elements, nor may they begin or end with a slash. To match everything in the current directory, use ‘*’ instead of ‘.’. To allow for naming files with spaces in their names, patterns can be written as Go double-quoted or back-quoted string literals.  If a pattern names a directory, all files in the subtree rooted at that directory are embedded (recursively), except that files with names beginning with ‘.’ or ‘_’ are excluded. So the variable in the above example is almost equivalent to:  \t// content is our static web server content. \t//go:embed image template html/index.html \tvar content embed.FS  The difference is that ‘image/*’ embeds ‘image/.tempfile’ while ‘image’ does not. Neither embeds ‘image/dir/.tempfile’.  If a pattern begins with the prefix ‘all:’, then the rule for walking directories is changed to include those files beginning with ‘.’ or ‘_’. For example, ‘all:image’ embeds both ‘image/.tempfile’ and ‘image/dir/.tempfile’.  The //go:embed directive can be used with both exported and unexported variables, depending on whether the package wants to make the data available to other packages. It can only be used with variables at package scope, not with local variables.  Patterns must not match files outside the package's module, such as ‘.git/*’, symbolic links, 'vendor/', or any directories containing go.mod (these are separate modules). Patterns must not match files whose names include the special punctuation characters  \" * \u003c \u003e ? ` ' | / \\ and :. Matches for empty directories are ignored. After that, each pattern in a //go:embed line must match at least one file or non-empty directory.  If any patterns are invalid or have invalid matches, the build will fail.  # Strings and Bytes  The //go:embed line for a variable of type string or []byte can have only a single pattern, and that pattern can match only a single file. The string or []byte is initialized with the contents of that file.  The //go:embed directive requires importing \"embed\", even when using a string or []byte. In source files that don't refer to [embed.FS], use a blank import (import _ \"embed\").  # File Systems  For embedding a single file, a variable of type string or []byte is often best. The [FS] type enables embedding a tree of files, such as a directory of static web server content, as in the example above.  FS implements the [io/fs] package's [FS] interface, so it can be used with any package that understands file systems, including [net/http], [text/template], and [html/template].  For example, given the content variable in the example above, we can write:  \thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(content))))  \ttemplate.ParseFS(content, \"*.tmpl\")  # Tools  To support tools that analyze Go packages, the patterns found in //go:embed lines are available in “go list” output. See the EmbedPatterns, TestEmbedPatterns, and XTestEmbedPatterns fields in the “go help list” output.",
    "functions": [
      {
        "name": "sortSearch",
        "desc": "sortSearch is like sort.Search, avoiding an import."
      },
      {
        "name": "split",
        "desc": "split splits the name into dir and elem as described in the comment in the FS struct above. isDir reports whether the final trailing slash was present, indicating that name is a directory."
      },
      {
        "name": "Open",
        "desc": "Open opens the named file for reading and returns it as an [fs.File].  The returned file implements [io.Seeker] and [io.ReaderAt] when the file is not a directory."
      },
      {
        "name": "ReadDir",
        "desc": "ReadDir reads and returns the entire named directory."
      },
      {
        "name": "ReadFile",
        "desc": "ReadFile reads and returns the content of the named file."
      },
      {
        "name": "lookup",
        "desc": "lookup returns the named file, or nil if it is not present."
      },
      {
        "name": "readDir",
        "desc": "readDir returns the list of files corresponding to the directory dir."
      },
      {
        "name": "Info",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadDir",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadAt",
        "desc": ""
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "FS",
        "desc": "An FS is a read-only collection of files, usually initialized with a //go:embed directive. When declared without a //go:embed directive, an FS is an empty file system.  An FS is a read-only value, so it is safe to use from multiple goroutines simultaneously and also safe to assign values of type FS to each other.  FS implements fs.FS, so it can be used with any package that understands file system interfaces, including net/http, text/template, and html/template.  See the package documentation for more details about initializing an FS."
      },
      {
        "name": "file",
        "desc": "A file is a single file in the FS. It implements fs.FileInfo and fs.DirEntry."
      },
      {
        "name": "openDir",
        "desc": "An openDir is a directory open for reading."
      },
      {
        "name": "openFile",
        "desc": "An openFile is a regular file open for reading."
      }
    ]
  },
  {
    "name": "encoding",
    "desc": "Package encoding defines interfaces shared by other packages that convert data to and from byte-level and textual representations. Packages that check for these interfaces include encoding/gob, encoding/json, and encoding/xml. As a result, implementing an interface once can make a type useful in multiple encodings. Standard types that implement these interfaces include time.Time and net.IP. The interfaces come in pairs that produce and consume encoded data.  Adding encoding/decoding methods to existing types may constitute a breaking change, as they can be used for serialization in communicating with programs written with different library versions. The policy for packages maintained by the Go project is to only allow the addition of marshaling functions if no existing, reasonable marshaling exists.",
    "functions": null,
    "types": [
      {
        "name": "BinaryAppender",
        "desc": "BinaryAppender is the interface implemented by an object that can append the binary representation of itself. If a type implements both [BinaryAppender] and [BinaryMarshaler], then v.MarshalBinary() must be semantically identical to v.AppendBinary(nil)."
      },
      {
        "name": "BinaryMarshaler",
        "desc": "BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form.  MarshalBinary encodes the receiver into a binary form and returns the result."
      },
      {
        "name": "BinaryUnmarshaler",
        "desc": "BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself.  UnmarshalBinary must be able to decode the form generated by MarshalBinary. UnmarshalBinary must copy the data if it wishes to retain the data after returning."
      },
      {
        "name": "TextAppender",
        "desc": "TextAppender is the interface implemented by an object that can append the textual representation of itself. If a type implements both [TextAppender] and [TextMarshaler], then v.MarshalText() must be semantically identical to v.AppendText(nil)."
      },
      {
        "name": "TextMarshaler",
        "desc": "TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.  MarshalText encodes the receiver into UTF-8-encoded text and returns the result."
      },
      {
        "name": "TextUnmarshaler",
        "desc": "TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.  UnmarshalText must be able to decode the form generated by MarshalText. UnmarshalText must copy the text if it wishes to retain the text after returning."
      }
    ]
  },
  {
    "name": "encoding/ascii85",
    "desc": "Package ascii85 implements the ascii85 data encoding as used in the btoa tool and Adobe's PostScript and PDF document formats.",
    "functions": [
      {
        "name": "Decode",
        "desc": "Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a [CorruptInputError]. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in \u003c~ and ~\u003e symbols. Decode expects these to have been stripped by the caller.  If flush is true, Decode assumes that src represents the end of the input stream and processes it completely rather than wait for the completion of another 32-bit block.  [NewDecoder] wraps an [io.Reader] interface around Decode."
      },
      {
        "name": "Encode",
        "desc": "Encode encodes src into at most [MaxEncodedLen](len(src)) bytes of dst, returning the actual number of bytes written.  The encoding handles 4-byte chunks, using a special encoding for the last fragment, so Encode is not appropriate for use on individual blocks of a large data stream. Use [NewEncoder] instead.  Often, ascii85-encoded data is wrapped in \u003c~ and ~\u003e symbols. Encode does not add these."
      },
      {
        "name": "MaxEncodedLen",
        "desc": "MaxEncodedLen returns the maximum length of an encoding of n source bytes."
      },
      {
        "name": "NewDecoder",
        "desc": "NewDecoder constructs a new ascii85 stream decoder."
      },
      {
        "name": "NewEncoder",
        "desc": "NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block."
      },
      {
        "name": "TestBig",
        "desc": ""
      },
      {
        "name": "TestDecode",
        "desc": ""
      },
      {
        "name": "TestDecodeCorrupt",
        "desc": ""
      },
      {
        "name": "TestDecoder",
        "desc": ""
      },
      {
        "name": "TestDecoderBuffering",
        "desc": ""
      },
      {
        "name": "TestDecoderInternalWhitespace",
        "desc": ""
      },
      {
        "name": "TestEncode",
        "desc": ""
      },
      {
        "name": "TestEncoder",
        "desc": ""
      },
      {
        "name": "TestEncoderBuffering",
        "desc": ""
      },
      {
        "name": "strip85",
        "desc": ""
      },
      {
        "name": "testEqual",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close flushes any pending output from the encoder. It is an error to call Write after calling Close."
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "CorruptInputError",
        "desc": ""
      },
      {
        "name": "decoder",
        "desc": ""
      },
      {
        "name": "encoder",
        "desc": ""
      },
      {
        "name": "testpair",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/asn1",
    "desc": "Package asn1 implements parsing of DER-encoded ASN.1 data structures, as defined in ITU-T Rec X.690.  See also “A Layman's Guide to a Subset of ASN.1, BER, and DER,” http://luca.ntop.org/Teaching/Appunti/asn1.html.",
    "functions": [
      {
        "name": "BenchmarkMarshal",
        "desc": ""
      },
      {
        "name": "BenchmarkObjectIdentifierString",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshal",
        "desc": ""
      },
      {
        "name": "Marshal",
        "desc": "Marshal returns the ASN.1 encoding of val.  In addition to the struct tags recognized by Unmarshal, the following can be used:  \tia5:         causes strings to be marshaled as ASN.1, IA5String values \tomitempty:   causes empty slices to be skipped \tprintable:   causes strings to be marshaled as ASN.1, PrintableString values \tutf8:        causes strings to be marshaled as ASN.1, UTF8String values \tnumeric:     causes strings to be marshaled as ASN.1, NumericString values \tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values \tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values"
      },
      {
        "name": "MarshalWithParams",
        "desc": "MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags."
      },
      {
        "name": "TestBMPString",
        "desc": ""
      },
      {
        "name": "TestBitString",
        "desc": ""
      },
      {
        "name": "TestBitStringAt",
        "desc": ""
      },
      {
        "name": "TestBitStringRightAlign",
        "desc": ""
      },
      {
        "name": "TestCertificate",
        "desc": ""
      },
      {
        "name": "TestCertificateWithNUL",
        "desc": ""
      },
      {
        "name": "TestExplicitTagRawValueStruct",
        "desc": ""
      },
      {
        "name": "TestExplicitTaggedTime",
        "desc": ""
      },
      {
        "name": "TestGeneralizedTime",
        "desc": ""
      },
      {
        "name": "TestImplicitTaggedTime",
        "desc": ""
      },
      {
        "name": "TestImplicitTypeRoundtrip",
        "desc": ""
      },
      {
        "name": "TestInvalidUTF8",
        "desc": ""
      },
      {
        "name": "TestIssue11130",
        "desc": ""
      },
      {
        "name": "TestIssue68241",
        "desc": ""
      },
      {
        "name": "TestMarshal",
        "desc": ""
      },
      {
        "name": "TestMarshalError",
        "desc": ""
      },
      {
        "name": "TestMarshalNilValue",
        "desc": ""
      },
      {
        "name": "TestMarshalOID",
        "desc": ""
      },
      {
        "name": "TestMarshalWithParams",
        "desc": ""
      },
      {
        "name": "TestNonMinimalEncodedOID",
        "desc": ""
      },
      {
        "name": "TestNull",
        "desc": ""
      },
      {
        "name": "TestObjectIdentifier",
        "desc": ""
      },
      {
        "name": "TestObjectIdentifierEqual",
        "desc": ""
      },
      {
        "name": "TestParseBigInt",
        "desc": ""
      },
      {
        "name": "TestParseBool",
        "desc": ""
      },
      {
        "name": "TestParseFieldParameters",
        "desc": ""
      },
      {
        "name": "TestParseInt32",
        "desc": ""
      },
      {
        "name": "TestParseInt64",
        "desc": ""
      },
      {
        "name": "TestParseTagAndLength",
        "desc": ""
      },
      {
        "name": "TestParsingMemoryConsumption",
        "desc": ""
      },
      {
        "name": "TestRawStructs",
        "desc": ""
      },
      {
        "name": "TestSetEncoder",
        "desc": ""
      },
      {
        "name": "TestSetEncoderSETSliceSuffix",
        "desc": ""
      },
      {
        "name": "TestStringSlice",
        "desc": ""
      },
      {
        "name": "TestTaggedRawValue",
        "desc": ""
      },
      {
        "name": "TestTruncatedExplicitTag",
        "desc": ""
      },
      {
        "name": "TestUTCTime",
        "desc": ""
      },
      {
        "name": "TestUnexportedStructField",
        "desc": ""
      },
      {
        "name": "TestUnmarshal",
        "desc": ""
      },
      {
        "name": "TestUnmarshalInvalidUTF8",
        "desc": ""
      },
      {
        "name": "TestUnmarshalWithNilOrNonPointer",
        "desc": ""
      },
      {
        "name": "Unmarshal",
        "desc": "Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names. If val is nil or not a pointer, Unmarshal returns an error.  After parsing b, any bytes that were leftover and not used to fill val will be returned in rest. When parsing a SEQUENCE into a struct, any trailing elements of the SEQUENCE that do not have matching fields in val will not be included in rest, as these are considered valid elements of the SEQUENCE and not trailing data.    - An ASN.1 INTEGER can be written to an int, int32, int64,     or *[big.Int].     If the encoded value does not fit in the Go type,     Unmarshal returns a parse error.    - An ASN.1 BIT STRING can be written to a [BitString].    - An ASN.1 OCTET STRING can be written to a []byte.    - An ASN.1 OBJECT IDENTIFIER can be written to an [ObjectIdentifier].    - An ASN.1 ENUMERATED can be written to an [Enumerated].    - An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a [time.Time].    - An ASN.1 PrintableString, IA5String, or NumericString can be written to a string.    - Any of the above ASN.1 values can be written to an interface{}.     The value stored in the interface has the corresponding Go type.     For integers, that type is int64.    - An ASN.1 SEQUENCE OF x or SET OF x can be written     to a slice if an x can be written to the slice's element type.    - An ASN.1 SEQUENCE or SET can be written to a struct     if each of the elements in the sequence can be     written to the corresponding element in the struct.  The following tags on struct fields have special meaning to Unmarshal:  \tapplication specifies that an APPLICATION tag is used \tprivate     specifies that a PRIVATE tag is used \tdefault:x   sets the default value for optional integer fields (only used if optional is also present) \texplicit    specifies that an additional, explicit tag wraps the implicit one \toptional    marks the field as ASN.1 OPTIONAL \tset         causes a SET, rather than a SEQUENCE type to be expected \ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC  When decoding an ASN.1 value with an IMPLICIT tag into a string field, Unmarshal will default to a PrintableString, which doesn't support characters such as '@' and '\u0026'. To force other encodings, use the following tags:  \tia5     causes strings to be unmarshaled as ASN.1 IA5String values \tnumeric causes strings to be unmarshaled as ASN.1 NumericString values \tutf8    causes strings to be unmarshaled as ASN.1 UTF8String values  When decoding an ASN.1 value with an IMPLICIT tag into a time.Time field, Unmarshal will default to a UTCTime, which doesn't support time zones or fractional seconds. To force usage of GeneralizedTime, use the following tag:  \tgeneralized causes time.Times to be unmarshaled as ASN.1 GeneralizedTime values  If the type of the first field of a structure is RawContent then the raw ASN1 contents of the struct will be stored in it.  If the name of a slice type ends with \"SET\" then it's treated as if the \"set\" tag was set on it. This results in interpreting the type as a SET OF x rather than a SEQUENCE OF x. This can be used with nested slices where a struct tag cannot be given.  Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error."
      },
      {
        "name": "UnmarshalWithParams",
        "desc": "UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags."
      },
      {
        "name": "appendBase128Int",
        "desc": ""
      },
      {
        "name": "appendFourDigits",
        "desc": ""
      },
      {
        "name": "appendGeneralizedTime",
        "desc": ""
      },
      {
        "name": "appendLength",
        "desc": ""
      },
      {
        "name": "appendTagAndLength",
        "desc": ""
      },
      {
        "name": "appendTimeCommon",
        "desc": ""
      },
      {
        "name": "appendTwoDigits",
        "desc": ""
      },
      {
        "name": "appendUTCTime",
        "desc": ""
      },
      {
        "name": "base128IntLength",
        "desc": ""
      },
      {
        "name": "canHaveDefaultValue",
        "desc": "canHaveDefaultValue reports whether k is a Kind that we will set a default value for. (A signed integer, essentially.)"
      },
      {
        "name": "checkInteger",
        "desc": "checkInteger returns nil if the given bytes are a valid DER-encoded INTEGER and an error otherwise."
      },
      {
        "name": "farFuture",
        "desc": ""
      },
      {
        "name": "getUniversalType",
        "desc": "Given a reflected Go type, getUniversalType returns the default tag number and expected compound flag."
      },
      {
        "name": "invalidLength",
        "desc": "invalidLength reports whether offset + length \u003e sliceLength, or if the addition would overflow."
      },
      {
        "name": "isNumeric",
        "desc": "isNumeric reports whether the given b is in the ASN.1 NumericString set."
      },
      {
        "name": "isPrintable",
        "desc": "isPrintable reports whether the given b is in the ASN.1 PrintableString set. If asterisk is allowAsterisk then '*' is also allowed, reflecting existing practice. If ampersand is allowAmpersand then '\u0026' is allowed as well."
      },
      {
        "name": "lengthLength",
        "desc": ""
      },
      {
        "name": "newBool",
        "desc": ""
      },
      {
        "name": "newInt",
        "desc": ""
      },
      {
        "name": "newInt64",
        "desc": ""
      },
      {
        "name": "newString",
        "desc": ""
      },
      {
        "name": "outsideUTCRange",
        "desc": ""
      },
      {
        "name": "parseBMPString",
        "desc": "parseBMPString parses an ASN.1 BMPString (Basic Multilingual Plane of ISO/IEC/ITU 10646-1) from the given byte slice and returns it."
      },
      {
        "name": "parseBase128Int",
        "desc": "parseBase128Int parses a base-128 encoded int from the given offset in the given byte slice. It returns the value and the new offset."
      },
      {
        "name": "parseBigInt",
        "desc": "parseBigInt treats the given bytes as a big-endian, signed integer and returns the result."
      },
      {
        "name": "parseBool",
        "desc": ""
      },
      {
        "name": "parseField",
        "desc": "parseField is the main parsing function. Given a byte slice and an offset into the array, it will try to parse a suitable ASN.1 value out and store it in the given Value."
      },
      {
        "name": "parseGeneralizedTime",
        "desc": "parseGeneralizedTime parses the GeneralizedTime from the given byte slice and returns the resulting time."
      },
      {
        "name": "parseIA5String",
        "desc": "parseIA5String parses an ASN.1 IA5String (ASCII string) from the given byte slice and returns it."
      },
      {
        "name": "parseInt32",
        "desc": "parseInt32 treats the given bytes as a big-endian, signed integer and returns the result."
      },
      {
        "name": "parseInt64",
        "desc": "parseInt64 treats the given bytes as a big-endian, signed integer and returns the result."
      },
      {
        "name": "parseNumericString",
        "desc": "parseNumericString parses an ASN.1 NumericString from the given byte array and returns it."
      },
      {
        "name": "parsePrintableString",
        "desc": "parsePrintableString parses an ASN.1 PrintableString from the given byte array and returns it."
      },
      {
        "name": "parseSequenceOf",
        "desc": "parseSequenceOf is used for SEQUENCE OF and SET OF values. It tries to parse a number of ASN.1 values from the given byte slice and returns them as a slice of Go values of the given type."
      },
      {
        "name": "parseT61String",
        "desc": "parseT61String parses an ASN.1 T61String (8-bit clean string) from the given byte slice and returns it."
      },
      {
        "name": "parseUTCTime",
        "desc": ""
      },
      {
        "name": "parseUTF8String",
        "desc": "parseUTF8String parses an ASN.1 UTF8String (raw UTF-8) from the given byte array and returns it."
      },
      {
        "name": "setDefaultValue",
        "desc": "setDefaultValue is used to install a default value, from a tag string, into a Value. It is successful if the field was optional, even if a default value wasn't provided or it failed to install it into the Value."
      },
      {
        "name": "stripTagAndLength",
        "desc": ""
      },
      {
        "name": "At",
        "desc": "At returns the bit at the given index. If the index is out of range it returns 0."
      },
      {
        "name": "RightAlign",
        "desc": "RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether oi and other represent the same identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "AlgorithmIdentifier",
        "desc": ""
      },
      {
        "name": "AttributeTypeAndValue",
        "desc": ""
      },
      {
        "name": "BitString",
        "desc": "BitString is the structure to use when you want an ASN.1 BIT STRING type. A bit string is padded up to the nearest byte in memory and the number of valid bits is recorded. Padding bits will be zero."
      },
      {
        "name": "Certificate",
        "desc": ""
      },
      {
        "name": "Enumerated",
        "desc": "An Enumerated is represented as a plain int."
      },
      {
        "name": "Flag",
        "desc": "A Flag accepts any data and is set to true if present."
      },
      {
        "name": "ObjectIdentifier",
        "desc": "An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER."
      },
      {
        "name": "PublicKeyInfo",
        "desc": ""
      },
      {
        "name": "RDNSequence",
        "desc": ""
      },
      {
        "name": "RawContent",
        "desc": "RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type."
      },
      {
        "name": "RawValue",
        "desc": "A RawValue represents an undecoded ASN.1 object."
      },
      {
        "name": "RelativeDistinguishedNameSET",
        "desc": ""
      },
      {
        "name": "StructuralError",
        "desc": "A StructuralError suggests that the ASN.1 data is valid, but the Go type which is receiving it doesn't match."
      },
      {
        "name": "SyntaxError",
        "desc": "A SyntaxError suggests that the ASN.1 data is invalid."
      },
      {
        "name": "TBSCertificate",
        "desc": ""
      },
      {
        "name": "TestBigInt",
        "desc": ""
      },
      {
        "name": "TestContextSpecificTags",
        "desc": ""
      },
      {
        "name": "TestContextSpecificTags2",
        "desc": ""
      },
      {
        "name": "TestContextSpecificTags3",
        "desc": ""
      },
      {
        "name": "TestElementsAfterString",
        "desc": ""
      },
      {
        "name": "TestObjectIdentifierStruct",
        "desc": ""
      },
      {
        "name": "TestSet",
        "desc": ""
      },
      {
        "name": "Validity",
        "desc": ""
      },
      {
        "name": "ampersandFlag",
        "desc": ""
      },
      {
        "name": "applicationTest",
        "desc": ""
      },
      {
        "name": "asteriskFlag",
        "desc": ""
      },
      {
        "name": "bigIntStruct",
        "desc": ""
      },
      {
        "name": "bitStringEncoder",
        "desc": ""
      },
      {
        "name": "bitStringRightAlignTest",
        "desc": ""
      },
      {
        "name": "bitStringTest",
        "desc": ""
      },
      {
        "name": "boolTest",
        "desc": ""
      },
      {
        "name": "byteEncoder",
        "desc": ""
      },
      {
        "name": "bytesEncoder",
        "desc": ""
      },
      {
        "name": "defaultTest",
        "desc": ""
      },
      {
        "name": "encoder",
        "desc": "encoder represents an ASN.1 element that is waiting to be marshaled."
      },
      {
        "name": "explicitTagTest",
        "desc": ""
      },
      {
        "name": "explicitTaggedTimeTest",
        "desc": ""
      },
      {
        "name": "exported",
        "desc": ""
      },
      {
        "name": "fieldParameters",
        "desc": "fieldParameters is the parsed representation of tag string from a structure field."
      },
      {
        "name": "flagTest",
        "desc": ""
      },
      {
        "name": "generalizedTimeTest",
        "desc": ""
      },
      {
        "name": "genericStringTest",
        "desc": ""
      },
      {
        "name": "ia5StringTest",
        "desc": ""
      },
      {
        "name": "implicitTagTest",
        "desc": ""
      },
      {
        "name": "implicitTaggedTimeTest",
        "desc": ""
      },
      {
        "name": "int32Test",
        "desc": ""
      },
      {
        "name": "int64Encoder",
        "desc": ""
      },
      {
        "name": "int64Test",
        "desc": ""
      },
      {
        "name": "intStruct",
        "desc": ""
      },
      {
        "name": "invalidUTF8Test",
        "desc": ""
      },
      {
        "name": "invalidUnmarshalError",
        "desc": "An invalidUnmarshalError describes an invalid argument passed to Unmarshal. (The argument to Unmarshal must be a non-nil pointer.)"
      },
      {
        "name": "marshalErrTest",
        "desc": ""
      },
      {
        "name": "marshalTest",
        "desc": ""
      },
      {
        "name": "marshalWithParamsTest",
        "desc": ""
      },
      {
        "name": "multiEncoder",
        "desc": ""
      },
      {
        "name": "nestedStruct",
        "desc": ""
      },
      {
        "name": "numericStringTest",
        "desc": ""
      },
      {
        "name": "objectIdentifierTest",
        "desc": ""
      },
      {
        "name": "oiEqualTest",
        "desc": ""
      },
      {
        "name": "oidEncoder",
        "desc": ""
      },
      {
        "name": "omitEmptyTest",
        "desc": ""
      },
      {
        "name": "optionalRawValueTest",
        "desc": ""
      },
      {
        "name": "parseFieldParametersTest",
        "desc": ""
      },
      {
        "name": "printableStringTest",
        "desc": ""
      },
      {
        "name": "privateTest",
        "desc": ""
      },
      {
        "name": "rawContentsStruct",
        "desc": ""
      },
      {
        "name": "rawStructTest",
        "desc": ""
      },
      {
        "name": "setEncoder",
        "desc": ""
      },
      {
        "name": "stringEncoder",
        "desc": ""
      },
      {
        "name": "tagAndLength",
        "desc": ""
      },
      {
        "name": "tagAndLengthTest",
        "desc": ""
      },
      {
        "name": "taggedEncoder",
        "desc": ""
      },
      {
        "name": "testSET",
        "desc": ""
      },
      {
        "name": "timeTest",
        "desc": ""
      },
      {
        "name": "truncatedExplicitTagTest",
        "desc": ""
      },
      {
        "name": "twoIntStruct",
        "desc": ""
      },
      {
        "name": "unexported",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/base32",
    "desc": "",
    "functions": [
      {
        "name": "ExampleEncoding_Decode",
        "desc": ""
      },
      {
        "name": "ExampleEncoding_DecodeString",
        "desc": ""
      },
      {
        "name": "ExampleEncoding_Encode",
        "desc": ""
      },
      {
        "name": "ExampleEncoding_EncodeToString",
        "desc": ""
      },
      {
        "name": "ExampleNewEncoder",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "encoding/base64",
    "desc": "Package base64 implements base64 encoding as specified by RFC 4648.",
    "functions": [
      {
        "name": "BenchmarkDecodeString",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeToString",
        "desc": ""
      },
      {
        "name": "BenchmarkNewEncoding",
        "desc": ""
      },
      {
        "name": "NewDecoder",
        "desc": "NewDecoder constructs a new base64 stream decoder."
      },
      {
        "name": "NewEncoder",
        "desc": "NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks."
      },
      {
        "name": "TestBig",
        "desc": ""
      },
      {
        "name": "TestDecode",
        "desc": ""
      },
      {
        "name": "TestDecodeBounds",
        "desc": ""
      },
      {
        "name": "TestDecodeCorrupt",
        "desc": ""
      },
      {
        "name": "TestDecodedLen",
        "desc": ""
      },
      {
        "name": "TestDecoder",
        "desc": ""
      },
      {
        "name": "TestDecoderBuffering",
        "desc": ""
      },
      {
        "name": "TestDecoderIssue15656",
        "desc": ""
      },
      {
        "name": "TestDecoderIssue3577",
        "desc": "tests that we don't ignore errors from our underlying reader"
      },
      {
        "name": "TestDecoderIssue4779",
        "desc": ""
      },
      {
        "name": "TestDecoderIssue7733",
        "desc": ""
      },
      {
        "name": "TestDecoderRaw",
        "desc": ""
      },
      {
        "name": "TestEncode",
        "desc": ""
      },
      {
        "name": "TestEncodedLen",
        "desc": ""
      },
      {
        "name": "TestEncoder",
        "desc": ""
      },
      {
        "name": "TestEncoderBuffering",
        "desc": ""
      },
      {
        "name": "TestNewLineCharacters",
        "desc": ""
      },
      {
        "name": "assemble32",
        "desc": "assemble32 assembles 4 base64 digits into 3 bytes. Each digit comes from the decode map, and will be 0xff if it came from an invalid character."
      },
      {
        "name": "assemble64",
        "desc": "assemble64 assembles 8 base64 digits into 6 bytes. Each digit comes from the decode map, and will be 0xff if it came from an invalid character."
      },
      {
        "name": "decodedLen",
        "desc": ""
      },
      {
        "name": "funnyRef",
        "desc": ""
      },
      {
        "name": "rawRef",
        "desc": "Convert a reference string to raw, unpadded format"
      },
      {
        "name": "rawURLRef",
        "desc": "Both URL and unpadding conversions"
      },
      {
        "name": "stdRef",
        "desc": "Do nothing to a reference base64 string (leave in standard format)"
      },
      {
        "name": "testEqual",
        "desc": ""
      },
      {
        "name": "urlRef",
        "desc": "Convert a reference string to URL-encoding"
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "AppendDecode",
        "desc": "AppendDecode appends the base64 decoded src to dst and returns the extended buffer. If the input is malformed, it returns the partially decoded src and an error. New line characters (\\r and \\n) are ignored."
      },
      {
        "name": "AppendEncode",
        "desc": "AppendEncode appends the base64 encoded src to dst and returns the extended buffer."
      },
      {
        "name": "Decode",
        "desc": "Decode decodes src using the encoding enc. It writes at most [Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes written. The caller must ensure that dst is large enough to hold all the decoded data. If src contains invalid base64 data, it will return the number of bytes successfully written and [CorruptInputError]. New line characters (\\r and \\n) are ignored."
      },
      {
        "name": "DecodeString",
        "desc": "DecodeString returns the bytes represented by the base64 string s. If the input is malformed, it returns the partially decoded data and [CorruptInputError]. New line characters (\\r and \\n) are ignored."
      },
      {
        "name": "DecodedLen",
        "desc": "DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base64-encoded data."
      },
      {
        "name": "Encode",
        "desc": "Encode encodes src using the encoding enc, writing [Encoding.EncodedLen](len(src)) bytes to dst.  The encoding pads the output to a multiple of 4 bytes, so Encode is not appropriate for use on individual blocks of a large data stream. Use [NewEncoder] instead."
      },
      {
        "name": "EncodeToString",
        "desc": "EncodeToString returns the base64 encoding of src."
      },
      {
        "name": "EncodedLen",
        "desc": "EncodedLen returns the length in bytes of the base64 encoding of an input buffer of length n."
      },
      {
        "name": "Strict",
        "desc": "Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5.  Note that the input is still malleable, as new line characters (CR and LF) are still ignored."
      },
      {
        "name": "WithPadding",
        "desc": "WithPadding creates a new encoding identical to enc except with a specified padding character, or [NoPadding] to disable padding. The padding character must not be '\\r' or '\\n', must not be contained in the encoding's alphabet, must not be negative, and must be a rune equal or below '\\xff'. Padding characters above '\\x7f' are encoded as their exact byte value rather than using the UTF-8 representation of the codepoint."
      },
      {
        "name": "decodeQuantum",
        "desc": "decodeQuantum decodes up to 4 base64 bytes. The received parameters are the destination buffer dst, the source buffer src and an index in the source buffer si. It returns the number of bytes read from src, the number of bytes written to dst, and an error, if any."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close flushes any pending output from the encoder. It is an error to call Write after calling Close."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "CorruptInputError",
        "desc": ""
      },
      {
        "name": "Encoding",
        "desc": "An Encoding is a radix 64 encoding/decoding scheme, defined by a 64-character alphabet. The most common encoding is the \"base64\" encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421).  RFC 4648 also defines an alternate encoding, which is the standard encoding with - and _ substituted for + and /."
      },
      {
        "name": "decoder",
        "desc": ""
      },
      {
        "name": "encoder",
        "desc": ""
      },
      {
        "name": "encodingTest",
        "desc": ""
      },
      {
        "name": "faultInjectReader",
        "desc": "faultInjectReader returns data from source, rate-limited and with the errors as written to nextc."
      },
      {
        "name": "newlineFilteringReader",
        "desc": ""
      },
      {
        "name": "nextRead",
        "desc": ""
      },
      {
        "name": "testpair",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/binary",
    "desc": "Package binary implements simple translation between numbers and byte sequences and encoding and decoding of varints.  Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values.  The varint functions encode and decode single integer values using a variable-length encoding; smaller values require fewer bytes. For a specification, see https://developers.google.com/protocol-buffers/docs/encoding.  This package favors simplicity over efficiency. Clients that require high-performance serialization, especially for large data structures, should look at more advanced solutions such as the [encoding/gob] package or [google.golang.org/protobuf] for protocol buffers.",
    "functions": [
      {
        "name": "Append",
        "desc": "Append appends the binary representation of data to buf. buf may be nil, in which case a new buffer will be allocated. See [Write] on which data are acceptable. It returns the (possibly extended) buffer containing data or an error."
      },
      {
        "name": "AppendUvarint",
        "desc": "AppendUvarint appends the varint-encoded form of x, as generated by [PutUvarint], to buf and returns the extended buffer."
      },
      {
        "name": "AppendVarint",
        "desc": "AppendVarint appends the varint-encoded form of x, as generated by [PutVarint], to buf and returns the extended buffer."
      },
      {
        "name": "BenchmarkAppendInts",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendSlice1000Int32s",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendSlice1000Structs",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendStruct",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendUint16",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendUint32",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendUint64",
        "desc": ""
      },
      {
        "name": "BenchmarkLittleEndianAppendUint16",
        "desc": ""
      },
      {
        "name": "BenchmarkLittleEndianAppendUint32",
        "desc": ""
      },
      {
        "name": "BenchmarkLittleEndianAppendUint64",
        "desc": ""
      },
      {
        "name": "BenchmarkLittleEndianPutUint16",
        "desc": ""
      },
      {
        "name": "BenchmarkLittleEndianPutUint32",
        "desc": ""
      },
      {
        "name": "BenchmarkLittleEndianPutUint64",
        "desc": ""
      },
      {
        "name": "BenchmarkPutUint16",
        "desc": ""
      },
      {
        "name": "BenchmarkPutUint32",
        "desc": ""
      },
      {
        "name": "BenchmarkPutUint64",
        "desc": ""
      },
      {
        "name": "BenchmarkPutUvarint32",
        "desc": ""
      },
      {
        "name": "BenchmarkPutUvarint64",
        "desc": ""
      },
      {
        "name": "BenchmarkReadFloats",
        "desc": ""
      },
      {
        "name": "BenchmarkReadInts",
        "desc": ""
      },
      {
        "name": "BenchmarkReadSlice1000Float32s",
        "desc": ""
      },
      {
        "name": "BenchmarkReadSlice1000Int32s",
        "desc": ""
      },
      {
        "name": "BenchmarkReadSlice1000Structs",
        "desc": ""
      },
      {
        "name": "BenchmarkReadSlice1000Uint8s",
        "desc": ""
      },
      {
        "name": "BenchmarkReadStruct",
        "desc": ""
      },
      {
        "name": "BenchmarkSize",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteFloats",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteInts",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteSlice1000Float32s",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteSlice1000Int32s",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteSlice1000Structs",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteSlice1000Uint8s",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteStruct",
        "desc": ""
      },
      {
        "name": "Decode",
        "desc": "Decode decodes binary data from buf into data according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes consumed from buf."
      },
      {
        "name": "Encode",
        "desc": "Encode encodes the binary representation of data into buf according to the given byte order. It returns an error if buf is too small, otherwise the number of bytes written into buf."
      },
      {
        "name": "PutUvarint",
        "desc": "PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic."
      },
      {
        "name": "PutVarint",
        "desc": "PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic."
      },
      {
        "name": "Read",
        "desc": "Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.  The error is [io.EOF] only if no bytes were read. If an [io.EOF] happens after reading some but not all the bytes, Read returns [io.ErrUnexpectedEOF]."
      },
      {
        "name": "ReadUvarint",
        "desc": "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64. The error is [io.EOF] only if no bytes were read. If an [io.EOF] happens after reading some but not all the bytes, ReadUvarint returns [io.ErrUnexpectedEOF]."
      },
      {
        "name": "ReadVarint",
        "desc": "ReadVarint reads an encoded signed integer from r and returns it as an int64. The error is [io.EOF] only if no bytes were read. If an [io.EOF] happens after reading some but not all the bytes, ReadVarint returns [io.ErrUnexpectedEOF]."
      },
      {
        "name": "Size",
        "desc": "Size returns how many bytes [Write] would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1."
      },
      {
        "name": "TestAppendAllocs",
        "desc": ""
      },
      {
        "name": "TestBigEndianPtrWrite",
        "desc": ""
      },
      {
        "name": "TestBigEndianRead",
        "desc": ""
      },
      {
        "name": "TestBigEndianWrite",
        "desc": ""
      },
      {
        "name": "TestBlankFields",
        "desc": ""
      },
      {
        "name": "TestBufferTooBigWithOverflow",
        "desc": "Ensure that we catch overflows of bytes going past MaxVarintLen64. See issue https://golang.org/issues/41185"
      },
      {
        "name": "TestBufferTooSmall",
        "desc": ""
      },
      {
        "name": "TestByteOrder",
        "desc": ""
      },
      {
        "name": "TestConstants",
        "desc": ""
      },
      {
        "name": "TestEarlyBoundsChecks",
        "desc": ""
      },
      {
        "name": "TestLittleEndianPtrWrite",
        "desc": ""
      },
      {
        "name": "TestLittleEndianRead",
        "desc": ""
      },
      {
        "name": "TestLittleEndianWrite",
        "desc": ""
      },
      {
        "name": "TestNativeEndian",
        "desc": ""
      },
      {
        "name": "TestNoFixedSize",
        "desc": ""
      },
      {
        "name": "TestNonCanonicalZero",
        "desc": ""
      },
      {
        "name": "TestOverflow",
        "desc": ""
      },
      {
        "name": "TestReadBool",
        "desc": ""
      },
      {
        "name": "TestReadBoolSlice",
        "desc": ""
      },
      {
        "name": "TestReadErrorMsg",
        "desc": ""
      },
      {
        "name": "TestReadInvalidDestination",
        "desc": ""
      },
      {
        "name": "TestReadSlice",
        "desc": ""
      },
      {
        "name": "TestReadTruncated",
        "desc": ""
      },
      {
        "name": "TestSizeAllocs",
        "desc": ""
      },
      {
        "name": "TestSizeInvalid",
        "desc": ""
      },
      {
        "name": "TestSizeStructCache",
        "desc": ""
      },
      {
        "name": "TestSliceRoundTrip",
        "desc": ""
      },
      {
        "name": "TestUnexportedRead",
        "desc": ""
      },
      {
        "name": "TestUvarint",
        "desc": ""
      },
      {
        "name": "TestVarint",
        "desc": ""
      },
      {
        "name": "TestWriteSlice",
        "desc": ""
      },
      {
        "name": "TestWriteT",
        "desc": ""
      },
      {
        "name": "Uvarint",
        "desc": "Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (\u003e 0). If an error occurred, the value is 0 and the number of bytes n is \u003c= 0 meaning:   - n == 0: buf too small;   - n \u003c 0: value larger than 64 bits (overflow) and -n is the number of     bytes read."
      },
      {
        "name": "Varint",
        "desc": "Varint decodes an int64 from buf and returns that value and the number of bytes read (\u003e 0). If an error occurred, the value is 0 and the number of bytes n is \u003c= 0 with the following meaning:   - n == 0: buf too small;   - n \u003c 0: value larger than 64 bits (overflow)     and -n is the number of bytes read."
      },
      {
        "name": "Write",
        "desc": "Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names."
      },
      {
        "name": "checkResult",
        "desc": ""
      },
      {
        "name": "dataSize",
        "desc": "dataSize returns the number of bytes the actual data represented by v occupies in memory. For compound structures, it sums the sizes of the elements. Thus, for instance, for a slice it returns the length of the slice times the element size and does not count the memory occupied by the header. If the type of v is not acceptable, dataSize returns -1."
      },
      {
        "name": "decodeFast",
        "desc": ""
      },
      {
        "name": "encodeFast",
        "desc": ""
      },
      {
        "name": "ensure",
        "desc": "ensure grows buf to length len(buf) + n and returns the grown buffer and a slice starting at the original length of buf (that is, buf2[len(buf):])."
      },
      {
        "name": "intDataSize",
        "desc": "intDataSize returns the size of the data required to represent the data when encoded, and optionally a byte slice containing the encoded data if no conversion is necessary. It returns zero, nil if the type cannot be implemented by the fast path in Read or Write."
      },
      {
        "name": "sizeof",
        "desc": "sizeof returns the size \u003e= 0 of variables for the given type or -1 if the type is not acceptable."
      },
      {
        "name": "testConstant",
        "desc": ""
      },
      {
        "name": "testOverflow",
        "desc": ""
      },
      {
        "name": "testPutUint64SmallSliceLengthPanics",
        "desc": ""
      },
      {
        "name": "testRead",
        "desc": ""
      },
      {
        "name": "testReadInvalidDestination",
        "desc": ""
      },
      {
        "name": "testUint64SmallSliceLengthPanics",
        "desc": ""
      },
      {
        "name": "testUvarint",
        "desc": ""
      },
      {
        "name": "testVarint",
        "desc": ""
      },
      {
        "name": "testWrite",
        "desc": ""
      },
      {
        "name": "AppendUint16",
        "desc": "AppendUint16 appends the bytes of v to b and returns the appended slice."
      },
      {
        "name": "AppendUint32",
        "desc": "AppendUint32 appends the bytes of v to b and returns the appended slice."
      },
      {
        "name": "AppendUint64",
        "desc": "AppendUint64 appends the bytes of v to b and returns the appended slice."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "PutUint16",
        "desc": "PutUint16 stores v into b[0:2]."
      },
      {
        "name": "PutUint32",
        "desc": "PutUint32 stores v into b[0:4]."
      },
      {
        "name": "PutUint64",
        "desc": "PutUint64 stores v into b[0:8]."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Uint16",
        "desc": "Uint16 returns the uint16 representation of b[0:2]."
      },
      {
        "name": "Uint32",
        "desc": "Uint32 returns the uint32 representation of b[0:4]."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 returns the uint64 representation of b[0:8]."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "bool",
        "desc": ""
      },
      {
        "name": "int16",
        "desc": ""
      },
      {
        "name": "int32",
        "desc": ""
      },
      {
        "name": "int64",
        "desc": ""
      },
      {
        "name": "int8",
        "desc": ""
      },
      {
        "name": "skip",
        "desc": ""
      },
      {
        "name": "uint16",
        "desc": ""
      },
      {
        "name": "uint32",
        "desc": ""
      },
      {
        "name": "uint64",
        "desc": ""
      },
      {
        "name": "uint8",
        "desc": ""
      },
      {
        "name": "value",
        "desc": ""
      },
      {
        "name": "bool",
        "desc": ""
      },
      {
        "name": "int16",
        "desc": ""
      },
      {
        "name": "int32",
        "desc": ""
      },
      {
        "name": "int64",
        "desc": ""
      },
      {
        "name": "int8",
        "desc": ""
      },
      {
        "name": "skip",
        "desc": ""
      },
      {
        "name": "uint16",
        "desc": ""
      },
      {
        "name": "uint32",
        "desc": ""
      },
      {
        "name": "uint64",
        "desc": ""
      },
      {
        "name": "uint8",
        "desc": ""
      },
      {
        "name": "value",
        "desc": ""
      },
      {
        "name": "AppendUint16",
        "desc": "AppendUint16 appends the bytes of v to b and returns the appended slice."
      },
      {
        "name": "AppendUint32",
        "desc": "AppendUint32 appends the bytes of v to b and returns the appended slice."
      },
      {
        "name": "AppendUint64",
        "desc": "AppendUint64 appends the bytes of v to b and returns the appended slice."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "PutUint16",
        "desc": "PutUint16 stores v into b[0:2]."
      },
      {
        "name": "PutUint32",
        "desc": "PutUint32 stores v into b[0:4]."
      },
      {
        "name": "PutUint64",
        "desc": "PutUint64 stores v into b[0:8]."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Uint16",
        "desc": "Uint16 returns the uint16 representation of b[0:2]."
      },
      {
        "name": "Uint32",
        "desc": "Uint32 returns the uint32 representation of b[0:4]."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 returns the uint64 representation of b[0:8]."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "AppendByteOrder",
        "desc": "AppendByteOrder specifies how to append 16-, 32-, or 64-bit unsigned integers into a byte slice.  It is implemented by [LittleEndian], [BigEndian], and [NativeEndian]."
      },
      {
        "name": "BlankFields",
        "desc": ""
      },
      {
        "name": "BlankFieldsProbe",
        "desc": ""
      },
      {
        "name": "ByteOrder",
        "desc": "A ByteOrder specifies how to convert byte slices into 16-, 32-, or 64-bit unsigned integers.  It is implemented by [LittleEndian], [BigEndian], and [NativeEndian]."
      },
      {
        "name": "Struct",
        "desc": ""
      },
      {
        "name": "T",
        "desc": ""
      },
      {
        "name": "Unexported",
        "desc": ""
      },
      {
        "name": "bigEndian",
        "desc": ""
      },
      {
        "name": "byteSliceReader",
        "desc": ""
      },
      {
        "name": "coder",
        "desc": ""
      },
      {
        "name": "decoder",
        "desc": ""
      },
      {
        "name": "encoder",
        "desc": ""
      },
      {
        "name": "littleEndian",
        "desc": ""
      },
      {
        "name": "nativeEndian",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/csv",
    "desc": "",
    "functions": [
      {
        "name": "ExampleReader",
        "desc": ""
      },
      {
        "name": "ExampleReader_ReadAll",
        "desc": ""
      },
      {
        "name": "ExampleReader_options",
        "desc": "This example shows how csv.Reader can be configured to handle other types of CSV files."
      },
      {
        "name": "ExampleWriter",
        "desc": ""
      },
      {
        "name": "ExampleWriter_WriteAll",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "encoding/gob",
    "desc": "",
    "functions": [
      {
        "name": "Example_basic",
        "desc": "This example shows the basic usage of the package: Create an encoder, transmit some values, receive them with a decoder."
      },
      {
        "name": "Example_encodeDecode",
        "desc": "This example transmits a value that implements the custom encoding and decoding methods."
      },
      {
        "name": "Example_interface",
        "desc": "This example shows how to encode an interface value. The key distinction from regular types is to register the concrete type that implements the interface."
      },
      {
        "name": "interfaceEncode",
        "desc": "interfaceEncode encodes the interface value into the encoder."
      },
      {
        "name": "Hypotenuse",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": "UnmarshalBinary modifies the receiver so it must take a pointer receiver."
      }
    ],
    "types": [
      {
        "name": "P",
        "desc": ""
      },
      {
        "name": "Point",
        "desc": ""
      },
      {
        "name": "Pythagoras",
        "desc": ""
      },
      {
        "name": "Q",
        "desc": ""
      },
      {
        "name": "Vector",
        "desc": "The Vector type has unexported fields, which the package cannot access. We therefore write a BinaryMarshal/BinaryUnmarshal method pair to allow us to send and receive the type with the gob package. These interfaces are defined in the \"encoding\" package. We could equivalently use the locally defined GobEncode/GobDecoder interfaces."
      }
    ]
  },
  {
    "name": "encoding/hex",
    "desc": "Package hex implements hexadecimal encoding and decoding.",
    "functions": [
      {
        "name": "AppendDecode",
        "desc": "AppendDecode appends the hexadecimally decoded src to dst and returns the extended buffer. If the input is malformed, it returns the partially decoded src and an error."
      },
      {
        "name": "AppendEncode",
        "desc": "AppendEncode appends the hexadecimally encoded src to dst and returns the extended buffer."
      },
      {
        "name": "BenchmarkDecode",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeString",
        "desc": ""
      },
      {
        "name": "BenchmarkDump",
        "desc": ""
      },
      {
        "name": "BenchmarkEncode",
        "desc": ""
      },
      {
        "name": "Decode",
        "desc": "Decode decodes src into [DecodedLen](len(src)) bytes, returning the actual number of bytes written to dst.  Decode expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, Decode returns the number of bytes decoded before the error."
      },
      {
        "name": "DecodeString",
        "desc": "DecodeString returns the bytes represented by the hexadecimal string s.  DecodeString expects that src contains only hexadecimal characters and that src has even length. If the input is malformed, DecodeString returns the bytes decoded before the error."
      },
      {
        "name": "DecodedLen",
        "desc": "DecodedLen returns the length of a decoding of x source bytes. Specifically, it returns x / 2."
      },
      {
        "name": "Dump",
        "desc": "Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of `hexdump -C` on the command line."
      },
      {
        "name": "Dumper",
        "desc": "Dumper returns a [io.WriteCloser] that writes a hex dump of all written data to w. The format of the dump matches the output of `hexdump -C` on the command line."
      },
      {
        "name": "Encode",
        "desc": "Encode encodes src into [EncodedLen](len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always [EncodedLen](len(src)). Encode implements hexadecimal encoding."
      },
      {
        "name": "EncodeToString",
        "desc": "EncodeToString returns the hexadecimal encoding of src."
      },
      {
        "name": "EncodedLen",
        "desc": "EncodedLen returns the length of an encoding of n source bytes. Specifically, it returns n * 2."
      },
      {
        "name": "NewDecoder",
        "desc": "NewDecoder returns an [io.Reader] that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters."
      },
      {
        "name": "NewEncoder",
        "desc": "NewEncoder returns an [io.Writer] that writes lowercase hexadecimal characters to w."
      },
      {
        "name": "TestDecode",
        "desc": ""
      },
      {
        "name": "TestDecodeErr",
        "desc": ""
      },
      {
        "name": "TestDecodeString",
        "desc": ""
      },
      {
        "name": "TestDecodeStringErr",
        "desc": ""
      },
      {
        "name": "TestDecoderErr",
        "desc": ""
      },
      {
        "name": "TestDump",
        "desc": ""
      },
      {
        "name": "TestDumper",
        "desc": ""
      },
      {
        "name": "TestDumper_doubleclose",
        "desc": ""
      },
      {
        "name": "TestDumper_earlyclose",
        "desc": ""
      },
      {
        "name": "TestEncode",
        "desc": ""
      },
      {
        "name": "TestEncodeToString",
        "desc": ""
      },
      {
        "name": "TestEncoderDecoder",
        "desc": ""
      },
      {
        "name": "toChar",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "InvalidByteError",
        "desc": "InvalidByteError values describe errors resulting from an invalid byte in a hex string."
      },
      {
        "name": "decoder",
        "desc": ""
      },
      {
        "name": "dumper",
        "desc": ""
      },
      {
        "name": "encDecTest",
        "desc": ""
      },
      {
        "name": "encoder",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/json",
    "desc": "Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.  See \"JSON and Go\" for an introduction to this package: https://golang.org/doc/articles/json_and_go.html  # Security Considerations  The JSON standard (RFC 7159) is lax in its definition of a number of parser behaviors. As such, many JSON parsers behave differently in various scenarios. These differences in parsers mean that systems that use multiple independent JSON parser implementations may parse the same JSON object in differing ways.  Systems that rely on a JSON object being parsed consistently for security purposes should be careful to understand the behaviors of this parser, as well as how these behaviors may cause interoperability issues with other parser implementations.  Due to the Go Backwards Compatibility promise (https://go.dev/doc/go1compat) there are a number of behaviors this package exhibits that may cause interopability issues, but cannot be changed. In particular the following parsing behaviors may cause issues:    - If a JSON object contains duplicate keys, keys are processed in the order     they are observed, meaning later values will replace or be merged into     prior values, depending on the field type (in particular maps and structs     will have values merged, while other types have values replaced).   - When parsing a JSON object into a Go struct, keys are considered in a     case-insensitive fashion.   - When parsing a JSON object into a Go struct, unknown keys in the JSON     object are ignored (unless a [Decoder] is used and     [Decoder.DisallowUnknownFields] has been called).   - Invalid UTF-8 bytes in JSON strings are replaced by the Unicode     replacement character.   - Large JSON number integers will lose precision when unmarshaled into     floating-point types.  Package json implements encoding and decoding of JSON as defined in RFC 7159. The mapping between JSON and Go values is described in the documentation for the Marshal and Unmarshal functions.  See \"JSON and Go\" for an introduction to this package: https://golang.org/doc/articles/json_and_go.html  # Security Considerations  See the \"Security Considerations\" section in [encoding/json/v2].  For historical reasons, the default behavior of v1 [encoding/json] unfortunately operates with less secure defaults. New usages of JSON in Go are encouraged to use [encoding/json/v2] instead.  Migrating to v2  This package (i.e., [encoding/json]) is now formally known as the v1 package since a v2 package now exists at [encoding/json/v2]. All the behavior of the v1 package is implemented in terms of the v2 package with the appropriate set of options specified that preserve the historical behavior of v1.  The [jsonv2.Marshal] function is the newer equivalent of v1 [Marshal]. The [jsonv2.Unmarshal] function is the newer equivalent of v1 [Unmarshal]. The v2 functions have the same calling signature as the v1 equivalent except that they take in variadic [Options] arguments that can be specified to alter the behavior of marshal or unmarshal. Both v1 and v2 generally behave in similar ways, but there are some notable differences.  The following is a list of differences between v1 and v2:    - In v1, JSON object members are unmarshaled into a Go struct using a     case-insensitive name match with the JSON name of the fields.     In contrast, v2 matches fields using an exact, case-sensitive match.     The [jsonv2.MatchCaseInsensitiveNames] and [MatchCaseSensitiveDelimiter]     options control this behavior difference. To explicitly specify a Go struct     field to use a particular name matching scheme, either the `case:ignore`     or the `case:strict` field option can be specified.     Field-specified options take precedence over caller-specified options.    - In v1, when marshaling a Go struct, a field marked as `omitempty`     is omitted if the field value is an \"empty\" Go value, which is defined as     false, 0, a nil pointer, a nil interface value, and     any empty array, slice, map, or string. In contrast, v2 redefines     `omitempty` to omit a field if it encodes as an \"empty\" JSON value,     which is defined as a JSON null, or an empty JSON string, object, or array.     The [OmitEmptyWithLegacySemantics] option controls this behavior difference.     Note that `omitempty` behaves identically in both v1 and v2 for a     Go array, slice, map, or string (assuming no user-defined MarshalJSON method     overrides the default representation). Existing usages of `omitempty` on a     Go bool, number, pointer, or interface value should migrate to specifying     `omitzero` instead (which is identically supported in both v1 and v2).    - In v1, a Go struct field marked as `string` can be used to quote a     Go string, bool, or number as a JSON string. It does not recursively     take effect on composite Go types. In contrast, v2 restricts     the `string` option to only quote a Go number as a JSON string.     It does recursively take effect on Go numbers within a composite Go type.     The [StringifyWithLegacySemantics] option controls this behavior difference.    - In v1, a nil Go slice or Go map is marshaled as a JSON null.     In contrast, v2 marshals a nil Go slice or Go map as     an empty JSON array or JSON object, respectively.     The [jsonv2.FormatNilSliceAsNull] and [jsonv2.FormatNilMapAsNull] options     control this behavior difference. To explicitly specify a Go struct field     to use a particular representation for nil, either the `format:emitempty`     or `format:emitnull` field option can be specified.     Field-specified options take precedence over caller-specified options.    - In v1, a Go array may be unmarshaled from a JSON array of any length.     In contrast, in v2 a Go array must be unmarshaled from a JSON array     of the same length, otherwise it results in an error.     The [UnmarshalArrayFromAnyLength] option controls this behavior difference.    - In v1, a Go byte array is represented as a JSON array of JSON numbers.     In contrast, in v2 a Go byte array is represented as a Base64-encoded JSON string.     The [FormatByteArrayAsArray] option controls this behavior difference.     To explicitly specify a Go struct field to use a particular representation,     either the `format:array` or `format:base64` field option can be specified.     Field-specified options take precedence over caller-specified options.    - In v1, MarshalJSON methods declared on a pointer receiver are only called     if the Go value is addressable. In contrast, in v2 a MarshalJSON method     is always callable regardless of addressability.     The [CallMethodsWithLegacySemantics] option controls this behavior difference.    - In v1, MarshalJSON and UnmarshalJSON methods are never called for Go map keys.     In contrast, in v2 a MarshalJSON or UnmarshalJSON method is eligible for     being called for Go map keys.     The [CallMethodsWithLegacySemantics] option controls this behavior difference.    - In v1, a Go map is marshaled in a deterministic order.     In contrast, in v2 a Go map is marshaled in a non-deterministic order.     The [jsonv2.Deterministic] option controls this behavior difference.    - In v1, JSON strings are encoded with HTML-specific or JavaScript-specific     characters being escaped. In contrast, in v2 JSON strings use the minimal     encoding and only escape if required by the JSON grammar.     The [jsontext.EscapeForHTML] and [jsontext.EscapeForJS] options     control this behavior difference.    - In v1, bytes of invalid UTF-8 within a string are silently replaced with     the Unicode replacement character. In contrast, in v2 the presence of     invalid UTF-8 results in an error. The [jsontext.AllowInvalidUTF8] option     controls this behavior difference.    - In v1, a JSON object with duplicate names is permitted.     In contrast, in v2 a JSON object with duplicate names results in an error.     The [jsontext.AllowDuplicateNames] option controls this behavior difference.    - In v1, when unmarshaling a JSON null into a non-empty Go value it will     inconsistently either zero out the value or do nothing.     In contrast, in v2 unmarshaling a JSON null will consistently and always     zero out the underlying Go value. The [MergeWithLegacySemantics] option     controls this behavior difference.    - In v1, when unmarshaling a JSON value into a non-zero Go value,     it merges into the original Go value for array elements, slice elements,     struct fields (but not map values),     pointer values, and interface values (only if a non-nil pointer).     In contrast, in v2 unmarshal merges into the Go value     for struct fields, map values, pointer values, and interface values.     In general, the v2 semantic merges when unmarshaling a JSON object,     otherwise it replaces the value. The [MergeWithLegacySemantics] option     controls this behavior difference.    - In v1, a [time.Duration] is represented as a JSON number containing     the decimal number of nanoseconds. In contrast, in v2 a [time.Duration]     has no default representation and results in a runtime error.     The [FormatDurationAsNano] option controls this behavior difference.     To explicitly specify a Go struct field to use a particular representation,     either the `format:nano` or `format:units` field option can be specified.     Field-specified options take precedence over caller-specified options.    - In v1, errors are never reported at runtime for Go struct types     that have some form of structural error (e.g., a malformed tag option).     In contrast, v2 reports a runtime error for Go types that are invalid     as they relate to JSON serialization. For example, a Go struct     with only unexported fields cannot be serialized.     The [ReportErrorsWithLegacySemantics] option controls this behavior difference.  As mentioned, the entirety of v1 is implemented in terms of v2, where options are implicitly specified to opt into legacy behavior. For example, [Marshal] directly calls [jsonv2.Marshal] with [DefaultOptionsV1]. Similarly, [Unmarshal] directly calls [jsonv2.Unmarshal] with [DefaultOptionsV1]. The [DefaultOptionsV1] option represents the set of all options that specify default v1 behavior.  For many of the behavior differences, there are Go struct field options that the author of a Go type can specify to control the behavior such that the type is represented identically in JSON under either v1 or v2 semantics.  The availability of [DefaultOptionsV1] and [jsonv2.DefaultOptionsV2], where later options take precedence over former options allows for a gradual migration from v1 to v2. For example:    - jsonv1.Marshal(v)     uses default v1 semantics.    - jsonv2.Marshal(v, jsonv1.DefaultOptionsV1())     is semantically equivalent to jsonv1.Marshal     and thus uses default v1 semantics.    - jsonv2.Marshal(v, jsonv1.DefaultOptionsV1(), jsontext.AllowDuplicateNames(false))     uses mostly v1 semantics, but opts into one particular v2-specific behavior.    - jsonv2.Marshal(v, jsonv1.CallMethodsWithLegacySemantics(true))     uses mostly v2 semantics, but opts into one particular v1-specific behavior.    - jsonv2.Marshal(v, ..., jsonv2.DefaultOptionsV2())     is semantically equivalent to jsonv2.Marshal since     jsonv2.DefaultOptionsV2 overrides any options specified earlier     and thus uses default v2 semantics.    - jsonv2.Marshal(v)     uses default v2 semantics.  All new usages of \"json\" in Go should use the v2 package, but the v1 package will forever remain supported.",
    "functions": [
      {
        "name": "BenchmarkCodeDecoder",
        "desc": ""
      },
      {
        "name": "BenchmarkCodeEncoder",
        "desc": ""
      },
      {
        "name": "BenchmarkCodeEncoderError",
        "desc": ""
      },
      {
        "name": "BenchmarkCodeMarshal",
        "desc": ""
      },
      {
        "name": "BenchmarkCodeMarshalError",
        "desc": ""
      },
      {
        "name": "BenchmarkCodeUnmarshal",
        "desc": ""
      },
      {
        "name": "BenchmarkCodeUnmarshalReuse",
        "desc": ""
      },
      {
        "name": "BenchmarkDecoderStream",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeMarshaler",
        "desc": ""
      },
      {
        "name": "BenchmarkEncoderEncode",
        "desc": ""
      },
      {
        "name": "BenchmarkIssue10335",
        "desc": ""
      },
      {
        "name": "BenchmarkIssue34127",
        "desc": ""
      },
      {
        "name": "BenchmarkMarshalBytes",
        "desc": ""
      },
      {
        "name": "BenchmarkMarshalBytesError",
        "desc": ""
      },
      {
        "name": "BenchmarkMarshalMap",
        "desc": ""
      },
      {
        "name": "BenchmarkNumberIsValid",
        "desc": ""
      },
      {
        "name": "BenchmarkNumberIsValidRegexp",
        "desc": ""
      },
      {
        "name": "BenchmarkTypeFieldsCache",
        "desc": ""
      },
      {
        "name": "BenchmarkUnicodeDecoder",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmapped",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshalFloat64",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshalInt64",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshalMap",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshalNumber",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshalString",
        "desc": ""
      },
      {
        "name": "Compact",
        "desc": "Compact appends to dst the JSON-encoded src with insignificant space characters elided."
      },
      {
        "name": "FuzzDecoderToken",
        "desc": ""
      },
      {
        "name": "FuzzEqualFold",
        "desc": ""
      },
      {
        "name": "FuzzUnmarshalJSON",
        "desc": ""
      },
      {
        "name": "HTMLEscape",
        "desc": "HTMLEscape appends to dst the JSON-encoded src with \u003c, \u003e, \u0026, U+2028 and U+2029 characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029 so that the JSON will be safe to embed inside HTML \u003cscript\u003e tags. For historical reasons, web browsers don't honor standard HTML escaping within \u003cscript\u003e tags, so an alternative JSON encoding must be used."
      },
      {
        "name": "Indent",
        "desc": "Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst."
      },
      {
        "name": "Marshal",
        "desc": "Marshal returns the JSON encoding of v.  Marshal traverses the value v recursively. If an encountered value implements [Marshaler] and is not a nil pointer, Marshal calls [Marshaler.MarshalJSON] to produce JSON. If no [Marshaler.MarshalJSON] method is present but the value implements [encoding.TextMarshaler] instead, Marshal calls [encoding.TextMarshaler.MarshalText] and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of [Unmarshaler.UnmarshalJSON].  Otherwise, Marshal uses the following type-dependent default encodings:  Boolean values encode as JSON booleans.  Floating point, integer, and [Number] values encode as JSON numbers. NaN and +/-Inf values will return an [UnsupportedValueError].  String values encode as JSON strings coerced to valid UTF-8, replacing invalid bytes with the Unicode replacement rune. So that the JSON will be safe to embed inside HTML \u003cscript\u003e tags, the string is encoded using [HTMLEscape], which replaces \"\u003c\", \"\u003e\", \"\u0026\", U+2028, and U+2029 are escaped to \"\\u003c\",\"\\u003e\", \"\\u0026\", \"\\u2028\", and \"\\u2029\". This replacement can be disabled when using an [Encoder], by calling [Encoder.SetEscapeHTML](false).  Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.  Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.  The encoding of each struct field can be customized by the format string stored under the \"json\" key in the struct field's tag. The format string gives the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.  The \"omitempty\" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any array, slice, map, or string of length zero.  As a special case, if the field tag is \"-\", the field is always omitted. JSON names containing commas or quotes, or names identical to \"\" or \"-\", can be specified using a single-quoted string literal, where the syntax is identical to the Go grammar for a double-quoted string literal, but instead uses single quotes as the delimiters.  Examples of struct field tags and their meanings:  \t// Field appears in JSON as key \"myName\". \tField int `json:\"myName\"`  \t// Field appears in JSON as key \"myName\" and \t// the field is omitted from the object if its value is empty, \t// as defined above. \tField int `json:\"myName,omitempty\"`  \t// Field appears in JSON as key \"Field\" (the default), but \t// the field is skipped if empty. \t// Note the leading comma. \tField int `json:\",omitempty\"`  \t// Field is ignored by this package. \tField int `json:\"-\"`  \t// Field appears in JSON as key \"-\". \tField int `json:\"'-'\"`  The \"omitzero\" option specifies that the field should be omitted from the encoding if the field has a zero value, according to rules:  1) If the field type has an \"IsZero() bool\" method, that will be used to determine whether the value is zero.  2) Otherwise, the value is zero if it is the zero value for its type.  If both \"omitempty\" and \"omitzero\" are specified, the field will be omitted if the value is either empty or zero (or both).  The \"string\" option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:  \tInt64String int64 `json:\",string\"`  The key name will be used if it's a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.  Embedded struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph. An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous. An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous.  The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:  1) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict.  2) If there is exactly one field (tagged or not according to the first rule), that is selected.  3) Otherwise there are multiple fields, and all are ignored; no error occurs.  Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of an anonymous struct field in both current and earlier versions, give the field a JSON tag of \"-\".  Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement [encoding.TextMarshaler]. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:   - keys of any string type are used directly   - keys that implement [encoding.TextMarshaler] are marshaled   - integer keys are converted to strings  Pointer values encode as the value pointed to. A nil pointer encodes as the null JSON value.  Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON value.  Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an [UnsupportedTypeError].  JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error."
      },
      {
        "name": "MarshalIndent",
        "desc": "MarshalIndent is like [Marshal] but applies [Indent] to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting."
      },
      {
        "name": "TestAnonymousFields",
        "desc": ""
      },
      {
        "name": "TestBlocking",
        "desc": ""
      },
      {
        "name": "TestByteKind",
        "desc": "Custom types with []byte as underlying type could not be marshaled and then unmarshaled. Issue 8962."
      },
      {
        "name": "TestCompactAndIndent",
        "desc": ""
      },
      {
        "name": "TestCompactBig",
        "desc": ""
      },
      {
        "name": "TestCompactSeparators",
        "desc": ""
      },
      {
        "name": "TestDecodeInStream",
        "desc": ""
      },
      {
        "name": "TestDecoder",
        "desc": ""
      },
      {
        "name": "TestDecoderBuffered",
        "desc": ""
      },
      {
        "name": "TestDuplicatedFieldDisappears",
        "desc": ""
      },
      {
        "name": "TestEmbeddedBug",
        "desc": "Issue 5245."
      },
      {
        "name": "TestEmptyString",
        "desc": "Test that the empty string doesn't panic decoding when ,string is specified Issue 3450"
      },
      {
        "name": "TestEncodeBytekind",
        "desc": "Issue 13783"
      },
      {
        "name": "TestEncodePointerString",
        "desc": "golang.org/issue/8582"
      },
      {
        "name": "TestEncodeRenamedByteSlice",
        "desc": ""
      },
      {
        "name": "TestEncodeString",
        "desc": ""
      },
      {
        "name": "TestEncoder",
        "desc": ""
      },
      {
        "name": "TestEncoderErrorAndReuseEncodeState",
        "desc": ""
      },
      {
        "name": "TestEncoderIndent",
        "desc": ""
      },
      {
        "name": "TestEncoderSetEscapeHTML",
        "desc": ""
      },
      {
        "name": "TestErrorMessageFromMisusedString",
        "desc": "If people misuse the ,string modifier, the error message should be helpful, telling the user that they're doing it wrong."
      },
      {
        "name": "TestEscape",
        "desc": ""
      },
      {
        "name": "TestHTMLEscape",
        "desc": ""
      },
      {
        "name": "TestHTTPDecoding",
        "desc": "Test from golang.org/issue/11893"
      },
      {
        "name": "TestIndentBig",
        "desc": ""
      },
      {
        "name": "TestIndentErrors",
        "desc": ""
      },
      {
        "name": "TestInterfaceSet",
        "desc": ""
      },
      {
        "name": "TestInvalidStringOption",
        "desc": "Test that string option is ignored for invalid types. Issue 9812."
      },
      {
        "name": "TestInvalidUnmarshal",
        "desc": ""
      },
      {
        "name": "TestIssue10281",
        "desc": ""
      },
      {
        "name": "TestIssue63379",
        "desc": ""
      },
      {
        "name": "TestLargeByteSlice",
        "desc": ""
      },
      {
        "name": "TestMarshal",
        "desc": ""
      },
      {
        "name": "TestMarshalEmbeds",
        "desc": ""
      },
      {
        "name": "TestMarshalErrorAndReuseEncodeState",
        "desc": ""
      },
      {
        "name": "TestMarshalFloat",
        "desc": ""
      },
      {
        "name": "TestMarshalInvalidUTF8",
        "desc": ""
      },
      {
        "name": "TestMarshalNumberZeroVal",
        "desc": ""
      },
      {
        "name": "TestMarshalPanic",
        "desc": ""
      },
      {
        "name": "TestMarshalRawMessageValue",
        "desc": ""
      },
      {
        "name": "TestMarshalTextFloatMap",
        "desc": "Issue 43207"
      },
      {
        "name": "TestMarshalUncommonFieldNames",
        "desc": ""
      },
      {
        "name": "TestMarshalerError",
        "desc": ""
      },
      {
        "name": "TestMarshalerEscaping",
        "desc": ""
      },
      {
        "name": "TestNilMarshal",
        "desc": "See golang.org/issue/16042 and golang.org/issue/34235."
      },
      {
        "name": "TestNilMarshalerTextMapKey",
        "desc": "https://golang.org/issue/33675"
      },
      {
        "name": "TestNullRawMessage",
        "desc": ""
      },
      {
        "name": "TestNullString",
        "desc": "Test that a null for ,string is not replaced with the previous quoted string (issue 7046). It should also not be an error (issue 2540, issue 8587)."
      },
      {
        "name": "TestNumberAccessors",
        "desc": "Independent of Decode, basic coverage of the accessors in Number"
      },
      {
        "name": "TestNumberIsValid",
        "desc": ""
      },
      {
        "name": "TestOmitEmpty",
        "desc": ""
      },
      {
        "name": "TestOmitEmptyZero",
        "desc": ""
      },
      {
        "name": "TestOmitZero",
        "desc": ""
      },
      {
        "name": "TestOmitZeroMap",
        "desc": ""
      },
      {
        "name": "TestPrefilled",
        "desc": "Test semantics of pre-filled data, such as struct fields, map elements, slices, and arrays. Issues 4900 and 8837, among others."
      },
      {
        "name": "TestRawMessage",
        "desc": ""
      },
      {
        "name": "TestRefUnmarshal",
        "desc": ""
      },
      {
        "name": "TestRefValMarshal",
        "desc": ""
      },
      {
        "name": "TestRoundtripStringTag",
        "desc": ""
      },
      {
        "name": "TestSamePointerNoCycle",
        "desc": ""
      },
      {
        "name": "TestSkipArrayObjects",
        "desc": "Test that extra object elements in an array do not result in a \"data changing underfoot\" error. Issue 3717"
      },
      {
        "name": "TestSliceNoCycle",
        "desc": ""
      },
      {
        "name": "TestSliceOfCustomByte",
        "desc": "The fix for issue 8962 introduced a regression. Issue 12921."
      },
      {
        "name": "TestStringKind",
        "desc": ""
      },
      {
        "name": "TestStructTagObjectKey",
        "desc": ""
      },
      {
        "name": "TestSynctestMarshal",
        "desc": "Issue #73733: encoding/json used a WaitGroup to coordinate access to cache entries. Since WaitGroup.Wait is durably blocking, this caused apparent deadlocks when multiple bubbles called json.Marshal at the same time."
      },
      {
        "name": "TestTagParsing",
        "desc": ""
      },
      {
        "name": "TestTaggedFieldDominates",
        "desc": "Test that a field with a tag dominates untagged fields."
      },
      {
        "name": "TestTextMarshalerMapKeysAreSorted",
        "desc": ""
      },
      {
        "name": "TestUnmarshal",
        "desc": ""
      },
      {
        "name": "TestUnmarshalEmbeddedUnexported",
        "desc": "Test unmarshal behavior with regards to embedded unexported structs.  (Issue 21357) If the embedded struct is a pointer and is unallocated, this returns an error because unmarshal cannot set the field.  (Issue 24152) If the embedded struct is given an explicit name, ensure that the normal unmarshal logic does not panic in reflect.  (Issue 28145) If the embedded struct is given an explicit name and has exported methods, don't cause a panic trying to get its value."
      },
      {
        "name": "TestUnmarshalErrorAfterMultipleJSON",
        "desc": ""
      },
      {
        "name": "TestUnmarshalInterface",
        "desc": ""
      },
      {
        "name": "TestUnmarshalJSONLiteralError",
        "desc": ""
      },
      {
        "name": "TestUnmarshalMapWithTextUnmarshalerStringKey",
        "desc": "Test unmarshal to a map, where the map key is a user defined type. See golang.org/issues/34437."
      },
      {
        "name": "TestUnmarshalMarshal",
        "desc": ""
      },
      {
        "name": "TestUnmarshalMaxDepth",
        "desc": ""
      },
      {
        "name": "TestUnmarshalNulls",
        "desc": "JSON null values should be ignored for primitives and string values instead of resulting in an error. Issue 2540"
      },
      {
        "name": "TestUnmarshalPanic",
        "desc": ""
      },
      {
        "name": "TestUnmarshalPtrPtr",
        "desc": ""
      },
      {
        "name": "TestUnmarshalRecursivePointer",
        "desc": "The decoder used to hang if decoding into an interface pointing to its own address. See golang.org/issues/31740."
      },
      {
        "name": "TestUnmarshalRescanLiteralMangledUnquote",
        "desc": ""
      },
      {
        "name": "TestUnmarshalSyntax",
        "desc": ""
      },
      {
        "name": "TestUnmarshalTypeError",
        "desc": ""
      },
      {
        "name": "TestUnmarshalUnexported",
        "desc": ""
      },
      {
        "name": "TestUnsupportedValues",
        "desc": ""
      },
      {
        "name": "TestValid",
        "desc": ""
      },
      {
        "name": "Unmarshal",
        "desc": "Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an [InvalidUnmarshalError].  Unmarshal uses the inverse of the encodings that [Marshal] uses, allocating maps, slices, and pointers as necessary, with the following additional rules:  To unmarshal JSON into a pointer, Unmarshal first handles the case of the JSON being the JSON literal null. In that case, Unmarshal sets the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at by the pointer. If the pointer is nil, Unmarshal allocates a new value for it to point to.  To unmarshal JSON into a value implementing [Unmarshaler], Unmarshal calls that value's [Unmarshaler.UnmarshalJSON] method, including when the input is a JSON null. Otherwise, if the value implements [encoding.TextUnmarshaler] and the input is a JSON quoted string, Unmarshal calls [encoding.TextUnmarshaler.UnmarshalText] with the unquoted form of the string.  To unmarshal JSON into a struct, Unmarshal matches incoming object keys to the keys used by [Marshal] (either the struct field name or its tag), ignoring case. If multiple struct fields match an object key, an exact case match is preferred over a case-insensitive one.  Incoming object members are processed in the order observed. If an object includes duplicate keys, later duplicates will replace or be merged into prior values.  To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:    - bool, for JSON booleans   - float64, for JSON numbers   - string, for JSON strings   - []any, for JSON arrays   - map[string]any, for JSON objects   - nil for JSON null  To unmarshal a JSON array into a slice, Unmarshal resets the slice length to zero and then appends each element to the slice. As a special case, to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice with a new empty slice.  To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array elements into corresponding Go array elements. If the Go array is smaller than the JSON array, the additional JSON array elements are discarded. If the JSON array is smaller than the Go array, the additional Go array elements are set to zero values.  To unmarshal a JSON object into a map, Unmarshal first establishes a map to use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal reuses the existing map, keeping existing entries. Unmarshal then stores key-value pairs from the JSON object into the map. The map's key type must either be any string type, an integer, or implement [encoding.TextUnmarshaler].  If the JSON-encoded data contain a syntax error, Unmarshal returns a [SyntaxError].  If a JSON value is not appropriate for a given target type, or if a JSON number overflows the target type, Unmarshal skips that field and completes the unmarshaling as best it can. If no more serious errors are encountered, Unmarshal returns an [UnmarshalTypeError] describing the earliest such error. In any case, it's not guaranteed that all the remaining fields following the problematic one will be unmarshaled into the target object.  The JSON null value unmarshals into an interface, map, pointer, or slice by setting that Go value to nil. Because null is often used in JSON to mean “not present,” unmarshaling a JSON null into any other Go type has no effect on the value and produces no error.  When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate pairs are not treated as an error. Instead, they are replaced by the Unicode replacement character U+FFFD."
      },
      {
        "name": "Valid",
        "desc": "Valid reports whether data is a valid JSON encoding."
      },
      {
        "name": "addr",
        "desc": ""
      },
      {
        "name": "addrMarshalerEncoder",
        "desc": ""
      },
      {
        "name": "addrTextMarshalerEncoder",
        "desc": ""
      },
      {
        "name": "appendCompact",
        "desc": ""
      },
      {
        "name": "appendFoldedName",
        "desc": ""
      },
      {
        "name": "appendHTMLEscape",
        "desc": ""
      },
      {
        "name": "appendIndent",
        "desc": ""
      },
      {
        "name": "appendNewline",
        "desc": ""
      },
      {
        "name": "appendString",
        "desc": ""
      },
      {
        "name": "benchMarshalBytes",
        "desc": ""
      },
      {
        "name": "benchMarshalBytesError",
        "desc": ""
      },
      {
        "name": "boolEncoder",
        "desc": ""
      },
      {
        "name": "checkValid",
        "desc": "checkValid verifies that data is valid JSON-encoded data. scan is passed in for use by checkValid to avoid an allocation. checkValid returns nil or a SyntaxError."
      },
      {
        "name": "codeInit",
        "desc": ""
      },
      {
        "name": "diff",
        "desc": ""
      },
      {
        "name": "encodeByteSlice",
        "desc": ""
      },
      {
        "name": "equalError",
        "desc": ""
      },
      {
        "name": "foldName",
        "desc": "foldName returns a folded string such that foldName(x) == foldName(y) is identical to bytes.EqualFold(x, y)."
      },
      {
        "name": "foldRune",
        "desc": "foldRune is returns the smallest rune for all runes in the same fold set."
      },
      {
        "name": "freeScanner",
        "desc": ""
      },
      {
        "name": "genArray",
        "desc": ""
      },
      {
        "name": "genMap",
        "desc": ""
      },
      {
        "name": "genString",
        "desc": ""
      },
      {
        "name": "genValue",
        "desc": ""
      },
      {
        "name": "getu4",
        "desc": "getu4 decodes \\uXXXX from the beginning of s, returning the hex value, or it returns -1."
      },
      {
        "name": "indentNewlines",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "Inject functionality into v2 to properly handle v1 types."
      },
      {
        "name": "initBig",
        "desc": ""
      },
      {
        "name": "intEncoder",
        "desc": ""
      },
      {
        "name": "interfaceEncoder",
        "desc": ""
      },
      {
        "name": "invalidValueEncoder",
        "desc": ""
      },
      {
        "name": "isEmptyValue",
        "desc": ""
      },
      {
        "name": "isSpace",
        "desc": ""
      },
      {
        "name": "isValidNumber",
        "desc": "isValidNumber reports whether s is a valid JSON number literal.  isValidNumber should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "isValidTag",
        "desc": ""
      },
      {
        "name": "len64",
        "desc": ""
      },
      {
        "name": "marshalerEncoder",
        "desc": ""
      },
      {
        "name": "mayAppendQuote",
        "desc": ""
      },
      {
        "name": "nlines",
        "desc": ""
      },
      {
        "name": "nonSpace",
        "desc": ""
      },
      {
        "name": "quoteChar",
        "desc": "quoteChar formats c as a quoted character literal."
      },
      {
        "name": "resolveKeyName",
        "desc": ""
      },
      {
        "name": "state0",
        "desc": "state0 is the state after reading `0` during a number."
      },
      {
        "name": "state1",
        "desc": "state1 is the state after reading a non-zero integer during a number, such as after reading `1` or `100` but not `0`."
      },
      {
        "name": "stateBeginString",
        "desc": "stateBeginString is the state after reading `{\"key\": value,`."
      },
      {
        "name": "stateBeginStringOrEmpty",
        "desc": "stateBeginStringOrEmpty is the state after reading `{`."
      },
      {
        "name": "stateBeginValue",
        "desc": "stateBeginValue is the state at the beginning of the input."
      },
      {
        "name": "stateBeginValueOrEmpty",
        "desc": "stateBeginValueOrEmpty is the state after reading `[`."
      },
      {
        "name": "stateDot",
        "desc": "stateDot is the state after reading the integer and decimal point in a number, such as after reading `1.`."
      },
      {
        "name": "stateDot0",
        "desc": "stateDot0 is the state after reading the integer, decimal point, and subsequent digits of a number, such as after reading `3.14`."
      },
      {
        "name": "stateE",
        "desc": "stateE is the state after reading the mantissa and e in a number, such as after reading `314e` or `0.314e`."
      },
      {
        "name": "stateE0",
        "desc": "stateE0 is the state after reading the mantissa, e, optional sign, and at least one digit of the exponent in a number, such as after reading `314e-2` or `0.314e+1` or `3.14e0`."
      },
      {
        "name": "stateESign",
        "desc": "stateESign is the state after reading the mantissa, e, and sign in a number, such as after reading `314e-` or `0.314e+`."
      },
      {
        "name": "stateEndTop",
        "desc": "stateEndTop is the state after finishing the top-level value, such as after reading `{}` or `[1,2,3]`. Only space characters should be seen now."
      },
      {
        "name": "stateEndValue",
        "desc": "stateEndValue is the state after completing a value, such as after reading `{}` or `true` or `[\"x\"`."
      },
      {
        "name": "stateError",
        "desc": "stateError is the state after reaching a syntax error, such as after reading `[1}` or `5.1.2`."
      },
      {
        "name": "stateF",
        "desc": "stateF is the state after reading `f`."
      },
      {
        "name": "stateFa",
        "desc": "stateFa is the state after reading `fa`."
      },
      {
        "name": "stateFal",
        "desc": "stateFal is the state after reading `fal`."
      },
      {
        "name": "stateFals",
        "desc": "stateFals is the state after reading `fals`."
      },
      {
        "name": "stateInString",
        "desc": "stateInString is the state after reading `\"`."
      },
      {
        "name": "stateInStringEsc",
        "desc": "stateInStringEsc is the state after reading `\"\\` during a quoted string."
      },
      {
        "name": "stateInStringEscU",
        "desc": "stateInStringEscU is the state after reading `\"\\u` during a quoted string."
      },
      {
        "name": "stateInStringEscU1",
        "desc": "stateInStringEscU1 is the state after reading `\"\\u1` during a quoted string."
      },
      {
        "name": "stateInStringEscU12",
        "desc": "stateInStringEscU12 is the state after reading `\"\\u12` during a quoted string."
      },
      {
        "name": "stateInStringEscU123",
        "desc": "stateInStringEscU123 is the state after reading `\"\\u123` during a quoted string."
      },
      {
        "name": "stateN",
        "desc": "stateN is the state after reading `n`."
      },
      {
        "name": "stateNeg",
        "desc": "stateNeg is the state after reading `-` during a number."
      },
      {
        "name": "stateNu",
        "desc": "stateNu is the state after reading `nu`."
      },
      {
        "name": "stateNul",
        "desc": "stateNul is the state after reading `nul`."
      },
      {
        "name": "stateT",
        "desc": "stateT is the state after reading `t`."
      },
      {
        "name": "stateTr",
        "desc": "stateTr is the state after reading `tr`."
      },
      {
        "name": "stateTru",
        "desc": "stateTru is the state after reading `tru`."
      },
      {
        "name": "stringEncoder",
        "desc": ""
      },
      {
        "name": "stripWhitespace",
        "desc": ""
      },
      {
        "name": "tenc",
        "desc": ""
      },
      {
        "name": "textMarshalerEncoder",
        "desc": ""
      },
      {
        "name": "transformMarshalError",
        "desc": ""
      },
      {
        "name": "transformSyntacticError",
        "desc": ""
      },
      {
        "name": "transformUnmarshalError",
        "desc": ""
      },
      {
        "name": "trim",
        "desc": ""
      },
      {
        "name": "typeByIndex",
        "desc": ""
      },
      {
        "name": "uintEncoder",
        "desc": ""
      },
      {
        "name": "unquote",
        "desc": "unquote converts a quoted JSON string literal s into an actual string t. The rules are different than for Go, so cannot use strconv.Unquote."
      },
      {
        "name": "unquoteBytes",
        "desc": "unquoteBytes should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "unsupportedTypeEncoder",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Buffered",
        "desc": "Buffered returns a reader of the data remaining in the Decoder's buffer. The reader is valid until the next call to [Decoder.Decode]."
      },
      {
        "name": "Decode",
        "desc": "Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.  See the documentation for [Unmarshal] for details about the conversion of JSON into a Go value."
      },
      {
        "name": "DisallowUnknownFields",
        "desc": "DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination."
      },
      {
        "name": "InputOffset",
        "desc": "InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token."
      },
      {
        "name": "More",
        "desc": "More reports whether there is another element in the current array or object being parsed."
      },
      {
        "name": "Token",
        "desc": "Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, [io.EOF].  Token guarantees that the delimiters [ ] { } it returns are properly nested and matched: if Token encounters an unexpected delimiter in the input, it will return an error.  The input stream consists of basic JSON values—bool, string, number, and null—along with delimiters [ ] { } of type [Delim] to mark the start and end of arrays and objects. Commas and colons are elided."
      },
      {
        "name": "UseNumber",
        "desc": "UseNumber causes the Decoder to unmarshal a number into an interface value as a [Number] instead of as a float64."
      },
      {
        "name": "peek",
        "desc": ""
      },
      {
        "name": "readValue",
        "desc": "readValue reads a JSON value into dec.buf. It returns the length of the encoding."
      },
      {
        "name": "refill",
        "desc": ""
      },
      {
        "name": "tokenError",
        "desc": ""
      },
      {
        "name": "tokenPrepareForDecode",
        "desc": "advance tokenstate from a separator state to a value state"
      },
      {
        "name": "tokenValueAllowed",
        "desc": ""
      },
      {
        "name": "tokenValueEnd",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": "Encode writes the JSON encoding of v to the stream, with insignificant space characters elided, followed by a newline character.  See the documentation for [Marshal] for details about the conversion of Go values to JSON."
      },
      {
        "name": "SetEscapeHTML",
        "desc": "SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape \u0026, \u003c, and \u003e to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that can arise when embedding JSON in HTML.  In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior."
      },
      {
        "name": "SetIndent",
        "desc": "SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(\"\", \"\") disables indentation."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": "Unwrap returns the underlying error."
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "Float64",
        "desc": "Float64 returns the number as a float64."
      },
      {
        "name": "Int64",
        "desc": "Int64 returns the number as an int64."
      },
      {
        "name": "MarshalJSONTo",
        "desc": "MarshalJSONTo implements [jsonv2.MarshalerTo]."
      },
      {
        "name": "String",
        "desc": "String returns the literal text of the number."
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": "UnmarshalJSONFrom implements [jsonv2.UnmarshalerFrom]."
      },
      {
        "name": "MarshalJSON",
        "desc": "MarshalJSON returns m as the JSON encoding of m."
      },
      {
        "name": "UnmarshalJSON",
        "desc": "UnmarshalJSON sets *m to a copy of data."
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "addErrorContext",
        "desc": "addErrorContext returns a new error enhanced with information from d.errorContext"
      },
      {
        "name": "array",
        "desc": "array consumes an array from d.data[d.off-1:], decoding into v. The first byte of the array ('[') has been read already."
      },
      {
        "name": "arrayInterface",
        "desc": "arrayInterface is like array but returns []any."
      },
      {
        "name": "convertNumber",
        "desc": "convertNumber converts the number literal s to a float64 or a Number depending on the setting of d.useNumber."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "literalInterface",
        "desc": "literalInterface consumes and returns a literal from d.data[d.off-1:] and it reads the following byte ahead. The first byte of the literal has been read already (that's how the caller knows it's a literal)."
      },
      {
        "name": "literalStore",
        "desc": "literalStore decodes a literal stored in item into v.  fromQuoted indicates whether this literal came from unwrapping a string from the \",string\" struct tag option. this is used only to produce more helpful error messages."
      },
      {
        "name": "object",
        "desc": "object consumes an object from d.data[d.off-1:], decoding into v. The first byte ('{') of the object has been read already."
      },
      {
        "name": "objectInterface",
        "desc": "objectInterface is like object but returns map[string]any."
      },
      {
        "name": "readIndex",
        "desc": "readIndex returns the position of the last byte read."
      },
      {
        "name": "rescanLiteral",
        "desc": "rescanLiteral is similar to scanWhile(scanContinue), but it specialises the common case where we're decoding a literal. The decoder scans the input twice, once for syntax errors and to check the length of the value, and the second to perform the decoding.  Only in the second step do we use decodeState to tokenize literals, so we know there aren't any syntax errors. We can take advantage of that knowledge, and scan a literal's bytes much more quickly."
      },
      {
        "name": "saveError",
        "desc": "saveError saves the first err it is called with, for reporting at the end of the unmarshal."
      },
      {
        "name": "scanNext",
        "desc": "scanNext processes the byte at d.data[d.off]."
      },
      {
        "name": "scanWhile",
        "desc": "scanWhile processes bytes in d.data[d.off:] until it receives a scan code not equal to op."
      },
      {
        "name": "skip",
        "desc": "skip scans to the end of what was started."
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "value",
        "desc": "value consumes a JSON value from d.data[d.off-1:], decoding into v, and reads the following byte ahead. If v is invalid, the value is discarded. The first byte of the value has been read already."
      },
      {
        "name": "valueInterface",
        "desc": "valueInterface is like value but returns any."
      },
      {
        "name": "valueQuoted",
        "desc": "valueQuoted is like value but decodes a quoted string literal or literal null into an interface value. If it finds anything other than a quoted string literal or null, valueQuoted returns unquotedValue{}."
      },
      {
        "name": "error",
        "desc": "error aborts the encoding by panicking with err wrapped in jsonError."
      },
      {
        "name": "marshal",
        "desc": ""
      },
      {
        "name": "reflectValue",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "eof",
        "desc": "eof tells the scanner that the end of input has been reached. It returns a scan status just as s.step does."
      },
      {
        "name": "error",
        "desc": "error records an error and switches to the error state."
      },
      {
        "name": "popParseState",
        "desc": "popParseState pops a parse state (already obtained) off the stack and updates s.step accordingly."
      },
      {
        "name": "pushParseState",
        "desc": "pushParseState pushes a new parse state newParseState onto the parse stack. an error state is returned if maxNestingDepth was exceeded, otherwise successState is returned."
      },
      {
        "name": "reset",
        "desc": "reset prepares the scanner for use. It must be called before calling s.step."
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": ""
      },
      {
        "name": "Contains",
        "desc": "Contains reports whether a comma-separated list of options contains a particular substr flag. substr must be surrounded by a string boundary or commas."
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "F",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": "needed for re-marshaling tests"
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "All",
        "desc": ""
      },
      {
        "name": "Ambig",
        "desc": ""
      },
      {
        "name": "B",
        "desc": ""
      },
      {
        "name": "BugA",
        "desc": ""
      },
      {
        "name": "BugB",
        "desc": ""
      },
      {
        "name": "BugC",
        "desc": ""
      },
      {
        "name": "BugD",
        "desc": ""
      },
      {
        "name": "BugX",
        "desc": "Legal Go: We never use the repeated embedded field (S)."
      },
      {
        "name": "BugY",
        "desc": "BugD's tagged S field should dominate BugA's."
      },
      {
        "name": "BugZ",
        "desc": "There are no tags here, so S should not appear."
      },
      {
        "name": "C",
        "desc": "C implements Marshaler and returns unescaped JSON."
      },
      {
        "name": "CText",
        "desc": "CText implements Marshaler and returns unescaped text."
      },
      {
        "name": "CaseName",
        "desc": ""
      },
      {
        "name": "CasePos",
        "desc": ""
      },
      {
        "name": "Decoder",
        "desc": "A Decoder reads and decodes JSON values from an input stream."
      },
      {
        "name": "Delim",
        "desc": "A Delim is a JSON array or object delimiter, one of [ ] { or }."
      },
      {
        "name": "DoublePtr",
        "desc": ""
      },
      {
        "name": "Embed0",
        "desc": ""
      },
      {
        "name": "Embed0a",
        "desc": ""
      },
      {
        "name": "Embed0b",
        "desc": ""
      },
      {
        "name": "Embed0c",
        "desc": ""
      },
      {
        "name": "Embed0p",
        "desc": ""
      },
      {
        "name": "Embed0q",
        "desc": ""
      },
      {
        "name": "Encoder",
        "desc": "An Encoder writes JSON values to an output stream."
      },
      {
        "name": "InvalidUTF8Error",
        "desc": "Before Go 1.2, an InvalidUTF8Error was returned by [Marshal] when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, [Marshal] instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD.  Deprecated: No longer used; kept for compatibility."
      },
      {
        "name": "InvalidUnmarshalError",
        "desc": "An InvalidUnmarshalError describes an invalid argument passed to [Unmarshal]. (The argument to [Unmarshal] must be a non-nil pointer.)"
      },
      {
        "name": "Loop",
        "desc": ""
      },
      {
        "name": "Marshaler",
        "desc": "Marshaler is the interface implemented by types that can marshal themselves into valid JSON."
      },
      {
        "name": "MarshalerError",
        "desc": "A MarshalerError represents an error from calling a [Marshaler.MarshalJSON] or [encoding.TextMarshaler.MarshalText] method."
      },
      {
        "name": "MustNotUnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MustNotUnmarshalText",
        "desc": ""
      },
      {
        "name": "NoPanicStruct",
        "desc": ""
      },
      {
        "name": "NonZeroStruct",
        "desc": ""
      },
      {
        "name": "NullTest",
        "desc": ""
      },
      {
        "name": "Number",
        "desc": "A Number represents a JSON number literal."
      },
      {
        "name": "OptionalsEmpty",
        "desc": ""
      },
      {
        "name": "OptionalsEmptyZero",
        "desc": ""
      },
      {
        "name": "OptionalsZero",
        "desc": ""
      },
      {
        "name": "Options",
        "desc": "Options are a set of options to configure the v2 \"json\" package to operate with v1 semantics for particular features. Values of this type can be passed to v2 functions like [jsonv2.Marshal] or [jsonv2.Unmarshal]. Instead of referencing this type, use [jsonv2.Options].  See the \"Migrating to v2\" section for guidance on how to migrate usage of \"json\" from using v1 to using v2 instead."
      },
      {
        "name": "P",
        "desc": ""
      },
      {
        "name": "PP",
        "desc": ""
      },
      {
        "name": "Point",
        "desc": ""
      },
      {
        "name": "PointerCycle",
        "desc": ""
      },
      {
        "name": "PointerCycleIndirect",
        "desc": ""
      },
      {
        "name": "RawMessage",
        "desc": "RawMessage is a raw encoded JSON value. It implements [Marshaler] and [Unmarshaler] and can be used to delay JSON decoding or precompute a JSON encoding."
      },
      {
        "name": "RecursiveSlice",
        "desc": ""
      },
      {
        "name": "Ref",
        "desc": "Ref has Marshaler and Unmarshaler methods with pointer receiver."
      },
      {
        "name": "RefText",
        "desc": "RefText has Marshaler and Unmarshaler methods with pointer receiver."
      },
      {
        "name": "S10",
        "desc": "From reflect test: The X in S11.S6 and S12.S6 annihilate, but they also block the X in S13.S8.S9."
      },
      {
        "name": "S11",
        "desc": ""
      },
      {
        "name": "S12",
        "desc": ""
      },
      {
        "name": "S13",
        "desc": ""
      },
      {
        "name": "S5",
        "desc": "From reflect test: The X in S6 and S7 annihilate, but they also block the X in S8.S9."
      },
      {
        "name": "S6",
        "desc": ""
      },
      {
        "name": "S7",
        "desc": ""
      },
      {
        "name": "S8",
        "desc": ""
      },
      {
        "name": "S9",
        "desc": ""
      },
      {
        "name": "SS",
        "desc": ""
      },
      {
        "name": "SamePointerNoCycle",
        "desc": ""
      },
      {
        "name": "Small",
        "desc": ""
      },
      {
        "name": "StringTag",
        "desc": ""
      },
      {
        "name": "SyntaxError",
        "desc": "A SyntaxError is a description of a JSON syntax error. [Unmarshal] will return a SyntaxError if the JSON can't be parsed."
      },
      {
        "name": "T",
        "desc": ""
      },
      {
        "name": "TAlias",
        "desc": ""
      },
      {
        "name": "TOuter",
        "desc": ""
      },
      {
        "name": "Time3339",
        "desc": "Time3339 is a time.Time which encodes to and from JSON as an RFC 3339 time in UTC."
      },
      {
        "name": "Token",
        "desc": "A Token holds a value of one of these types:    - [Delim], for the four JSON delimiters [ ] { }   - bool, for JSON booleans   - float64, for JSON numbers   - [Number], for JSON numbers   - string, for JSON string literals   - nil, for JSON null"
      },
      {
        "name": "Top",
        "desc": ""
      },
      {
        "name": "U",
        "desc": ""
      },
      {
        "name": "UnmarshalFieldError",
        "desc": "An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field.  Deprecated: No longer used; kept for compatibility."
      },
      {
        "name": "UnmarshalTypeError",
        "desc": "An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type."
      },
      {
        "name": "Unmarshaler",
        "desc": "Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning."
      },
      {
        "name": "UnsupportedTypeError",
        "desc": "An UnsupportedTypeError is returned by [Marshal] when attempting to encode an unsupported value type."
      },
      {
        "name": "UnsupportedValueError",
        "desc": "An UnsupportedValueError is returned by [Marshal] when attempting to encode an unsupported value."
      },
      {
        "name": "V",
        "desc": ""
      },
      {
        "name": "VOuter",
        "desc": ""
      },
      {
        "name": "Val",
        "desc": "Val has Marshaler methods with value receiver."
      },
      {
        "name": "ValText",
        "desc": "ValText has Marshaler methods with value receiver."
      },
      {
        "name": "W",
        "desc": ""
      },
      {
        "name": "XYZ",
        "desc": ""
      },
      {
        "name": "Xint",
        "desc": ""
      },
      {
        "name": "arrayEncoder",
        "desc": ""
      },
      {
        "name": "badCodeTag",
        "desc": ""
      },
      {
        "name": "badFormatTag",
        "desc": ""
      },
      {
        "name": "basicLatin2xTag",
        "desc": ""
      },
      {
        "name": "basicLatin3xTag",
        "desc": ""
      },
      {
        "name": "basicLatin4xTag",
        "desc": ""
      },
      {
        "name": "basicLatin5xTag",
        "desc": ""
      },
      {
        "name": "basicLatin6xTag",
        "desc": ""
      },
      {
        "name": "basicLatin7xTag",
        "desc": ""
      },
      {
        "name": "byteWithMarshalJSON",
        "desc": ""
      },
      {
        "name": "byteWithMarshalText",
        "desc": ""
      },
      {
        "name": "byteWithPtrMarshalJSON",
        "desc": ""
      },
      {
        "name": "byteWithPtrMarshalText",
        "desc": ""
      },
      {
        "name": "codeNode",
        "desc": ""
      },
      {
        "name": "codeResponse",
        "desc": ""
      },
      {
        "name": "condAddrEncoder",
        "desc": ""
      },
      {
        "name": "dashTag",
        "desc": ""
      },
      {
        "name": "decodeState",
        "desc": "decodeState represents the state while decoding a JSON value."
      },
      {
        "name": "decodeThis",
        "desc": ""
      },
      {
        "name": "embed",
        "desc": ""
      },
      {
        "name": "emptyTag",
        "desc": ""
      },
      {
        "name": "encOpts",
        "desc": ""
      },
      {
        "name": "encodeState",
        "desc": "An encodeState encodes JSON into a bytes.Buffer."
      },
      {
        "name": "encoderFunc",
        "desc": ""
      },
      {
        "name": "errorContext",
        "desc": "An errorContext provides context for type errors during decoding."
      },
      {
        "name": "field",
        "desc": "A field represents a single field found in a struct."
      },
      {
        "name": "floatEncoder",
        "desc": ""
      },
      {
        "name": "intWithMarshalJSON",
        "desc": ""
      },
      {
        "name": "intWithMarshalText",
        "desc": ""
      },
      {
        "name": "intWithPtrMarshalJSON",
        "desc": ""
      },
      {
        "name": "intWithPtrMarshalText",
        "desc": ""
      },
      {
        "name": "isZeroer",
        "desc": ""
      },
      {
        "name": "jsonError",
        "desc": "jsonError is an error wrapper type for internal use only. Panics with errors are wrapped in jsonError so that the top-level recover can distinguish intentional panics from this package."
      },
      {
        "name": "jsonbyte",
        "desc": ""
      },
      {
        "name": "jsonint",
        "desc": ""
      },
      {
        "name": "mapEncoder",
        "desc": ""
      },
      {
        "name": "mapStringToStringData",
        "desc": ""
      },
      {
        "name": "marshalPanic",
        "desc": ""
      },
      {
        "name": "marshaledValue",
        "desc": ""
      },
      {
        "name": "miscPlaneTag",
        "desc": ""
      },
      {
        "name": "misnamedTag",
        "desc": ""
      },
      {
        "name": "nilJSONMarshaler",
        "desc": "golang.org/issue/16042. Even if a nil interface value is passed in, as long as it implements Marshaler, it should be marshaled."
      },
      {
        "name": "nilTextMarshaler",
        "desc": "golang.org/issue/34235. Even if a nil interface value is passed in, as long as it implements encoding.TextMarshaler, it should be marshaled."
      },
      {
        "name": "percentSlashTag",
        "desc": ""
      },
      {
        "name": "ptrEncoder",
        "desc": ""
      },
      {
        "name": "punctuationTag",
        "desc": ""
      },
      {
        "name": "reflectWithString",
        "desc": ""
      },
      {
        "name": "renamedByte",
        "desc": "byte slices are special even if they're renamed types."
      },
      {
        "name": "renamedByteSlice",
        "desc": ""
      },
      {
        "name": "renamedRenamedByteSlice",
        "desc": ""
      },
      {
        "name": "scanner",
        "desc": "A scanner is a JSON scanning state machine. Callers call scan.reset and then pass bytes in one at a time by calling scan.step(\u0026scan, c) for each byte. The return value, referred to as an opcode, tells the caller about significant parsing events like beginning and ending literals, objects, and arrays, so that the caller can follow along if it wishes. The return value scanEnd indicates that a single top-level JSON value has been completed, *before* the byte that just got passed in.  (The indication must be delayed in order to recognize the end of numbers: is 123 a whole value or the beginning of 12345e+6?)."
      },
      {
        "name": "sliceEncoder",
        "desc": "sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil."
      },
      {
        "name": "spaceTag",
        "desc": ""
      },
      {
        "name": "strMarshaler",
        "desc": ""
      },
      {
        "name": "strPtrMarshaler",
        "desc": ""
      },
      {
        "name": "structEncoder",
        "desc": ""
      },
      {
        "name": "structFields",
        "desc": ""
      },
      {
        "name": "tagOptions",
        "desc": "tagOptions is the string following a comma in a struct field's \"json\" tag, or the empty string. It does not include the leading comma."
      },
      {
        "name": "textUnmarshalerString",
        "desc": ""
      },
      {
        "name": "textbyte",
        "desc": ""
      },
      {
        "name": "textfloat",
        "desc": ""
      },
      {
        "name": "textint",
        "desc": ""
      },
      {
        "name": "tx",
        "desc": ""
      },
      {
        "name": "u8",
        "desc": ""
      },
      {
        "name": "u8marshal",
        "desc": "u8marshal is an integer type that can marshal/unmarshal itself."
      },
      {
        "name": "unexportedFields",
        "desc": "Test handling of unexported fields that should be ignored. Issue 4660"
      },
      {
        "name": "unexportedWithMethods",
        "desc": ""
      },
      {
        "name": "unicodeTag",
        "desc": ""
      },
      {
        "name": "unmarshalPanic",
        "desc": ""
      },
      {
        "name": "unmarshaler",
        "desc": ""
      },
      {
        "name": "unmarshalerText",
        "desc": ""
      },
      {
        "name": "unquotedValue",
        "desc": ""
      },
      {
        "name": "ustruct",
        "desc": ""
      },
      {
        "name": "ustructText",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/json/jsontext",
    "desc": "Package jsontext implements syntactic processing of JSON as specified in RFC 4627, RFC 7159, RFC 7493, RFC 8259, and RFC 8785. JSON is a simple data interchange format that can represent primitive data types such as booleans, strings, and numbers, in addition to structured data types such as objects and arrays.  This package (encoding/json/jsontext) is experimental, and not subject to the Go 1 compatibility promise. It only exists when building with the GOEXPERIMENT=jsonv2 environment variable set. Most users should use [encoding/json].  The [Encoder] and [Decoder] types are used to encode or decode a stream of JSON tokens or values.  # Tokens and Values  A JSON token refers to the basic structural elements of JSON:    - a JSON literal (i.e., null, true, or false)   - a JSON string (e.g., \"hello, world!\")   - a JSON number (e.g., 123.456)   - a begin or end delimiter for a JSON object (i.e., '{' or '}')   - a begin or end delimiter for a JSON array (i.e., '[' or ']')  A JSON token is represented by the [Token] type in Go. Technically, there are two additional structural characters (i.e., ':' and ','), but there is no [Token] representation for them since their presence can be inferred by the structure of the JSON grammar itself. For example, there must always be an implicit colon between the name and value of a JSON object member.  A JSON value refers to a complete unit of JSON data:    - a JSON literal, string, or number   - a JSON object (e.g., `{\"name\":\"value\"}`)   - a JSON array (e.g., `[1,2,3,]`)  A JSON value is represented by the [Value] type in Go and is a []byte containing the raw textual representation of the value. There is some overlap between tokens and values as both contain literals, strings, and numbers. However, only a value can represent the entirety of a JSON object or array.  The [Encoder] and [Decoder] types contain methods to read or write the next [Token] or [Value] in a sequence. They maintain a state machine to validate whether the sequence of JSON tokens and/or values produces a valid JSON. [Options] may be passed to the [NewEncoder] or [NewDecoder] constructors to configure the syntactic behavior of encoding and decoding.  # Terminology  The terms \"encode\" and \"decode\" are used for syntactic functionality that is concerned with processing JSON based on its grammar, and the terms \"marshal\" and \"unmarshal\" are used for semantic functionality that determines the meaning of JSON values as Go values and vice-versa. This package (i.e., [jsontext]) deals with JSON at a syntactic layer, while [encoding/json/v2] deals with JSON at a semantic layer. The goal is to provide a clear distinction between functionality that is purely concerned with encoding versus that of marshaling. For example, one can directly encode a stream of JSON tokens without needing to marshal a concrete Go value representing them. Similarly, one can decode a stream of JSON tokens without needing to unmarshal them into a concrete Go value.  This package uses JSON terminology when discussing JSON, which may differ from related concepts in Go or elsewhere in computing literature.    - a JSON \"object\" refers to an unordered collection of name/value members.   - a JSON \"array\" refers to an ordered sequence of elements.   - a JSON \"value\" refers to either a literal (i.e., null, false, or true),     string, number, object, or array.  See RFC 8259 for more information.  # Specifications  Relevant specifications include RFC 4627, RFC 7159, RFC 7493, RFC 8259, and RFC 8785. Each RFC is generally a stricter subset of another RFC. In increasing order of strictness:    - RFC 4627 and RFC 7159 do not require (but recommend) the use of UTF-8     and also do not require (but recommend) that object names be unique.   - RFC 8259 requires the use of UTF-8,     but does not require (but recommends) that object names be unique.   - RFC 7493 requires the use of UTF-8     and also requires that object names be unique.   - RFC 8785 defines a canonical representation. It requires the use of UTF-8     and also requires that object names be unique and in a specific ordering.     It specifies exactly how strings and numbers must be formatted.  The primary difference between RFC 4627 and RFC 7159 is that the former restricted top-level values to only JSON objects and arrays, while RFC 7159 and subsequent RFCs permit top-level values to additionally be JSON nulls, booleans, strings, or numbers.  By default, this package operates on RFC 7493, but can be configured to operate according to the other RFC specifications. RFC 7493 is a stricter subset of RFC 8259 and fully compliant with it. In particular, it makes specific choices about behavior that RFC 8259 leaves as undefined in order to ensure greater interoperability.  # Security Considerations  See the \"Security Considerations\" section in [encoding/json/v2].",
    "functions": [
      {
        "name": "AppendFormat",
        "desc": "AppendFormat formats the JSON value in src and appends it to dst according to the specified options. See [Value.Format] for more details about the formatting behavior.  The dst and src may overlap. If an error is reported, then the entirety of src is appended to dst."
      },
      {
        "name": "AppendQuote",
        "desc": "AppendQuote appends a double-quoted JSON string literal representing src to dst and returns the extended buffer. It uses the minimal string representation per RFC 8785, section 3.2.2.2. Invalid UTF-8 bytes are replaced with the Unicode replacement character and an error is returned at the end indicating the presence of invalid UTF-8. The dst must not overlap with the src."
      },
      {
        "name": "AppendUnquote",
        "desc": "AppendUnquote appends the decoded interpretation of src as a double-quoted JSON string literal to dst and returns the extended buffer. The input src must be a JSON string without any surrounding whitespace. Invalid UTF-8 bytes are replaced with the Unicode replacement character and an error is returned at the end indicating the presence of invalid UTF-8. Any trailing bytes after the JSON string literal results in an error. The dst must not overlap with the src."
      },
      {
        "name": "FuzzCoder",
        "desc": ""
      },
      {
        "name": "FuzzResumableDecoder",
        "desc": ""
      },
      {
        "name": "FuzzValueFormat",
        "desc": ""
      },
      {
        "name": "TestBlockingDecoder",
        "desc": "TestBlockingDecoder verifies that JSON values except numbers can be synchronously sent and received on a blocking pipe without a deadlock. Numbers are the exception since termination cannot be determined until either the pipe ends or a non-numeric character is encountered."
      },
      {
        "name": "TestBufferDecoder",
        "desc": "TestBufferDecoder tests that we detect misuses of bytes.Buffer with Decoder."
      },
      {
        "name": "TestCoderInterleaved",
        "desc": "TestCoderInterleaved tests that we can interleave calls that operate on tokens and raw values. The only error condition is trying to operate on a raw value when the next token is an end of object or array."
      },
      {
        "name": "TestCoderMaxDepth",
        "desc": ""
      },
      {
        "name": "TestCoderStackPointer",
        "desc": ""
      },
      {
        "name": "TestDecoder",
        "desc": "TestDecoder tests whether we can parse JSON with either tokens or raw values."
      },
      {
        "name": "TestDecoderErrors",
        "desc": "TestDecoderErrors test that Decoder errors occur when we expect and leaves the Decoder in a consistent state."
      },
      {
        "name": "TestEncoder",
        "desc": "TestEncoder tests whether we can produce JSON with either tokens or raw values."
      },
      {
        "name": "TestEncoderErrors",
        "desc": "TestEncoderErrors test that Encoder errors occur when we expect and leaves the Encoder in a consistent state."
      },
      {
        "name": "TestFaultyDecoder",
        "desc": "TestFaultyDecoder tests that temporary I/O errors are not fatal."
      },
      {
        "name": "TestFaultyEncoder",
        "desc": "TestFaultyEncoder tests that temporary I/O errors are not fatal."
      },
      {
        "name": "TestObjectNamespace",
        "desc": ""
      },
      {
        "name": "TestPeekableDecoder",
        "desc": ""
      },
      {
        "name": "TestPointer",
        "desc": ""
      },
      {
        "name": "TestResumableDecoder",
        "desc": "TestResumableDecoder tests that resume logic for parsing a JSON string and number properly works across every possible split point."
      },
      {
        "name": "TestStateMachine",
        "desc": ""
      },
      {
        "name": "TestTokenAccessors",
        "desc": ""
      },
      {
        "name": "TestTokenClone",
        "desc": ""
      },
      {
        "name": "TestTokenStringAllocations",
        "desc": ""
      },
      {
        "name": "TestValueMethods",
        "desc": ""
      },
      {
        "name": "appendEscapePointerName",
        "desc": ""
      },
      {
        "name": "equalError",
        "desc": ""
      },
      {
        "name": "equalTokens",
        "desc": "equalTokens reports whether to sequences of tokens formats the same way."
      },
      {
        "name": "getObjectMembers",
        "desc": ""
      },
      {
        "name": "mustReorderObjects",
        "desc": "mustReorderObjects reorders in-place all object members in a JSON value, which must be valid otherwise it panics."
      },
      {
        "name": "mustReorderObjectsFromDecoder",
        "desc": "mustReorderObjectsFromDecoder recursively reorders all object members in place according to the ordering specified in RFC 8785, section 3.2.3.  Pre-conditions:   - The value is valid (i.e., no decoder errors should ever occur).   - Initial call is provided a Decoder reading from the start of v.  Post-conditions:   - Exactly one JSON value is read from the Decoder.   - All fully-parsed JSON objects are reordered by directly moving     the members in the value buffer.  The runtime is approximately O(n·log(n)) + O(m·log(m)), where n is len(v) and m is the total number of object members."
      },
      {
        "name": "putBufferedDecoder",
        "desc": ""
      },
      {
        "name": "putBufferedEncoder",
        "desc": ""
      },
      {
        "name": "putObjectMembers",
        "desc": ""
      },
      {
        "name": "putStreamingDecoder",
        "desc": ""
      },
      {
        "name": "putStreamingEncoder",
        "desc": ""
      },
      {
        "name": "testCoderInterleaved",
        "desc": ""
      },
      {
        "name": "testDecoder",
        "desc": ""
      },
      {
        "name": "testDecoderErrors",
        "desc": ""
      },
      {
        "name": "testEncoder",
        "desc": ""
      },
      {
        "name": "testEncoderErrors",
        "desc": ""
      },
      {
        "name": "testFaultyDecoder",
        "desc": ""
      },
      {
        "name": "testFaultyEncoder",
        "desc": ""
      },
      {
        "name": "unescapePointerToken",
        "desc": ""
      },
      {
        "name": "wrapSyntacticError",
        "desc": "wrapSyntacticError wraps an error and annotates it with a precise location using the provided [encoderState] or [decoderState]. If err is an [ioError] or [io.EOF], then it is not wrapped.  It takes a relative offset pos that can be resolved into an absolute offset using state.offsetAt.  It takes a where that specify how the JSON pointer is derived. If the underlying error is a [pointerSuffixError], then the suffix is appended to the derived pointer."
      },
      {
        "name": "wrapWithArrayIndex",
        "desc": "wrapWithArrayIndex wraps err with a JSON array index access."
      },
      {
        "name": "wrapWithObjectName",
        "desc": "wrapWithObjectName wraps err with a JSON object name access, which must be a valid quoted JSON string."
      },
      {
        "name": "InputOffset",
        "desc": "InputOffset returns the current input byte offset. It gives the location of the next byte immediately after the most recently returned token or value. The number of bytes actually read from the underlying [io.Reader] may be more than this offset due to internal buffering effects."
      },
      {
        "name": "Options",
        "desc": "Options returns the options used to construct the encoder and may additionally contain semantic options passed to a [encoding/json/v2.UnmarshalDecode] call.  If operating within a [encoding/json/v2.UnmarshalerFrom.UnmarshalJSONFrom] method call or a [encoding/json/v2.UnmarshalFromFunc] function call, then the returned options are only valid within the call."
      },
      {
        "name": "PeekKind",
        "desc": "PeekKind retrieves the next token kind, but does not advance the read offset.  It returns 0 if an error occurs. Any such error is cached until the next read call and it is the caller's responsibility to eventually follow up a PeekKind call with a read call."
      },
      {
        "name": "ReadToken",
        "desc": "ReadToken reads the next [Token], advancing the read offset. The returned token is only valid until the next Peek, Read, or Skip call. It returns [io.EOF] if there are no more tokens."
      },
      {
        "name": "ReadValue",
        "desc": "ReadValue returns the next raw JSON value, advancing the read offset. The value is stripped of any leading or trailing whitespace and contains the exact bytes of the input, which may contain invalid UTF-8 if [AllowInvalidUTF8] is specified.  The returned value is only valid until the next Peek, Read, or Skip call and may not be mutated while the Decoder remains in use. If the decoder is currently at the end token for an object or array, then it reports a [SyntacticError] and the internal state remains unchanged. It returns [io.EOF] if there are no more values."
      },
      {
        "name": "Reset",
        "desc": "Reset resets a decoder such that it is reading afresh from r and configured with the provided options. Reset must not be called on an a Decoder passed to the [encoding/json/v2.UnmarshalerFrom.UnmarshalJSONFrom] method or the [encoding/json/v2.UnmarshalFromFunc] function."
      },
      {
        "name": "SkipValue",
        "desc": "SkipValue is semantically equivalent to calling [Decoder.ReadValue] and discarding the result except that memory is not wasted trying to hold the entire result."
      },
      {
        "name": "StackDepth",
        "desc": "StackDepth returns the depth of the state machine for read JSON data. Each level on the stack represents a nested JSON object or array. It is incremented whenever an [BeginObject] or [BeginArray] token is encountered and decremented whenever an [EndObject] or [EndArray] token is encountered. The depth is zero-indexed, where zero represents the top-level JSON value."
      },
      {
        "name": "StackIndex",
        "desc": "StackIndex returns information about the specified stack level. It must be a number between 0 and [Decoder.StackDepth], inclusive. For each level, it reports the kind:    - 0 for a level of zero,   - '{' for a level representing a JSON object, and   - '[' for a level representing a JSON array.  It also reports the length of that JSON object or array. Each name and value in a JSON object is counted separately, so the effective number of members would be half the length. A complete JSON object must have an even length."
      },
      {
        "name": "StackPointer",
        "desc": "StackPointer returns a JSON Pointer (RFC 6901) to the most recently read value."
      },
      {
        "name": "UnreadBuffer",
        "desc": "UnreadBuffer returns the data remaining in the unread buffer, which may contain zero or more bytes. The returned buffer must not be mutated while Decoder continues to be used. The buffer contents are valid until the next Peek, Read, or Skip call."
      },
      {
        "name": "AvailableBuffer",
        "desc": "AvailableBuffer returns a zero-length buffer with a possible non-zero capacity. This buffer is intended to be used to populate a [Value] being passed to an immediately succeeding [Encoder.WriteValue] call.  Example usage:  \tb := d.AvailableBuffer() \tb = append(b, '\"') \tb = appendString(b, v) // append the string formatting of v \tb = append(b, '\"') \t... := d.WriteValue(b)  It is the user's responsibility to ensure that the value is valid JSON."
      },
      {
        "name": "Options",
        "desc": "Options returns the options used to construct the decoder and may additionally contain semantic options passed to a [encoding/json/v2.MarshalEncode] call.  If operating within a [encoding/json/v2.MarshalerTo.MarshalJSONTo] method call or a [encoding/json/v2.MarshalToFunc] function call, then the returned options are only valid within the call."
      },
      {
        "name": "OutputOffset",
        "desc": "OutputOffset returns the current output byte offset. It gives the location of the next byte immediately after the most recently written token or value. The number of bytes actually written to the underlying [io.Writer] may be less than this offset due to internal buffering effects."
      },
      {
        "name": "Reset",
        "desc": "Reset resets an encoder such that it is writing afresh to w and configured with the provided options. Reset must not be called on a Encoder passed to the [encoding/json/v2.MarshalerTo.MarshalJSONTo] method or the [encoding/json/v2.MarshalToFunc] function."
      },
      {
        "name": "StackDepth",
        "desc": "StackDepth returns the depth of the state machine for written JSON data. Each level on the stack represents a nested JSON object or array. It is incremented whenever an [BeginObject] or [BeginArray] token is encountered and decremented whenever an [EndObject] or [EndArray] token is encountered. The depth is zero-indexed, where zero represents the top-level JSON value."
      },
      {
        "name": "StackIndex",
        "desc": "StackIndex returns information about the specified stack level. It must be a number between 0 and [Encoder.StackDepth], inclusive. For each level, it reports the kind:    - 0 for a level of zero,   - '{' for a level representing a JSON object, and   - '[' for a level representing a JSON array.  It also reports the length of that JSON object or array. Each name and value in a JSON object is counted separately, so the effective number of members would be half the length. A complete JSON object must have an even length."
      },
      {
        "name": "StackPointer",
        "desc": "StackPointer returns a JSON Pointer (RFC 6901) to the most recently written value."
      },
      {
        "name": "WriteToken",
        "desc": "WriteToken writes the next token and advances the internal write offset.  The provided token kind must be consistent with the JSON grammar. For example, it is an error to provide a number when the encoder is expecting an object name (which is always a string), or to provide an end object delimiter when the encoder is finishing an array. If the provided token is invalid, then it reports a [SyntacticError] and the internal state remains unchanged. The offset reported in [SyntacticError] will be relative to the [Encoder.OutputOffset]."
      },
      {
        "name": "WriteValue",
        "desc": "WriteValue writes the next raw value and advances the internal write offset. The Encoder does not simply copy the provided value verbatim, but parses it to ensure that it is syntactically valid and reformats it according to how the Encoder is configured to format whitespace and strings. If [AllowInvalidUTF8] is specified, then any invalid UTF-8 is mangled as the Unicode replacement character, U+FFFD.  The provided value kind must be consistent with the JSON grammar (see examples on [Encoder.WriteToken]). If the provided value is invalid, then it reports a [SyntacticError] and the internal state remains unchanged. The offset reported in [SyntacticError] will be relative to the [Encoder.OutputOffset] plus the offset into v of any encountered syntax error."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "mayError",
        "desc": "mayError may return a non-nil error."
      },
      {
        "name": "mayTruncate",
        "desc": "mayTruncate may return a value between [0, n]."
      },
      {
        "name": "randN",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String prints the kind in a humanly readable fashion."
      },
      {
        "name": "normalize",
        "desc": "normalize coalesces all possible starting characters of a number as just '0'."
      },
      {
        "name": "AppendToken",
        "desc": "AppendToken appends a token to the end of p and returns the full pointer."
      },
      {
        "name": "Contains",
        "desc": "Contains reports whether the JSON value that p points to is equal to or contains the JSON value that pc points to."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether p is a valid JSON Pointer according to RFC 6901. Note that the concatenation of two valid pointers produces a valid pointer."
      },
      {
        "name": "LastToken",
        "desc": "LastToken returns the last token in the pointer. The last token of an empty p is an empty string."
      },
      {
        "name": "Parent",
        "desc": "Parent strips off the last token and returns the remaining pointer. The parent of an empty p is an empty string."
      },
      {
        "name": "Tokens",
        "desc": "Tokens returns an iterator over the reference tokens in the JSON pointer, starting from the first token until the last token (unless stopped early)."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "withPos",
        "desc": ""
      },
      {
        "name": "Bool",
        "desc": "Bool returns the value for a JSON boolean. It panics if the token kind is not a JSON boolean."
      },
      {
        "name": "Clone",
        "desc": "Clone makes a copy of the Token such that its value remains valid even after a subsequent [Decoder.Read] call."
      },
      {
        "name": "Float",
        "desc": "Float returns the floating-point value for a JSON number. It returns a NaN, +Inf, or -Inf value for any JSON string with the values \"NaN\", \"Infinity\", or \"-Infinity\". It panics for all other cases."
      },
      {
        "name": "Int",
        "desc": "Int returns the signed integer value for a JSON number. The fractional component of any number is ignored (truncation toward zero). Any number beyond the representation of an int64 will be saturated to the closest representable value. It panics if the token kind is not a JSON number."
      },
      {
        "name": "Kind",
        "desc": "Kind returns the token kind."
      },
      {
        "name": "String",
        "desc": "String returns the unescaped string value for a JSON string. For other JSON kinds, this returns the raw JSON representation."
      },
      {
        "name": "Uint",
        "desc": "Uint returns the unsigned integer value for a JSON number. The fractional component of any number is ignored (truncation toward zero). Any number beyond the representation of an uint64 will be saturated to the closest representable value. It panics if the token kind is not a JSON number."
      },
      {
        "name": "appendNumber",
        "desc": "appendNumber appends a JSON number to dst and returns it. It panics if t is not a JSON number."
      },
      {
        "name": "appendString",
        "desc": "appendString appends a JSON string to dst and returns it. It panics if t is not a JSON string."
      },
      {
        "name": "string",
        "desc": ""
      },
      {
        "name": "Canonicalize",
        "desc": "Canonicalize canonicalizes the raw JSON value according to the JSON Canonicalization Scheme (JCS) as defined by RFC 8785 where it produces a stable representation of a JSON value.  JSON strings are formatted to use their minimal representation, JSON numbers are formatted as double precision numbers according to some stable serialization algorithm. JSON object members are sorted in ascending order by name. All whitespace is removed.  The output stability is dependent on the stability of the application data (see RFC 8785, Appendix E). It cannot produce stable output from fundamentally unstable input. For example, if the JSON value contains ephemeral data (e.g., a frequently changing timestamp), then the value is still unstable regardless of whether this is called.  Canonicalize is equivalent to calling [Value.Format] with the following options:   - [CanonicalizeRawInts](true)   - [CanonicalizeRawFloats](true)   - [ReorderRawObjects](true)  Any options specified by the caller are applied after the initial set and may deliberately override prior options.  Note that JCS treats all JSON numbers as IEEE 754 double precision numbers. Any numbers with precision beyond what is representable by that form will lose their precision when canonicalized. For example, integer values beyond ±2⁵³ will lose their precision. To preserve the original representation of JSON integers, additionally set [CanonicalizeRawInts] to false:  \tv.Canonicalize(jsontext.CanonicalizeRawInts(false))"
      },
      {
        "name": "Clone",
        "desc": "Clone returns a copy of v."
      },
      {
        "name": "Compact",
        "desc": "Compact removes all whitespace from the raw JSON value.  It does not reformat JSON strings or numbers to use any other representation. To maximize the set of JSON values that can be formatted, this permits values with duplicate names and invalid UTF-8.  Compact is equivalent to calling [Value.Format] with the following options:   - [AllowDuplicateNames](true)   - [AllowInvalidUTF8](true)   - [PreserveRawStrings](true)  Any options specified by the caller are applied after the initial set and may deliberately override prior options."
      },
      {
        "name": "Format",
        "desc": "Format formats the raw JSON value in place.  By default (if no options are specified), it validates according to RFC 7493 and produces the minimal JSON representation, where all whitespace is elided and JSON strings use the shortest encoding.  Relevant options include:   - [AllowDuplicateNames]   - [AllowInvalidUTF8]   - [EscapeForHTML]   - [EscapeForJS]   - [PreserveRawStrings]   - [CanonicalizeRawInts]   - [CanonicalizeRawFloats]   - [ReorderRawObjects]   - [SpaceAfterColon]   - [SpaceAfterComma]   - [Multiline]   - [WithIndent]   - [WithIndentPrefix]  All other options are ignored.  It is guaranteed to succeed if the value is valid according to the same options. If the value is already formatted, then the buffer is not mutated."
      },
      {
        "name": "Indent",
        "desc": "Indent reformats the whitespace in the raw JSON value so that each element in a JSON object or array begins on a indented line according to the nesting.  It does not reformat JSON strings or numbers to use any other representation. To maximize the set of JSON values that can be formatted, this permits values with duplicate names and invalid UTF-8.  Indent is equivalent to calling [Value.Format] with the following options:   - [AllowDuplicateNames](true)   - [AllowInvalidUTF8](true)   - [PreserveRawStrings](true)   - [Multiline](true)  Any options specified by the caller are applied after the initial set and may deliberately override prior options."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether the raw JSON value is syntactically valid according to the specified options.  By default (if no options are specified), it validates according to RFC 7493. It verifies whether the input is properly encoded as UTF-8, that escape sequences within strings decode to valid Unicode codepoints, and that all names in each object are unique. It does not verify whether numbers are representable within the limits of any common numeric type (e.g., float64, int64, or uint64).  Relevant options include:   - [AllowDuplicateNames]   - [AllowInvalidUTF8]  All other options are ignored."
      },
      {
        "name": "Kind",
        "desc": "Kind returns the starting token kind. For a valid value, this will never include '}' or ']'."
      },
      {
        "name": "MarshalJSON",
        "desc": "MarshalJSON returns v as the JSON encoding of v. It returns the stored value as the raw JSON output without any validation. If v is nil, then this returns a JSON null."
      },
      {
        "name": "String",
        "desc": "String returns the string formatting of v."
      },
      {
        "name": "UnmarshalJSON",
        "desc": "UnmarshalJSON sets v as the JSON encoding of b. It stores a copy of the provided raw JSON input without any validation."
      },
      {
        "name": "format",
        "desc": "format accepts two []Options to avoid the allocation appending them together. It is equivalent to v.Format(append(opts1, opts2...)...)."
      },
      {
        "name": "PreviousTokenOrValue",
        "desc": "PreviousTokenOrValue returns the previously read token or value unless it has been invalidated by a call to PeekKind. If a token is just a delimiter, then this returns a 1-byte buffer. This method is used for error reporting at the semantic layer."
      },
      {
        "name": "invalidatePreviousRead",
        "desc": "invalidatePreviousRead invalidates buffers returned by Peek and Read calls so that the first byte is an invalid character. This Hyrum-proofs the API against faulty application code that assumes values returned by ReadValue remain valid past subsequent Read calls."
      },
      {
        "name": "needMore",
        "desc": "needMore reports whether there are no more unread bytes."
      },
      {
        "name": "offsetAt",
        "desc": ""
      },
      {
        "name": "previousBuffer",
        "desc": ""
      },
      {
        "name": "previousOffsetEnd",
        "desc": ""
      },
      {
        "name": "previousOffsetStart",
        "desc": ""
      },
      {
        "name": "unreadBuffer",
        "desc": ""
      },
      {
        "name": "AppendStackPointer",
        "desc": ""
      },
      {
        "name": "CheckEOF",
        "desc": "CheckEOF verifies that the input has no more data."
      },
      {
        "name": "CheckNextValue",
        "desc": "CheckNextValue checks whether the next value is syntactically valid, but does not advance the read offset."
      },
      {
        "name": "CountNextDelimWhitespace",
        "desc": "CountNextDelimWhitespace counts the number of upcoming bytes of delimiter or whitespace characters. This method is used for error reporting at the semantic layer."
      },
      {
        "name": "PeekKind",
        "desc": ""
      },
      {
        "name": "PreviousTokenOrValue",
        "desc": "PreviousTokenOrValue returns the previously read token or value unless it has been invalidated by a call to PeekKind. If a token is just a delimiter, then this returns a 1-byte buffer. This method is used for error reporting at the semantic layer."
      },
      {
        "name": "ReadToken",
        "desc": ""
      },
      {
        "name": "ReadValue",
        "desc": ""
      },
      {
        "name": "SkipUntil",
        "desc": "SkipUntil skips all tokens until the state machine is at or past the specified depth and length."
      },
      {
        "name": "SkipValue",
        "desc": ""
      },
      {
        "name": "SkipValueRemainder",
        "desc": "SkipValueRemainder skips the remainder of a value after reading a '{' or '[' token."
      },
      {
        "name": "appendStackPointer",
        "desc": "appendStackPointer appends a JSON Pointer (RFC 6901) to the current value.    - If where is -1, then it points to the previously processed token.    - If where is 0, then it points to the parent JSON object or array,     or an object member if in-between an object member key and value.     This is useful when the position is ambiguous whether     we are interested in the previous or next token, or     when we are uncertain whether the next token     continues or terminates the current object or array.    - If where is +1, then it points to the next expected value,     assuming that it continues the current JSON object or array.     As a special case, if the next token is a JSON object name,     then it points to the parent JSON object.  Invariant: Must call s.names.copyQuotedBuffer beforehand."
      },
      {
        "name": "checkDelim",
        "desc": "checkDelim checks whether delim is valid for the given next kind."
      },
      {
        "name": "checkDelimBeforeIOError",
        "desc": "checkDelimBeforeIOError checks whether the delim is even valid before returning an IO error, which occurs after the delim."
      },
      {
        "name": "consumeArray",
        "desc": "consumeArray consumes a single JSON array starting at d.buf[pos:]. It returns the new position in d.buf immediately after the array."
      },
      {
        "name": "consumeLiteral",
        "desc": "consumeLiteral consumes a single JSON literal starting at d.buf[pos:]. It returns the new position in d.buf immediately after the literal."
      },
      {
        "name": "consumeNumber",
        "desc": "consumeNumber consumes a single JSON number starting at d.buf[pos:]. It returns the new position in d.buf immediately after the number."
      },
      {
        "name": "consumeObject",
        "desc": "consumeObject consumes a single JSON object starting at d.buf[pos:]. It returns the new position in d.buf immediately after the object."
      },
      {
        "name": "consumeString",
        "desc": "consumeString consumes a single JSON string starting at d.buf[pos:]. It returns the new position in d.buf immediately after the string."
      },
      {
        "name": "consumeValue",
        "desc": "consumeValue consumes a single JSON value starting at d.buf[pos:]. It returns the new position in d.buf immediately after the value."
      },
      {
        "name": "consumeWhitespace",
        "desc": "consumeWhitespace consumes all whitespace starting at d.buf[pos:]. It returns the new position in d.buf immediately after the last whitespace. If it returns nil, there is guaranteed to at least be one unread byte.  The following pattern is common in this implementation:  \tpos += jsonwire.ConsumeWhitespace(d.buf[pos:]) \tif d.needMore(pos) { \t\tif pos, err = d.consumeWhitespace(pos); err != nil { \t\t\treturn ... \t\t} \t}  It is difficult to simplify this without sacrificing performance since consumeWhitespace must be inlined. The body of the if statement is executed only in rare situations where we need to fetch more data. Since fetching may return an error, we also need to check the error."
      },
      {
        "name": "fetch",
        "desc": "fetch reads at least 1 byte from the underlying io.Reader. It returns io.ErrUnexpectedEOF if zero bytes were read and io.EOF was seen."
      },
      {
        "name": "invalidatePreviousRead",
        "desc": "invalidatePreviousRead invalidates buffers returned by Peek and Read calls so that the first byte is an invalid character. This Hyrum-proofs the API against faulty application code that assumes values returned by ReadValue remain valid past subsequent Read calls."
      },
      {
        "name": "needMore",
        "desc": "needMore reports whether there are no more unread bytes."
      },
      {
        "name": "needObjectValue",
        "desc": "needObjectValue reports whether the next token should be an object value. This method is used by [wrapSyntacticError]."
      },
      {
        "name": "offsetAt",
        "desc": ""
      },
      {
        "name": "previousBuffer",
        "desc": ""
      },
      {
        "name": "previousOffsetEnd",
        "desc": ""
      },
      {
        "name": "previousOffsetStart",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "unreadBuffer",
        "desc": ""
      },
      {
        "name": "offsetAt",
        "desc": ""
      },
      {
        "name": "previousOffsetEnd",
        "desc": ""
      },
      {
        "name": "unflushedBuffer",
        "desc": ""
      },
      {
        "name": "AppendIndent",
        "desc": "AppendIndent appends the appropriate number of indentation characters for the current nested level, n."
      },
      {
        "name": "AppendRaw",
        "desc": "AppendRaw appends either a raw string (without double quotes) or number. Specify safeASCII if the string output is guaranteed to be ASCII without any characters (including '\u003c', '\u003e', and '\u0026') that need escaping, otherwise this will validate whether the string needs escaping. The appended bytes for a JSON number must be valid.  This is a specialized implementation of Encoder.WriteValue that allows appending directly into the buffer. It is only called from marshal logic in the \"json\" package."
      },
      {
        "name": "AppendStackPointer",
        "desc": ""
      },
      {
        "name": "CountNextDelimWhitespace",
        "desc": "CountNextDelimWhitespace counts the number of bytes of delimiter and whitespace bytes assuming the upcoming token is a JSON value. This method is used for error reporting at the semantic layer."
      },
      {
        "name": "Flush",
        "desc": "Flush flushes the buffer to the underlying io.Writer. It may append a trailing newline after the top-level value."
      },
      {
        "name": "NeedFlush",
        "desc": "NeedFlush determines whether to flush at this point."
      },
      {
        "name": "UnwriteEmptyObjectMember",
        "desc": "UnwriteEmptyObjectMember unwrites the last object member if it is empty and reports whether it performed an unwrite operation."
      },
      {
        "name": "UnwriteOnlyObjectMemberName",
        "desc": "UnwriteOnlyObjectMemberName unwrites the only object member name and returns the unquoted name."
      },
      {
        "name": "WriteToken",
        "desc": ""
      },
      {
        "name": "WriteValue",
        "desc": ""
      },
      {
        "name": "appendStackPointer",
        "desc": "appendStackPointer appends a JSON Pointer (RFC 6901) to the current value.    - If where is -1, then it points to the previously processed token.    - If where is 0, then it points to the parent JSON object or array,     or an object member if in-between an object member key and value.     This is useful when the position is ambiguous whether     we are interested in the previous or next token, or     when we are uncertain whether the next token     continues or terminates the current object or array.    - If where is +1, then it points to the next expected value,     assuming that it continues the current JSON object or array.     As a special case, if the next token is a JSON object name,     then it points to the parent JSON object.  Invariant: Must call s.names.copyQuotedBuffer beforehand."
      },
      {
        "name": "appendWhitespace",
        "desc": "appendWhitespace appends whitespace that immediately precedes the next token."
      },
      {
        "name": "avoidFlush",
        "desc": "avoidFlush indicates whether to avoid flushing to ensure there is always enough in the buffer to unwrite the last object member if it were empty."
      },
      {
        "name": "needObjectValue",
        "desc": "needObjectValue reports whether the next token should be an object value. This method is used by [wrapSyntacticError]."
      },
      {
        "name": "offsetAt",
        "desc": ""
      },
      {
        "name": "previousOffsetEnd",
        "desc": ""
      },
      {
        "name": "reformatArray",
        "desc": "reformatArray parses a JSON array from the start of src and appends it to the end of dst, reformatting whitespace and strings as needed. It returns the extended dst buffer and the number of consumed input bytes."
      },
      {
        "name": "reformatObject",
        "desc": "reformatObject parses a JSON object from the start of src and appends it to the end of src, reformatting whitespace and strings as needed. It returns the extended dst buffer and the number of consumed input bytes."
      },
      {
        "name": "reformatValue",
        "desc": "reformatValue parses a JSON value from the start of src and appends it to the end of dst, reformatting whitespace and strings as needed. It returns the extended dst buffer and the number of consumed input bytes."
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "unflushedBuffer",
        "desc": ""
      },
      {
        "name": "Decoder",
        "desc": "Decoder returns a pointer to the underlying decoderState."
      },
      {
        "name": "Encoder",
        "desc": "Encoder returns a pointer to the underlying encoderState."
      },
      {
        "name": "GetBufferedDecoder",
        "desc": ""
      },
      {
        "name": "GetBufferedEncoder",
        "desc": ""
      },
      {
        "name": "GetStreamingDecoder",
        "desc": ""
      },
      {
        "name": "GetStreamingEncoder",
        "desc": ""
      },
      {
        "name": "IsIOError",
        "desc": ""
      },
      {
        "name": "PutBufferedDecoder",
        "desc": ""
      },
      {
        "name": "PutBufferedEncoder",
        "desc": ""
      },
      {
        "name": "PutStreamingDecoder",
        "desc": ""
      },
      {
        "name": "PutStreamingEncoder",
        "desc": ""
      },
      {
        "name": "Export",
        "desc": "Export exposes internal functionality from \"jsontext\" to \"json\". This cannot be dynamically called by other packages since they cannot obtain a reference to the internal.AllowInternalUse value."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Compare",
        "desc": ""
      },
      {
        "name": "ReplaceLastQuotedOffset",
        "desc": "ReplaceLastQuotedOffset replaces the last name with the starting offset to the quoted name in some remote buffer. All offsets provided must be relative to the same buffer until copyQuotedBuffer is called."
      },
      {
        "name": "clearLast",
        "desc": "clearLast removes any name in the last JSON object. It is semantically equivalent to ns.push followed by ns.pop."
      },
      {
        "name": "copyQuotedBuffer",
        "desc": "copyQuotedBuffer copies names from the remote buffer into the local names buffer so that there are no more offset references into the remote buffer. This allows the remote buffer to change contents without affecting the names that this data structure is trying to remember."
      },
      {
        "name": "ensureCopiedBuffer",
        "desc": ""
      },
      {
        "name": "getUnquoted",
        "desc": "getUnquoted retrieves the ith unquoted name in the stack. It returns an empty string if the last object is empty.  Invariant: Must call copyQuotedBuffer beforehand."
      },
      {
        "name": "length",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": "pop ascends out of a nested JSON object."
      },
      {
        "name": "push",
        "desc": "push descends into a nested JSON object."
      },
      {
        "name": "replaceLastUnquotedName",
        "desc": "replaceLastUnquotedName replaces the last name with the provided name.  Invariant: Must call copyQuotedBuffer beforehand."
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "InsertUnquoted",
        "desc": ""
      },
      {
        "name": "getUnquoted",
        "desc": "getUnquoted retrieves the ith unquoted name in the namespace."
      },
      {
        "name": "insert",
        "desc": ""
      },
      {
        "name": "insertQuoted",
        "desc": "insertQuoted inserts a name and reports whether it was inserted, which only occurs if name is not already in the namespace. The provided name must be a valid JSON string."
      },
      {
        "name": "lastUnquoted",
        "desc": "lastUnquoted retrieves the last name in the namespace."
      },
      {
        "name": "length",
        "desc": "length reports the number of names in the namespace."
      },
      {
        "name": "removeLast",
        "desc": "removeLast removes the last name in the namespace."
      },
      {
        "name": "reset",
        "desc": "reset resets the namespace to be empty."
      },
      {
        "name": "Last",
        "desc": "Last returns a pointer to the last JSON object namespace."
      },
      {
        "name": "pop",
        "desc": "pop terminates the namespace for a nested JSON object."
      },
      {
        "name": "push",
        "desc": "push starts a new namespace for a nested JSON object."
      },
      {
        "name": "reset",
        "desc": "reset resets the object namespace stack."
      },
      {
        "name": "appendPointer",
        "desc": "appendPointer appends the path encoded in e to the end of pointer."
      },
      {
        "name": "appendStackPointer",
        "desc": "appendStackPointer appends a JSON Pointer (RFC 6901) to the current value.    - If where is -1, then it points to the previously processed token.    - If where is 0, then it points to the parent JSON object or array,     or an object member if in-between an object member key and value.     This is useful when the position is ambiguous whether     we are interested in the previous or next token, or     when we are uncertain whether the next token     continues or terminates the current object or array.    - If where is +1, then it points to the next expected value,     assuming that it continues the current JSON object or array.     As a special case, if the next token is a JSON object name,     then it points to the parent JSON object.  Invariant: Must call s.names.copyQuotedBuffer beforehand."
      },
      {
        "name": "needObjectValue",
        "desc": "needObjectValue reports whether the next token should be an object value. This method is used by [wrapSyntacticError]."
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "DisableNamespace",
        "desc": "DisableNamespace disables the JSON object namespace such that the Encoder or Decoder no longer updates the namespace."
      },
      {
        "name": "Increment",
        "desc": "Increment increments the number of elements for the current object or array. This assumes that overflow won't practically be an issue since 1\u003c\u003cbits.OnesCount(stateCountMask) is sufficiently large."
      },
      {
        "name": "Length",
        "desc": "Length reports the number of elements in the JSON object or array. Each name and value in an object entry is treated as a separate element."
      },
      {
        "name": "NeedObjectName",
        "desc": "NeedObjectName reports whether the next token must be a JSON string, which is necessary for JSON object names."
      },
      {
        "name": "decrement",
        "desc": "decrement decrements the number of elements for the current object or array. It is the callers responsibility to ensure that e.length \u003e 0."
      },
      {
        "name": "invalidateNamespace",
        "desc": "invalidateNamespace marks the JSON object namespace as being invalid."
      },
      {
        "name": "isActiveNamespace",
        "desc": "isActiveNamespace reports whether the JSON object namespace is actively being updated and used for duplicate name checks."
      },
      {
        "name": "isArray",
        "desc": "isArray reports whether this is a JSON array."
      },
      {
        "name": "isObject",
        "desc": "isObject reports whether this is a JSON object."
      },
      {
        "name": "isValidNamespace",
        "desc": "isValidNamespace reports whether the JSON object namespace is valid."
      },
      {
        "name": "needImplicitColon",
        "desc": "needImplicitColon reports whether an colon should occur next, which always occurs after JSON object names."
      },
      {
        "name": "needImplicitComma",
        "desc": "needImplicitComma reports whether an comma should occur next, which always occurs after a value in a JSON object or array before the next value (or name)."
      },
      {
        "name": "needObjectValue",
        "desc": "needObjectValue reports whether the next token must be a JSON value, which is necessary after every JSON object name."
      },
      {
        "name": "Depth",
        "desc": "Depth is the current nested depth of JSON objects and arrays. It is one-indexed (i.e., top-level values have a depth of 1)."
      },
      {
        "name": "DepthLength",
        "desc": "DepthLength reports the current nested depth and the length of the last JSON object or array."
      },
      {
        "name": "InvalidateDisabledNamespaces",
        "desc": "InvalidateDisabledNamespaces marks all disabled namespaces as invalid.  For efficiency, Marshal and Unmarshal may disable namespaces since there are more efficient ways to track duplicate names. However, if an error occurs, the namespaces in Encoder or Decoder will be left in an inconsistent state. Mark the namespaces as invalid so that future method calls on Encoder or Decoder will return an error."
      },
      {
        "name": "MayAppendDelim",
        "desc": "MayAppendDelim appends a colon or comma that may precede the next token."
      },
      {
        "name": "NeedIndent",
        "desc": "NeedIndent reports whether indent whitespace should be injected. A zero value means that no whitespace should be injected. A positive value means '\\n', indentPrefix, and (n-1) copies of indentBody should be appended to the output immediately before the next token."
      },
      {
        "name": "append",
        "desc": "append is a thin wrapper over the other append, pop, or push methods based on the token kind."
      },
      {
        "name": "appendLiteral",
        "desc": "appendLiteral appends a JSON literal as the next token in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "appendNumber",
        "desc": "appendNumber appends a JSON number as the next token in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "appendString",
        "desc": "appendString appends a JSON string as the next token in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "index",
        "desc": "index returns a reference to the ith entry. It is only valid until the next push method call."
      },
      {
        "name": "needDelim",
        "desc": "needDelim reports whether a colon or comma token should be implicitly emitted before the next token of the specified kind. A zero value means no delimiter should be emitted."
      },
      {
        "name": "popArray",
        "desc": "popArray appends a JSON end array token as next in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "popObject",
        "desc": "popObject appends a JSON end object token as next in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "pushArray",
        "desc": "pushArray appends a JSON begin array token as next in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "pushObject",
        "desc": "pushObject appends a JSON begin object token as next in the sequence. If an error is returned, the state is not mutated."
      },
      {
        "name": "reset",
        "desc": "reset resets the state machine. The machine always starts with a minimum depth of 1."
      }
    ],
    "types": [
      {
        "name": "Decoder",
        "desc": "Decoder is a streaming decoder for raw JSON tokens and values. It is used to read a stream of top-level JSON values, each separated by optional whitespace characters.  [Decoder.ReadToken] and [Decoder.ReadValue] calls may be interleaved. For example, the following JSON value:  \t{\"name\":\"value\",\"array\":[null,false,true,3.14159],\"object\":{\"k\":\"v\"}}  can be parsed with the following calls (ignoring errors for brevity):  \td.ReadToken() // { \td.ReadToken() // \"name\" \td.ReadToken() // \"value\" \td.ReadValue() // \"array\" \td.ReadToken() // [ \td.ReadToken() // null \td.ReadToken() // false \td.ReadValue() // true \td.ReadToken() // 3.14159 \td.ReadToken() // ] \td.ReadValue() // \"object\" \td.ReadValue() // {\"k\":\"v\"} \td.ReadToken() // }  The above is one of many possible sequence of calls and may not represent the most sensible method to call for any given token/value. For example, it is probably more common to call [Decoder.ReadToken] to obtain a string token for object names."
      },
      {
        "name": "Encoder",
        "desc": "Encoder is a streaming encoder from raw JSON tokens and values. It is used to write a stream of top-level JSON values, each terminated with a newline character.  [Encoder.WriteToken] and [Encoder.WriteValue] calls may be interleaved. For example, the following JSON value:  \t{\"name\":\"value\",\"array\":[null,false,true,3.14159],\"object\":{\"k\":\"v\"}}  can be composed with the following calls (ignoring errors for brevity):  \te.WriteToken(BeginObject)        // { \te.WriteToken(String(\"name\"))     // \"name\" \te.WriteToken(String(\"value\"))    // \"value\" \te.WriteValue(Value(`\"array\"`))   // \"array\" \te.WriteToken(BeginArray)         // [ \te.WriteToken(Null)               // null \te.WriteToken(False)              // false \te.WriteValue(Value(\"true\"))      // true \te.WriteToken(Float(3.14159))     // 3.14159 \te.WriteToken(EndArray)           // ] \te.WriteValue(Value(`\"object\"`))  // \"object\" \te.WriteValue(Value(`{\"k\":\"v\"}`)) // {\"k\":\"v\"} \te.WriteToken(EndObject)          // }  The above is one of many possible sequence of calls and may not represent the most sensible method to call for any given token/value. For example, it is probably more common to call [Encoder.WriteToken] with a string for object names."
      },
      {
        "name": "FaultyBuffer",
        "desc": "FaultyBuffer implements io.Reader and io.Writer. It may process fewer bytes than the provided buffer and may randomly return an error."
      },
      {
        "name": "Kind",
        "desc": "Kind represents each possible JSON token kind with a single byte, which is conveniently the first byte of that kind's grammar with the restriction that numbers always be represented with '0':    - 'n': null   - 'f': false   - 't': true   - '\"': string   - '0': number   - '{': object begin   - '}': object end   - '[': array begin   - ']': array end  An invalid kind is usually represented using 0, but may be non-zero due to invalid JSON data."
      },
      {
        "name": "Options",
        "desc": "Options configures [NewEncoder], [Encoder.Reset], [NewDecoder], and [Decoder.Reset] with specific features. Each function takes in a variadic list of options, where properties set in latter options override the value of previously set properties.  There is a single Options type, which is used with both encoding and decoding. Some options affect both operations, while others only affect one operation:    - [AllowDuplicateNames] affects encoding and decoding   - [AllowInvalidUTF8] affects encoding and decoding   - [EscapeForHTML] affects encoding only   - [EscapeForJS] affects encoding only   - [PreserveRawStrings] affects encoding only   - [CanonicalizeRawInts] affects encoding only   - [CanonicalizeRawFloats] affects encoding only   - [ReorderRawObjects] affects encoding only   - [SpaceAfterColon] affects encoding only   - [SpaceAfterComma] affects encoding only   - [Multiline] affects encoding only   - [WithIndent] affects encoding only   - [WithIndentPrefix] affects encoding only  Options that do not affect a particular operation are ignored.  The Options type is identical to [encoding/json.Options] and [encoding/json/v2.Options]. Options from the other packages may be passed to functionality in this package, but are ignored. Options from this package may be used with the other packages."
      },
      {
        "name": "Pointer",
        "desc": "Pointer is a JSON Pointer (RFC 6901) that references a particular JSON value relative to the root of the top-level JSON value.  A Pointer is a slash-separated list of tokens, where each token is either a JSON object name or an index to a JSON array element encoded as a base-10 integer value. It is impossible to distinguish between an array index and an object name (that happens to be an base-10 encoded integer) without also knowing the structure of the top-level JSON value that the pointer refers to.  There is exactly one representation of a pointer to a particular value, so comparability of Pointer values is equivalent to checking whether they both point to the exact same value."
      },
      {
        "name": "SyntacticError",
        "desc": "SyntacticError is a description of a syntactic error that occurred when encoding or decoding JSON according to the grammar.  The contents of this error as produced by this package may change over time."
      },
      {
        "name": "Token",
        "desc": "Token represents a lexical JSON token, which may be one of the following:   - a JSON literal (i.e., null, true, or false)   - a JSON string (e.g., \"hello, world!\")   - a JSON number (e.g., 123.456)   - a begin or end delimiter for a JSON object (i.e., { or } )   - a begin or end delimiter for a JSON array (i.e., [ or ] )  A Token cannot represent entire array or object values, while a [Value] can. There is no Token to represent commas and colons since these structural tokens can be inferred from the surrounding context."
      },
      {
        "name": "Value",
        "desc": "Value represents a single raw JSON value, which may be one of the following:   - a JSON literal (i.e., null, true, or false)   - a JSON string (e.g., \"hello, world!\")   - a JSON number (e.g., 123.456)   - an entire JSON object (e.g., {\"fizz\":\"buzz\"} )   - an entire JSON array (e.g., [1,2,3] )  Value can represent entire array or object values, while [Token] cannot. Value may contain leading and/or trailing whitespace."
      },
      {
        "name": "bufferStatistics",
        "desc": "bufferStatistics is statistics to track buffer utilization. It is used to determine whether to recycle a buffer or not to avoid https://go.dev/issue/23199."
      },
      {
        "name": "coderTestdataEntry",
        "desc": ""
      },
      {
        "name": "decodeBuffer",
        "desc": "decodeBuffer is a buffer split into 4 segments:    - buf[0:prevEnd]         // already read portion of the buffer   - buf[prevStart:prevEnd] // previously read value   - buf[prevEnd:len(buf)]  // unread portion of the buffer   - buf[len(buf):cap(buf)] // unused portion of the buffer  Invariants:  \t0 ≤ prevStart ≤ prevEnd ≤ len(buf) ≤ cap(buf)"
      },
      {
        "name": "decoderMethodCall",
        "desc": ""
      },
      {
        "name": "decoderState",
        "desc": "decoderState is the low-level state of Decoder. It has exported fields and method for use by the \"json\" package."
      },
      {
        "name": "encodeBuffer",
        "desc": "encodeBuffer is a buffer split into 2 segments:    - buf[0:len(buf)]        // written (but unflushed) portion of the buffer   - buf[len(buf):cap(buf)] // unused portion of the buffer"
      },
      {
        "name": "encoderMethodCall",
        "desc": ""
      },
      {
        "name": "encoderState",
        "desc": "encoderState is the low-level state of Encoder. It has exported fields and method for use by the \"json\" package."
      },
      {
        "name": "export",
        "desc": "The export type exposes functionality to packages with visibility to the internal.AllowInternalUse variable. The \"json\" package uses this to modify low-level state in the Encoder and Decoder types. It mutates the state directly instead of calling ReadToken or WriteToken since this is more performant. The public APIs need to track state to ensure that users are constructing a valid JSON value, but the \"json\" implementation guarantees that it emits valid JSON by the structure of the code itself."
      },
      {
        "name": "exporter",
        "desc": ""
      },
      {
        "name": "ioError",
        "desc": ""
      },
      {
        "name": "nonComparable",
        "desc": "nonComparable can be embedded in a struct to prevent comparability."
      },
      {
        "name": "objectMember",
        "desc": ""
      },
      {
        "name": "objectNameStack",
        "desc": "objectNameStack is a stack of names when descending into a JSON object. In contrast to objectNamespaceStack, this only has to remember a single name per JSON object.  This data structure may contain offsets to encodeBuffer or decodeBuffer. It violates clean abstraction of layers, but is significantly more efficient. This ensures that popping and pushing in the common case is a trivial push/pop of an offset integer.  The zero value is an empty names stack ready for use."
      },
      {
        "name": "objectNamespace",
        "desc": "objectNamespace is the namespace for a JSON object. In contrast to objectNameStack, this needs to remember a all names per JSON object.  The zero value is an empty namespace ready for use."
      },
      {
        "name": "objectNamespaceStack",
        "desc": "objectNamespaceStack is a stack of object namespaces. This data structure assists in detecting duplicate names."
      },
      {
        "name": "pointerSuffixError",
        "desc": "pointerSuffixError represents a JSON pointer suffix to be appended to [SyntacticError.JSONPointer]. It is an internal error type used within this package and does not appear in the public API.  This type is primarily used to annotate errors in Encoder.WriteValue and Decoder.ReadValue with precise positions. At the time WriteValue or ReadValue is called, a JSON pointer to the upcoming value can be constructed using the Encoder/Decoder state. However, tracking pointers within values during normal operation would incur a performance penalty in the error-free case.  To provide precise error locations without this overhead, the error is wrapped with object names or array indices as the call stack is popped when an error occurs. Since this happens in reverse order, pointerSuffixError holds the pointer in reverse and is only later reversed when appending to the pointer prefix.  For example, if the encoder is at \"/alpha/bravo/charlie\" and an error occurs in WriteValue at \"/xray/yankee/zulu\", then the final pointer should be \"/alpha/bravo/charlie/xray/yankee/zulu\".  As pointerSuffixError is populated during the error return path, it first contains \"/zulu\", then \"/zulu/yankee\", and finally \"/zulu/yankee/xray\". These tokens are reversed and concatenated to \"/alpha/bravo/charlie\" to form the full pointer."
      },
      {
        "name": "requireKeyedLiterals",
        "desc": "requireKeyedLiterals can be embedded in a struct to require keyed literals."
      },
      {
        "name": "state",
        "desc": ""
      },
      {
        "name": "stateEntry",
        "desc": "stateEntry encodes several artifacts within a single unsigned integer:   - whether this represents a JSON object or array,   - whether this object should check for duplicate names, and   - how many elements are in this JSON object or array."
      },
      {
        "name": "stateMachine",
        "desc": "stateMachine is a push-down automaton that validates whether a sequence of tokens is valid or not according to the JSON grammar. It is useful for both encoding and decoding.  It is a stack where each entry represents a nested JSON object or array. The stack has a minimum depth of 1 where the first level is a virtual JSON array to handle a stream of top-level JSON values. The top-level virtual JSON array is special in that it doesn't require commas between each JSON value.  For performance, most methods are carefully written to be inlinable. The zero value is a valid state machine ready for use."
      },
      {
        "name": "tokOrVal",
        "desc": "tokOrVal is either a Token or a Value."
      },
      {
        "name": "valueTestdataEntry",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/json/v2",
    "desc": "Package json implements semantic processing of JSON as specified in RFC 8259. JSON is a simple data interchange format that can represent primitive data types such as booleans, strings, and numbers, in addition to structured data types such as objects and arrays.  This package (encoding/json/v2) is experimental, and not subject to the Go 1 compatibility promise. It only exists when building with the GOEXPERIMENT=jsonv2 environment variable set. Most users should use [encoding/json].  [Marshal] and [Unmarshal] encode and decode Go values to/from JSON text contained within a []byte. [MarshalWrite] and [UnmarshalRead] operate on JSON text by writing to or reading from an [io.Writer] or [io.Reader]. [MarshalEncode] and [UnmarshalDecode] operate on JSON text by encoding to or decoding from a [jsontext.Encoder] or [jsontext.Decoder]. [Options] may be passed to each of the marshal or unmarshal functions to configure the semantic behavior of marshaling and unmarshaling (i.e., alter how JSON data is understood as Go data and vice versa). [jsontext.Options] may also be passed to the marshal or unmarshal functions to configure the syntactic behavior of encoding or decoding.  The data types of JSON are mapped to/from the data types of Go based on the closest logical equivalent between the two type systems. For example, a JSON boolean corresponds with a Go bool, a JSON string corresponds with a Go string, a JSON number corresponds with a Go int, uint or float, a JSON array corresponds with a Go slice or array, and a JSON object corresponds with a Go struct or map. See the documentation on [Marshal] and [Unmarshal] for a comprehensive list of how the JSON and Go type systems correspond.  Arbitrary Go types can customize their JSON representation by implementing [Marshaler], [MarshalerTo], [Unmarshaler], or [UnmarshalerFrom]. This provides authors of Go types with control over how their types are serialized as JSON. Alternatively, users can implement functions that match [MarshalFunc], [MarshalToFunc], [UnmarshalFunc], or [UnmarshalFromFunc] to specify the JSON representation for arbitrary types. This provides callers of JSON functionality with control over how any arbitrary type is serialized as JSON.  # JSON Representation of Go structs  A Go struct is naturally represented as a JSON object, where each Go struct field corresponds with a JSON object member. When marshaling, all Go struct fields are recursively encoded in depth-first order as JSON object members except those that are ignored or omitted. When unmarshaling, JSON object members are recursively decoded into the corresponding Go struct fields. Object members that do not match any struct fields, also known as “unknown members”, are ignored by default or rejected if [RejectUnknownMembers] is specified.  The representation of each struct field can be customized in the \"json\" struct field tag, where the tag is a comma separated list of options. As a special case, if the entire tag is `json:\"-\"`, then the field is ignored with regard to its JSON representation. Some options also have equivalent behavior controlled by a caller-specified [Options]. Field-specified options take precedence over caller-specified options.  The first option is the JSON object name override for the Go struct field. If the name is not specified, then the Go struct field name is used as the JSON object name. JSON names containing commas or quotes, or names identical to \"\" or \"-\", can be specified using a single-quoted string literal, where the syntax is identical to the Go grammar for a double-quoted string literal, but instead uses single quotes as the delimiters. By default, unmarshaling uses case-sensitive matching to identify the Go struct field associated with a JSON object name.  After the name, the following tag options are supported:    - omitzero: When marshaling, the \"omitzero\" option specifies that     the struct field should be omitted if the field value is zero     as determined by the \"IsZero() bool\" method if present,     otherwise based on whether the field is the zero Go value.     This option has no effect when unmarshaling.    - omitempty: When marshaling, the \"omitempty\" option specifies that     the struct field should be omitted if the field value would have been     encoded as a JSON null, empty string, empty object, or empty array.     This option has no effect when unmarshaling.    - string: The \"string\" option specifies that [StringifyNumbers]     be set when marshaling or unmarshaling a struct field value.     This causes numeric types to be encoded as a JSON number     within a JSON string, and to be decoded from a JSON string     containing the JSON number without any surrounding whitespace.     This extra level of encoding is often necessary since     many JSON parsers cannot precisely represent 64-bit integers.    - case: When unmarshaling, the \"case\" option specifies how     JSON object names are matched with the JSON name for Go struct fields.     The option is a key-value pair specified as \"case:value\" where     the value must either be 'ignore' or 'strict'.     The 'ignore' value specifies that matching is case-insensitive     where dashes and underscores are also ignored. If multiple fields match,     the first declared field in breadth-first order takes precedence.     The 'strict' value specifies that matching is case-sensitive.     This takes precedence over the [MatchCaseInsensitiveNames] option.    - inline: The \"inline\" option specifies that     the JSON representable content of this field type is to be promoted     as if they were specified in the parent struct.     It is the JSON equivalent of Go struct embedding.     A Go embedded field is implicitly inlined unless an explicit JSON name     is specified. The inlined field must be a Go struct     (that does not implement any JSON methods), [jsontext.Value],     map[~string]T, or an unnamed pointer to such types. When marshaling,     inlined fields from a pointer type are omitted if it is nil.     Inlined fields of type [jsontext.Value] and map[~string]T are called     “inlined fallbacks” as they can represent all possible     JSON object members not directly handled by the parent struct.     Only one inlined fallback field may be specified in a struct,     while many non-fallback fields may be specified. This option     must not be specified with any other option (including the JSON name).    - unknown: The \"unknown\" option is a specialized variant     of the inlined fallback to indicate that this Go struct field     contains any number of unknown JSON object members. The field type must     be a [jsontext.Value], map[~string]T, or an unnamed pointer to such types.     If [DiscardUnknownMembers] is specified when marshaling,     the contents of this field are ignored.     If [RejectUnknownMembers] is specified when unmarshaling,     any unknown object members are rejected regardless of whether     an inlined fallback with the \"unknown\" option exists. This option     must not be specified with any other option (including the JSON name).    - format: The \"format\" option specifies a format flag     used to specialize the formatting of the field value.     The option is a key-value pair specified as \"format:value\" where     the value must be either a literal consisting of letters and numbers     (e.g., \"format:RFC3339\") or a single-quoted string literal     (e.g., \"format:'2006-01-02'\"). The interpretation of the format flag     is determined by the struct field type.  The \"omitzero\" and \"omitempty\" options are mostly semantically identical. The former is defined in terms of the Go type system, while the latter in terms of the JSON type system. Consequently they behave differently in some circumstances. For example, only a nil slice or map is omitted under \"omitzero\", while an empty slice or map is omitted under \"omitempty\" regardless of nilness. The \"omitzero\" option is useful for types with a well-defined zero value (e.g., [net/netip.Addr]) or have an IsZero method (e.g., [time.Time.IsZero]).  Every Go struct corresponds to a list of JSON representable fields which is constructed by performing a breadth-first search over all struct fields (excluding unexported or ignored fields), where the search recursively descends into inlined structs. The set of non-inlined fields in a struct must have unique JSON names. If multiple fields all have the same JSON name, then the one at shallowest depth takes precedence and the other fields at deeper depths are excluded from the list of JSON representable fields. If multiple fields at the shallowest depth have the same JSON name, but exactly one is explicitly tagged with a JSON name, then that field takes precedence and all others are excluded from the list. This is analogous to Go visibility rules for struct field selection with embedded struct types.  Marshaling or unmarshaling a non-empty struct without any JSON representable fields results in a [SemanticError]. Unexported fields must not have any `json` tags except for `json:\"-\"`.  # Security Considerations  JSON is frequently used as a data interchange format to communicate between different systems, possibly implemented in different languages. For interoperability and security reasons, it is important that all implementations agree upon the semantic meaning of the data.  [For example, suppose we have two micro-services.] The first service is responsible for authenticating a JSON request, while the second service is responsible for executing the request (having assumed that the prior service authenticated the request). If an attacker were able to maliciously craft a JSON request such that both services believe that the same request is from different users, it could bypass the authenticator with valid credentials for one user, but maliciously perform an action on behalf of a different user.  According to RFC 8259, there unfortunately exist many JSON texts that are syntactically valid but semantically ambiguous. For example, the standard does not define how to interpret duplicate names within an object.  The v1 [encoding/json] and [encoding/json/v2] packages interpret some inputs in different ways. In particular:    - The standard specifies that JSON must be encoded using UTF-8.     By default, v1 replaces invalid bytes of UTF-8 in JSON strings     with the Unicode replacement character,     while v2 rejects inputs with invalid UTF-8.     To change the default, specify the [jsontext.AllowInvalidUTF8] option.     The replacement of invalid UTF-8 is a form of data corruption     that alters the precise meaning of strings.    - The standard does not specify a particular behavior when     duplicate names are encountered within a JSON object,     which means that different implementations may behave differently.     By default, v1 allows for the presence of duplicate names,     while v2 rejects duplicate names.     To change the default, specify the [jsontext.AllowDuplicateNames] option.     If allowed, object members are processed in the order they are observed,     meaning that later values will replace or be merged into prior values,     depending on the Go value type.    - The standard defines a JSON object as an unordered collection of name/value pairs.     While ordering can be observed through the underlying [jsontext] API,     both v1 and v2 generally avoid exposing the ordering.     No application should semantically depend on the order of object members.     Allowing duplicate names is a vector through which ordering of members     can accidentally be observed and depended upon.    - The standard suggests that JSON object names are typically compared     based on equality of the sequence of Unicode code points,     which implies that comparing names is often case-sensitive.     When unmarshaling a JSON object into a Go struct,     by default, v1 uses a (loose) case-insensitive match on the name,     while v2 uses a (strict) case-sensitive match on the name.     To change the default, specify the [MatchCaseInsensitiveNames] option.     The use of case-insensitive matching provides another vector through     which duplicate names can occur. Allowing case-insensitive matching     means that v1 or v2 might interpret JSON objects differently from most     other JSON implementations (which typically use a case-sensitive match).    - The standard does not specify a particular behavior when     an unknown name in a JSON object is encountered.     When unmarshaling a JSON object into a Go struct, by default     both v1 and v2 ignore unknown names and their corresponding values.     To change the default, specify the [RejectUnknownMembers] option.    - The standard suggests that implementations may use a float64     to represent a JSON number. Consequently, large JSON integers     may lose precision when stored as a floating-point type.     Both v1 and v2 correctly preserve precision when marshaling and     unmarshaling a concrete integer type. However, even if v1 and v2     preserve precision for concrete types, other JSON implementations     may not be able to preserve precision for outputs produced by v1 or v2.     The `string` tag option can be used to specify that an integer type     is to be quoted within a JSON string to avoid loss of precision.     Furthermore, v1 and v2 may still lose precision when unmarshaling     into an any interface value, where unmarshal uses a float64     by default to represent a JSON number.     To change the default, specify the [WithUnmarshalers] option     with a custom unmarshaler that pre-populates the interface value     with a concrete Go type that can preserve precision.  RFC 8785 specifies a canonical form for any JSON text, which explicitly defines specific behaviors that RFC 8259 leaves undefined. In theory, if a text can successfully [jsontext.Value.Canonicalize] without changing the semantic meaning of the data, then it provides a greater degree of confidence that the data is more secure and interoperable.  The v2 API generally chooses more secure defaults than v1, but care should still be taken with large integers or unknown members.  [For example, suppose we have two micro-services.]: https://www.youtube.com/watch?v=avilmOcHKHE\u0026t=1057s",
    "functions": [
      {
        "name": "BenchmarkIntern",
        "desc": ""
      },
      {
        "name": "BenchmarkMarshalEncodeOptions",
        "desc": "BenchmarkMarshalEncodeOptions is a minimal encode operation to measure the overhead of options setup before the marshal operation."
      },
      {
        "name": "BenchmarkUnmarshalDecodeOptions",
        "desc": "BenchmarkUnmarshalDecodeOptions is a minimal decode operation to measure the overhead options setup before the unmarshal operation."
      },
      {
        "name": "FuzzEqualFold",
        "desc": ""
      },
      {
        "name": "FuzzFormatDuration",
        "desc": ""
      },
      {
        "name": "FuzzFormatTime",
        "desc": ""
      },
      {
        "name": "FuzzParseDuration",
        "desc": ""
      },
      {
        "name": "FuzzParseTime",
        "desc": ""
      },
      {
        "name": "GetOption",
        "desc": "GetOption returns the value stored in opts with the provided setter, reporting whether the value is present.  Example usage:  \tv, ok := json.GetOption(opts, json.Deterministic)  Options are most commonly introspected to alter the JSON representation of [MarshalerTo.MarshalJSONTo] and [UnmarshalerFrom.UnmarshalJSONFrom] methods, and [MarshalToFunc] and [UnmarshalFromFunc] functions. In such cases, the presence bit should generally be ignored."
      },
      {
        "name": "Marshal",
        "desc": "Marshal serializes a Go value as a []byte according to the provided marshal and encode options (while ignoring unmarshal or decode options). It does not terminate the output with a newline.  Type-specific marshal functions and methods take precedence over the default representation of a value. Functions or methods that operate on *T are only called when encoding a value of type T (by taking its address) or a non-nil value of *T. Marshal ensures that a value is always addressable (by boxing it on the heap if necessary) so that these functions and methods can be consistently called. For performance, it is recommended that Marshal be passed a non-nil pointer to the value.  The input value is encoded as JSON according the following rules:    - If any type-specific functions in a [WithMarshalers] option match     the value type, then those functions are called to encode the value.     If all applicable functions return [SkipFunc],     then the value is encoded according to subsequent rules.    - If the value type implements [MarshalerTo],     then the MarshalJSONTo method is called to encode the value.    - If the value type implements [Marshaler],     then the MarshalJSON method is called to encode the value.    - If the value type implements [encoding.TextAppender],     then the AppendText method is called to encode the value and     subsequently encode its result as a JSON string.    - If the value type implements [encoding.TextMarshaler],     then the MarshalText method is called to encode the value and     subsequently encode its result as a JSON string.    - Otherwise, the value is encoded according to the value's type     as described in detail below.  Most Go types have a default JSON representation. Certain types support specialized formatting according to a format flag optionally specified in the Go struct tag for the struct field that contains the current value (see the “JSON Representation of Go structs” section for more details).  The representation of each type is as follows:    - A Go boolean is encoded as a JSON boolean (e.g., true or false).     It does not support any custom format flags.    - A Go string is encoded as a JSON string.     It does not support any custom format flags.    - A Go []byte or [N]byte is encoded as a JSON string containing     the binary value encoded using RFC 4648.     If the format is \"base64\" or unspecified, then this uses RFC 4648, section 4.     If the format is \"base64url\", then this uses RFC 4648, section 5.     If the format is \"base32\", then this uses RFC 4648, section 6.     If the format is \"base32hex\", then this uses RFC 4648, section 7.     If the format is \"base16\" or \"hex\", then this uses RFC 4648, section 8.     If the format is \"array\", then the bytes value is encoded as a JSON array     where each byte is recursively JSON-encoded as each JSON array element.    - A Go integer is encoded as a JSON number without fractions or exponents.     If [StringifyNumbers] is specified or encoding a JSON object name,     then the JSON number is encoded within a JSON string.     It does not support any custom format flags.    - A Go float is encoded as a JSON number.     If [StringifyNumbers] is specified or encoding a JSON object name,     then the JSON number is encoded within a JSON string.     If the format is \"nonfinite\", then NaN, +Inf, and -Inf are encoded as     the JSON strings \"NaN\", \"Infinity\", and \"-Infinity\", respectively.     Otherwise, the presence of non-finite numbers results in a [SemanticError].    - A Go map is encoded as a JSON object, where each Go map key and value     is recursively encoded as a name and value pair in the JSON object.     The Go map key must encode as a JSON string, otherwise this results     in a [SemanticError]. The Go map is traversed in a non-deterministic order.     For deterministic encoding, consider using the [Deterministic] option.     If the format is \"emitnull\", then a nil map is encoded as a JSON null.     If the format is \"emitempty\", then a nil map is encoded as an empty JSON object,     regardless of whether [FormatNilMapAsNull] is specified.     Otherwise by default, a nil map is encoded as an empty JSON object.    - A Go struct is encoded as a JSON object.     See the “JSON Representation of Go structs” section     in the package-level documentation for more details.    - A Go slice is encoded as a JSON array, where each Go slice element     is recursively JSON-encoded as the elements of the JSON array.     If the format is \"emitnull\", then a nil slice is encoded as a JSON null.     If the format is \"emitempty\", then a nil slice is encoded as an empty JSON array,     regardless of whether [FormatNilSliceAsNull] is specified.     Otherwise by default, a nil slice is encoded as an empty JSON array.    - A Go array is encoded as a JSON array, where each Go array element     is recursively JSON-encoded as the elements of the JSON array.     The JSON array length is always identical to the Go array length.     It does not support any custom format flags.    - A Go pointer is encoded as a JSON null if nil, otherwise it is     the recursively JSON-encoded representation of the underlying value.     Format flags are forwarded to the encoding of the underlying value.    - A Go interface is encoded as a JSON null if nil, otherwise it is     the recursively JSON-encoded representation of the underlying value.     It does not support any custom format flags.    - A Go [time.Time] is encoded as a JSON string containing the timestamp     formatted in RFC 3339 with nanosecond precision.     If the format matches one of the format constants declared     in the time package (e.g., RFC1123), then that format is used.     If the format is \"unix\", \"unixmilli\", \"unixmicro\", or \"unixnano\",     then the timestamp is encoded as a possibly fractional JSON number     of the number of seconds (or milliseconds, microseconds, or nanoseconds)     since the Unix epoch, which is January 1st, 1970 at 00:00:00 UTC.     To avoid a fractional component, round the timestamp to the relevant unit.     Otherwise, the format is used as-is with [time.Time.Format] if non-empty.    - A Go [time.Duration] currently has no default representation and     requires an explicit format to be specified.     If the format is \"sec\", \"milli\", \"micro\", or \"nano\",     then the duration is encoded as a possibly fractional JSON number     of the number of seconds (or milliseconds, microseconds, or nanoseconds).     To avoid a fractional component, round the duration to the relevant unit.     If the format is \"units\", it is encoded as a JSON string formatted using     [time.Duration.String] (e.g., \"1h30m\" for 1 hour 30 minutes).     If the format is \"iso8601\", it is encoded as a JSON string using the     ISO 8601 standard for durations (e.g., \"PT1H30M\" for 1 hour 30 minutes)     using only accurate units of hours, minutes, and seconds.    - All other Go types (e.g., complex numbers, channels, and functions)     have no default representation and result in a [SemanticError].  JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures will result in an error."
      },
      {
        "name": "MarshalEncode",
        "desc": "MarshalEncode serializes a Go value into an [jsontext.Encoder] according to the provided marshal options (while ignoring unmarshal, encode, or decode options). Any marshal-relevant options already specified on the [jsontext.Encoder] take lower precedence than the set of options provided by the caller. Unlike [Marshal] and [MarshalWrite], encode options are ignored because they must have already been specified on the provided [jsontext.Encoder].  See [Marshal] for details about the conversion of a Go value into JSON."
      },
      {
        "name": "MarshalWrite",
        "desc": "MarshalWrite serializes a Go value into an [io.Writer] according to the provided marshal and encode options (while ignoring unmarshal or decode options). It does not terminate the output with a newline. See [Marshal] for details about the conversion of a Go value into JSON."
      },
      {
        "name": "T",
        "desc": ""
      },
      {
        "name": "TestBenchmarkUnmarshalUnknown",
        "desc": "TestBenchmarkUnmarshalUnknown unmarshals an unknown field into a struct with varying number of fields. Since the unknown field does not directly match any known field by name, it must fall back on case-insensitive matching."
      },
      {
        "name": "TestCoderBufferGrowth",
        "desc": ""
      },
      {
        "name": "TestEqualFold",
        "desc": ""
      },
      {
        "name": "TestFoldRune",
        "desc": ""
      },
      {
        "name": "TestFormatDuration",
        "desc": ""
      },
      {
        "name": "TestFormatTime",
        "desc": ""
      },
      {
        "name": "TestInline",
        "desc": ""
      },
      {
        "name": "TestIntern",
        "desc": ""
      },
      {
        "name": "TestMakeStructFields",
        "desc": ""
      },
      {
        "name": "TestMarshal",
        "desc": ""
      },
      {
        "name": "TestMarshalEncodeOptions",
        "desc": ""
      },
      {
        "name": "TestMarshalInvalidNamespace",
        "desc": ""
      },
      {
        "name": "TestParseDuration",
        "desc": ""
      },
      {
        "name": "TestParseTagOptions",
        "desc": ""
      },
      {
        "name": "TestParseTime",
        "desc": ""
      },
      {
        "name": "TestSemanticError",
        "desc": ""
      },
      {
        "name": "TestUintSet",
        "desc": ""
      },
      {
        "name": "TestUnmarshal",
        "desc": ""
      },
      {
        "name": "TestUnmarshalDecodeOptions",
        "desc": ""
      },
      {
        "name": "TestUnmarshalInvalidNamespace",
        "desc": ""
      },
      {
        "name": "TestUnmarshalReuse",
        "desc": ""
      },
      {
        "name": "Unmarshal",
        "desc": "Unmarshal decodes a []byte input into a Go value according to the provided unmarshal and decode options (while ignoring marshal or encode options). The input must be a single JSON value with optional whitespace interspersed. The output must be a non-nil pointer.  Type-specific unmarshal functions and methods take precedence over the default representation of a value. Functions or methods that operate on *T are only called when decoding a value of type T (by taking its address) or a non-nil value of *T. Unmarshal ensures that a value is always addressable (by boxing it on the heap if necessary) so that these functions and methods can be consistently called.  The input is decoded into the output according the following rules:    - If any type-specific functions in a [WithUnmarshalers] option match     the value type, then those functions are called to decode the JSON     value. If all applicable functions return [SkipFunc],     then the input is decoded according to subsequent rules.    - If the value type implements [UnmarshalerFrom],     then the UnmarshalJSONFrom method is called to decode the JSON value.    - If the value type implements [Unmarshaler],     then the UnmarshalJSON method is called to decode the JSON value.    - If the value type implements [encoding.TextUnmarshaler],     then the input is decoded as a JSON string and     the UnmarshalText method is called with the decoded string value.     This fails with a [SemanticError] if the input is not a JSON string.    - Otherwise, the JSON value is decoded according to the value's type     as described in detail below.  Most Go types have a default JSON representation. Certain types support specialized formatting according to a format flag optionally specified in the Go struct tag for the struct field that contains the current value (see the “JSON Representation of Go structs” section for more details). A JSON null may be decoded into every supported Go value where it is equivalent to storing the zero value of the Go value. If the input JSON kind is not handled by the current Go value type, then this fails with a [SemanticError]. Unless otherwise specified, the decoded value replaces any pre-existing value.  The representation of each type is as follows:    - A Go boolean is decoded from a JSON boolean (e.g., true or false).     It does not support any custom format flags.    - A Go string is decoded from a JSON string.     It does not support any custom format flags.    - A Go []byte or [N]byte is decoded from a JSON string     containing the binary value encoded using RFC 4648.     If the format is \"base64\" or unspecified, then this uses RFC 4648, section 4.     If the format is \"base64url\", then this uses RFC 4648, section 5.     If the format is \"base32\", then this uses RFC 4648, section 6.     If the format is \"base32hex\", then this uses RFC 4648, section 7.     If the format is \"base16\" or \"hex\", then this uses RFC 4648, section 8.     If the format is \"array\", then the Go slice or array is decoded from a     JSON array where each JSON element is recursively decoded for each byte.     When decoding into a non-nil []byte, the slice length is reset to zero     and the decoded input is appended to it.     When decoding into a [N]byte, the input must decode to exactly N bytes,     otherwise it fails with a [SemanticError].    - A Go integer is decoded from a JSON number.     It must be decoded from a JSON string containing a JSON number     if [StringifyNumbers] is specified or decoding a JSON object name.     It fails with a [SemanticError] if the JSON number     has a fractional or exponent component.     It also fails if it overflows the representation of the Go integer type.     It does not support any custom format flags.    - A Go float is decoded from a JSON number.     It must be decoded from a JSON string containing a JSON number     if [StringifyNumbers] is specified or decoding a JSON object name.     It fails if it overflows the representation of the Go float type.     If the format is \"nonfinite\", then the JSON strings     \"NaN\", \"Infinity\", and \"-Infinity\" are decoded as NaN, +Inf, and -Inf.     Otherwise, the presence of such strings results in a [SemanticError].    - A Go map is decoded from a JSON object,     where each JSON object name and value pair is recursively decoded     as the Go map key and value. Maps are not cleared.     If the Go map is nil, then a new map is allocated to decode into.     If the decoded key matches an existing Go map entry, the entry value     is reused by decoding the JSON object value into it.     The formats \"emitnull\" and \"emitempty\" have no effect when decoding.    - A Go struct is decoded from a JSON object.     See the “JSON Representation of Go structs” section     in the package-level documentation for more details.    - A Go slice is decoded from a JSON array, where each JSON element     is recursively decoded and appended to the Go slice.     Before appending into a Go slice, a new slice is allocated if it is nil,     otherwise the slice length is reset to zero.     The formats \"emitnull\" and \"emitempty\" have no effect when decoding.    - A Go array is decoded from a JSON array, where each JSON array element     is recursively decoded as each corresponding Go array element.     Each Go array element is zeroed before decoding into it.     It fails with a [SemanticError] if the JSON array does not contain     the exact same number of elements as the Go array.     It does not support any custom format flags.    - A Go pointer is decoded based on the JSON kind and underlying Go type.     If the input is a JSON null, then this stores a nil pointer.     Otherwise, it allocates a new underlying value if the pointer is nil,     and recursively JSON decodes into the underlying value.     Format flags are forwarded to the decoding of the underlying type.    - A Go interface is decoded based on the JSON kind and underlying Go type.     If the input is a JSON null, then this stores a nil interface value.     Otherwise, a nil interface value of an empty interface type is initialized     with a zero Go bool, string, float64, map[string]any, or []any if the     input is a JSON boolean, string, number, object, or array, respectively.     If the interface value is still nil, then this fails with a [SemanticError]     since decoding could not determine an appropriate Go type to decode into.     For example, unmarshaling into a nil io.Reader fails since     there is no concrete type to populate the interface value with.     Otherwise an underlying value exists and it recursively decodes     the JSON input into it. It does not support any custom format flags.    - A Go [time.Time] is decoded from a JSON string containing the time     formatted in RFC 3339 with nanosecond precision.     If the format matches one of the format constants declared in     the time package (e.g., RFC1123), then that format is used for parsing.     If the format is \"unix\", \"unixmilli\", \"unixmicro\", or \"unixnano\",     then the timestamp is decoded from an optionally fractional JSON number     of the number of seconds (or milliseconds, microseconds, or nanoseconds)     since the Unix epoch, which is January 1st, 1970 at 00:00:00 UTC.     Otherwise, the format is used as-is with [time.Time.Parse] if non-empty.    - A Go [time.Duration] currently has no default representation and     requires an explicit format to be specified.     If the format is \"sec\", \"milli\", \"micro\", or \"nano\",     then the duration is decoded from an optionally fractional JSON number     of the number of seconds (or milliseconds, microseconds, or nanoseconds).     If the format is \"units\", it is decoded from a JSON string parsed using     [time.ParseDuration] (e.g., \"1h30m\" for 1 hour 30 minutes).     If the format is \"iso8601\", it is decoded from a JSON string using the     ISO 8601 standard for durations (e.g., \"PT1H30M\" for 1 hour 30 minutes)     accepting only accurate units of hours, minutes, or seconds.    - All other Go types (e.g., complex numbers, channels, and functions)     have no default representation and result in a [SemanticError].  In general, unmarshaling follows merge semantics (similar to RFC 7396) where the decoded Go value replaces the destination value for any JSON kind other than an object. For JSON objects, the input object is merged into the destination value where matching object members recursively apply merge semantics."
      },
      {
        "name": "UnmarshalDecode",
        "desc": "UnmarshalDecode deserializes a Go value from a [jsontext.Decoder] according to the provided unmarshal options (while ignoring marshal, encode, or decode options). Any unmarshal options already specified on the [jsontext.Decoder] take lower precedence than the set of options provided by the caller. Unlike [Unmarshal] and [UnmarshalRead], decode options are ignored because they must have already been specified on the provided [jsontext.Decoder].  The input may be a stream of one or more JSON values, where this only unmarshals the next JSON value in the stream. The output must be a non-nil pointer. See [Unmarshal] for details about the conversion of JSON into a Go value."
      },
      {
        "name": "UnmarshalRead",
        "desc": "UnmarshalRead deserializes a Go value from an [io.Reader] according to the provided unmarshal and decode options (while ignoring marshal or encode options). The input must be a single JSON value with optional whitespace interspersed. It consumes the entirety of [io.Reader] until [io.EOF] is encountered, without reporting an error for EOF. The output must be a non-nil pointer. See [Unmarshal] for details about the conversion of JSON into a Go value."
      },
      {
        "name": "addr",
        "desc": ""
      },
      {
        "name": "appendDurationBase10",
        "desc": "appendDurationBase10 appends d formatted as a decimal fractional number, where pow10 is a power-of-10 used to scale down the number."
      },
      {
        "name": "appendDurationISO8601",
        "desc": "appendDurationISO8601 appends an ISO 8601 duration with a restricted grammar, where leading and trailing zeroes and zero-value designators are omitted. It only uses hour, minute, and second designators since ISO 8601 defines those as being \"accurate\", while year, month, week, and day are \"nominal\"."
      },
      {
        "name": "appendFoldedName",
        "desc": ""
      },
      {
        "name": "appendFracBase10",
        "desc": "appendFracBase10 appends the fraction of n/max10, where max10 is a power-of-10 that is larger than n."
      },
      {
        "name": "appendPaddedBase10",
        "desc": "appendPaddedBase10 appends a zero-padded encoding of n, where max10 is a power-of-10 that is larger than n."
      },
      {
        "name": "appendTimeUnix",
        "desc": "appendTimeUnix appends t formatted as a decimal fractional number, where pow10 is a power-of-10 used to scale up the number."
      },
      {
        "name": "assertCastableTo",
        "desc": "assertCastableTo asserts that \"to\" is a valid type to be casted to. These are the Go types that type-specific arshalers may operate upon.  Let AllTypes be the universal set of all possible Go types. This function generally asserts that:  \tlen([from for from in AllTypes if castableTo(from, to)]) \u003e 0  otherwise it panics.  As a special-case if marshal is false, then we forbid any non-pointer or non-interface type since it is almost always a bug trying to unmarshal into something where the end-user caller did not pass in an addressable value since they will not observe the mutations."
      },
      {
        "name": "baseLabel",
        "desc": ""
      },
      {
        "name": "boolsCompare",
        "desc": "boolsCompare compares x and y, ordering false before true."
      },
      {
        "name": "bytesCutByte",
        "desc": "bytesCutByte is similar to bytes.Cut(b, []byte{c}), except c may optionally be included as part of the suffix."
      },
      {
        "name": "canLegacyStringify",
        "desc": "canLegacyStringify reports whether t can be stringified according to v1, where t is a bool, string, or number (or unnamed pointer to such). In v1, the `string` option does not apply recursively to nested types within a composite Go type (e.g., an array, slice, struct, map, or interface)."
      },
      {
        "name": "castableTo",
        "desc": "castableTo checks whether values of type \"from\" can be casted to type \"to\". Nil pointer or interface \"from\" values are never considered castable.  This function must be kept in sync with addressableValue.castTo."
      },
      {
        "name": "castableToFromAny",
        "desc": "castableToFromAny reports whether \"to\" can be casted to from any of the dynamic types used to represent arbitrary JSON."
      },
      {
        "name": "collapseSemanticErrors",
        "desc": "collapseSemanticErrors collapses double SemanticErrors at the outer levels into a single SemanticError by preserving the inner error, but prepending the ByteOffset and JSONPointer with the outer error.  For example:  \tcollapseSemanticErrors(\u0026SemanticError{ \t\tByteOffset:  len64(`[0,{\"alpha\":[0,1,`), \t\tJSONPointer: \"/1/alpha/2\", \t\tGoType:      reflect.TypeFor[outerType](), \t\tErr: \u0026SemanticError{ \t\t\tByteOffset:  len64(`{\"foo\":\"bar\",\"fizz\":[0,`), \t\t\tJSONPointer: \"/fizz/1\", \t\t\tGoType:      reflect.TypeFor[innerType](), \t\t\tErr:         ..., \t\t}, \t})  results in:  \t\u0026SemanticError{ \t\tByteOffset:  len64(`[0,{\"alpha\":[0,1,`) + len64(`{\"foo\":\"bar\",\"fizz\":[0,`), \t\tJSONPointer: \"/1/alpha/2\" + \"/fizz/1\", \t\tGoType:      reflect.TypeFor[innerType](), \t\tErr:         ..., \t}  This is used to annotate errors returned by user-provided v1 MarshalJSON or UnmarshalJSON methods with precise position information if they themselves happened to return a SemanticError. Since MarshalJSON and UnmarshalJSON are not operating on the root JSON value, their positioning must be relative to the nested JSON value returned by UnmarshalJSON or passed to MarshalJSON. Therefore, we can construct an absolute position by concatenating the outer with the inner positions.  Note that we do not use collapseSemanticErrors with user-provided functions that take in an [jsontext.Encoder] or [jsontext.Decoder] since they contain methods to report position relative to the root JSON value. We assume user-constructed errors are correctly precise about position."
      },
      {
        "name": "consumeSign",
        "desc": "consumeSign consumes an optional leading negative or positive sign."
      },
      {
        "name": "consumeTagOption",
        "desc": "consumeTagOption consumes the next option, which is either a Go identifier or a single-quoted string. If the next option is invalid, it returns all of in until the next comma, and reports an error."
      },
      {
        "name": "equalFold",
        "desc": ""
      },
      {
        "name": "foldName",
        "desc": "foldName returns a folded string such that foldName(x) == foldName(y) is similar to strings.EqualFold(x, y), but ignores underscore and dashes. This allows foldName to match common naming conventions."
      },
      {
        "name": "foldRune",
        "desc": "foldRune is a variation on unicode.SimpleFold that returns the same rune for all runes in the same fold set.  Invariant:  \tfoldRune(x) == foldRune(y) ⇔ strings.EqualFold(string(x), string(y))"
      },
      {
        "name": "hash64",
        "desc": "hash64 returns the hash of two uint32s as a single uint32."
      },
      {
        "name": "implements",
        "desc": "implements is like t.Implements(ifaceType) but checks whether either t or reflect.PointerTo(t) implements the interface. It also reports whether the value needs to be addressed in order to satisfy the interface."
      },
      {
        "name": "implementsAny",
        "desc": "implementsAny is like t.Implements(ifaceType) for a list of interfaces, but checks whether either t or reflect.PointerTo(t) implements the interface."
      },
      {
        "name": "indirectType",
        "desc": "indirectType unwraps one level of pointer indirection similar to how Go only allows embedding either T or *T, but not **T or P (which is a named pointer)."
      },
      {
        "name": "init",
        "desc": "Inject support into \"jsonopts\" to handle these types."
      },
      {
        "name": "isAnyType",
        "desc": "isAnyType reports wether t is equivalent to the any interface type."
      },
      {
        "name": "isFatalError",
        "desc": "isFatalError reports whether this error must terminate asharling. All errors are considered fatal unless operating under [jsonflags.ReportErrorsWithLegacySemantics] in which case only syntactic errors and I/O errors are considered fatal."
      },
      {
        "name": "isLegacyEmpty",
        "desc": "isLegacyEmpty reports whether a value is empty according to the v1 definition."
      },
      {
        "name": "isLetterOrDigit",
        "desc": ""
      },
      {
        "name": "isSemanticError",
        "desc": ""
      },
      {
        "name": "isSyntacticError",
        "desc": ""
      },
      {
        "name": "leavePointer",
        "desc": ""
      },
      {
        "name": "len64",
        "desc": ""
      },
      {
        "name": "makeString",
        "desc": "makeString returns the string form of b. It returns a pre-allocated string from c if present, otherwise it allocates a new string, inserts it into the cache, and returns it."
      },
      {
        "name": "makeStructFields",
        "desc": ""
      },
      {
        "name": "mapKeyWithUniqueRepresentation",
        "desc": "mapKeyWithUniqueRepresentation reports whether all possible values of k marshal to a different JSON value, and whether all possible JSON values that can unmarshal into k unmarshal to different Go values. In other words, the representation must be a bijective."
      },
      {
        "name": "marshalArrayAny",
        "desc": "marshalArrayAny marshals a Go []any as a JSON array (or as a JSON null if nil and [jsonflags.FormatNilSliceAsNull])."
      },
      {
        "name": "marshalEncode",
        "desc": ""
      },
      {
        "name": "marshalInlinedFallbackAll",
        "desc": "marshalInlinedFallbackAll marshals all the members in an inlined fallback."
      },
      {
        "name": "marshalObjectAny",
        "desc": "marshalObjectAny marshals a Go map[string]any as a JSON object (or as a JSON null if nil and [jsonflags.FormatNilMapAsNull])."
      },
      {
        "name": "marshalValueAny",
        "desc": "marshalValueAny marshals a Go any as a JSON value. This assumes that there are no special formatting directives for any possible nested value."
      },
      {
        "name": "mayAppendDurationSign",
        "desc": "mayAppendDurationSign appends a negative sign if n is negative."
      },
      {
        "name": "mayApplyDurationSign",
        "desc": "mayApplyDurationSign inverts n if neg is specified."
      },
      {
        "name": "mustParseTime",
        "desc": ""
      },
      {
        "name": "negateSecNano",
        "desc": "negateSecNano negates a Unix timestamp, where nsec must be within [0, 1e9)."
      },
      {
        "name": "newDuplicateNameError",
        "desc": ""
      },
      {
        "name": "newInvalidCharacterError",
        "desc": ""
      },
      {
        "name": "newInvalidFormatError",
        "desc": "newInvalidFormatError wraps err in a SemanticError because the current type t cannot handle the provided options format. This error must be called before producing or consuming the next value.  If [jsonflags.ReportErrorsWithLegacySemantics] is specified, then this automatically skips the next value when unmarshaling to ensure that the value is fully consumed."
      },
      {
        "name": "newInvalidUTF8Error",
        "desc": ""
      },
      {
        "name": "newMarshalErrorBefore",
        "desc": "newMarshalErrorBefore wraps err in a SemanticError assuming that e is positioned right before the next token or value, which causes an error."
      },
      {
        "name": "newNonStringNameError",
        "desc": ""
      },
      {
        "name": "newParseTimeError",
        "desc": ""
      },
      {
        "name": "newSemanticErrorWithPosition",
        "desc": "newSemanticErrorWithPosition wraps err in a SemanticError assuming that the error occurred at the provided depth, and length. If err is already a SemanticError, then position information is only injected if it is currently unpopulated.  If the position is unpopulated, it is ambiguous where the error occurred in the user code, whether it was before or after the current position. For the byte offset, we assume that the error occurred before the last read token or value when decoding, or before the next value when encoding. For the JSON pointer, we point to the parent object or array unless we can be certain that it happened with an object member.  This is used to annotate errors returned by user-provided v2 MarshalJSON or UnmarshalJSON methods or functions."
      },
      {
        "name": "newUnmarshalErrorAfter",
        "desc": "newUnmarshalErrorAfter wraps err in a SemanticError assuming that d is positioned right after the previous token or value, which caused an error."
      },
      {
        "name": "newUnmarshalErrorAfterWithSkipping",
        "desc": "newUnmarshalErrorAfterWithSkipping is like [newUnmarshalErrorAfter], but automatically skips the remainder of the current value if [jsonflags.ReportErrorsWithLegacySemantics] is specified."
      },
      {
        "name": "newUnmarshalErrorAfterWithValue",
        "desc": "newUnmarshalErrorAfter wraps err in a SemanticError assuming that d is positioned right after the previous token or value, which caused an error. It also stores a copy of the last JSON value if it is a string or number."
      },
      {
        "name": "newUnmarshalErrorBefore",
        "desc": "newUnmarshalErrorBefore wraps err in a SemanticError assuming that d is positioned right before the next token or value, which causes an error. It does not record the next JSON kind as this error is used to indicate the receiving Go value is invalid to unmarshal into (and not a JSON error)."
      },
      {
        "name": "newUnmarshalErrorBeforeWithSkipping",
        "desc": "newUnmarshalErrorBeforeWithSkipping is like [newUnmarshalErrorBefore], but automatically skips the next value if [jsonflags.ReportErrorsWithLegacySemantics] is specified."
      },
      {
        "name": "parseDec2",
        "desc": "parseDec2 parses b as an unsigned, base-10, 2-digit number. The result is undefined if digits are not base-10."
      },
      {
        "name": "parseDurationBase10",
        "desc": "parseDurationBase10 parses d from a decimal fractional number, where pow10 is a power-of-10 used to scale up the number."
      },
      {
        "name": "parseDurationISO8601",
        "desc": "parseDurationISO8601 parses a duration according to ISO 8601-1:2019, section 5.5.2.2 and 5.5.2.3 with the following restrictions or extensions:    - A leading minus sign is permitted for negative duration according     to ISO 8601-2:2019, section 4.4.1.9. We do not permit negative values     for each \"time scale component\", which is permitted by section 4.4.1.1,     but rarely supported by parsers.    - A leading plus sign is permitted (and ignored).     This is not required by ISO 8601, but not forbidden either.     There is some precedent for this as it is supported by the principle of     duration arithmetic as specified in ISO 8601-2-2019, section 14.1.     Of note, the JavaScript grammar for ISO 8601 permits a leading plus sign.    - A fractional value is only permitted for accurate units     (i.e., hour, minute, and seconds) in the last time component,     which is permissible by ISO 8601-1:2019, section 5.5.2.3.    - Both periods ('.') and commas (',') are supported as the separator     between the integer part and fraction part of a number,     as specified in ISO 8601-1:2019, section 3.2.6.     While ISO 8601 recommends comma as the default separator,     most formatters uses a period.    - Leading zeros are ignored. This is not required by ISO 8601,     but also not forbidden by the standard. Many parsers support this.    - Lowercase designators are supported. This is not required by ISO 8601,     but also not forbidden by the standard. Many parsers support this.  If the nominal units of year, month, week, or day are present, this produces a best-effort value and also reports [errInaccurateDateUnits].  The accepted grammar is identical to JavaScript's Duration:  \thttps://tc39.es/proposal-temporal/#prod-Duration  We follow JavaScript's grammar as JSON itself is derived from JavaScript. The Temporal.Duration.toJSON method is guaranteed to produce an output that can be parsed by this function so long as arithmetic in JavaScript do not use a largestUnit value higher than \"hours\" (which is the default). Even if it does, this will do a best-effort parsing with inaccurate units, but report [errInaccurateDateUnits]."
      },
      {
        "name": "parseFracBase10",
        "desc": "parseFracBase10 parses the fraction of n/max10, where max10 is a power-of-10 that is larger than n."
      },
      {
        "name": "parsePaddedBase10",
        "desc": "parsePaddedBase10 parses b as the zero-padded encoding of n, where max10 is a power-of-10 that is larger than n. Truncated suffix is treated as implicit zeros. Extended suffix is ignored, but verified to contain only digits."
      },
      {
        "name": "parseTimeUnix",
        "desc": "parseTimeUnix parses t formatted as a decimal fractional number, where pow10 is a power-of-10 used to scale down the number."
      },
      {
        "name": "putStrings",
        "desc": ""
      },
      {
        "name": "sliceLen",
        "desc": ""
      },
      {
        "name": "stringOrNumberKind",
        "desc": ""
      },
      {
        "name": "unmarshalArrayAny",
        "desc": "unmarshalArrayAny unmarshals a JSON array as a Go []any. It panics if not decoding a JSON array."
      },
      {
        "name": "unmarshalDecode",
        "desc": ""
      },
      {
        "name": "unmarshalFull",
        "desc": ""
      },
      {
        "name": "unmarshalInlinedFallbackNext",
        "desc": "unmarshalInlinedFallbackNext unmarshals only the next member in an inlined fallback."
      },
      {
        "name": "unmarshalObjectAny",
        "desc": "unmarshalObjectAny unmarshals a JSON object as a Go map[string]any. It panics if not decoding a JSON object."
      },
      {
        "name": "unmarshalValueAny",
        "desc": "unmarshalValueAny unmarshals a JSON value as a Go any. This assumes that there are no special formatting directives for any possible nested value. Duplicate names must be rejected since this does not implement merging."
      },
      {
        "name": "visitPointer",
        "desc": "visitPointer visits pointer p of type t, reporting an error if seen before. If successfully visited, then the caller must eventually call leave."
      },
      {
        "name": "wrapSkipFunc",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "withPos",
        "desc": ""
      },
      {
        "name": "withType",
        "desc": ""
      },
      {
        "name": "withVal",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "castTo",
        "desc": "castTo casts va to the specified type. If the type is an interface, then the underlying type will always be a non-nil pointer to a concrete type.  Requirement: castableTo(va.Type(), to) must hold."
      },
      {
        "name": "fieldByIndex",
        "desc": ""
      },
      {
        "name": "indirect",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "AppendText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "appendMarshal",
        "desc": ""
      },
      {
        "name": "initFormat",
        "desc": ""
      },
      {
        "name": "isNumeric",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "JSONOptions",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "Sort",
        "desc": ""
      },
      {
        "name": "matchFoldedName",
        "desc": "matchFoldedName matches a case-insensitive name depending on the options. It assumes that foldName(f.name) == foldName(name).  Case-insensitive matching is used if the `case:ignore` tag option is specified or the MatchCaseInsensitiveNames call option is specified (and the `case:strict` tag option is not specified). Functionally, the `case:ignore` and `case:strict` tag options take precedence.  The v1 definition of case-insensitivity operated under strings.EqualFold and would strictly compare dashes and underscores, while the v2 definition would ignore the presence of dashes and underscores. Thus, if the MatchCaseSensitiveDelimiter call option is specified, the match is further restricted to using strings.EqualFold."
      },
      {
        "name": "lookupByFoldedName",
        "desc": "lookupByFoldedName looks up name by a case-insensitive match that also ignores the presence of dashes and underscores."
      },
      {
        "name": "reindex",
        "desc": "reindex recomputes index to avoid bounds check during runtime.  During the construction of each [structField] in [makeStructFields], the index field is 0-indexed. However, before it returns, the 0th field is stored in index0 and index stores the remainder."
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalJSONTo",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "AppendText",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "appendMarshal",
        "desc": ""
      },
      {
        "name": "hasCustomFormat",
        "desc": ""
      },
      {
        "name": "initFormat",
        "desc": ""
      },
      {
        "name": "isNumeric",
        "desc": ""
      },
      {
        "name": "unmarshal",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "has",
        "desc": "has reports whether i is in the set."
      },
      {
        "name": "insert",
        "desc": "insert inserts i into the set and reports whether it was the first insertion."
      },
      {
        "name": "has",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "UnmarshalJSON",
        "desc": ""
      },
      {
        "name": "UnmarshalJSONFrom",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": ""
      },
      {
        "name": "JSONOptions",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Marshaler",
        "desc": "Marshaler is implemented by types that can marshal themselves. It is recommended that types implement [MarshalerTo] unless the implementation is trying to avoid a hard dependency on the \"jsontext\" package.  It is recommended that implementations return a buffer that is safe for the caller to retain and potentially mutate."
      },
      {
        "name": "MarshalerTo",
        "desc": "MarshalerTo is implemented by types that can marshal themselves. It is recommended that types implement MarshalerTo instead of [Marshaler] since this is both more performant and flexible. If a type implements both Marshaler and MarshalerTo, then MarshalerTo takes precedence. In such a case, both implementations should aim to have equivalent behavior for the default marshal options.  The implementation must write only one JSON value to the Encoder and must not retain the pointer to [jsontext.Encoder]."
      },
      {
        "name": "Marshalers",
        "desc": "Marshalers is a list of functions that may override the marshal behavior of specific types. Populate [WithMarshalers] to use it with [Marshal], [MarshalWrite], or [MarshalEncode]. A nil *Marshalers is equivalent to an empty list. There are no exported fields or methods on Marshalers."
      },
      {
        "name": "NamedString",
        "desc": ""
      },
      {
        "name": "Options",
        "desc": "Options configure [Marshal], [MarshalWrite], [MarshalEncode], [Unmarshal], [UnmarshalRead], and [UnmarshalDecode] with specific features. Each function takes in a variadic list of options, where properties set in later options override the value of previously set properties.  The Options type is identical to [encoding/json.Options] and [encoding/json/jsontext.Options]. Options from the other packages can be used interchangeably with functionality in this package.  Options represent either a singular option or a set of options. It can be functionally thought of as a Go map of option properties (even though the underlying implementation avoids Go maps for performance).  The constructors (e.g., [Deterministic]) return a singular option value:  \topt := Deterministic(true)  which is analogous to creating a single entry map:  \topt := Options{\"Deterministic\": true}  [JoinOptions] composes multiple options values to together:  \tout := JoinOptions(opts...)  which is analogous to making a new map and copying the options over:  \tout := make(Options) \tfor _, m := range opts { \t\tfor k, v := range m { \t\t\tout[k] = v \t\t} \t}  [GetOption] looks up the value of options parameter:  \tv, ok := GetOption(opts, Deterministic)  which is analogous to a Go map lookup:  \tv, ok := Options[\"Deterministic\"]  There is a single Options type, which is used with both marshal and unmarshal. Some options affect both operations, while others only affect one operation:    - [StringifyNumbers] affects marshaling and unmarshaling   - [Deterministic] affects marshaling only   - [FormatNilSliceAsNull] affects marshaling only   - [FormatNilMapAsNull] affects marshaling only   - [OmitZeroStructFields] affects marshaling only   - [MatchCaseInsensitiveNames] affects marshaling and unmarshaling   - [DiscardUnknownMembers] affects marshaling only   - [RejectUnknownMembers] affects unmarshaling only   - [WithMarshalers] affects marshaling only   - [WithUnmarshalers] affects unmarshaling only  Options that do not affect a particular operation are ignored."
      },
      {
        "name": "ReaderFunc",
        "desc": ""
      },
      {
        "name": "SemanticError",
        "desc": "SemanticError describes an error determining the meaning of JSON data as Go data or vice-versa.  The contents of this error as produced by this package may change over time."
      },
      {
        "name": "StructEmbed1",
        "desc": ""
      },
      {
        "name": "StructEmbed2",
        "desc": ""
      },
      {
        "name": "Unmarshaler",
        "desc": "Unmarshaler is implemented by types that can unmarshal themselves. It is recommended that types implement [UnmarshalerFrom] unless the implementation is trying to avoid a hard dependency on the \"jsontext\" package.  The input can be assumed to be a valid encoding of a JSON value if called from unmarshal functionality in this package. UnmarshalJSON must copy the JSON data if it is retained after returning. It is recommended that UnmarshalJSON implement merge semantics when unmarshaling into a pre-populated value.  Implementations must not retain or mutate the input []byte."
      },
      {
        "name": "UnmarshalerFrom",
        "desc": "UnmarshalerFrom is implemented by types that can unmarshal themselves. It is recommended that types implement UnmarshalerFrom instead of [Unmarshaler] since this is both more performant and flexible. If a type implements both Unmarshaler and UnmarshalerFrom, then UnmarshalerFrom takes precedence. In such a case, both implementations should aim to have equivalent behavior for the default unmarshal options.  The implementation must read only one JSON value from the Decoder. It is recommended that UnmarshalJSONFrom implement merge semantics when unmarshaling into a pre-populated value.  Implementations must not retain the pointer to [jsontext.Decoder]."
      },
      {
        "name": "Unmarshalers",
        "desc": "Unmarshalers is a list of functions that may override the unmarshal behavior of specific types. Populate [WithUnmarshalers] to use it with [Unmarshal], [UnmarshalRead], or [UnmarshalDecode]. A nil *Unmarshalers is equivalent to an empty list. There are no exported fields or methods on Unmarshalers."
      },
      {
        "name": "WriterFunc",
        "desc": ""
      },
      {
        "name": "addressableValue",
        "desc": "addressableValue is a reflect.Value that is guaranteed to be addressable such that calling the Addr and Set methods do not panic.  There is no compile magic that enforces this property, but rather the need to construct this type makes it easier to examine each construction site to ensure that this property is upheld."
      },
      {
        "name": "allMethods",
        "desc": ""
      },
      {
        "name": "allMethodsExceptJSONv1",
        "desc": ""
      },
      {
        "name": "allMethodsExceptJSONv2",
        "desc": ""
      },
      {
        "name": "allMethodsExceptText",
        "desc": ""
      },
      {
        "name": "appendTextFunc",
        "desc": ""
      },
      {
        "name": "arshaler",
        "desc": ""
      },
      {
        "name": "bytesMarshalEmpty",
        "desc": ""
      },
      {
        "name": "bytesMarshalNonEmpty",
        "desc": ""
      },
      {
        "name": "coder",
        "desc": "coder is implemented by [jsontext.Encoder] or [jsontext.Decoder]."
      },
      {
        "name": "cyclicA",
        "desc": ""
      },
      {
        "name": "cyclicB",
        "desc": ""
      },
      {
        "name": "durationArshaler",
        "desc": ""
      },
      {
        "name": "fieldOptions",
        "desc": ""
      },
      {
        "name": "formatTimeTestdataEntry",
        "desc": ""
      },
      {
        "name": "isZeroer",
        "desc": ""
      },
      {
        "name": "jsonArray",
        "desc": ""
      },
      {
        "name": "jsonObject",
        "desc": ""
      },
      {
        "name": "mapMarshalEmpty",
        "desc": ""
      },
      {
        "name": "mapMarshalNonEmpty",
        "desc": ""
      },
      {
        "name": "marshalJSONv1Func",
        "desc": ""
      },
      {
        "name": "marshalJSONv2Func",
        "desc": ""
      },
      {
        "name": "marshalTextFunc",
        "desc": ""
      },
      {
        "name": "marshaler",
        "desc": "All marshal and unmarshal behavior is implemented using these signatures. The *jsonopts.Struct argument is guaranteed to identical to or at least a strict super-set of the options in Encoder.Struct or Decoder.Struct. It is identical for Marshal, Unmarshal, MarshalWrite, and UnmarshalRead. It is a super-set for MarshalEncode and UnmarshalDecode."
      },
      {
        "name": "marshalersOption",
        "desc": "These option types are declared here instead of \"jsonopts\" to avoid a dependency on \"reflect\" from \"jsonopts\"."
      },
      {
        "name": "namedAny",
        "desc": ""
      },
      {
        "name": "namedBool",
        "desc": ""
      },
      {
        "name": "namedByte",
        "desc": ""
      },
      {
        "name": "namedBytes",
        "desc": ""
      },
      {
        "name": "namedFloat64",
        "desc": ""
      },
      {
        "name": "namedInt64",
        "desc": ""
      },
      {
        "name": "namedString",
        "desc": ""
      },
      {
        "name": "namedUint64",
        "desc": ""
      },
      {
        "name": "netipAddr",
        "desc": ""
      },
      {
        "name": "nocaseString",
        "desc": ""
      },
      {
        "name": "nonComparable",
        "desc": "nonComparable can be embedded in a struct to prevent comparability."
      },
      {
        "name": "onlyMethodJSONv1",
        "desc": ""
      },
      {
        "name": "onlyMethodJSONv2",
        "desc": ""
      },
      {
        "name": "onlyMethodText",
        "desc": ""
      },
      {
        "name": "pointerAlwaysZero",
        "desc": ""
      },
      {
        "name": "pointerNeverZero",
        "desc": ""
      },
      {
        "name": "pointerStringer",
        "desc": ""
      },
      {
        "name": "recursiveMap",
        "desc": ""
      },
      {
        "name": "recursivePointer",
        "desc": ""
      },
      {
        "name": "recursiveSlice",
        "desc": ""
      },
      {
        "name": "requireKeyedLiterals",
        "desc": "requireKeyedLiterals can be embedded in a struct to require keyed literals."
      },
      {
        "name": "seenPointers",
        "desc": ""
      },
      {
        "name": "sliceMarshalEmpty",
        "desc": ""
      },
      {
        "name": "sliceMarshalNonEmpty",
        "desc": ""
      },
      {
        "name": "stringCache",
        "desc": "stringCache is a cache for strings converted from a []byte."
      },
      {
        "name": "stringMarshalEmpty",
        "desc": ""
      },
      {
        "name": "stringMarshalNonEmpty",
        "desc": ""
      },
      {
        "name": "stringSlice",
        "desc": ""
      },
      {
        "name": "structAll",
        "desc": ""
      },
      {
        "name": "structConflicting",
        "desc": ""
      },
      {
        "name": "structDurationFormat",
        "desc": ""
      },
      {
        "name": "structEmpty",
        "desc": ""
      },
      {
        "name": "structExportedEmbedded",
        "desc": ""
      },
      {
        "name": "structExportedEmbeddedTag",
        "desc": ""
      },
      {
        "name": "structField",
        "desc": ""
      },
      {
        "name": "structFields",
        "desc": ""
      },
      {
        "name": "structFormatArrayBytes",
        "desc": ""
      },
      {
        "name": "structFormatBytes",
        "desc": ""
      },
      {
        "name": "structFormatFloats",
        "desc": ""
      },
      {
        "name": "structFormatInvalid",
        "desc": ""
      },
      {
        "name": "structFormatMaps",
        "desc": ""
      },
      {
        "name": "structFormatSlices",
        "desc": ""
      },
      {
        "name": "structIgnoredUnexportedEmbedded",
        "desc": ""
      },
      {
        "name": "structInlineInlinePointerMapStringAny",
        "desc": ""
      },
      {
        "name": "structInlineInlinePointerTextValue",
        "desc": ""
      },
      {
        "name": "structInlineMapNamedStringAny",
        "desc": ""
      },
      {
        "name": "structInlineMapNamedStringInt",
        "desc": ""
      },
      {
        "name": "structInlineMapStringAny",
        "desc": ""
      },
      {
        "name": "structInlineMapStringInt",
        "desc": ""
      },
      {
        "name": "structInlinePointerInlineMapStringAny",
        "desc": ""
      },
      {
        "name": "structInlinePointerInlineTextValue",
        "desc": ""
      },
      {
        "name": "structInlinePointerMapStringAny",
        "desc": ""
      },
      {
        "name": "structInlinePointerTextValue",
        "desc": ""
      },
      {
        "name": "structInlineTextValue",
        "desc": ""
      },
      {
        "name": "structInlined",
        "desc": ""
      },
      {
        "name": "structInlinedL1",
        "desc": ""
      },
      {
        "name": "structInlinedL2",
        "desc": ""
      },
      {
        "name": "structMalformedTag",
        "desc": ""
      },
      {
        "name": "structMaps",
        "desc": ""
      },
      {
        "name": "structMethodJSONv1",
        "desc": ""
      },
      {
        "name": "structMethodJSONv2",
        "desc": ""
      },
      {
        "name": "structMethodText",
        "desc": ""
      },
      {
        "name": "structNestedAddr",
        "desc": ""
      },
      {
        "name": "structNoCase",
        "desc": ""
      },
      {
        "name": "structNoCaseInlineMapStringAny",
        "desc": ""
      },
      {
        "name": "structNoCaseInlineTextValue",
        "desc": ""
      },
      {
        "name": "structNoneExported",
        "desc": ""
      },
      {
        "name": "structOmitEmptyAll",
        "desc": ""
      },
      {
        "name": "structOmitZeroAll",
        "desc": ""
      },
      {
        "name": "structOmitZeroEmptyAll",
        "desc": ""
      },
      {
        "name": "structOmitZeroMethodAll",
        "desc": ""
      },
      {
        "name": "structOmitZeroMethodInterfaceAll",
        "desc": ""
      },
      {
        "name": "structScalars",
        "desc": ""
      },
      {
        "name": "structSlices",
        "desc": ""
      },
      {
        "name": "structStringifiedAll",
        "desc": ""
      },
      {
        "name": "structTimeFormat",
        "desc": ""
      },
      {
        "name": "structUnexportedEmbedded",
        "desc": ""
      },
      {
        "name": "structUnexportedEmbeddedMethodTag",
        "desc": ""
      },
      {
        "name": "structUnexportedEmbeddedStruct",
        "desc": ""
      },
      {
        "name": "structUnexportedEmbeddedStructPointer",
        "desc": ""
      },
      {
        "name": "structUnexportedEmbeddedTag",
        "desc": ""
      },
      {
        "name": "structUnexportedIgnored",
        "desc": ""
      },
      {
        "name": "structUnexportedTag",
        "desc": ""
      },
      {
        "name": "structUnknownTextValue",
        "desc": ""
      },
      {
        "name": "structWeirdNames",
        "desc": ""
      },
      {
        "name": "timeArshaler",
        "desc": ""
      },
      {
        "name": "typedArshaler",
        "desc": ""
      },
      {
        "name": "typedArshalers",
        "desc": ""
      },
      {
        "name": "typedMarshaler",
        "desc": ""
      },
      {
        "name": "typedMarshalers",
        "desc": ""
      },
      {
        "name": "typedPointer",
        "desc": ""
      },
      {
        "name": "typedUnmarshaler",
        "desc": ""
      },
      {
        "name": "typedUnmarshalers",
        "desc": ""
      },
      {
        "name": "uintSet",
        "desc": "uintSet is a set of unsigned integers. It is optimized for most integers being close to zero."
      },
      {
        "name": "uintSet64",
        "desc": ""
      },
      {
        "name": "unexported",
        "desc": ""
      },
      {
        "name": "unmarshalJSONv1Func",
        "desc": ""
      },
      {
        "name": "unmarshalJSONv2Func",
        "desc": ""
      },
      {
        "name": "unmarshalTextFunc",
        "desc": ""
      },
      {
        "name": "unmarshaler",
        "desc": "All marshal and unmarshal behavior is implemented using these signatures. The *jsonopts.Struct argument is guaranteed to identical to or at least a strict super-set of the options in Encoder.Struct or Decoder.Struct. It is identical for Marshal, Unmarshal, MarshalWrite, and UnmarshalRead. It is a super-set for MarshalEncode and UnmarshalDecode."
      },
      {
        "name": "unmarshalersOption",
        "desc": "These option types are declared here instead of \"jsonopts\" to avoid a dependency on \"reflect\" from \"jsonopts\"."
      },
      {
        "name": "valueAlwaysZero",
        "desc": ""
      },
      {
        "name": "valueNeverZero",
        "desc": ""
      },
      {
        "name": "valueStringer",
        "desc": ""
      }
    ]
  },
  {
    "name": "encoding/pem",
    "desc": "",
    "functions": [
      {
        "name": "ExampleDecode",
        "desc": ""
      },
      {
        "name": "ExampleEncode",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "encoding/xml",
    "desc": "Package xml implements a simple XML 1.0 parser that understands XML name spaces.",
    "functions": [
      {
        "name": "BenchmarkHTMLAutoClose",
        "desc": ""
      },
      {
        "name": "BenchmarkMarshal",
        "desc": ""
      },
      {
        "name": "BenchmarkUnmarshal",
        "desc": ""
      },
      {
        "name": "Escape",
        "desc": "Escape is like [EscapeText] but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use [EscapeText]."
      },
      {
        "name": "EscapeText",
        "desc": "EscapeText writes to w the properly escaped XML equivalent of the plain text data s."
      },
      {
        "name": "Marshal",
        "desc": "Marshal returns the XML encoding of v.  Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.  The name for the XML elements is taken from, in order of preference:   - the tag on the XMLName field, if the data is a struct   - the value of the XMLName field of type [Name]   - the tag of the struct field used to obtain the data   - the name of the struct field used to obtain the data   - the name of the marshaled type  The XML element for a struct contains marshaled elements for each of the exported fields of the struct, with these exceptions:   - the XMLName field, described above, is omitted.   - a field with tag \"-\" is omitted.   - a field with tag \"name,attr\" becomes an attribute with     the given name in the XML element.   - a field with tag \",attr\" becomes an attribute with the     field name in the XML element.   - a field with tag \",chardata\" is written as character data,     not as an XML element.   - a field with tag \",cdata\" is written as character data     wrapped in one or more \u003c![CDATA[ ... ]]\u003e tags, not as an XML element.   - a field with tag \",innerxml\" is written verbatim, not subject     to the usual marshaling procedure.   - a field with tag \",comment\" is written as an XML comment, not     subject to the usual marshaling procedure. It must not contain     the \"--\" string within it.   - a field with a tag including the \"omitempty\" option is omitted     if the field value is empty. The empty values are false, 0, any     nil pointer or interface value, and any array, slice, map, or     string of length zero.   - an anonymous struct field is handled as if the fields of its     value were part of the outer struct.   - an anonymous struct field of interface type is treated the same as having     that type as its name, rather than being anonymous.   - a field implementing [Marshaler] is written by calling its MarshalXML     method.   - a field implementing [encoding.TextMarshaler] is written by encoding the     result of its MarshalText method as text.  If a field uses a tag \"a\u003eb\u003ec\", then the element c will be nested inside parent elements a and b. Fields that appear next to each other that name the same parent will be enclosed in one XML element.  If the XML name for a struct field is defined by both the field tag and the struct's XMLName field, the names must match.  See [MarshalIndent] for an example.  Marshal will return an error if asked to marshal a channel, function, or map."
      },
      {
        "name": "MarshalIndent",
        "desc": "MarshalIndent works like [Marshal], but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth."
      },
      {
        "name": "ParseTime",
        "desc": ""
      },
      {
        "name": "TestAllScalars",
        "desc": ""
      },
      {
        "name": "TestCVE202228131",
        "desc": ""
      },
      {
        "name": "TestCVE202230633",
        "desc": ""
      },
      {
        "name": "TestClose",
        "desc": ""
      },
      {
        "name": "TestCopyTokenCharData",
        "desc": ""
      },
      {
        "name": "TestCopyTokenComment",
        "desc": ""
      },
      {
        "name": "TestCopyTokenStartElement",
        "desc": ""
      },
      {
        "name": "TestDecodeEOF",
        "desc": ""
      },
      {
        "name": "TestDecodeEncode",
        "desc": ""
      },
      {
        "name": "TestDecodeNilToken",
        "desc": ""
      },
      {
        "name": "TestDirectivesWithComments",
        "desc": ""
      },
      {
        "name": "TestDisallowedCharacters",
        "desc": ""
      },
      {
        "name": "TestEncodeToken",
        "desc": ""
      },
      {
        "name": "TestEncodeXMLNS",
        "desc": ""
      },
      {
        "name": "TestEntityInsideCDATA",
        "desc": ""
      },
      {
        "name": "TestEscapeTextIOErrors",
        "desc": ""
      },
      {
        "name": "TestEscapeTextInvalidChar",
        "desc": ""
      },
      {
        "name": "TestHTMLAutoClose",
        "desc": ""
      },
      {
        "name": "TestInputLinePos",
        "desc": ""
      },
      {
        "name": "TestInvalidInnerXMLType",
        "desc": "Issue 15600. \",innerxml\" on a field that can't hold it."
      },
      {
        "name": "TestInvalidXMLName",
        "desc": ""
      },
      {
        "name": "TestIsInCharacterRange",
        "desc": ""
      },
      {
        "name": "TestIsValidDirective",
        "desc": ""
      },
      {
        "name": "TestIssue11405",
        "desc": ""
      },
      {
        "name": "TestIssue12417",
        "desc": ""
      },
      {
        "name": "TestIssue16158",
        "desc": "Issue 16158. Decoder.unmarshalAttr ignores the return value of copyValue."
      },
      {
        "name": "TestIssue20396",
        "desc": ""
      },
      {
        "name": "TestIssue20685",
        "desc": ""
      },
      {
        "name": "TestIssue569",
        "desc": ""
      },
      {
        "name": "TestIssue5880",
        "desc": ""
      },
      {
        "name": "TestIssue68387",
        "desc": ""
      },
      {
        "name": "TestIssue7113",
        "desc": ""
      },
      {
        "name": "TestIssue8535",
        "desc": ""
      },
      {
        "name": "TestMalformedComment",
        "desc": "Issue 11112. Unmarshal must reject invalid comments."
      },
      {
        "name": "TestMarshal",
        "desc": ""
      },
      {
        "name": "TestMarshalErrors",
        "desc": ""
      },
      {
        "name": "TestMarshalFlush",
        "desc": ""
      },
      {
        "name": "TestMarshalIndent",
        "desc": ""
      },
      {
        "name": "TestMarshalNS",
        "desc": ""
      },
      {
        "name": "TestMarshalNSAttr",
        "desc": ""
      },
      {
        "name": "TestMarshalWriteErrors",
        "desc": ""
      },
      {
        "name": "TestMarshalWriteIOErrors",
        "desc": ""
      },
      {
        "name": "TestMarshalZeroValue",
        "desc": ""
      },
      {
        "name": "TestNestedDirectives",
        "desc": ""
      },
      {
        "name": "TestNewTokenDecoderIdempotent",
        "desc": ""
      },
      {
        "name": "TestNonStrictRawToken",
        "desc": ""
      },
      {
        "name": "TestParseErrors",
        "desc": ""
      },
      {
        "name": "TestProcInstEncodeToken",
        "desc": ""
      },
      {
        "name": "TestProcInstEncoding",
        "desc": ""
      },
      {
        "name": "TestRace9796",
        "desc": "Issue 9796. Used to fail with GORACE=\"halt_on_error=1\" -race."
      },
      {
        "name": "TestRawToken",
        "desc": ""
      },
      {
        "name": "TestRawTokenAltEncoding",
        "desc": ""
      },
      {
        "name": "TestRawTokenAltEncodingNoConverter",
        "desc": ""
      },
      {
        "name": "TestRoundTrip",
        "desc": ""
      },
      {
        "name": "TestSimpleUseOfEncodeToken",
        "desc": "Issue 11719. EncodeToken used to silently eat tokens with an invalid type."
      },
      {
        "name": "TestStructPointerMarshal",
        "desc": "golang.org/issue/6556"
      },
      {
        "name": "TestSyntax",
        "desc": ""
      },
      {
        "name": "TestSyntaxErrorLineNum",
        "desc": ""
      },
      {
        "name": "TestToken",
        "desc": ""
      },
      {
        "name": "TestTokenUnmarshaler",
        "desc": ""
      },
      {
        "name": "TestTrailingRawToken",
        "desc": ""
      },
      {
        "name": "TestTrailingToken",
        "desc": ""
      },
      {
        "name": "TestUnmarshal",
        "desc": "Do invertibility testing on the various structures that we test"
      },
      {
        "name": "TestUnmarshalAttr",
        "desc": ""
      },
      {
        "name": "TestUnmarshalBadPaths",
        "desc": ""
      },
      {
        "name": "TestUnmarshalEmptyValues",
        "desc": "golang.org/issues/13417"
      },
      {
        "name": "TestUnmarshalFeed",
        "desc": ""
      },
      {
        "name": "TestUnmarshalIntoInterface",
        "desc": "https://golang.org/issue/6836"
      },
      {
        "name": "TestUnmarshalIntoNil",
        "desc": "golang.org/issues/53350"
      },
      {
        "name": "TestUnmarshalNS",
        "desc": ""
      },
      {
        "name": "TestUnmarshalNSAttr",
        "desc": ""
      },
      {
        "name": "TestUnmarshalPaths",
        "desc": ""
      },
      {
        "name": "TestUnmarshalWhitespaceAttrs",
        "desc": "golang.org/issues/22146"
      },
      {
        "name": "TestUnmarshalWhitespaceValues",
        "desc": "golang.org/issues/22146"
      },
      {
        "name": "TestUnmarshalWithoutNameType",
        "desc": ""
      },
      {
        "name": "TestUnmarshaler",
        "desc": ""
      },
      {
        "name": "TestUnquotedAttrs",
        "desc": ""
      },
      {
        "name": "TestValuelessAttrs",
        "desc": ""
      },
      {
        "name": "TestWrapDecoder",
        "desc": ""
      },
      {
        "name": "Unmarshal",
        "desc": "Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.  Because Unmarshal uses the reflect package, it can only assign to exported (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML element names to tag values and struct field names.  Unmarshal maps an XML element to a struct using the following rules. In the rules, the tag of a field refers to the value associated with the key 'xml' in the struct field's tag (see the example above).    - If the struct has a field of type []byte or string with tag     \",innerxml\", Unmarshal accumulates the raw XML nested inside the     element in that field. The rest of the rules still apply.    - If the struct has a field named XMLName of type Name,     Unmarshal records the element name in that field.    - If the XMLName field has an associated tag of the form     \"name\" or \"namespace-URL name\", the XML element must have     the given name (and, optionally, name space) or else Unmarshal     returns an error.    - If the XML element has an attribute whose name matches a     struct field name with an associated tag containing \",attr\" or     the explicit name in a struct field tag of the form \"name,attr\",     Unmarshal records the attribute value in that field.    - If the XML element has an attribute not handled by the previous     rule and the struct has a field with an associated tag containing     \",any,attr\", Unmarshal records the attribute value in the first     such field.    - If the XML element contains character data, that data is     accumulated in the first struct field that has tag \",chardata\".     The struct field may have type []byte or string.     If there is no such field, the character data is discarded.    - If the XML element contains comments, they are accumulated in     the first struct field that has tag \",comment\".  The struct     field may have type []byte or string. If there is no such     field, the comments are discarded.    - If the XML element contains a sub-element whose name matches     the prefix of a tag formatted as \"a\" or \"a\u003eb\u003ec\", unmarshal     will descend into the XML structure looking for elements with the     given names, and will map the innermost elements to that struct     field. A tag starting with \"\u003e\" is equivalent to one starting     with the field name followed by \"\u003e\".    - If the XML element contains a sub-element whose name matches     a struct field's XMLName tag and the struct field has no     explicit name tag as per the previous rule, unmarshal maps     the sub-element to that struct field.    - If the XML element contains a sub-element whose name matches a     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal     maps the sub-element to that struct field.    - If the XML element contains a sub-element that hasn't matched any     of the above rules and the struct has a field with tag \",any\",     unmarshal maps the sub-element to that struct field.    - An anonymous struct field is handled as if the fields of its     value were part of the outer struct.    - A struct field with tag \"-\" is never unmarshaled into.  If Unmarshal encounters a field type that implements the Unmarshaler interface, Unmarshal calls its UnmarshalXML method to produce the value from the XML element.  Otherwise, if the value implements [encoding.TextUnmarshaler], Unmarshal calls that value's UnmarshalText method.  Unmarshal maps an XML element to a string or []byte by saving the concatenation of that element's character data in the string or []byte. The saved []byte is never nil.  Unmarshal maps an attribute value to a string or []byte by saving the value in the string or slice.  Unmarshal maps an attribute value to an [Attr] by saving the attribute, including its name, in the Attr.  Unmarshal maps an XML element or attribute value to a slice by extending the length of the slice and mapping the element or attribute to the newly created value.  Unmarshal maps an XML element or attribute value to a bool by setting it to the boolean value represented by the string. Whitespace is trimmed and ignored.  Unmarshal maps an XML element or attribute value to an integer or floating-point field by setting the field to the result of interpreting the string value in decimal. There is no check for overflow. Whitespace is trimmed and ignored.  Unmarshal maps an XML element to a Name by recording the element name.  Unmarshal maps an XML element to a pointer by setting the pointer to a freshly allocated value and then mapping the element to that value.  A missing element or empty attribute value will be unmarshaled as a zero value. If the field is a slice, a zero value will be appended to the field. Otherwise, the field will be set to its zero value."
      },
      {
        "name": "addFieldInfo",
        "desc": "addFieldInfo adds finfo to tinfo.fields if there are no conflicts, or if conflicts arise from previous fields that were obtained from deeper embedded structures than finfo. In the latter case, the conflicting entries are dropped. A conflict occurs when the path (parent + name) to a field is itself a prefix of another path, or when two paths match exactly. It is okay for field paths to share a common, shorter prefix."
      },
      {
        "name": "copyValue",
        "desc": ""
      },
      {
        "name": "emitCDATA",
        "desc": "emitCDATA writes to w the CDATA-wrapped plain text data s. It escapes CDATA directives nested in s."
      },
      {
        "name": "encodeXMLNS1",
        "desc": ""
      },
      {
        "name": "encodeXMLNS2",
        "desc": ""
      },
      {
        "name": "encodeXMLNS3",
        "desc": ""
      },
      {
        "name": "encodeXMLNS4",
        "desc": ""
      },
      {
        "name": "escapeText",
        "desc": "escapeText writes to w the properly escaped XML equivalent of the plain text data s. If escapeNewline is true, newline characters will be escaped."
      },
      {
        "name": "ifaceptr",
        "desc": ""
      },
      {
        "name": "indirect",
        "desc": "indirect drills into interfaces and pointers, returning the pointed-at value. If it encounters a nil interface or pointer, indirect returns that nil value. This can turn into an infinite loop given a cyclic chain, but it matches the Go 1 behavior."
      },
      {
        "name": "isEmptyValue",
        "desc": ""
      },
      {
        "name": "isInCharacterRange",
        "desc": "Decide whether the given rune is in the XML Character Range, per the Char production of https://www.xml.com/axml/testaxml.htm, Section 2.2 Characters."
      },
      {
        "name": "isName",
        "desc": ""
      },
      {
        "name": "isNameByte",
        "desc": ""
      },
      {
        "name": "isNameString",
        "desc": ""
      },
      {
        "name": "isValidDirective",
        "desc": "isValidDirective reports whether dir is a valid directive text, meaning angle brackets are matched, ignoring comments and strings."
      },
      {
        "name": "procInst",
        "desc": "procInst parses the `param=\"...\"` or `param='...'` value out of the provided string, returning \"\" if not found."
      },
      {
        "name": "receiverType",
        "desc": "receiverType returns the receiver type to use in an expression like \"%s.MethodName\"."
      },
      {
        "name": "stringptr",
        "desc": ""
      },
      {
        "name": "testRawToken",
        "desc": ""
      },
      {
        "name": "testRoundTrip",
        "desc": ""
      },
      {
        "name": "tokenMap",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": "Copy creates a new copy of CharData."
      },
      {
        "name": "Copy",
        "desc": "Copy creates a new copy of Comment."
      },
      {
        "name": "Decode",
        "desc": "Decode works like [Unmarshal], except it reads the decoder stream to find the start element."
      },
      {
        "name": "DecodeElement",
        "desc": "DecodeElement works like [Unmarshal] except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to [Unmarshal] for some elements."
      },
      {
        "name": "InputOffset",
        "desc": "InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token."
      },
      {
        "name": "InputPos",
        "desc": "InputPos returns the line of the current decoder position and the 1 based input position of the line. The position gives the location of the end of the most recently returned token."
      },
      {
        "name": "RawToken",
        "desc": "RawToken is like [Decoder.Token] but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs."
      },
      {
        "name": "Skip",
        "desc": "Skip reads tokens until it has consumed the end element matching the most recent start element already consumed, skipping nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem."
      },
      {
        "name": "Token",
        "desc": "Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, [io.EOF].  Slices of bytes in the returned token data refer to the parser's internal buffer and remain valid only until the next call to Token. To acquire a copy of the bytes, call [CopyToken] or the token's Copy method.  Token expands self-closing elements such as \u003cbr\u003e into separate start and end elements returned by successive calls.  Token guarantees that the [StartElement] and [EndElement] tokens it returns are properly nested and matched: if Token encounters an unexpected end element or EOF before all expected end elements, it will return an error.  If [Decoder.CharsetReader] is called and returns an error, the error is wrapped and returned.  Token implements XML name spaces as described by https://www.w3.org/TR/REC-xml-names/. Each of the [Name] structures contained in the Token has the Space set to the URL identifying its name space when known. If Token encounters an unrecognized name space prefix, it uses the prefix as the Space rather than report an error."
      },
      {
        "name": "attrval",
        "desc": ""
      },
      {
        "name": "autoClose",
        "desc": "If the top element on the stack is autoclosing and t is not the end tag, invent the end tag."
      },
      {
        "name": "getc",
        "desc": "Read a single byte. If there is no byte to read, return ok==false and leave the error in d.err. Maintain line number."
      },
      {
        "name": "mustgetc",
        "desc": "Must read a single byte. If there is no byte to read, set d.err to SyntaxError(\"unexpected EOF\") and return ok==false"
      },
      {
        "name": "name",
        "desc": "Get name: /first(first|second)*/ Do not set d.err if the name is missing (unless unexpected EOF is received): let the caller provide better context."
      },
      {
        "name": "nsname",
        "desc": "Get name space name: name with a : stuck in the middle. The part before the : is the name space identifier."
      },
      {
        "name": "pop",
        "desc": ""
      },
      {
        "name": "popEOF",
        "desc": "Undo a pushEOF. The element must have been finished, so the EOF should be at the top of the stack."
      },
      {
        "name": "popElement",
        "desc": "Record that we are ending an element with the given name. The name must match the record at the top of the stack, which must be a pushElement record. After popping the element, apply any undo records from the stack to restore the name translations that existed before we saw this element."
      },
      {
        "name": "push",
        "desc": ""
      },
      {
        "name": "pushEOF",
        "desc": "Record that after the current element is finished (that element is already pushed on the stack) Token should return EOF until popEOF is called."
      },
      {
        "name": "pushElement",
        "desc": "Record that we are starting an element with the given name."
      },
      {
        "name": "pushNs",
        "desc": "Record that we are changing the value of ns[local]. The old value is url, ok."
      },
      {
        "name": "rawToken",
        "desc": ""
      },
      {
        "name": "readName",
        "desc": "Read a name and append its bytes to d.buf. The name is delimited by any single-byte character not valid in names. All multi-byte characters are accepted; the caller must check their validity."
      },
      {
        "name": "savedOffset",
        "desc": "Return saved offset. If we did ungetc (nextByte \u003e= 0), have to back up one."
      },
      {
        "name": "space",
        "desc": "Skip spaces if any"
      },
      {
        "name": "switchToReader",
        "desc": ""
      },
      {
        "name": "syntaxError",
        "desc": "Creates a SyntaxError with the current line number."
      },
      {
        "name": "text",
        "desc": "Read plain text section (XML calls it character data). If quote \u003e= 0, we are in a quoted string and need to find the matching quote. If cdata == true, we are in a \u003c![CDATA[ section and need to find ]]\u003e. On failure return nil and leave the error in d.err."
      },
      {
        "name": "translate",
        "desc": "Apply name space translation to name n. The default name space (for Space==\"\") applies only to element names, not to attribute names."
      },
      {
        "name": "ungetc",
        "desc": "Unread a single byte."
      },
      {
        "name": "unmarshal",
        "desc": "Unmarshal a single XML element into val."
      },
      {
        "name": "unmarshalAttr",
        "desc": "unmarshalAttr unmarshals a single XML attribute into val."
      },
      {
        "name": "unmarshalInterface",
        "desc": "unmarshalInterface unmarshals a single XML element into val. start is the opening tag of the element."
      },
      {
        "name": "unmarshalPath",
        "desc": "unmarshalPath walks down an XML structure looking for wanted paths, and calls unmarshal on them. The consumed result tells whether XML elements have been consumed from the Decoder until start's matching end element, or if it's still untouched because start is uninteresting for sv's fields."
      },
      {
        "name": "unmarshalTextInterface",
        "desc": "unmarshalTextInterface unmarshals a single XML element into val. The chardata contained in the element (but not its children) is passed to the text unmarshaler."
      },
      {
        "name": "Copy",
        "desc": "Copy creates a new copy of Directive."
      },
      {
        "name": "Close",
        "desc": "Close the Encoder, indicating that no more data will be written. It flushes any buffered XML to the underlying writer and returns an error if the written XML is invalid (e.g. by containing unclosed elements)."
      },
      {
        "name": "Encode",
        "desc": "Encode writes the XML encoding of v to the stream.  See the documentation for [Marshal] for details about the conversion of Go values to XML.  Encode calls [Encoder.Flush] before returning."
      },
      {
        "name": "EncodeElement",
        "desc": "EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding.  See the documentation for [Marshal] for details about the conversion of Go values to XML.  EncodeElement calls [Encoder.Flush] before returning."
      },
      {
        "name": "EncodeToken",
        "desc": "EncodeToken writes the given XML token to the stream. It returns an error if [StartElement] and [EndElement] tokens are not properly matched.  EncodeToken does not call [Encoder.Flush], because usually it is part of a larger operation such as [Encoder.Encode] or [Encoder.EncodeElement] (or a custom [Marshaler]'s MarshalXML invoked during those), and those will call Flush when finished. Callers that create an Encoder and then invoke EncodeToken directly, without using Encode or EncodeElement, need to call Flush when finished to ensure that the XML is written to the underlying writer.  EncodeToken allows writing a [ProcInst] with Target set to \"xml\" only as the first token in the stream."
      },
      {
        "name": "Flush",
        "desc": "Flush flushes any buffered XML to the underlying writer. See the [Encoder.EncodeToken] documentation for details about when it is necessary."
      },
      {
        "name": "Indent",
        "desc": "Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth."
      },
      {
        "name": "UnmarshalXML",
        "desc": ""
      },
      {
        "name": "UnmarshalXMLAttr",
        "desc": ""
      },
      {
        "name": "UnmarshalXML",
        "desc": ""
      },
      {
        "name": "UnmarshalXMLAttr",
        "desc": ""
      },
      {
        "name": "MarshalXMLAttr",
        "desc": ""
      },
      {
        "name": "UnmarshalXMLAttr",
        "desc": ""
      },
      {
        "name": "MarshalXML",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": "Copy creates a new copy of ProcInst."
      },
      {
        "name": "Copy",
        "desc": "Copy creates a new copy of StartElement."
      },
      {
        "name": "End",
        "desc": "End returns the corresponding XML end element."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadByte",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "value",
        "desc": "value returns v's field value corresponding to finfo. It's equivalent to v.FieldByIndex(finfo.idx), but when passed initNilPointers, it initializes and dereferences pointers as necessary. When passed dontInitNilPointers and a nil pointer is reached, the function returns a zero reflect.Value."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Token",
        "desc": ""
      },
      {
        "name": "push",
        "desc": "push adds parent elements to the stack and writes open tags."
      },
      {
        "name": "trim",
        "desc": "trim updates the XML context to match the longest common prefix of the stack and the given parents. A closing tag will be written for every parent popped. Passing a zero slice or nil will close all the elements."
      },
      {
        "name": "Close",
        "desc": "Close the Encoder, indicating that no more data will be written. It flushes any buffered XML to the underlying writer and returns an error if the written XML is invalid (e.g. by containing unclosed elements)."
      },
      {
        "name": "EscapeString",
        "desc": "EscapeString writes to p the properly escaped XML equivalent of the plain text data s."
      },
      {
        "name": "Write",
        "desc": "Write implements io.Writer"
      },
      {
        "name": "WriteByte",
        "desc": "WriteByte implements io.ByteWriter"
      },
      {
        "name": "WriteString",
        "desc": "WriteString implements io.StringWriter"
      },
      {
        "name": "cachedWriteError",
        "desc": "return the bufio Writer's cached write error"
      },
      {
        "name": "createAttrPrefix",
        "desc": "createAttrPrefix finds the name space prefix attribute to use for the given name space, defining a new prefix if necessary. It returns the prefix."
      },
      {
        "name": "deleteAttrPrefix",
        "desc": "deleteAttrPrefix removes an attribute name space prefix."
      },
      {
        "name": "markPrefix",
        "desc": ""
      },
      {
        "name": "marshalAttr",
        "desc": "marshalAttr marshals an attribute with the given name and value, adding to start.Attr."
      },
      {
        "name": "marshalInterface",
        "desc": "marshalInterface marshals a Marshaler interface value."
      },
      {
        "name": "marshalSimple",
        "desc": ""
      },
      {
        "name": "marshalStruct",
        "desc": ""
      },
      {
        "name": "marshalTextInterface",
        "desc": "marshalTextInterface marshals a TextMarshaler interface value."
      },
      {
        "name": "marshalValue",
        "desc": "marshalValue writes one or more XML elements representing val. If val was obtained from a struct field, finfo must have its details."
      },
      {
        "name": "popPrefix",
        "desc": ""
      },
      {
        "name": "writeEnd",
        "desc": ""
      },
      {
        "name": "writeIndent",
        "desc": ""
      },
      {
        "name": "writeStart",
        "desc": "writeStart writes the given start element."
      },
      {
        "name": "Token",
        "desc": ""
      },
      {
        "name": "Token",
        "desc": ""
      },
      {
        "name": "Token",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "AnyHolder",
        "desc": ""
      },
      {
        "name": "AnyOmitTest",
        "desc": ""
      },
      {
        "name": "AnySliceTest",
        "desc": ""
      },
      {
        "name": "AnyTest",
        "desc": ""
      },
      {
        "name": "Attr",
        "desc": "An Attr represents an attribute in an XML element (Name=Value)."
      },
      {
        "name": "AttrParent",
        "desc": ""
      },
      {
        "name": "AttrTest",
        "desc": ""
      },
      {
        "name": "AttrsTest",
        "desc": ""
      },
      {
        "name": "BadAttr",
        "desc": ""
      },
      {
        "name": "BadPathEmbeddedA",
        "desc": ""
      },
      {
        "name": "BadPathEmbeddedB",
        "desc": ""
      },
      {
        "name": "BadPathTestA",
        "desc": ""
      },
      {
        "name": "BadPathTestB",
        "desc": ""
      },
      {
        "name": "BadPathTestC",
        "desc": ""
      },
      {
        "name": "BadPathTestD",
        "desc": ""
      },
      {
        "name": "Book",
        "desc": ""
      },
      {
        "name": "CDataTest",
        "desc": ""
      },
      {
        "name": "CharData",
        "desc": "A CharData represents XML character data (raw text), in which XML escape sequences have been replaced by the characters they represent."
      },
      {
        "name": "ChardataEmptyTest",
        "desc": ""
      },
      {
        "name": "Child",
        "desc": ""
      },
      {
        "name": "ChildToEmbed",
        "desc": ""
      },
      {
        "name": "Comment",
        "desc": "A Comment represents an XML comment of the form \u003c!--comment--\u003e. The bytes do not include the \u003c!-- and --\u003e comment markers."
      },
      {
        "name": "Data",
        "desc": ""
      },
      {
        "name": "Decoder",
        "desc": "A Decoder represents an XML parser reading a particular input stream. The parser assumes that its input is encoded in UTF-8."
      },
      {
        "name": "Departure",
        "desc": ""
      },
      {
        "name": "DirectAny",
        "desc": ""
      },
      {
        "name": "DirectCDATA",
        "desc": ""
      },
      {
        "name": "DirectChardata",
        "desc": ""
      },
      {
        "name": "DirectComment",
        "desc": ""
      },
      {
        "name": "DirectElement",
        "desc": ""
      },
      {
        "name": "DirectInnerXML",
        "desc": ""
      },
      {
        "name": "DirectOmitEmpty",
        "desc": ""
      },
      {
        "name": "Directive",
        "desc": "A Directive represents an XML directive of the form \u003c!text\u003e. The bytes do not include the \u003c! and \u003e markers."
      },
      {
        "name": "Domain",
        "desc": ""
      },
      {
        "name": "DriveType",
        "desc": ""
      },
      {
        "name": "EmbedA",
        "desc": ""
      },
      {
        "name": "EmbedB",
        "desc": ""
      },
      {
        "name": "EmbedC",
        "desc": ""
      },
      {
        "name": "EmbedInt",
        "desc": ""
      },
      {
        "name": "Encoder",
        "desc": "An Encoder writes XML data to an output stream."
      },
      {
        "name": "EndElement",
        "desc": "An EndElement represents an XML end element."
      },
      {
        "name": "Entry",
        "desc": ""
      },
      {
        "name": "Event",
        "desc": ""
      },
      {
        "name": "Failure",
        "desc": ""
      },
      {
        "name": "Feed",
        "desc": ""
      },
      {
        "name": "Generic",
        "desc": ""
      },
      {
        "name": "IXField",
        "desc": ""
      },
      {
        "name": "IfaceAny",
        "desc": ""
      },
      {
        "name": "IfaceCDATA",
        "desc": ""
      },
      {
        "name": "IfaceChardata",
        "desc": ""
      },
      {
        "name": "IfaceComment",
        "desc": ""
      },
      {
        "name": "IfaceElement",
        "desc": ""
      },
      {
        "name": "IfaceInnerXML",
        "desc": ""
      },
      {
        "name": "IfaceOmitEmpty",
        "desc": ""
      },
      {
        "name": "IgnoreTest",
        "desc": ""
      },
      {
        "name": "IndirAny",
        "desc": ""
      },
      {
        "name": "IndirCDATA",
        "desc": ""
      },
      {
        "name": "IndirChardata",
        "desc": ""
      },
      {
        "name": "IndirComment",
        "desc": ""
      },
      {
        "name": "IndirElement",
        "desc": ""
      },
      {
        "name": "IndirInnerXML",
        "desc": ""
      },
      {
        "name": "IndirOmitEmpty",
        "desc": ""
      },
      {
        "name": "InnerStruct",
        "desc": ""
      },
      {
        "name": "InvalidXMLName",
        "desc": ""
      },
      {
        "name": "LayerOne",
        "desc": "Issue 50164. Crash on zero value XML attribute."
      },
      {
        "name": "LayerTwo",
        "desc": ""
      },
      {
        "name": "Link",
        "desc": ""
      },
      {
        "name": "Marshaler",
        "desc": "Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.  MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable [Unmarshal] to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements."
      },
      {
        "name": "MarshalerAttr",
        "desc": "MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.  MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable [Unmarshal] to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute [Attr]{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the \"attr\" option in the field tag."
      },
      {
        "name": "MarshalerStruct",
        "desc": ""
      },
      {
        "name": "MixedNested",
        "desc": ""
      },
      {
        "name": "Movie",
        "desc": ""
      },
      {
        "name": "MyAttr",
        "desc": ""
      },
      {
        "name": "MyBytes",
        "desc": ""
      },
      {
        "name": "MyCharData",
        "desc": ""
      },
      {
        "name": "MyInt",
        "desc": ""
      },
      {
        "name": "MyMarshalerAttrTest",
        "desc": ""
      },
      {
        "name": "MyMarshalerTest",
        "desc": ""
      },
      {
        "name": "MyStruct",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": "A Name represents an XML name (Local) annotated with a name space identifier (Space). In tokens returned by [Decoder.Token], the Space identifier is given as a canonical URL, not the short prefix used in the document being parsed."
      },
      {
        "name": "NameCasing",
        "desc": ""
      },
      {
        "name": "NameInField",
        "desc": ""
      },
      {
        "name": "NamePrecedence",
        "desc": ""
      },
      {
        "name": "NamedType",
        "desc": ""
      },
      {
        "name": "NestedAndCData",
        "desc": ""
      },
      {
        "name": "NestedAndChardata",
        "desc": ""
      },
      {
        "name": "NestedAndComment",
        "desc": ""
      },
      {
        "name": "NestedItems",
        "desc": ""
      },
      {
        "name": "NestedOrder",
        "desc": ""
      },
      {
        "name": "NilTest",
        "desc": ""
      },
      {
        "name": "OmitAttrTest",
        "desc": ""
      },
      {
        "name": "OmitFieldTest",
        "desc": ""
      },
      {
        "name": "OuterNamedOrderedStruct",
        "desc": ""
      },
      {
        "name": "OuterNamedStruct",
        "desc": ""
      },
      {
        "name": "OuterOuterStruct",
        "desc": ""
      },
      {
        "name": "OuterStruct",
        "desc": ""
      },
      {
        "name": "Parent",
        "desc": ""
      },
      {
        "name": "Particle",
        "desc": ""
      },
      {
        "name": "Passenger",
        "desc": ""
      },
      {
        "name": "PathTestA",
        "desc": ""
      },
      {
        "name": "PathTestB",
        "desc": ""
      },
      {
        "name": "PathTestC",
        "desc": ""
      },
      {
        "name": "PathTestD",
        "desc": ""
      },
      {
        "name": "PathTestE",
        "desc": ""
      },
      {
        "name": "PathTestItem",
        "desc": ""
      },
      {
        "name": "PathTestSet",
        "desc": ""
      },
      {
        "name": "Pea",
        "desc": ""
      },
      {
        "name": "Person",
        "desc": ""
      },
      {
        "name": "Pi",
        "desc": ""
      },
      {
        "name": "Plain",
        "desc": ""
      },
      {
        "name": "Pod",
        "desc": ""
      },
      {
        "name": "PointerAnonFields",
        "desc": ""
      },
      {
        "name": "PointerFieldsTest",
        "desc": ""
      },
      {
        "name": "Port",
        "desc": ""
      },
      {
        "name": "PresenceTest",
        "desc": ""
      },
      {
        "name": "ProcInst",
        "desc": "A ProcInst represents an XML processing instruction of the form \u003c?target inst?\u003e"
      },
      {
        "name": "RecurseA",
        "desc": ""
      },
      {
        "name": "RecurseB",
        "desc": ""
      },
      {
        "name": "SecretAgent",
        "desc": ""
      },
      {
        "name": "Service",
        "desc": ""
      },
      {
        "name": "Ship",
        "desc": ""
      },
      {
        "name": "StartElement",
        "desc": "A StartElement represents an XML start element."
      },
      {
        "name": "Strings",
        "desc": ""
      },
      {
        "name": "SyntaxError",
        "desc": "A SyntaxError represents a syntax error in the XML input stream."
      },
      {
        "name": "T1",
        "desc": ""
      },
      {
        "name": "T2",
        "desc": ""
      },
      {
        "name": "TAttr",
        "desc": ""
      },
      {
        "name": "TableAttrs",
        "desc": ""
      },
      {
        "name": "Tables",
        "desc": ""
      },
      {
        "name": "TagPathError",
        "desc": "A TagPathError represents an error in the unmarshaling process caused by the use of field tags with conflicting paths."
      },
      {
        "name": "TestThree",
        "desc": ""
      },
      {
        "name": "Text",
        "desc": ""
      },
      {
        "name": "Token",
        "desc": "A Token is an interface holding one of the token types: [StartElement], [EndElement], [CharData], [Comment], [ProcInst], or [Directive]."
      },
      {
        "name": "TokenReader",
        "desc": "A TokenReader is anything that can decode a stream of XML tokens, including a [Decoder].  When Token encounters an error or end-of-file condition after successfully reading a token, it returns the token. It may return the (non-nil) error from the same call or return the error (and a nil token) from a subsequent call. An instance of this general case is that a TokenReader returning a non-nil token at the end of the token stream may return either io.EOF or a nil error. The next Read should return nil, [io.EOF].  Implementations of Token are discouraged from returning a nil token with a nil error. Callers should treat a return of nil, nil as indicating that nothing happened; in particular it does not indicate EOF."
      },
      {
        "name": "Universe",
        "desc": ""
      },
      {
        "name": "UnmarshalError",
        "desc": "An UnmarshalError represents an error in the unmarshaling process."
      },
      {
        "name": "Unmarshaler",
        "desc": "Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.  UnmarshalXML decodes a single XML element beginning with the given start element. If it returns an error, the outer call to Unmarshal stops and returns that error. UnmarshalXML must consume exactly one XML element. One common implementation strategy is to unmarshal into a separate value with a layout matching the expected XML using d.DecodeElement, and then to copy the data from that value into the receiver. Another common strategy is to use d.Token to process the XML object one token at a time. UnmarshalXML may not use d.RawToken."
      },
      {
        "name": "UnmarshalerAttr",
        "desc": "UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.  UnmarshalXMLAttr decodes a single XML attribute. If it returns an error, the outer call to [Unmarshal] stops and returns that error. UnmarshalXMLAttr is used only for struct fields with the \"attr\" option in the field tag."
      },
      {
        "name": "UnsupportedTypeError",
        "desc": "UnsupportedTypeError is returned when [Marshal] encounters a type that cannot be converted into XML."
      },
      {
        "name": "WhitespaceAttrsParent",
        "desc": ""
      },
      {
        "name": "WhitespaceValuesParent",
        "desc": ""
      },
      {
        "name": "X",
        "desc": ""
      },
      {
        "name": "XMLNameWithTag",
        "desc": ""
      },
      {
        "name": "XMLNameWithoutTag",
        "desc": ""
      },
      {
        "name": "allScalars",
        "desc": ""
      },
      {
        "name": "downCaser",
        "desc": ""
      },
      {
        "name": "embedD",
        "desc": ""
      },
      {
        "name": "errWriter",
        "desc": "Writer whose Write method always returns an error."
      },
      {
        "name": "fieldFlags",
        "desc": ""
      },
      {
        "name": "fieldInfo",
        "desc": "fieldInfo holds details for the xml representation of a single field."
      },
      {
        "name": "item",
        "desc": ""
      },
      {
        "name": "limitedBytesWriter",
        "desc": ""
      },
      {
        "name": "mapper",
        "desc": ""
      },
      {
        "name": "parentStack",
        "desc": ""
      },
      {
        "name": "printer",
        "desc": ""
      },
      {
        "name": "stack",
        "desc": "Parsing state - stack holds old name space translations and the current set of open elements. The translations to pop when ending a given tag are *below* it on the stack, which is more work but forced on us by XML."
      },
      {
        "name": "tokReader",
        "desc": ""
      },
      {
        "name": "toks",
        "desc": ""
      },
      {
        "name": "toksNil",
        "desc": ""
      },
      {
        "name": "typeInfo",
        "desc": "typeInfo holds details for the xml representation of a type."
      }
    ]
  },
  {
    "name": "errors",
    "desc": "Package errors implements functions to manipulate errors.  The [New] function creates errors whose only content is a text message.  An error e wraps another error if e's type has one of the methods  \tUnwrap() error \tUnwrap() []error  If e.Unwrap() returns a non-nil error w or a slice containing w, then we say that e wraps w. A nil error returned from e.Unwrap() indicates that e does not wrap any error. It is invalid for an Unwrap method to return an []error containing a nil error value.  An easy way to create wrapped errors is to call [fmt.Errorf] and apply the %w verb to the error argument:  \twrapsErr := fmt.Errorf(\"... %w ...\", ..., err, ...)  Successive unwrapping of an error creates a tree. The [Is] and [As] functions inspect an error's tree by examining first the error itself followed by the tree of each of its children in turn (pre-order, depth-first traversal).  See https://go.dev/blog/go1.13-errors for a deeper discussion of the philosophy of wrapping and when to wrap.  [Is] examines the tree of its first argument looking for an error that matches the second. It reports whether it finds a match. It should be used in preference to simple equality checks:  \tif errors.Is(err, fs.ErrExist)  is preferable to  \tif err == fs.ErrExist  because the former will succeed if err wraps [io/fs.ErrExist].  [As] examines the tree of its first argument looking for an error that can be assigned to its second argument, which must be a pointer. If it succeeds, it performs the assignment and returns true. Otherwise, it returns false. The form  \tvar perr *fs.PathError \tif errors.As(err, \u0026perr) { \t\tfmt.Println(perr.Path) \t}  is preferable to  \tif perr, ok := err.(*fs.PathError); ok { \t\tfmt.Println(perr.Path) \t}  because the former will succeed if err wraps an [*io/fs.PathError].",
    "functions": [
      {
        "name": "As",
        "desc": "As finds the first error in err's tree that matches target, and if one is found, sets target to that error value and returns true. Otherwise, it returns false.  The tree consists of err itself, followed by the errors obtained by repeatedly calling its Unwrap() error or Unwrap() []error method. When err wraps multiple errors, As examines err followed by a depth-first traversal of its children.  An error matches target if the error's concrete value is assignable to the value pointed to by target, or if the error has a method As(any) bool such that As(target) returns true. In the latter case, the As method is responsible for setting target.  An error type might provide an As method so it can be treated as if it were a different error type.  As panics if target is not a non-nil pointer to either a type that implements error, or to any interface type."
      },
      {
        "name": "Is",
        "desc": "Is reports whether any error in err's tree matches target.  The tree consists of err itself, followed by the errors obtained by repeatedly calling its Unwrap() error or Unwrap() []error method. When err wraps multiple errors, Is examines err followed by a depth-first traversal of its children.  An error is considered to match a target if it is equal to that target or if it implements a method Is(error) bool such that Is(target) returns true.  An error type might provide an Is method so it can be treated as equivalent to an existing error. For example, if MyError defines  \tfunc (m MyError) Is(target error) bool { return target == fs.ErrExist }  then Is(MyError{}, fs.ErrExist) returns true. See [syscall.Errno.Is] for an example in the standard library. An Is method should only shallowly compare err and the target and not call [Unwrap] on either."
      },
      {
        "name": "Join",
        "desc": "Join returns an error that wraps the given errors. Any nil error values are discarded. Join returns nil if every value in errs is nil. The error formats as the concatenation of the strings obtained by calling the Error method of each element of errs, with a newline between each string.  A non-nil error returned by Join implements the Unwrap() []error method."
      },
      {
        "name": "New",
        "desc": "New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical."
      },
      {
        "name": "Unwrap",
        "desc": "Unwrap returns the result of calling the Unwrap method on err, if err's type contains an Unwrap method returning error. Otherwise, Unwrap returns nil.  Unwrap only calls a method of the form \"Unwrap() error\". In particular Unwrap does not unwrap errors returned by [Join]."
      },
      {
        "name": "as",
        "desc": ""
      },
      {
        "name": "is",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "errorString",
        "desc": "errorString is a trivial implementation of error."
      },
      {
        "name": "joinError",
        "desc": ""
      }
    ]
  },
  {
    "name": "expvar",
    "desc": "Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at /debug/vars in JSON format. As of Go 1.22, the /debug/vars request must use GET.  Operations to set or modify these public variables are atomic.  In addition to adding the HTTP handler, this package registers the following variables:  \tcmdline   os.Args \tmemstats  runtime.Memstats  The package is sometimes only imported for the side effect of registering its HTTP handler and the above variables. To use it this way, link this package into your program:  \timport _ \"expvar\"",
    "functions": [
      {
        "name": "BenchmarkFloatAdd",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatSet",
        "desc": ""
      },
      {
        "name": "BenchmarkIntAdd",
        "desc": ""
      },
      {
        "name": "BenchmarkIntSet",
        "desc": ""
      },
      {
        "name": "BenchmarkMapAddDifferent",
        "desc": ""
      },
      {
        "name": "BenchmarkMapAddDifferentRandom",
        "desc": "BenchmarkMapAddDifferentRandom simulates such a case where that the concerned keys of Map.Add are generated dynamically and as a result insertion is out of order and the number of the keys may be large."
      },
      {
        "name": "BenchmarkMapAddDifferentSteadyState",
        "desc": ""
      },
      {
        "name": "BenchmarkMapAddSame",
        "desc": ""
      },
      {
        "name": "BenchmarkMapAddSameSteadyState",
        "desc": ""
      },
      {
        "name": "BenchmarkMapSet",
        "desc": ""
      },
      {
        "name": "BenchmarkMapSetDifferent",
        "desc": ""
      },
      {
        "name": "BenchmarkMapSetDifferentRandom",
        "desc": "BenchmarkMapSetDifferentRandom simulates such a case where the concerned keys of Map.Set are generated dynamically and as a result insertion is out of order and the number of the keys may be large."
      },
      {
        "name": "BenchmarkMapSetString",
        "desc": ""
      },
      {
        "name": "BenchmarkMapString",
        "desc": ""
      },
      {
        "name": "BenchmarkRealworldExpvarUsage",
        "desc": ""
      },
      {
        "name": "BenchmarkStringSet",
        "desc": ""
      },
      {
        "name": "Do",
        "desc": "Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated."
      },
      {
        "name": "Handler",
        "desc": "Handler returns the expvar HTTP Handler.  This is only needed to install the handler in a non-standard location."
      },
      {
        "name": "Publish",
        "desc": "Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic."
      },
      {
        "name": "RemoveAll",
        "desc": "RemoveAll removes all exported variables. This is for tests only."
      },
      {
        "name": "TestAppendJSONQuote",
        "desc": ""
      },
      {
        "name": "TestFloat",
        "desc": ""
      },
      {
        "name": "TestFunc",
        "desc": ""
      },
      {
        "name": "TestHandler",
        "desc": ""
      },
      {
        "name": "TestInt",
        "desc": ""
      },
      {
        "name": "TestMapCounter",
        "desc": ""
      },
      {
        "name": "TestMapDelete",
        "desc": ""
      },
      {
        "name": "TestMapInit",
        "desc": ""
      },
      {
        "name": "TestMapNil",
        "desc": ""
      },
      {
        "name": "TestNil",
        "desc": ""
      },
      {
        "name": "TestString",
        "desc": ""
      },
      {
        "name": "appendJSONQuote",
        "desc": "TODO: Use json.appendString instead."
      },
      {
        "name": "cmdline",
        "desc": ""
      },
      {
        "name": "expvarHandler",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "memstats",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": "Add adds delta to v."
      },
      {
        "name": "Set",
        "desc": "Set sets v to value."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "appendJSON",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "appendJSON",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": "Add adds delta to the *[Int] value stored under the given map key."
      },
      {
        "name": "AddFloat",
        "desc": "AddFloat adds delta to the *[Float] value stored under the given map key."
      },
      {
        "name": "Delete",
        "desc": "Delete deletes the given key from the map."
      },
      {
        "name": "Do",
        "desc": "Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated."
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Init",
        "desc": "Init removes all keys from the map."
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "addKey",
        "desc": "addKey updates the sorted list of keys in v.keys."
      },
      {
        "name": "appendJSON",
        "desc": ""
      },
      {
        "name": "appendJSONMayExpand",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String implements the [Var] interface. To get the unquoted string use [String.Value]."
      },
      {
        "name": "Value",
        "desc": ""
      },
      {
        "name": "appendJSON",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Float",
        "desc": "Float is a 64-bit float variable that satisfies the [Var] interface."
      },
      {
        "name": "Func",
        "desc": "Func implements [Var] by calling the function and formatting the returned value using JSON."
      },
      {
        "name": "Int",
        "desc": "Int is a 64-bit integer variable that satisfies the [Var] interface."
      },
      {
        "name": "KeyValue",
        "desc": "KeyValue represents a single entry in a [Map]."
      },
      {
        "name": "Map",
        "desc": "Map is a string-to-Var map variable that satisfies the [Var] interface."
      },
      {
        "name": "String",
        "desc": "String is a string variable, and satisfies the [Var] interface."
      },
      {
        "name": "Var",
        "desc": "Var is an abstract type for all exported variables."
      },
      {
        "name": "jsonVar",
        "desc": ""
      }
    ]
  },
  {
    "name": "flag",
    "desc": "Package flag implements command-line flag parsing.  # Usage  Define flags using [flag.String], [Bool], [Int], etc.  This declares an integer flag, -n, stored in the pointer nFlag, with type *int:  \timport \"flag\" \tvar nFlag = flag.Int(\"n\", 1234, \"help message for flag n\")  If you like, you can bind the flag to a variable using the Var() functions.  \tvar flagvar int \tfunc init() { \t\tflag.IntVar(\u0026flagvar, \"flagname\", 1234, \"help message for flagname\") \t}  Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by  \tflag.Var(\u0026flagVal, \"name\", \"help message for flagname\")  For such flags, the default value is just the initial value of the variable.  After all flags are defined, call  \tflag.Parse()  to parse the command line into the defined flags.  Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values.  \tfmt.Println(\"ip has value \", *ip) \tfmt.Println(\"flagvar has value \", flagvar)  After parsing, the arguments following the flags are available as the slice [flag.Args] or individually as [flag.Arg](i). The arguments are indexed from 0 through [flag.NArg]-1.  # Command line flag syntax  The following forms are permitted:  \t-flag \t--flag   // double dashes are also permitted \t-flag=x \t-flag x  // non-boolean flags only  One or two dashes may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command  \tcmd -x *  where * is a Unix shell wildcard, will change if there is a file called 0, false, etc. You must use the -flag=false form to turn off a boolean flag.  Flag parsing stops just before the first non-flag argument (\"-\" is a non-flag argument) or after the terminator \"--\".  Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be:  \t1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False  Duration flags accept any input valid for time.ParseDuration.  The default set of command-line flags is controlled by top-level functions.  The [FlagSet] type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of [FlagSet] are analogous to the top-level functions for the command-line flag set.",
    "functions": [
      {
        "name": "Arg",
        "desc": "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist."
      },
      {
        "name": "Args",
        "desc": "Args returns the non-flag command-line arguments."
      },
      {
        "name": "Bool",
        "desc": "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag."
      },
      {
        "name": "BoolFunc",
        "desc": "BoolFunc defines a flag with the specified name and usage string without requiring values. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error."
      },
      {
        "name": "BoolVar",
        "desc": "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag."
      },
      {
        "name": "Duration",
        "desc": "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration."
      },
      {
        "name": "DurationVar",
        "desc": "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration."
      },
      {
        "name": "Float64",
        "desc": "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag."
      },
      {
        "name": "Float64Var",
        "desc": "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag."
      },
      {
        "name": "Func",
        "desc": "Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error."
      },
      {
        "name": "Int",
        "desc": "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag."
      },
      {
        "name": "Int64",
        "desc": "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag."
      },
      {
        "name": "Int64Var",
        "desc": "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag."
      },
      {
        "name": "IntVar",
        "desc": "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag."
      },
      {
        "name": "NArg",
        "desc": "NArg is the number of arguments remaining after flags have been processed."
      },
      {
        "name": "NFlag",
        "desc": "NFlag returns the number of command-line flags that have been set."
      },
      {
        "name": "Parse",
        "desc": "Parse parses the command-line flags from [os.Args][1:]. Must be called after all flags are defined and before flags are accessed by the program."
      },
      {
        "name": "Parsed",
        "desc": "Parsed reports whether the command-line flags have been parsed."
      },
      {
        "name": "PrintDefaults",
        "desc": "PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form  \t-x int \t\tusage-message-for-x (default 7)  The usage message will appear on a separate line for anything but a bool flag with a one-byte name. For bool flags, the type is omitted and if the flag name is one byte the usage message appears on the same line. The parenthetical default is omitted if the default is the zero value for the type. The listed type, here int, can be changed by placing a back-quoted name in the flag's usage string; the first such item in the message is taken to be a parameter name to show in the message and the back quotes are stripped from the message when displayed. For instance, given  \tflag.String(\"I\", \"\", \"search `directory` for include files\")  the output will be  \t-I directory \t\tsearch directory for include files.  To change the destination for flag messages, call [CommandLine].SetOutput."
      },
      {
        "name": "ResetForTesting",
        "desc": "ResetForTesting clears all flag state and sets the usage function as directed. After calling ResetForTesting, parse errors in flag handling will not exit the program."
      },
      {
        "name": "Set",
        "desc": "Set sets the value of the named command-line flag."
      },
      {
        "name": "String",
        "desc": "String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag."
      },
      {
        "name": "StringVar",
        "desc": "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag."
      },
      {
        "name": "TextVar",
        "desc": "TextVar defines a flag with a specified name, default value, and usage string. The argument p must be a pointer to a variable that will hold the value of the flag, and p must implement encoding.TextUnmarshaler. If the flag is used, the flag value will be passed to p's UnmarshalText method. The type of the default value must be the same as the type of p."
      },
      {
        "name": "Uint",
        "desc": "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag."
      },
      {
        "name": "Uint64Var",
        "desc": "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag."
      },
      {
        "name": "UintVar",
        "desc": "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag."
      },
      {
        "name": "UnquoteUsage",
        "desc": "UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given \"a `name` to show\" it returns (\"name\", \"a name to show\"). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean."
      },
      {
        "name": "Var",
        "desc": "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type [Value], which typically holds a user-defined implementation of [Value]. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of [Value]; in particular, [Set] would decompose the comma-separated string into the slice."
      },
      {
        "name": "Visit",
        "desc": "Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set."
      },
      {
        "name": "VisitAll",
        "desc": "VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set."
      },
      {
        "name": "commandLineUsage",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "isZeroValue",
        "desc": "isZeroValue determines whether the string represents the zero value for a flag."
      },
      {
        "name": "numError",
        "desc": ""
      },
      {
        "name": "Arg",
        "desc": "Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist."
      },
      {
        "name": "Args",
        "desc": "Args returns the non-flag arguments."
      },
      {
        "name": "Bool",
        "desc": "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag."
      },
      {
        "name": "BoolFunc",
        "desc": "BoolFunc defines a flag with the specified name and usage string without requiring values. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error."
      },
      {
        "name": "BoolVar",
        "desc": "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag."
      },
      {
        "name": "Duration",
        "desc": "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration."
      },
      {
        "name": "DurationVar",
        "desc": "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration."
      },
      {
        "name": "ErrorHandling",
        "desc": "ErrorHandling returns the error handling behavior of the flag set."
      },
      {
        "name": "Float64",
        "desc": "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag."
      },
      {
        "name": "Float64Var",
        "desc": "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag."
      },
      {
        "name": "Func",
        "desc": "Func defines a flag with the specified name and usage string. Each time the flag is seen, fn is called with the value of the flag. If fn returns a non-nil error, it will be treated as a flag value parsing error."
      },
      {
        "name": "Init",
        "desc": "Init sets the name and error handling property for a flag set. By default, the zero [FlagSet] uses an empty name and the [ContinueOnError] error handling policy."
      },
      {
        "name": "Int",
        "desc": "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag."
      },
      {
        "name": "Int64",
        "desc": "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag."
      },
      {
        "name": "Int64Var",
        "desc": "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag."
      },
      {
        "name": "IntVar",
        "desc": "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the [Flag] structure of the named flag, returning nil if none exists."
      },
      {
        "name": "NArg",
        "desc": "NArg is the number of arguments remaining after flags have been processed."
      },
      {
        "name": "NFlag",
        "desc": "NFlag returns the number of flags that have been set."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the flag set."
      },
      {
        "name": "Output",
        "desc": "Output returns the destination for usage and error messages. [os.Stderr] is returned if output was not set or was set to nil."
      },
      {
        "name": "Parse",
        "desc": "Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the [FlagSet] are defined and before flags are accessed by the program. The return value will be [ErrHelp] if -help or -h were set but not defined."
      },
      {
        "name": "Parsed",
        "desc": "Parsed reports whether f.Parse has been called."
      },
      {
        "name": "PrintDefaults",
        "desc": "PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information."
      },
      {
        "name": "Set",
        "desc": "Set sets the value of the named flag."
      },
      {
        "name": "SetOutput",
        "desc": "SetOutput sets the destination for usage and error messages. If output is nil, [os.Stderr] is used."
      },
      {
        "name": "String",
        "desc": "String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag."
      },
      {
        "name": "StringVar",
        "desc": "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag."
      },
      {
        "name": "TextVar",
        "desc": "TextVar defines a flag with a specified name, default value, and usage string. The argument p must be a pointer to a variable that will hold the value of the flag, and p must implement encoding.TextUnmarshaler. If the flag is used, the flag value will be passed to p's UnmarshalText method. The type of the default value must be the same as the type of p."
      },
      {
        "name": "Uint",
        "desc": "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag."
      },
      {
        "name": "Uint64Var",
        "desc": "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag."
      },
      {
        "name": "UintVar",
        "desc": "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag."
      },
      {
        "name": "Var",
        "desc": "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type [Value], which typically holds a user-defined implementation of [Value]. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of [Value]; in particular, [Set] would decompose the comma-separated string into the slice."
      },
      {
        "name": "Visit",
        "desc": "Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set."
      },
      {
        "name": "VisitAll",
        "desc": "VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set."
      },
      {
        "name": "defaultUsage",
        "desc": "defaultUsage is the default function to print a usage message."
      },
      {
        "name": "failf",
        "desc": "failf prints to standard error a formatted error and usage message and returns the error."
      },
      {
        "name": "parseOne",
        "desc": "parseOne parses one flag. It reports whether a flag was seen."
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "sprintf",
        "desc": "sprintf formats the message, prints it to output, and returns it."
      },
      {
        "name": "usage",
        "desc": "usage calls the Usage method for the flag set if one is specified, or the appropriate default usage function otherwise."
      },
      {
        "name": "IsBoolFlag",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "IsBoolFlag",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ErrorHandling",
        "desc": "ErrorHandling defines how [FlagSet.Parse] behaves if the parse fails."
      },
      {
        "name": "Flag",
        "desc": "A Flag represents the state of a flag."
      },
      {
        "name": "FlagSet",
        "desc": "A FlagSet represents a set of defined flags. The zero value of a FlagSet has no name and has [ContinueOnError] error handling.  [Flag] names must be unique within a FlagSet. An attempt to define a flag whose name is already in use will cause a panic."
      },
      {
        "name": "Getter",
        "desc": "Getter is an interface that allows the contents of a [Value] to be retrieved. It wraps the [Value] interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All [Value] types provided by this package satisfy the [Getter] interface, except the type used by [Func]."
      },
      {
        "name": "Value",
        "desc": "Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)  If a Value has an IsBoolFlag() bool method returning true, the command-line parser makes -name equivalent to -name=true rather than using the next command-line argument.  Set is called once, in command line order, for each flag present. The flag package may call the [String] method with a zero-valued receiver, such as a nil pointer."
      },
      {
        "name": "boolFlag",
        "desc": "optional interface to indicate boolean flags that can be supplied without \"=value\" text"
      },
      {
        "name": "boolFuncValue",
        "desc": "-- boolFunc Value"
      },
      {
        "name": "boolValue",
        "desc": "-- bool Value"
      },
      {
        "name": "durationValue",
        "desc": "-- time.Duration Value"
      },
      {
        "name": "float64Value",
        "desc": "-- float64 Value"
      },
      {
        "name": "funcValue",
        "desc": "-- func Value"
      },
      {
        "name": "int64Value",
        "desc": "-- int64 Value"
      },
      {
        "name": "intValue",
        "desc": "-- int Value"
      },
      {
        "name": "stringValue",
        "desc": "-- string Value"
      },
      {
        "name": "textValue",
        "desc": "-- encoding.TextUnmarshaler Value"
      },
      {
        "name": "uint64Value",
        "desc": "-- uint64 Value"
      },
      {
        "name": "uintValue",
        "desc": "-- uint Value"
      }
    ]
  },
  {
    "name": "fmt",
    "desc": "Package fmt implements formatted I/O with functions analogous to C's printf and scanf.  The format 'verbs' are derived from C's but are simpler.  # Printing  The verbs:  General:  \t%v\tthe value in a default format \t\twhen printing structs, the plus flag (%+v) adds field names \t%#v\ta Go-syntax representation of the value \t\t(floating-point infinities and NaNs print as ±Inf and NaN) \t%T\ta Go-syntax representation of the type of the value \t%%\ta literal percent sign; consumes no value  Boolean:  \t%t\tthe word true or false  Integer:  \t%b\tbase 2 \t%c\tthe character represented by the corresponding Unicode code point \t%d\tbase 10 \t%o\tbase 8 \t%O\tbase 8 with 0o prefix \t%q\ta single-quoted character literal safely escaped with Go syntax. \t%x\tbase 16, with lower-case letters for a-f \t%X\tbase 16, with upper-case letters for A-F \t%U\tUnicode format: U+1234; same as \"U+%04X\"  Floating-point and complex constituents:  \t%b\tdecimalless scientific notation with exponent a power of two, \t\tin the manner of strconv.FormatFloat with the 'b' format, \t\te.g. -123456p-78 \t%e\tscientific notation, e.g. -1.234456e+78 \t%E\tscientific notation, e.g. -1.234456E+78 \t%f\tdecimal point but no exponent, e.g. 123.456 \t%F\tsynonym for %f \t%g\t%e for large exponents, %f otherwise. Precision is discussed below. \t%G\t%E for large exponents, %F otherwise \t%x\thexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20 \t%X\tupper-case hexadecimal notation, e.g. -0X1.23ABCP+20  \tThe exponent is always a decimal integer. \tFor formats other than %b the exponent is at least two digits.  String and slice of bytes (treated equivalently with these verbs):  \t%s\tthe uninterpreted bytes of the string or slice \t%q\ta double-quoted string safely escaped with Go syntax \t%x\tbase 16, lower-case, two characters per byte \t%X\tbase 16, upper-case, two characters per byte  Slice:  \t%p\taddress of 0th element in base 16 notation, with leading 0x  Pointer:  \t%p\tbase 16 notation, with leading 0x \tThe %b, %d, %o, %x and %X verbs also work with pointers, \tformatting the value exactly as if it were an integer.  The default format for %v is:  \tbool:                    %t \tint, int8 etc.:          %d \tuint, uint8 etc.:        %d, %#x if printed with %#v \tfloat32, complex64, etc: %g \tstring:                  %s \tchan:                    %p \tpointer:                 %p  For compound objects, the elements are printed using these rules, recursively, laid out like this:  \tstruct:             {field0 field1 ...} \tarray, slice:       [elem0 elem1 ...] \tmaps:               map[key1:value1 key2:value2 ...] \tpointer to above:   \u0026{}, \u0026[], \u0026map[]  Width is specified by an optional decimal number immediately preceding the verb. If absent, the width is whatever is necessary to represent the value. Precision is specified after the (optional) width by a period followed by a decimal number. If no period is present, a default precision is used. A period with no following number specifies a precision of zero. Examples:  \t%f     default width, default precision \t%9f    width 9, default precision \t%.2f   default width, precision 2 \t%9.2f  width 9, precision 2 \t%9.f   width 9, precision 0  Width and precision are measured in units of Unicode code points, that is, runes. (This differs from C's printf where the units are always measured in bytes.) Either or both of the flags may be replaced with the character '*', causing their values to be obtained from the next operand (preceding the one to format), which must be of type int.  For most values, width is the minimum number of runes to output, padding the formatted form with spaces if necessary.  For strings, byte slices and byte arrays, however, precision limits the length of the input to be formatted (not the size of the output), truncating if necessary. Normally it is measured in runes, but for these types when formatted with the %x or %X format it is measured in bytes.  For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G precision sets the maximum number of significant digits (trailing zeros are removed). For example, given 12.345 the format %6.3f prints 12.345 while %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it is the smallest number of digits necessary to identify the value uniquely.  For complex numbers, the width and precision apply to the two components independently and the result is parenthesized, so %f applied to 1.2+3.4i produces (1.200000+3.400000i).  When formatting a single integer code point or a rune string (type []rune) with %q, invalid Unicode code points are changed to the Unicode replacement character, U+FFFD, as in [strconv.QuoteRune].  Other flags:  \t'+'\talways print a sign for numeric values; \t\tguarantee ASCII-only output for %q (%+q) \t'-'\tpad with spaces on the right rather than the left (left-justify the field) \t'#'\talternate format: add leading 0b for binary (%#b), 0 for octal (%#o), \t\t0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p); \t\tfor %q, print a raw (backquoted) string if [strconv.CanBackquote] \t\treturns true; \t\talways print a decimal point for %e, %E, %f, %F, %g and %G; \t\tdo not remove trailing zeros for %g and %G; \t\twrite e.g. U+0078 'x' if the character is printable for %U (%#U) \t' '\t(space) leave a space for elided sign in numbers (% d); \t\tput spaces between bytes printing strings or slices in hex (% x, % X) \t'0'\tpad with leading zeros rather than spaces; \t\tfor numbers, this moves the padding after the sign  Flags are ignored by verbs that do not expect them. For example there is no alternate decimal format, so %#d and %d behave identically.  For each Printf-like function, there is also a Print function that takes no format and is equivalent to saying %v for every operand.  Another variant Println inserts blanks between operands and appends a newline.  Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. Thus:  \tvar i interface{} = 23 \tfmt.Printf(\"%v\\n\", i)  will print 23.  Except when printed using the verbs %T and %p, special formatting considerations apply for operands that implement certain interfaces. In order of application:  1. If the operand is a [reflect.Value], the operand is replaced by the concrete value that it holds, and printing continues with the next rule.  2. If an operand implements the [Formatter] interface, it will be invoked. In this case the interpretation of verbs and flags is controlled by that implementation.  3. If the %v verb is used with the # flag (%#v) and the operand implements the [GoStringer] interface, that will be invoked.  If the format (which is implicitly %v for [Println] etc.) is valid for a string (%s %q %x %X), or is %v but not %#v, the following two rules apply:  4. If an operand implements the error interface, the Error method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).  5. If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).  For compound operands such as slices and structs, the format applies to the elements of each operand, recursively, not to the operand as a whole. Thus %q will quote each element of a slice of strings, and %6.2f will control formatting for each element of a floating-point array.  However, when printing a byte slice with a string-like verb (%s %q %x %X), it is treated identically to a string, as a single item.  To avoid recursion in cases such as  \ttype X string \tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", x) }  convert the value before recurring:  \tfunc (x X) String() string { return Sprintf(\"\u003c%s\u003e\", string(x)) }  Infinite recursion can also be triggered by self-referential data structures, such as a slice that contains itself as an element, if that type has a String method. Such pathologies are rare, however, and the package does not protect against them.  When printing a struct, fmt cannot and therefore does not invoke formatting methods such as Error or String on unexported fields.  # Explicit argument indexes  In [Printf], [Sprintf], and [Fprintf], the default behavior is for each formatting verb to format successive arguments passed in the call. However, the notation [n] immediately before the verb indicates that the nth one-indexed argument is to be formatted instead. The same notation before a '*' for a width or precision selects the argument index holding the value. After processing a bracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc. unless otherwise directed.  For example,  \tfmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)  will yield \"22 11\", while  \tfmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)  equivalent to  \tfmt.Sprintf(\"%6.2f\", 12.0)  will yield \" 12.00\". Because an explicit index affects subsequent verbs, this notation can be used to print the same values multiple times by resetting the index for the first argument to be repeated:  \tfmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)  will yield \"16 17 0x10 0x11\".  # Format errors  If an invalid argument is given for a verb, such as providing a string to %d, the generated string will contain a description of the problem, as in these examples:  \tWrong type or unknown verb: %!verb(type=value) \t\tPrintf(\"%d\", \"hi\"):        %!d(string=hi) \tToo many arguments: %!(EXTRA type=value) \t\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys) \tToo few arguments: %!verb(MISSING) \t\tPrintf(\"hi%d\"):            hi%!d(MISSING) \tNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC) \t\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi \t\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi \tInvalid or invalid use of argument index: %!(BADINDEX) \t\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX) \t\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)  All errors begin with the string \"%!\" followed sometimes by a single character (the verb) and end with a parenthesized description.  If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package.  For example, if a String method calls panic(\"bad\"), the resulting formatted message will look like  \t%!s(PANIC=bad)  The %!s just shows the print verb in use when the failure occurred. If the panic is caused by a nil receiver to an Error, String, or GoString method, however, the output is the undecorated string, \"\u003cnil\u003e\".  # Scanning  An analogous set of functions scans formatted text to yield values.  [Scan], [Scanf] and [Scanln] read from [os.Stdin]; [Fscan], [Fscanf] and [Fscanln] read from a specified [io.Reader]; [Sscan], [Sscanf] and [Sscanln] read from an argument string.  [Scan], [Fscan], [Sscan] treat newlines in the input as spaces.  [Scanln], [Fscanln] and [Sscanln] stop scanning at a newline and require that the items be followed by a newline or EOF.  [Scanf], [Fscanf], and [Sscanf] parse the arguments according to a format string, analogous to that of [Printf]. In the text that follows, 'space' means any Unicode whitespace character except newline.  In the format string, a verb introduced by the % character consumes and parses input; these verbs are described in more detail below. A character other than %, space, or newline in the format consumes exactly that input character, which must be present. A newline with zero or more spaces before it in the format string consumes zero or more spaces in the input followed by a single newline or the end of the input. A space following a newline in the format string consumes zero or more spaces in the input. Otherwise, any run of one or more spaces in the format string consumes as many spaces as possible in the input. Unless the run of spaces in the format string appears adjacent to a newline, the run must consume at least one space from the input or find the end of the input.  The handling of spaces and newlines differs from that of C's scanf family: in C, newlines are treated as any other space, and it is never an error when a run of spaces in the format string finds no spaces to consume in the input.  The verbs behave analogously to those of [Printf]. For example, %x will scan an integer as a hexadecimal number, and %v will scan the default representation format for the value. The [Printf] verbs %p and %T and the flags # and + are not implemented. For floating-point and complex values, all valid formatting verbs (%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and hexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating underscores (for example: \"3.14159_26535_89793\").  Input processed by verbs is implicitly space-delimited: the implementation of every verb except %c starts by discarding leading spaces from the remaining input, and the %s verb (and %v reading into a string) stops consuming input at the first space or newline character.  The familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x (hexadecimal) are accepted when scanning integers without a format or with the %v verb, as are digit-separating underscores.  Width is interpreted in the input text but there is no syntax for scanning with a precision (no %5.2f, just %5f). If width is provided, it applies after leading spaces are trimmed and specifies the maximum number of runes to read to satisfy the verb. For example,  \tSscanf(\" 1234567 \", \"%5s%d\", \u0026s, \u0026i)  will set s to \"12345\" and i to 67 while  \tSscanf(\" 12 34 567 \", \"%5s%d\", \u0026s, \u0026i)  will set s to \"12\" and i to 34.  In all the scanning functions, a carriage return followed immediately by a newline is treated as a plain newline (\\r\\n means the same as \\n).  In all the scanning functions, if an operand implements method [Scan] (that is, it implements the [Scanner] interface) that method will be used to scan the text for that operand.  Also, if the number of arguments scanned is less than the number of arguments provided, an error is returned.  All arguments to be scanned must be either pointers to basic types or implementations of the [Scanner] interface.  Like [Scanf] and [Fscanf], [Sscanf] need not consume its entire input. There is no way to recover how much of the input string [Sscanf] used.  Note: [Fscan] etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input.  This is usually a problem only when there is no space between input values.  If the reader provided to [Fscan] implements ReadRune, that method will be used to read characters.  If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data.  To attach ReadRune and UnreadRune methods to a reader without that capability, use [bufio.NewReader].",
    "functions": [
      {
        "name": "Append",
        "desc": "Append formats using the default formats for its operands, appends the result to the byte slice, and returns the updated slice."
      },
      {
        "name": "Appendf",
        "desc": "Appendf formats according to a format specifier, appends the result to the byte slice, and returns the updated slice."
      },
      {
        "name": "Appendln",
        "desc": "Appendln formats using the default formats for its operands, appends the result to the byte slice, and returns the updated slice. Spaces are always added between operands and a newline is appended."
      },
      {
        "name": "Errorf",
        "desc": "Errorf formats according to a format specifier and returns the string as a value that satisfies error.  If the format specifier includes a %w verb with an error operand, the returned error will implement an Unwrap method returning the operand. If there is more than one %w verb, the returned error will implement an Unwrap method returning a []error containing all the %w operands in the order they appear in the arguments. It is invalid to supply the %w verb with an operand that does not implement the error interface. The %w verb is otherwise a synonym for %v."
      },
      {
        "name": "FormatString",
        "desc": "FormatString returns a string representing the fully qualified formatting directive captured by the [State], followed by the argument verb. ([State] does not itself contain the verb.) The result has a leading percent sign followed by any flags, the width, and the precision. Missing flags, width, and precision are omitted. This function allows a [Formatter] to reconstruct the original directive triggering the call to Format."
      },
      {
        "name": "Fprint",
        "desc": "Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered."
      },
      {
        "name": "Fprintf",
        "desc": "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered."
      },
      {
        "name": "Fprintln",
        "desc": "Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."
      },
      {
        "name": "Fscan",
        "desc": "Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why."
      },
      {
        "name": "Fscanf",
        "desc": "Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format."
      },
      {
        "name": "Fscanln",
        "desc": "Fscanln is similar to [Fscan], but stops scanning at a newline and after the final item there must be a newline or EOF."
      },
      {
        "name": "Print",
        "desc": "Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered."
      },
      {
        "name": "Printf",
        "desc": "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered."
      },
      {
        "name": "Println",
        "desc": "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered."
      },
      {
        "name": "Scan",
        "desc": "Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why."
      },
      {
        "name": "Scanf",
        "desc": "Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline."
      },
      {
        "name": "Scanln",
        "desc": "Scanln is similar to [Scan], but stops scanning at a newline and after the final item there must be a newline or EOF."
      },
      {
        "name": "Sprint",
        "desc": "Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string."
      },
      {
        "name": "Sprintf",
        "desc": "Sprintf formats according to a format specifier and returns the resulting string."
      },
      {
        "name": "Sprintln",
        "desc": "Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended."
      },
      {
        "name": "Sscan",
        "desc": "Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why."
      },
      {
        "name": "Sscanf",
        "desc": "Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format."
      },
      {
        "name": "Sscanln",
        "desc": "Sscanln is similar to [Sscan], but stops scanning at a newline and after the final item there must be a newline or EOF."
      },
      {
        "name": "errorHandler",
        "desc": "errorHandler turns local panics into error returns."
      },
      {
        "name": "getField",
        "desc": "getField gets the i'th field of the struct value. If the field itself is a non-nil interface, return a value for the thing inside the interface, not the interface itself."
      },
      {
        "name": "hasX",
        "desc": ""
      },
      {
        "name": "hexDigit",
        "desc": "hexDigit returns the value of the hexadecimal digit."
      },
      {
        "name": "indexRune",
        "desc": ""
      },
      {
        "name": "intFromArg",
        "desc": "intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has integer type."
      },
      {
        "name": "isSpace",
        "desc": ""
      },
      {
        "name": "newScanState",
        "desc": "newScanState allocates a new ss struct or grab a cached one."
      },
      {
        "name": "notSpace",
        "desc": "notSpace is the default scanning function used in Token."
      },
      {
        "name": "parseArgNumber",
        "desc": "parseArgNumber returns the value of the bracketed number, minus 1 (explicit argument numbers are one-indexed but we want zero-indexed). The opening bracket is known to be present at format[0]. The returned values are the index, the number of bytes to consume up to the closing paren, if present, and whether the number parsed ok. The bytes to consume will be 1 if no closing paren is present."
      },
      {
        "name": "parsenum",
        "desc": "parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present."
      },
      {
        "name": "tooLarge",
        "desc": "tooLarge reports whether the magnitude of the integer is too large to be used as a formatting width or precision."
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeByte",
        "desc": ""
      },
      {
        "name": "writeRune",
        "desc": ""
      },
      {
        "name": "writeString",
        "desc": ""
      },
      {
        "name": "clearflags",
        "desc": ""
      },
      {
        "name": "fmtBoolean",
        "desc": "fmtBoolean formats a boolean."
      },
      {
        "name": "fmtBs",
        "desc": "fmtBs formats the byte slice b as if it was formatted as string with fmtS."
      },
      {
        "name": "fmtBx",
        "desc": "fmtBx formats a byte slice as a hexadecimal encoding of its bytes."
      },
      {
        "name": "fmtC",
        "desc": "fmtC formats an integer as a Unicode character. If the character is not valid Unicode, it will print '\\ufffd'."
      },
      {
        "name": "fmtFloat",
        "desc": "fmtFloat formats a float64. It assumes that verb is a valid format specifier for strconv.AppendFloat and therefore fits into a byte."
      },
      {
        "name": "fmtInteger",
        "desc": "fmtInteger formats signed and unsigned integers."
      },
      {
        "name": "fmtQ",
        "desc": "fmtQ formats a string as a double-quoted, escaped Go string constant. If f.sharp is set a raw (backquoted) string may be returned instead if the string does not contain any control characters other than tab."
      },
      {
        "name": "fmtQc",
        "desc": "fmtQc formats an integer as a single-quoted, escaped Go character constant. If the character is not valid Unicode, it will print '\\ufffd'."
      },
      {
        "name": "fmtS",
        "desc": "fmtS formats a string."
      },
      {
        "name": "fmtSbx",
        "desc": "fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes."
      },
      {
        "name": "fmtSx",
        "desc": "fmtSx formats a string as a hexadecimal encoding of its bytes."
      },
      {
        "name": "fmtUnicode",
        "desc": "fmtUnicode formats a uint64 as \"U+0078\" or with f.sharp set as \"U+0078 'x'\"."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "pad",
        "desc": "pad appends b to f.buf, padded on left (!f.minus) or right (f.minus)."
      },
      {
        "name": "padString",
        "desc": "padString appends s to f.buf, padded on left (!f.minus) or right (f.minus)."
      },
      {
        "name": "truncate",
        "desc": "truncate truncates the byte slice b as a string of the specified precision, if present."
      },
      {
        "name": "truncateString",
        "desc": "truncateString truncates the string s to the specified precision, if present."
      },
      {
        "name": "writePadding",
        "desc": "writePadding generates n bytes of padding."
      },
      {
        "name": "Flag",
        "desc": ""
      },
      {
        "name": "Precision",
        "desc": ""
      },
      {
        "name": "Width",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": "Write implements [io.Writer] so we can call [Fprintf] on a pp (through [State]), for recursive use in custom verbs."
      },
      {
        "name": "WriteString",
        "desc": "WriteString implements [io.StringWriter] so that we can call [io.WriteString] on a pp (through state), for efficiency."
      },
      {
        "name": "argNumber",
        "desc": "argNumber returns the next argument to evaluate, which is either the value of the passed-in argNum or the value of the bracketed integer that begins format[i:]. It also returns the new value of i, that is, the index of the next byte of the format to process."
      },
      {
        "name": "badArgNum",
        "desc": ""
      },
      {
        "name": "badVerb",
        "desc": ""
      },
      {
        "name": "catchPanic",
        "desc": ""
      },
      {
        "name": "doPrint",
        "desc": ""
      },
      {
        "name": "doPrintf",
        "desc": ""
      },
      {
        "name": "doPrintln",
        "desc": "doPrintln is like doPrint but always adds a space between arguments and a newline after the last argument."
      },
      {
        "name": "fmt0x64",
        "desc": "fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or not, as requested, by temporarily setting the sharp flag."
      },
      {
        "name": "fmtBool",
        "desc": ""
      },
      {
        "name": "fmtBytes",
        "desc": ""
      },
      {
        "name": "fmtComplex",
        "desc": "fmtComplex formats a complex number v with r = real(v) and j = imag(v) as (r+ji) using fmtFloat for r and j formatting."
      },
      {
        "name": "fmtFloat",
        "desc": "fmtFloat formats a float. The default precision for each verb is specified as last argument in the call to fmt_float."
      },
      {
        "name": "fmtInteger",
        "desc": "fmtInteger formats a signed or unsigned integer."
      },
      {
        "name": "fmtPointer",
        "desc": ""
      },
      {
        "name": "fmtString",
        "desc": ""
      },
      {
        "name": "free",
        "desc": "free saves used pp structs in ppFree; avoids an allocation per invocation."
      },
      {
        "name": "handleMethods",
        "desc": ""
      },
      {
        "name": "missingArg",
        "desc": ""
      },
      {
        "name": "printArg",
        "desc": ""
      },
      {
        "name": "printValue",
        "desc": "printValue is similar to printArg but starts with a reflect value, not an interface{} value. It does not handle 'p' and 'T' verbs because these should have been already handled by printArg."
      },
      {
        "name": "unknownType",
        "desc": ""
      },
      {
        "name": "ReadRune",
        "desc": "ReadRune returns the next UTF-8 encoded code point from the io.Reader inside r."
      },
      {
        "name": "UnreadRune",
        "desc": ""
      },
      {
        "name": "readByte",
        "desc": "readByte returns the next byte from the input, which may be left over from a previous read if the UTF-8 was ill-formed."
      },
      {
        "name": "Read",
        "desc": "The Read method is only in ScanState so that ScanState satisfies io.Reader. It will never be called when used as intended, so there is no need to make it actually work."
      },
      {
        "name": "ReadRune",
        "desc": ""
      },
      {
        "name": "SkipSpace",
        "desc": "SkipSpace provides Scan methods the ability to skip space and newline characters in keeping with the current scanning mode set by format strings and [Scan]/[Scanln]."
      },
      {
        "name": "Token",
        "desc": ""
      },
      {
        "name": "UnreadRune",
        "desc": ""
      },
      {
        "name": "Width",
        "desc": ""
      },
      {
        "name": "accept",
        "desc": "accept checks the next rune in the input. If it's a byte (sic) in the string, it puts it in the buffer and returns true. Otherwise it return false."
      },
      {
        "name": "advance",
        "desc": "advance determines whether the next characters in the input match those of the format. It returns the number of bytes (sic) consumed in the format. All runs of space characters in either input or format behave as a single space. Newlines are special, though: newlines in the format must match those in the input and vice versa. This routine also handles the %% case. If the return value is zero, either format starts with a % (with no following %) or the input is empty. If it is negative, the input did not match the string."
      },
      {
        "name": "complexTokens",
        "desc": "complexTokens returns the real and imaginary parts of the complex number starting here. The number might be parenthesized and has the format (N+Ni) where N is a floating-point number and there are no spaces within."
      },
      {
        "name": "consume",
        "desc": "consume reads the next rune in the input and reports whether it is in the ok string. If accept is true, it puts the character into the input token."
      },
      {
        "name": "convertFloat",
        "desc": "convertFloat converts the string to a float64value."
      },
      {
        "name": "convertString",
        "desc": "convertString returns the string represented by the next input characters. The format of the input is determined by the verb."
      },
      {
        "name": "doScan",
        "desc": "doScan does the real work for scanning without a format string."
      },
      {
        "name": "doScanf",
        "desc": "doScanf does the real work when scanning with a format string. At the moment, it handles only pointers to basic types."
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "errorString",
        "desc": ""
      },
      {
        "name": "floatToken",
        "desc": "floatToken returns the floating-point number starting here, no longer than swid if the width is specified. It's not rigorous about syntax because it doesn't check that we have at least some digits, but Atof will do that."
      },
      {
        "name": "free",
        "desc": "free saves used ss structs in ssFree; avoid an allocation per invocation."
      },
      {
        "name": "getBase",
        "desc": "getBase returns the numeric base represented by the verb and its digit string."
      },
      {
        "name": "getRune",
        "desc": "The public method returns an error; this private one panics. If getRune reaches EOF, the return value is EOF (-1)."
      },
      {
        "name": "hexByte",
        "desc": "hexByte returns the next hex-encoded (two-character) byte from the input. It returns ok==false if the next bytes in the input do not encode a hex byte. If the first byte is hex and the second is not, processing stops."
      },
      {
        "name": "hexString",
        "desc": "hexString returns the space-delimited hexpair-encoded string."
      },
      {
        "name": "mustReadRune",
        "desc": "mustReadRune turns io.EOF into a panic(io.ErrUnexpectedEOF). It is called in cases such as string scanning where an EOF is a syntax error."
      },
      {
        "name": "notEOF",
        "desc": ""
      },
      {
        "name": "okVerb",
        "desc": "okVerb verifies that the verb is present in the list, setting s.err appropriately if not."
      },
      {
        "name": "peek",
        "desc": "peek reports whether the next character is in the ok string, without consuming it."
      },
      {
        "name": "quotedString",
        "desc": "quotedString returns the double- or back-quoted string represented by the next input characters."
      },
      {
        "name": "scanBasePrefix",
        "desc": "scanBasePrefix reports whether the integer begins with a base prefix and returns the base, digit string, and whether a zero was found. It is called only if the verb is %v."
      },
      {
        "name": "scanBool",
        "desc": "scanBool returns the value of the boolean represented by the next token."
      },
      {
        "name": "scanComplex",
        "desc": "scanComplex converts the next token to a complex128 value. The atof argument is a type-specific reader for the underlying type. If we're reading complex64, atof will parse float32s and convert them to float64's to avoid reproducing this code for each complex type."
      },
      {
        "name": "scanInt",
        "desc": "scanInt returns the value of the integer represented by the next token, checking for overflow. Any error is stored in s.err."
      },
      {
        "name": "scanNumber",
        "desc": "scanNumber returns the numerical string with specified digits starting here."
      },
      {
        "name": "scanOne",
        "desc": "scanOne scans a single value, deriving the scanner from the type of the argument."
      },
      {
        "name": "scanPercent",
        "desc": "scanPercent scans a literal percent character."
      },
      {
        "name": "scanRune",
        "desc": "scanRune returns the next rune value in the input."
      },
      {
        "name": "scanUint",
        "desc": "scanUint returns the value of the unsigned integer represented by the next token, checking for overflow. Any error is stored in s.err."
      },
      {
        "name": "token",
        "desc": "token returns the next space-delimited string from the input. It skips white space. For Scanln, it stops at newlines. For Scan, newlines are treated as spaces."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Formatter",
        "desc": "Formatter is implemented by any value that has a Format method. The implementation controls how [State] and rune are interpreted, and may call [Sprint] or [Fprint](f) etc. to generate its output."
      },
      {
        "name": "GoStringer",
        "desc": "GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format."
      },
      {
        "name": "ScanState",
        "desc": "ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token."
      },
      {
        "name": "Scanner",
        "desc": "Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to [Scan], [Scanf], or [Scanln] that implements it."
      },
      {
        "name": "State",
        "desc": "State represents the printer state passed to custom formatters. It provides access to the [io.Writer] interface plus information about the flags and options for the operand's format specifier."
      },
      {
        "name": "Stringer",
        "desc": "Stringer is implemented by any value that has a String method, which defines the “native” format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as [Print]."
      },
      {
        "name": "buffer",
        "desc": "Use simple []byte instead of bytes.Buffer to avoid large dependency."
      },
      {
        "name": "fmt",
        "desc": "A fmt is the raw formatter used by Printf etc. It prints into a buffer that must be set up separately."
      },
      {
        "name": "fmtFlags",
        "desc": "flags placed in a separate struct for easy clearing."
      },
      {
        "name": "pp",
        "desc": "pp is used to store a printer's state and is reused with sync.Pool to avoid allocations."
      },
      {
        "name": "readRune",
        "desc": "readRune is a structure to enable reading UTF-8 encoded code points from an io.Reader. It is used if the Reader given to the scanner does not already implement io.RuneScanner."
      },
      {
        "name": "scanError",
        "desc": "scanError represents an error generated by the scanning software. It's used as a unique signature to identify such errors when recovering."
      },
      {
        "name": "ss",
        "desc": "ss is the internal implementation of ScanState."
      },
      {
        "name": "ssave",
        "desc": "ssave holds the parts of ss that need to be saved and restored on recursive scans."
      },
      {
        "name": "stringReader",
        "desc": ""
      },
      {
        "name": "wrapError",
        "desc": ""
      },
      {
        "name": "wrapErrors",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/ast",
    "desc": "Package ast declares the types used to represent syntax trees for Go packages.  Syntax trees may be constructed directly, but they are typically produced from Go source code by the parser; see the ParseFile function in package [go/parser].",
    "functions": [
      {
        "name": "FileExports",
        "desc": "FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The [File.Comments] list is not changed.  FileExports reports whether there are exported declarations."
      },
      {
        "name": "FilterDecl",
        "desc": "FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.  FilterDecl reports whether there are any declared names left after filtering."
      },
      {
        "name": "FilterFile",
        "desc": "FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The [File.Comments] list is not changed.  FilterFile reports whether there are any top-level declarations left after filtering."
      },
      {
        "name": "FilterPackage",
        "desc": "FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.  FilterPackage reports whether there are any top-level declarations left after filtering.  Deprecated: use the type checker [go/types] instead of [Package]; see [Object]. Alternatively, use [FilterFile]."
      },
      {
        "name": "Fprint",
        "desc": "Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).  A non-nil [FieldFilter] f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed."
      },
      {
        "name": "Inspect",
        "desc": "Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).  In many cases it may be more convenient to use [Preorder], which returns an iterator over the sqeuence of nodes, or [PreorderStack], which (like [Inspect]) provides control over descent into subtrees, but additionally reports the stack of enclosing nodes."
      },
      {
        "name": "IsExported",
        "desc": "IsExported reports whether name starts with an upper-case letter."
      },
      {
        "name": "IsGenerated",
        "desc": "IsGenerated reports whether the file was generated by a program, not handwritten, by detecting the special comment described at https://go.dev/s/generatedcode.  The syntax tree must have been parsed with the [parser.ParseComments] flag. Example:  \tf, err := parser.ParseFile(fset, filename, src, parser.ParseComments|parser.PackageClauseOnly) \tif err != nil { ... } \tgen := ast.IsGenerated(f)"
      },
      {
        "name": "NotNilFilter",
        "desc": "NotNilFilter is a [FieldFilter] that returns true for field values that are not nil; it returns false otherwise."
      },
      {
        "name": "PackageExports",
        "desc": "PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.  PackageExports reports whether there are exported declarations; it returns false otherwise.  Deprecated: use the type checker [go/types] instead of [Package]; see [Object]. Alternatively, use [FileExports]."
      },
      {
        "name": "Preorder",
        "desc": "Preorder returns an iterator over all the nodes of the syntax tree beneath (and including) the specified root, in depth-first preorder.  For greater control over the traversal of each subtree, use [Inspect] or [PreorderStack]."
      },
      {
        "name": "PreorderStack",
        "desc": "PreorderStack traverses the tree rooted at root, calling f before visiting each node.  Each call to f provides the current node and traversal stack, consisting of the original value of stack appended with all nodes from root to n, excluding n itself. (This design allows calls to PreorderStack to be nested without double counting.)  If f returns false, the traversal skips over that subtree. Unlike [Inspect], no second call to f is made after visiting node n. (In practice, the second call is nearly always used only to pop the stack, and it is surprisingly tricky to do this correctly.)"
      },
      {
        "name": "Print",
        "desc": "Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter)."
      },
      {
        "name": "SortImports",
        "desc": "SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss."
      },
      {
        "name": "TestCommentText",
        "desc": ""
      },
      {
        "name": "TestIsDirective",
        "desc": ""
      },
      {
        "name": "TestPrint",
        "desc": ""
      },
      {
        "name": "Walk",
        "desc": "Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil)."
      },
      {
        "name": "collapse",
        "desc": "collapse indicates whether prev may be removed, leaving only next."
      },
      {
        "name": "exportFilter",
        "desc": "exportFilter is a special filter function to extract exported nodes."
      },
      {
        "name": "filterCompositeLit",
        "desc": ""
      },
      {
        "name": "filterDecl",
        "desc": ""
      },
      {
        "name": "filterFieldList",
        "desc": ""
      },
      {
        "name": "filterFile",
        "desc": ""
      },
      {
        "name": "filterPackage",
        "desc": ""
      },
      {
        "name": "filterParamList",
        "desc": ""
      },
      {
        "name": "filterSpec",
        "desc": ""
      },
      {
        "name": "filterType",
        "desc": ""
      },
      {
        "name": "fprint",
        "desc": ""
      },
      {
        "name": "generator",
        "desc": ""
      },
      {
        "name": "importComment",
        "desc": ""
      },
      {
        "name": "importName",
        "desc": ""
      },
      {
        "name": "importPath",
        "desc": ""
      },
      {
        "name": "isDirective",
        "desc": "isDirective reports whether c is a comment directive. This code is also in go/printer."
      },
      {
        "name": "isWhitespace",
        "desc": ""
      },
      {
        "name": "lineAt",
        "desc": ""
      },
      {
        "name": "nameOf",
        "desc": "nameOf returns the function (foo) or method name (foo.bar) for the given function declaration. If the AST is incorrect for the receiver, it assumes a function instead."
      },
      {
        "name": "resolve",
        "desc": ""
      },
      {
        "name": "sortComments",
        "desc": "sortComments sorts the list of comment groups in source order."
      },
      {
        "name": "stripTrailingWhitespace",
        "desc": ""
      },
      {
        "name": "summary",
        "desc": ""
      },
      {
        "name": "trim",
        "desc": "Split s into lines, trim whitespace from all lines, and return the concatenated non-empty lines."
      },
      {
        "name": "walkList",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "declNode",
        "desc": "declNode() ensures that only declaration nodes can be assigned to a Decl."
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": "exprNode() ensures that only expression/type nodes can be assigned to an Expr."
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": "stmtNode() ensures that only statement nodes can be assigned to a Stmt."
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "Text",
        "desc": "Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Comment directives like \"//line\" and \"//go:noinline\" are also removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated."
      },
      {
        "name": "Comments",
        "desc": "Comments returns the list of comment groups in the comment map. The result is sorted in source order."
      },
      {
        "name": "Filter",
        "desc": "Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Update",
        "desc": "Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node."
      },
      {
        "name": "addComment",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "NumFields",
        "desc": "NumFields returns the number of parameters or struct fields represented by a [FieldList]."
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "End",
        "desc": "End returns the end of the last declaration in the file. It may be invalid, for example in an empty file.  (Use FileEnd for the end of the entire file. It is always valid.)"
      },
      {
        "name": "Pos",
        "desc": "Pos returns the position of the package declaration. It may be invalid, for example in an empty file.  (Use FileStart for the start of the entire file. It is always valid.)"
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "declNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "declNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "IsExported",
        "desc": "IsExported reports whether id starts with an upper-case letter."
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "specNode",
        "desc": "specNode() ensures that only spec nodes can be assigned to a Spec."
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": "Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct)."
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "Insert",
        "desc": "Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored."
      },
      {
        "name": "String",
        "desc": "Debugging support"
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "specNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "stmtNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "exprNode",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "specNode",
        "desc": ""
      },
      {
        "name": "eol",
        "desc": ""
      },
      {
        "name": "next",
        "desc": ""
      },
      {
        "name": "Visit",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": "pop pops all nodes that appear lexically before pos (i.e., whose lexical extent has ended before or at pos). It returns the last node popped."
      },
      {
        "name": "push",
        "desc": "push pops all nodes that appear lexically before n and then pushes n on the stack."
      },
      {
        "name": "declare",
        "desc": ""
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "errorf",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "print",
        "desc": ""
      },
      {
        "name": "printf",
        "desc": "printf is a convenience wrapper that takes care of print errors."
      }
    ],
    "types": [
      {
        "name": "ArrayType",
        "desc": "An ArrayType node represents an array or slice type."
      },
      {
        "name": "AssignStmt",
        "desc": "An AssignStmt node represents an assignment or a short variable declaration."
      },
      {
        "name": "BadDecl",
        "desc": "A BadDecl node is a placeholder for a declaration containing syntax errors for which a correct declaration node cannot be created."
      },
      {
        "name": "BadExpr",
        "desc": "A BadExpr node is a placeholder for an expression containing syntax errors for which a correct expression node cannot be created."
      },
      {
        "name": "BadStmt",
        "desc": "A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created."
      },
      {
        "name": "BasicLit",
        "desc": "A BasicLit node represents a literal of basic type.  Note that for the CHAR and STRING kinds, the literal is stored with its quotes. For example, for a double-quoted STRING, the first and the last rune in the Value field will be \". The [strconv.Unquote] and [strconv.UnquoteChar] functions can be used to unquote STRING and CHAR values, respectively.  For raw string literals (Kind == token.STRING \u0026\u0026 Value[0] == '`'), the Value field contains the string text without carriage returns (\\r) that may have been present in the source. Because the end position is computed using len(Value), the position reported by [BasicLit.End] does not match the true source end position for raw string literals containing carriage returns."
      },
      {
        "name": "BinaryExpr",
        "desc": "A BinaryExpr node represents a binary expression."
      },
      {
        "name": "BlockStmt",
        "desc": "A BlockStmt node represents a braced statement list."
      },
      {
        "name": "BranchStmt",
        "desc": "A BranchStmt node represents a break, continue, goto, or fallthrough statement."
      },
      {
        "name": "CallExpr",
        "desc": "A CallExpr node represents an expression followed by an argument list."
      },
      {
        "name": "CaseClause",
        "desc": "A CaseClause represents a case of an expression or type switch statement."
      },
      {
        "name": "ChanDir",
        "desc": "The direction of a channel type is indicated by a bit mask including one or both of the following constants."
      },
      {
        "name": "ChanType",
        "desc": "A ChanType node represents a channel type."
      },
      {
        "name": "CommClause",
        "desc": "A CommClause node represents a case of a select statement."
      },
      {
        "name": "Comment",
        "desc": "A Comment node represents a single //-style or /*-style comment.  The Text field contains the comment text without carriage returns (\\r) that may have been present in the source. Because a comment's end position is computed using len(Text), the position reported by [Comment.End] does not match the true source end position for comments containing carriage returns."
      },
      {
        "name": "CommentGroup",
        "desc": "A CommentGroup represents a sequence of comments with no other tokens and no empty lines between."
      },
      {
        "name": "CommentMap",
        "desc": "A CommentMap maps an AST node to a list of comment groups associated with it. See [NewCommentMap] for a description of the association."
      },
      {
        "name": "CompositeLit",
        "desc": "A CompositeLit node represents a composite literal."
      },
      {
        "name": "Decl",
        "desc": "All declaration nodes implement the Decl interface."
      },
      {
        "name": "DeclStmt",
        "desc": "A DeclStmt node represents a declaration in a statement list."
      },
      {
        "name": "DeferStmt",
        "desc": "A DeferStmt node represents a defer statement."
      },
      {
        "name": "Ellipsis",
        "desc": "An Ellipsis node stands for the \"...\" type in a parameter list or the \"...\" length in an array type."
      },
      {
        "name": "EmptyStmt",
        "desc": "An EmptyStmt node represents an empty statement. The \"position\" of the empty statement is the position of the immediately following (explicit or implicit) semicolon."
      },
      {
        "name": "Expr",
        "desc": "All expression nodes implement the Expr interface."
      },
      {
        "name": "ExprStmt",
        "desc": "An ExprStmt node represents a (stand-alone) expression in a statement list."
      },
      {
        "name": "Field",
        "desc": "A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. [Field.Names] is nil for unnamed parameters (parameter lists which only contain types) and embedded struct fields. In the latter case, the field name is the type name."
      },
      {
        "name": "FieldFilter",
        "desc": "A FieldFilter may be provided to [Fprint] to control the output."
      },
      {
        "name": "FieldList",
        "desc": "A FieldList represents a list of Fields, enclosed by parentheses, curly braces, or square brackets."
      },
      {
        "name": "File",
        "desc": "A File node represents a Go source file.  The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields.  For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the [File.Comments] list) or moved accordingly (by updating their positions). A [CommentMap] may be used to facilitate some of these operations.  Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: except for Doc and [Comment] comments directly associated with nodes, the remaining comments are \"free-floating\" (see also issues [#18593], [#20744]).  [#18593]: https://go.dev/issue/18593 [#20744]: https://go.dev/issue/20744"
      },
      {
        "name": "Filter",
        "desc": ""
      },
      {
        "name": "ForStmt",
        "desc": "A ForStmt represents a for statement."
      },
      {
        "name": "FuncDecl",
        "desc": "A FuncDecl node represents a function declaration."
      },
      {
        "name": "FuncLit",
        "desc": "A FuncLit node represents a function literal."
      },
      {
        "name": "FuncType",
        "desc": "A FuncType node represents a function type."
      },
      {
        "name": "GenDecl",
        "desc": "A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration.  Relationship between Tok value and Specs element type:  \ttoken.IMPORT  *ImportSpec \ttoken.CONST   *ValueSpec \ttoken.TYPE    *TypeSpec \ttoken.VAR     *ValueSpec"
      },
      {
        "name": "GoStmt",
        "desc": "A GoStmt node represents a go statement."
      },
      {
        "name": "Ident",
        "desc": "An Ident node represents an identifier."
      },
      {
        "name": "IfStmt",
        "desc": "An IfStmt node represents an if statement."
      },
      {
        "name": "ImportSpec",
        "desc": "An ImportSpec node represents a single package import."
      },
      {
        "name": "Importer",
        "desc": "An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new *[Object] (pkg), record pkg in the imports map, and then return pkg.  Deprecated: use the type checker [go/types] instead; see [Object]."
      },
      {
        "name": "IncDecStmt",
        "desc": "An IncDecStmt node represents an increment or decrement statement."
      },
      {
        "name": "IndexExpr",
        "desc": "An IndexExpr node represents an expression followed by an index."
      },
      {
        "name": "IndexListExpr",
        "desc": "An IndexListExpr node represents an expression followed by multiple indices."
      },
      {
        "name": "InterfaceType",
        "desc": "An InterfaceType node represents an interface type."
      },
      {
        "name": "KeyValueExpr",
        "desc": "A KeyValueExpr node represents (key : value) pairs in composite literals."
      },
      {
        "name": "LabeledStmt",
        "desc": "A LabeledStmt node represents a labeled statement."
      },
      {
        "name": "MapType",
        "desc": "A MapType node represents a map type."
      },
      {
        "name": "MergeMode",
        "desc": "The MergeMode flags control the behavior of [MergePackageFiles].  Deprecated: use the type checker [go/types] instead of [Package]; see [Object]."
      },
      {
        "name": "Node",
        "desc": "All node types implement the Node interface."
      },
      {
        "name": "ObjKind",
        "desc": "ObjKind describes what an [Object] represents."
      },
      {
        "name": "Object",
        "desc": "An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label.  The Data fields contains object-specific data:  \tKind    Data type         Data value \tPkg     *Scope            package scope \tCon     int               iota for the respective declaration  Deprecated: The relationship between Idents and Objects cannot be correctly computed without type information. For example, the expression T{K: 0} may denote a struct, map, slice, or array literal, depending on the type of T. If T is a struct, then K refers to a field of T, whereas for the other types it refers to a value in the environment.  New programs should set the [parser.SkipObjectResolution] parser flag to disable syntactic object resolution (which also saves CPU and memory), and instead use the type checker [go/types] if object resolution is desired. See the Defs, Uses, and Implicits fields of the [types.Info] struct for details."
      },
      {
        "name": "Package",
        "desc": "A Package node represents a set of source files collectively building a Go package.  Deprecated: use the type checker [go/types] instead; see [Object]."
      },
      {
        "name": "ParenExpr",
        "desc": "A ParenExpr node represents a parenthesized expression."
      },
      {
        "name": "RangeStmt",
        "desc": "A RangeStmt represents a for statement with a range clause."
      },
      {
        "name": "ReturnStmt",
        "desc": "A ReturnStmt node represents a return statement."
      },
      {
        "name": "Scope",
        "desc": "A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope.  Deprecated: use the type checker [go/types] instead; see [Object]."
      },
      {
        "name": "SelectStmt",
        "desc": "A SelectStmt node represents a select statement."
      },
      {
        "name": "SelectorExpr",
        "desc": "A SelectorExpr node represents an expression followed by a selector."
      },
      {
        "name": "SendStmt",
        "desc": "A SendStmt node represents a send statement."
      },
      {
        "name": "SliceExpr",
        "desc": "A SliceExpr node represents an expression followed by slice indices."
      },
      {
        "name": "Spec",
        "desc": "The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec."
      },
      {
        "name": "StarExpr",
        "desc": "A StarExpr node represents an expression of the form \"*\" Expression. Semantically it could be a unary \"*\" expression, or a pointer type."
      },
      {
        "name": "Stmt",
        "desc": "All statement nodes implement the Stmt interface."
      },
      {
        "name": "StructType",
        "desc": "A StructType node represents a struct type."
      },
      {
        "name": "SwitchStmt",
        "desc": "A SwitchStmt node represents an expression switch statement."
      },
      {
        "name": "TypeAssertExpr",
        "desc": "A TypeAssertExpr node represents an expression followed by a type assertion."
      },
      {
        "name": "TypeSpec",
        "desc": "A TypeSpec node represents a type declaration (TypeSpec production)."
      },
      {
        "name": "TypeSwitchStmt",
        "desc": "A TypeSwitchStmt node represents a type switch statement."
      },
      {
        "name": "UnaryExpr",
        "desc": "A UnaryExpr node represents a unary expression. Unary \"*\" expressions are represented via StarExpr nodes."
      },
      {
        "name": "ValueSpec",
        "desc": "A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production)."
      },
      {
        "name": "Visitor",
        "desc": "A Visitor's Visit method is invoked for each node encountered by [Walk]. If the result visitor w is not nil, [Walk] visits each of the children of node with the visitor w, followed by a call of w.Visit(nil)."
      },
      {
        "name": "cgPos",
        "desc": ""
      },
      {
        "name": "commentListReader",
        "desc": "A commentListReader helps iterating through a list of comment groups."
      },
      {
        "name": "inspector",
        "desc": ""
      },
      {
        "name": "localError",
        "desc": "localError wraps locally caught errors so we can distinguish them from genuine panics which we don't want to return as errors."
      },
      {
        "name": "nodeStack",
        "desc": "A nodeStack keeps track of nested nodes. A node lower on the stack lexically contains the nodes higher on the stack."
      },
      {
        "name": "pkgBuilder",
        "desc": ""
      },
      {
        "name": "posSpan",
        "desc": ""
      },
      {
        "name": "printer",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/build",
    "desc": "Package build gathers information about Go packages.  # Build Constraints  A build constraint, also known as a build tag, is a condition under which a file should be included in the package. Build constraints are given by a line comment that begins  \t//go:build  Build constraints may also be part of a file's name (for example, source_windows.go will only be included if the target operating system is windows).  See 'go help buildconstraint' (https://pkg.go.dev/cmd/go#hdr-Build_constraints) for details.  # Go Path  The Go path is a list of directory trees containing Go source code. It is consulted to resolve imports that cannot be found in the standard Go tree. The default path is the value of the GOPATH environment variable, interpreted as a path list appropriate to the operating system (on Unix, the variable is a colon-separated string; on Windows, a semicolon-separated string; on Plan 9, a list).  Each directory listed in the Go path must have a prescribed structure:  The src/ directory holds source code. The path below 'src' determines the import path or executable name.  The pkg/ directory holds installed package objects. As in the Go tree, each target operating system and architecture pair has its own subdirectory of pkg (pkg/GOOS_GOARCH).  If DIR is a directory listed in the Go path, a package with source in DIR/src/foo/bar can be imported as \"foo/bar\" and has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\" (or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").  The bin/ directory holds compiled commands. Each command is named for its source directory, but only using the final element, not the entire path. That is, the command with source in DIR/src/foo/quux is installed into DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your PATH to get at the installed commands.  Here's an example directory layout:  \tGOPATH=/home/user/gocode  \t/home/user/gocode/ \t    src/ \t        foo/ \t            bar/               (go code in package bar) \t                x.go \t            quux/              (go code in package main) \t                y.go \t    bin/ \t        quux                   (installed command) \t    pkg/ \t        linux_amd64/ \t            foo/ \t                bar.a          (installed package object)  # Binary-Only Packages  In Go 1.12 and earlier, it was possible to distribute packages in binary form without including the source code used for compiling the package. The package was distributed with a source file not excluded by build constraints and containing a \"//go:binary-only-package\" comment. Like a build constraint, this comment appeared at the top of a file, preceded only by blank lines and other line comments and with a blank line following the comment, to separate it from the package documentation. Unlike build constraints, this comment is only recognized in non-test Go source files.  The minimal source code for a binary-only package was therefore:  \t//go:binary-only-package  \tpackage mypkg  The source code could include additional Go code. That code was never compiled but would be processed by tools like godoc and might be useful as end-user documentation.  \"go build\" and other commands no longer support binary-only-packages. [Import] and [ImportDir] will still set the BinaryOnly flag in packages containing these comments for use in tools and error messages.",
    "functions": [
      {
        "name": "ArchChar",
        "desc": "ArchChar returns \"?\" and an error. In earlier versions of Go, the returned string was used to derive the compiler and linker tool names, the default object file suffix, and the default linker output name. As of Go 1.5, those strings no longer vary by architecture; they are compile, link, .o, and a.out, respectively."
      },
      {
        "name": "BenchmarkImportVendor",
        "desc": ""
      },
      {
        "name": "IsLocalImport",
        "desc": "IsLocalImport reports whether the import path is a local import path, like \".\", \"..\", \"./foo\", or \"../foo\"."
      },
      {
        "name": "TestAllTags",
        "desc": "Issue #52053. Check that if there is a file x_GOOS_GOARCH.go that both GOOS and GOARCH show up in the Package.AllTags field. We test both the case where the file matches and where the file does not match. The latter case used to fail, incorrectly omitting GOOS."
      },
      {
        "name": "TestAllTagsNonSourceFile",
        "desc": ""
      },
      {
        "name": "TestCgoImportsIgnored",
        "desc": "TestCgoImportsIgnored checks that imports in cgo files are not included in the imports list when cgo is disabled. Verifies golang.org/issue/35946."
      },
      {
        "name": "TestDependencies",
        "desc": ""
      },
      {
        "name": "TestDirectives",
        "desc": ""
      },
      {
        "name": "TestDotSlashImport",
        "desc": ""
      },
      {
        "name": "TestEmptyFolderImport",
        "desc": ""
      },
      {
        "name": "TestEmptyImport",
        "desc": ""
      },
      {
        "name": "TestExpandSrcDir",
        "desc": ""
      },
      {
        "name": "TestFindImports",
        "desc": "TestFindImports tests that findImports works.  See #43249."
      },
      {
        "name": "TestGoodOSArch",
        "desc": ""
      },
      {
        "name": "TestGoodOSArchFile",
        "desc": ""
      },
      {
        "name": "TestImportCmd",
        "desc": ""
      },
      {
        "name": "TestImportDirNotExist",
        "desc": "Want to get a \"cannot find package\" error when directory for package does not exist. There should be valid partial information in the returned non-nil *Package."
      },
      {
        "name": "TestImportPackageOutsideModule",
        "desc": "Check that a package is loaded in module mode if GO111MODULE=on, even when no go.mod file is present. It should fail to resolve packages outside std. Verifies golang.org/issue/34669."
      },
      {
        "name": "TestImportVendor",
        "desc": ""
      },
      {
        "name": "TestImportVendorFailure",
        "desc": ""
      },
      {
        "name": "TestImportVendorParentFailure",
        "desc": ""
      },
      {
        "name": "TestIsAllowed",
        "desc": ""
      },
      {
        "name": "TestIssue23594",
        "desc": "TestIssue23594 prevents go/build from regressing and populating Package.Doc from comments in test files."
      },
      {
        "name": "TestIssue56509",
        "desc": "TestIssue56509 tests that go/build does not add non-go files to InvalidGoFiles when they have unparsable comments."
      },
      {
        "name": "TestLocalDirectory",
        "desc": ""
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "TestMatch",
        "desc": ""
      },
      {
        "name": "TestMatchFile",
        "desc": ""
      },
      {
        "name": "TestMissingImportErrorRepetition",
        "desc": "TestMissingImportErrorRepetition checks that when an unknown package is imported, the package path is only shown once in the error. Verifies golang.org/issue/34752."
      },
      {
        "name": "TestMultiplePackageImport",
        "desc": ""
      },
      {
        "name": "TestReadComments",
        "desc": ""
      },
      {
        "name": "TestReadEmbed",
        "desc": ""
      },
      {
        "name": "TestReadFailuresIgnored",
        "desc": ""
      },
      {
        "name": "TestReadGoInfo",
        "desc": ""
      },
      {
        "name": "TestShellSafety",
        "desc": ""
      },
      {
        "name": "TestShouldBuild",
        "desc": ""
      },
      {
        "name": "TestStdlibLowercase",
        "desc": "TestStdlibLowercase tests that all standard library package names are lowercase. See Issue 40065."
      },
      {
        "name": "TestVendorPackages",
        "desc": "Verify that the vendor directories contain only packages matching the list above."
      },
      {
        "name": "anotherArch",
        "desc": ""
      },
      {
        "name": "anotherOS",
        "desc": ""
      },
      {
        "name": "cleanDecls",
        "desc": ""
      },
      {
        "name": "defaultGOPATH",
        "desc": "Keep consistent with cmd/go/internal/cfg.defaultGOPATH."
      },
      {
        "name": "depsPolicy",
        "desc": "depsPolicy returns a map m such that m[p][d] == true when p can import d."
      },
      {
        "name": "envOr",
        "desc": ""
      },
      {
        "name": "equal",
        "desc": ""
      },
      {
        "name": "expandSrcDir",
        "desc": "expandSrcDir expands any occurrence of ${SRCDIR}, making sure the result is safe for the shell."
      },
      {
        "name": "fileListForExt",
        "desc": ""
      },
      {
        "name": "findImportComment",
        "desc": ""
      },
      {
        "name": "findImports",
        "desc": ""
      },
      {
        "name": "getToolDir",
        "desc": "getToolDir returns the default value of ToolDir."
      },
      {
        "name": "hasGoFiles",
        "desc": "hasGoFiles reports whether dir contains any files with names ending in .go. For a vendor check we must exclude directories that contain no .go files. Otherwise it is not possible to vendor just a/b/c and still import the non-vendored a/b. See golang.org/issue/13832."
      },
      {
        "name": "hasSubdir",
        "desc": "hasSubdir reports if dir is within root by performing lexical analysis only."
      },
      {
        "name": "isAllowed",
        "desc": ""
      },
      {
        "name": "isGoBuildComment",
        "desc": ""
      },
      {
        "name": "isIdent",
        "desc": ""
      },
      {
        "name": "isValidImport",
        "desc": "isValidImport checks if the import is a valid import using the more strict checks allowed by the implementation restriction in https://go.dev/ref/spec#Import_declarations. It was ported from the function of the same name that was removed from the parser in CL 424855, when the parser stopped doing these checks."
      },
      {
        "name": "listStdPkgs",
        "desc": "listStdPkgs returns the same list of packages as \"go list std\"."
      },
      {
        "name": "nameExt",
        "desc": ""
      },
      {
        "name": "parseFileHeader",
        "desc": "parseFileHeader should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bazelbuild/bazel-gazelle  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "parseWord",
        "desc": "parseWord skips any leading spaces or comments in data and then parses the beginning of data as an identifier or keyword, returning that word and what remains after the word."
      },
      {
        "name": "readComments",
        "desc": "readComments is like io.ReadAll, except that it only reads the leading block of comments in the file.  readComments should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bazelbuild/bazel-gazelle  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "readGoInfo",
        "desc": "readGoInfo expects a Go file as input and reads the file up to and including the import section. It records what it learned in *info. If info.fset is non-nil, readGoInfo parses the file and sets info.parsed, info.parseErr, info.imports and info.embeds.  It only returns an error if there are problems reading the file, not for syntax errors in the file itself."
      },
      {
        "name": "safeCgoName",
        "desc": ""
      },
      {
        "name": "skipSpaceOrComment",
        "desc": "skipSpaceOrComment returns data with any leading spaces or comments removed."
      },
      {
        "name": "splitQuoted",
        "desc": "splitQuoted splits the string s around each instance of one or more consecutive white space characters while taking into account quotes and escaping, and returns an array of substrings of s or an empty list if s contains only white space. Single quotes and double quotes are recognized to prevent splitting within the quoted region, and are removed from the resulting substrings. If a quote in s isn't closed err will be set and r will have the unclosed argument as the last element. The backslash is used for escaping.  For example, the following string:  \ta b:\"c d\" 'e''f'  \"g\\\"\"  Would be parsed as:  \t[]string{\"a\", \"b:c d\", \"ef\", `g\"`}"
      },
      {
        "name": "testRead",
        "desc": ""
      },
      {
        "name": "uniq",
        "desc": ""
      },
      {
        "name": "Import",
        "desc": "Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.  In the directory containing the package, .go, .c, .h, and .s files are considered part of the package except for:    - .go files in package documentation   - files starting with _ or . (likely editor temporary files)   - files with build constraints not satisfied by the context  If an error occurs, Import returns a non-nil error and a non-nil *[Package] containing partial information."
      },
      {
        "name": "ImportDir",
        "desc": "ImportDir is like [Import] but processes the Go package found in the named directory."
      },
      {
        "name": "MatchFile",
        "desc": "MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a [Package] created by [ImportDir] of that directory.  MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content."
      },
      {
        "name": "SrcDirs",
        "desc": "SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist."
      },
      {
        "name": "eval",
        "desc": ""
      },
      {
        "name": "goodOSArchFile",
        "desc": "goodOSArchFile returns false if the name contains a $GOOS or $GOARCH suffix which does not match the current system. The recognized name formats are:  \tname_$(GOOS).* \tname_$(GOARCH).* \tname_$(GOOS)_$(GOARCH).* \tname_$(GOOS)_test.* \tname_$(GOARCH)_test.* \tname_$(GOOS)_$(GOARCH)_test.*  Exceptions: if GOOS=android, then files with GOOS=linux are also matched. if GOOS=illumos, then files with GOOS=solaris are also matched. if GOOS=ios, then files with GOOS=darwin are also matched."
      },
      {
        "name": "gopath",
        "desc": "gopath returns the list of Go path directories."
      },
      {
        "name": "hasSubdir",
        "desc": "hasSubdir calls ctxt.HasSubdir (if not nil) or else uses the local file system to answer the question."
      },
      {
        "name": "importGo",
        "desc": "importGo checks whether it can use the go command to find the directory for path. If using the go command is not appropriate, importGo returns errNoModules. Otherwise, importGo tries using the go command and reports whether that succeeded. Using the go command lets build.Import and build.Context.Import find code in Go modules. In the long term we want tools to use go/packages (currently golang.org/x/tools/go/packages), which will also use the go command. Invoking the go command here is not very efficient in that it computes information about the requested package and all dependencies and then only reports about the requested package. Then we reinvoke it for every dependency. But this is still better than not working at all. See golang.org/issue/26504."
      },
      {
        "name": "isAbsPath",
        "desc": "isAbsPath calls ctxt.IsAbsPath (if not nil) or else filepath.IsAbs."
      },
      {
        "name": "isDir",
        "desc": "isDir calls ctxt.IsDir (if not nil) or else uses os.Stat."
      },
      {
        "name": "isFile",
        "desc": "isFile determines whether path is a file by trying to open it. It reuses openFile instead of adding another function to the list in Context."
      },
      {
        "name": "joinPath",
        "desc": "joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join."
      },
      {
        "name": "makePathsAbsolute",
        "desc": "makePathsAbsolute looks for compiler options that take paths and makes them absolute. We do this because through the 1.8 release we ran the compiler in the package directory, so any relative -I or -L options would be relative to that directory. In 1.9 we changed to running the compiler in the build directory, to get consistent build results (issue #19964). To keep builds working, we change any relative -I or -L options to be absolute.  Using filepath.IsAbs and filepath.Join here means the results will be different on different systems, but that's OK: -I and -L options are inherently system-dependent."
      },
      {
        "name": "matchAuto",
        "desc": "matchAuto interprets text as either a +build or //go:build expression (whichever works), reporting whether the expression matches the build context.  matchAuto is only used for testing of tag evaluation and in #cgo lines, which accept either syntax."
      },
      {
        "name": "matchFile",
        "desc": "matchFile determines whether the file with the given name in the given directory should be included in the package being constructed. If the file should be included, matchFile returns a non-nil *fileInfo (and a nil error). Non-nil errors are reserved for unexpected problems.  If name denotes a Go program, matchFile reads until the end of the imports and returns that section of the file in the fileInfo's header field, even though it only considers text until the first non-comment for go:build lines.  If allTags is non-nil, matchFile records any encountered build tag by setting allTags[tag] = true."
      },
      {
        "name": "matchTag",
        "desc": "matchTag reports whether the name is one of:  \tcgo (if cgo is enabled) \t$GOOS \t$GOARCH \tctxt.Compiler \tlinux (if GOOS = android) \tsolaris (if GOOS = illumos) \tdarwin (if GOOS = ios) \tunix (if this is a Unix GOOS) \tboringcrypto (if GOEXPERIMENT=boringcrypto is enabled) \ttag (if tag is listed in ctxt.BuildTags, ctxt.ToolTags, or ctxt.ReleaseTags)  It records all consulted tags in allTags."
      },
      {
        "name": "openFile",
        "desc": "openFile calls ctxt.OpenFile (if not nil) or else os.Open."
      },
      {
        "name": "readDir",
        "desc": "readDir calls ctxt.ReadDir (if not nil) or else os.ReadDir."
      },
      {
        "name": "saveCgo",
        "desc": "saveCgo saves the information from the #cgo lines in the import \"C\" comment. These lines set CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS and pkg-config directives that affect the way cgo's C code is built."
      },
      {
        "name": "shouldBuild",
        "desc": "shouldBuild reports whether it is okay to use this file, The rule is that in the file's leading run of // comments and blank lines, which must be followed by a blank line (to avoid including a Go package clause doc comment), lines beginning with '//go:build' are taken as build directives.  The file is accepted only if each such line lists something matching the file. For example:  \t//go:build windows linux  marks the file as applicable only on Windows and Linux.  For each build tag it consults, shouldBuild sets allTags[tag] = true.  shouldBuild reports whether the file should be built and whether a //go:binary-only-package comment was found."
      },
      {
        "name": "splitPathList",
        "desc": "splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "IsCommand",
        "desc": "IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named \"main\" are treated as commands."
      },
      {
        "name": "findEmbed",
        "desc": "findEmbed advances the input reader to the next //go:embed comment. It reports whether it found a comment. (Otherwise it found an error or EOF.)"
      },
      {
        "name": "nextByte",
        "desc": "nextByte is like peekByte but advances beyond the returned byte."
      },
      {
        "name": "peekByte",
        "desc": "peekByte returns the next byte from the input reader but does not advance beyond it. If skipSpace is set, peekByte skips leading spaces and comments."
      },
      {
        "name": "readByte",
        "desc": "readByte reads the next byte from the input, saves it in buf, and returns it. If an error occurs, readByte records the error in r.err and returns 0."
      },
      {
        "name": "readByteNoBuf",
        "desc": "readByteNoBuf is like readByte but doesn't buffer the byte. It exhausts r.buf before reading from r.b."
      },
      {
        "name": "readIdent",
        "desc": "readIdent reads an identifier from the input. If an identifier is not present, readIdent records a syntax error."
      },
      {
        "name": "readImport",
        "desc": "readImport reads an import clause - optional identifier followed by quoted string - from the input."
      },
      {
        "name": "readKeyword",
        "desc": "readKeyword reads the given keyword from the input. If the keyword is not present, readKeyword records a syntax error."
      },
      {
        "name": "readString",
        "desc": "readString reads a quoted string literal from the input. If an identifier is not present, readString records a syntax error."
      },
      {
        "name": "syntaxError",
        "desc": "syntaxError records a syntax error, but only if an I/O error has not already been recorded."
      },
      {
        "name": "Close",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Context",
        "desc": "A Context specifies the supporting context for a build."
      },
      {
        "name": "Directive",
        "desc": "A Directive is a Go directive comment (//go:zzz...) found in a source file."
      },
      {
        "name": "GoodFileTest",
        "desc": ""
      },
      {
        "name": "ImportMode",
        "desc": "An ImportMode controls the behavior of the Import method."
      },
      {
        "name": "MultiplePackageError",
        "desc": "MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages."
      },
      {
        "name": "NoGoError",
        "desc": "NoGoError is the error used by [Import] to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)"
      },
      {
        "name": "Package",
        "desc": "A Package describes the Go package found in a directory."
      },
      {
        "name": "fileEmbed",
        "desc": ""
      },
      {
        "name": "fileImport",
        "desc": ""
      },
      {
        "name": "fileInfo",
        "desc": "fileInfo records information learned about a file included in a build."
      },
      {
        "name": "importReader",
        "desc": ""
      },
      {
        "name": "readNopCloser",
        "desc": ""
      },
      {
        "name": "readTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/build/constraint",
    "desc": "Package constraint implements parsing and evaluation of build constraint lines. See https://golang.org/cmd/go/#hdr-Build_constraints for documentation about build constraints themselves.  This package parses both the original “// +build” syntax and the “//go:build” syntax that was added in Go 1.17. See https://golang.org/design/draft-gobuild for details about the “//go:build” syntax.",
    "functions": [
      {
        "name": "GoVersion",
        "desc": "GoVersion returns the minimum Go version implied by a given build expression. If the expression can be satisfied without any Go version tags, GoVersion returns an empty string.  For example:  \tGoVersion(linux \u0026\u0026 go1.22) = \"go1.22\" \tGoVersion((linux \u0026\u0026 go1.22) || (windows \u0026\u0026 go1.20)) = \"go1.20\" =\u003e go1.20 \tGoVersion(linux) = \"\" \tGoVersion(linux || (windows \u0026\u0026 go1.22)) = \"\" \tGoVersion(!go1.22) = \"\"  GoVersion assumes that any tag or negated tag may independently be true, so that its analysis can be purely structural, without SAT solving. “Impossible” subexpressions may therefore affect the result.  For example:  \tGoVersion((linux \u0026\u0026 !linux \u0026\u0026 go1.20) || go1.21) = \"go1.20\""
      },
      {
        "name": "IsGoBuild",
        "desc": "IsGoBuild reports whether the line of text is a “//go:build” constraint. It only checks the prefix of the text, not that the expression itself parses."
      },
      {
        "name": "IsPlusBuild",
        "desc": "IsPlusBuild reports whether the line of text is a “// +build” constraint. It only checks the prefix of the text, not that the expression itself parses."
      },
      {
        "name": "PlusBuildLines",
        "desc": "PlusBuildLines returns a sequence of “// +build” lines that evaluate to the build expression x. If the expression is too complex to convert directly to “// +build” lines, PlusBuildLines returns an error."
      },
      {
        "name": "TestExprEval",
        "desc": ""
      },
      {
        "name": "TestExprString",
        "desc": ""
      },
      {
        "name": "TestGoVersion",
        "desc": ""
      },
      {
        "name": "TestLex",
        "desc": ""
      },
      {
        "name": "TestParse",
        "desc": ""
      },
      {
        "name": "TestParseError",
        "desc": ""
      },
      {
        "name": "TestParseExpr",
        "desc": ""
      },
      {
        "name": "TestParsePlusBuildExpr",
        "desc": ""
      },
      {
        "name": "TestPlusBuildLines",
        "desc": ""
      },
      {
        "name": "TestPlusSizeLimits",
        "desc": ""
      },
      {
        "name": "TestSizeLimits",
        "desc": ""
      },
      {
        "name": "andArg",
        "desc": ""
      },
      {
        "name": "andVersion",
        "desc": "andVersion returns the minimum Go version implied by the AND of two minimum Go versions, which is the max of the versions."
      },
      {
        "name": "isValidTag",
        "desc": "isValidTag reports whether the word is a valid build tag. Tags must be letters, digits, underscores or dots. Unlike in Go identifiers, all digits are fine (e.g., \"386\")."
      },
      {
        "name": "lexHelp",
        "desc": ""
      },
      {
        "name": "minVersion",
        "desc": "minVersion returns the minimum Go major version (9 for go1.9) implied by expression z, or if sign \u003c 0, by expression !z."
      },
      {
        "name": "orArg",
        "desc": ""
      },
      {
        "name": "orVersion",
        "desc": "orVersion returns the minimum Go version implied by the OR of two minimum Go versions, which is the min of the versions."
      },
      {
        "name": "splitGoBuild",
        "desc": "splitGoBuild splits apart the leading //go:build prefix in line from the build expression itself. It returns \"\", false if the input is not a //go:build line or if the input contains multiple lines."
      },
      {
        "name": "splitPlusBuild",
        "desc": "splitPlusBuild splits apart the leading // +build prefix in line from the build expression itself. It returns \"\", false if the input is not a // +build line or if the input contains multiple lines."
      },
      {
        "name": "Eval",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isExpr",
        "desc": ""
      },
      {
        "name": "Eval",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isExpr",
        "desc": ""
      },
      {
        "name": "Eval",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isExpr",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Eval",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isExpr",
        "desc": ""
      },
      {
        "name": "and",
        "desc": "and parses a sequence of \u0026\u0026 expressions. On entry, the next input token has not yet been lexed. On exit, the next input token has been lexed and is in p.tok."
      },
      {
        "name": "atom",
        "desc": "atom parses a tag or a parenthesized expression. On entry, the next input token HAS been lexed. On exit, the next input token has been lexed and is in p.tok."
      },
      {
        "name": "lex",
        "desc": "lex finds and consumes the next token in the input stream. On return, p.tok is set to the token text, p.isTag reports whether the token was a tag, and p.pos records the byte offset of the start of the token in the input stream. If lex reaches the end of the input, p.tok is set to the empty string. For any other syntax error, lex panics with a SyntaxError."
      },
      {
        "name": "not",
        "desc": "not parses a ! expression. On entry, the next input token has not yet been lexed. On exit, the next input token has been lexed and is in p.tok."
      },
      {
        "name": "or",
        "desc": "or parses a sequence of || expressions. On entry, the next input token has not yet been lexed. On exit, the next input token has been lexed and is in p.tok."
      }
    ],
    "types": [
      {
        "name": "AndExpr",
        "desc": "An AndExpr represents the expression X \u0026\u0026 Y."
      },
      {
        "name": "Expr",
        "desc": "An Expr is a build tag constraint expression. The underlying concrete type is *[AndExpr], *[OrExpr], *[NotExpr], or *[TagExpr]."
      },
      {
        "name": "NotExpr",
        "desc": "A NotExpr represents the expression !X (the negation of X)."
      },
      {
        "name": "OrExpr",
        "desc": "An OrExpr represents the expression X || Y."
      },
      {
        "name": "SyntaxError",
        "desc": "A SyntaxError reports a syntax error in a parsed build expression."
      },
      {
        "name": "TagExpr",
        "desc": "A TagExpr is an [Expr] for the single tag Tag."
      },
      {
        "name": "exprParser",
        "desc": "An exprParser holds state for parsing a build expression."
      }
    ]
  },
  {
    "name": "go/constant",
    "desc": "Package constant implements Values representing untyped Go constants and their corresponding operations.  A special Unknown value may be used when a value is unknown due to an error. Operations on unknown values produce unknown values unless specified otherwise.",
    "functions": [
      {
        "name": "BenchmarkStringAdd",
        "desc": ""
      },
      {
        "name": "BitLen",
        "desc": "BitLen returns the number of bits required to represent the absolute value x in binary representation; x must be an [Int] or an [Unknown]. If x is [Unknown], the result is 0."
      },
      {
        "name": "BoolVal",
        "desc": "BoolVal returns the Go boolean value of x, which must be a [Bool] or an [Unknown]. If x is [Unknown], the result is false."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns the bytes for the absolute value of x in little- endian binary representation; x must be an [Int]."
      },
      {
        "name": "Compare",
        "desc": "Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is [Unknown], the result is false."
      },
      {
        "name": "Float32Val",
        "desc": "Float32Val is like [Float64Val] but for float32 instead of float64."
      },
      {
        "name": "Float64Val",
        "desc": "Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an [Unknown], but not [Complex]. For values too small (too close to 0) to represent as float64, [Float64Val] silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is [Unknown], the result is (0, false)."
      },
      {
        "name": "Int64Val",
        "desc": "Int64Val returns the Go int64 value of x and whether the result is exact; x must be an [Int] or an [Unknown]. If the result is not exact, its value is undefined. If x is [Unknown], the result is (0, false)."
      },
      {
        "name": "Sign",
        "desc": "Sign returns -1, 0, or 1 depending on whether x \u003c 0, x == 0, or x \u003e 0; x must be numeric or [Unknown]. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is [Unknown], the result is 1."
      },
      {
        "name": "StringVal",
        "desc": "StringVal returns the Go string value of x, which must be a [String] or an [Unknown]. If x is [Unknown], the result is \"\"."
      },
      {
        "name": "TestBitLen",
        "desc": ""
      },
      {
        "name": "TestBytes",
        "desc": ""
      },
      {
        "name": "TestFractions",
        "desc": ""
      },
      {
        "name": "TestMake",
        "desc": ""
      },
      {
        "name": "TestMakeFloat64",
        "desc": ""
      },
      {
        "name": "TestNumbers",
        "desc": "TestNumbers verifies that differently written literals representing the same number do have the same value."
      },
      {
        "name": "TestOps",
        "desc": ""
      },
      {
        "name": "TestString",
        "desc": ""
      },
      {
        "name": "TestUnknown",
        "desc": ""
      },
      {
        "name": "Uint64Val",
        "desc": "Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an [Int] or an [Unknown]. If the result is not exact, its value is undefined. If x is [Unknown], the result is (0, false)."
      },
      {
        "name": "Val",
        "desc": "Val returns the underlying value for a given constant. Since it returns an interface, it is up to the caller to type assert the result to the expected type. The possible dynamic return types are:  \tx Kind             type of result \t----------------------------------------- \tBool               bool \tString             string \tInt                int64 or *big.Int \tFloat              *big.Float or *big.Rat \teverything else    nil"
      },
      {
        "name": "_",
        "desc": ""
      },
      {
        "name": "cmpZero",
        "desc": ""
      },
      {
        "name": "eql",
        "desc": ""
      },
      {
        "name": "is32bit",
        "desc": "is32bit reports whether x can be represented using 32 bits."
      },
      {
        "name": "is63bit",
        "desc": "is63bit reports whether x can be represented using 63 bits."
      },
      {
        "name": "newFloat",
        "desc": ""
      },
      {
        "name": "newInt",
        "desc": ""
      },
      {
        "name": "newRat",
        "desc": ""
      },
      {
        "name": "ord",
        "desc": ""
      },
      {
        "name": "panicHandler",
        "desc": ""
      },
      {
        "name": "reverse",
        "desc": "reverse reverses x in place and returns it."
      },
      {
        "name": "smallFloat",
        "desc": "smallFloat reports whether x would lead to \"reasonably\"-sized fraction if converted to a *big.Rat."
      },
      {
        "name": "smallFloat64",
        "desc": "smallFloat64 reports whether x would lead to \"reasonably\"-sized fraction if converted to a *big.Rat."
      },
      {
        "name": "smallInt",
        "desc": "smallInt reports whether x would lead to \"reasonably\"-sized fraction if converted to a *big.Rat."
      },
      {
        "name": "testNumbers",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String returns a decimal approximation of the Float value."
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String returns a possibly shortened quoted form of the String value."
      },
      {
        "name": "appendReverse",
        "desc": "appendReverse appends to list all of x's subpieces, but in reverse, and returns the result. Appending the reversal allows processing the right side in a recursive call and the left side in a loop. Because a chain like a + b + c + d + e is actually represented as ((((a + b) + c) + d) + e), the left-side loop avoids deep recursion. x must be locked."
      },
      {
        "name": "implementsValue",
        "desc": ""
      },
      {
        "name": "string",
        "desc": "string constructs and returns the actual string literal value. If x represents an addition, then it rewrites x to be a single string, to speed future calls. This lazy construction avoids building different string values for all subpieces of a large concatenation. See golang.org/issue/23348."
      },
      {
        "name": "ExactString",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "implementsValue",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Kind",
        "desc": "Kind specifies the kind of value represented by a [Value]."
      },
      {
        "name": "Value",
        "desc": "A Value represents the value of a Go constant."
      },
      {
        "name": "boolVal",
        "desc": ""
      },
      {
        "name": "complexVal",
        "desc": ""
      },
      {
        "name": "floatVal",
        "desc": ""
      },
      {
        "name": "int64Val",
        "desc": ""
      },
      {
        "name": "intVal",
        "desc": ""
      },
      {
        "name": "makeTestCase",
        "desc": ""
      },
      {
        "name": "ratVal",
        "desc": ""
      },
      {
        "name": "stringVal",
        "desc": ""
      },
      {
        "name": "unknownVal",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/doc",
    "desc": "Package doc extracts source code documentation from a Go AST.",
    "functions": [
      {
        "name": "IsPredeclared",
        "desc": "IsPredeclared reports whether s is a predeclared identifier."
      },
      {
        "name": "Synopsis",
        "desc": "Synopsis returns a cleaned version of the first sentence in text.  Deprecated: New programs should use [Package.Synopsis] instead, which handles links in text properly."
      },
      {
        "name": "Test",
        "desc": ""
      },
      {
        "name": "TestComment",
        "desc": ""
      },
      {
        "name": "TestFuncs",
        "desc": ""
      },
      {
        "name": "TestImportGroupStarts",
        "desc": ""
      },
      {
        "name": "TestSynopsis",
        "desc": ""
      },
      {
        "name": "ToHTML",
        "desc": "ToHTML converts comment text to formatted HTML.  Deprecated: ToHTML cannot identify documentation links in the doc comment, because they depend on knowing what package the text came from, which is not included in this API.  Given the *[doc.Package] p where text was found, ToHTML(w, text, nil) can be replaced by:  \tw.Write(p.HTML(text))  which is in turn shorthand for:  \tw.Write(p.Printer().HTML(p.Parser().Parse(text)))  If words may be non-nil, the longer replacement is:  \tparser := p.Parser() \tparser.Words = words \tw.Write(p.Printer().HTML(parser.Parse(d)))"
      },
      {
        "name": "ToText",
        "desc": "ToText converts comment text to formatted text.  Deprecated: ToText cannot identify documentation links in the doc comment, because they depend on knowing what package the text came from, which is not included in this API.  Given the *[doc.Package] p where text was found, ToText(w, text, \"\", \"\\t\", 80) can be replaced by:  \tw.Write(p.Text(text))  In the general case, ToText(w, text, prefix, codePrefix, width) can be replaced by:  \td := p.Parser().Parse(text) \tpr := p.Printer() \tpr.TextPrefix = prefix \tpr.TextCodePrefix = codePrefix \tpr.TextWidth = width \tw.Write(pr.Text(d))  See the documentation for [Package.Text] and [comment.Printer.Text] for more details."
      },
      {
        "name": "assumedPackageName",
        "desc": "assumedPackageName returns the assumed package name for a given import path. This is a copy of golang.org/x/tools/internal/imports.ImportPathToAssumedName."
      },
      {
        "name": "baseTypeName",
        "desc": "baseTypeName returns the name of the base type of x (or \"\") and whether the type is imported or not."
      },
      {
        "name": "classifyExamples",
        "desc": "classifyExamples classifies examples and assigns them to the Examples field of the relevant Func, Type, or Package that the example is associated with.  The classification process is ambiguous in some cases:    - ExampleFoo_Bar matches a type named Foo_Bar     or a method named Foo.Bar.   - ExampleFoo_bar matches a type named Foo_bar     or Foo (with a \"bar\" suffix).  Examples with malformed names are not associated with anything."
      },
      {
        "name": "clean",
        "desc": "clean replaces each sequence of space, \\r, or \\t characters with a single space and removes any trailing and leading spaces."
      },
      {
        "name": "compareSlices",
        "desc": ""
      },
      {
        "name": "copyConstType",
        "desc": "copyConstType returns a copy of typ with position pos. typ must be a valid constant type. In practice, only (possibly qualified) identifiers are possible."
      },
      {
        "name": "exampleOutput",
        "desc": "Extracts the expected output and whether there was a valid output comment."
      },
      {
        "name": "fields",
        "desc": "fields returns a struct's fields or an interface's methods."
      },
      {
        "name": "filterCompositeLit",
        "desc": ""
      },
      {
        "name": "filterExprList",
        "desc": ""
      },
      {
        "name": "filterIdentList",
        "desc": "filterIdentList removes unexported names from list in place and returns the resulting list."
      },
      {
        "name": "findDeclsAndUnresolved",
        "desc": "findDeclsAndUnresolved returns all the top-level declarations mentioned in the body, and a set of unresolved symbols (those that appear in the body but have no declaration in the program).  topDecls maps objects to the top-level declaration declaring them (not necessarily obj.Decl, as obj.Decl will be a Spec for GenDecls, but topDecls[obj] will be the GenDecl itself)."
      },
      {
        "name": "findImportGroupStarts",
        "desc": "findImportGroupStarts finds the start positions of each sequence of import specs that are not separated by a blank line."
      },
      {
        "name": "findImportGroupStarts1",
        "desc": "Helper for findImportGroupStarts to ease testing."
      },
      {
        "name": "firstSentence",
        "desc": "firstSentence returns the first sentence in s. The sentence ends after the first period followed by space and not preceded by exactly one uppercase letter."
      },
      {
        "name": "hasExportedName",
        "desc": "hasExportedName reports whether list contains any exported names."
      },
      {
        "name": "hasIota",
        "desc": ""
      },
      {
        "name": "indentFmt",
        "desc": ""
      },
      {
        "name": "isExampleSuffix",
        "desc": ""
      },
      {
        "name": "isGoFile",
        "desc": ""
      },
      {
        "name": "isTest",
        "desc": "isTest tells whether name looks like a test, example, fuzz test, or benchmark. It is a Test (say) if there is a character after Test that is not a lower-case letter. (We don't want Testiness.)"
      },
      {
        "name": "lastComment",
        "desc": "lastComment returns the last comment inside the provided block."
      },
      {
        "name": "lookupTypeParam",
        "desc": "lookupTypeParam searches for type parameters named name within the tparams field list, returning the relevant identifier if found, or nil if not."
      },
      {
        "name": "matchDecl",
        "desc": ""
      },
      {
        "name": "matchFields",
        "desc": ""
      },
      {
        "name": "nameWithoutInst",
        "desc": "nameWithoutInst returns name if name has no brackets. If name contains brackets, then it returns name with all the contents between (and including) the outermost left and right bracket removed.  Adapted from debug/gosym/symtab.go:Sym.nameWithoutInst."
      },
      {
        "name": "nodeFmt",
        "desc": ""
      },
      {
        "name": "noteBodies",
        "desc": "noteBodies returns a list of note body strings given a list of notes. This is only used to populate the deprecated Package.Bugs field."
      },
      {
        "name": "playExample",
        "desc": "playExample synthesizes a new *ast.File based on the provided file with the provided function body as the body of main."
      },
      {
        "name": "playExampleFile",
        "desc": "playExampleFile takes a whole file example and synthesizes a new *ast.File such that the example is function main in package main."
      },
      {
        "name": "readTemplate",
        "desc": ""
      },
      {
        "name": "recvParam",
        "desc": ""
      },
      {
        "name": "recvString",
        "desc": "recvString returns a string representation of recv of the form \"T\", \"*T\", \"T[A, ...]\", \"*T[A, ...]\" or \"BADRECV\" (if not a proper receiver type)."
      },
      {
        "name": "removeAnonymousField",
        "desc": "removeAnonymousField removes anonymous fields named name from an interface."
      },
      {
        "name": "removeStar",
        "desc": ""
      },
      {
        "name": "sortedKeys",
        "desc": ""
      },
      {
        "name": "sortingName",
        "desc": "sortingName returns the name to use when sorting d into place."
      },
      {
        "name": "specNames",
        "desc": ""
      },
      {
        "name": "splitExampleName",
        "desc": "splitExampleName attempts to split example name s at index i, and reports if that produces a valid split. The suffix may be absent. Otherwise, it must start with a lower-case letter and be preceded by '_'.  One of i == len(s) or s[i] == '_' must be true."
      },
      {
        "name": "stripOutputComment",
        "desc": "stripOutputComment finds and removes the \"Output:\" or \"Unordered output:\" comment from body and comments, and adjusts the body block's end position."
      },
      {
        "name": "synopsisFmt",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "updateIdentList",
        "desc": "updateIdentList replaces all unexported identifiers with underscore and reports whether at least one exported name exists."
      },
      {
        "name": "Filter",
        "desc": "Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize \"Type.Method\" as a name."
      },
      {
        "name": "HTML",
        "desc": "HTML returns formatted HTML for the doc comment text.  To customize details of the HTML, use [Package.Printer] to obtain a [comment.Printer], and configure it before calling its HTML method."
      },
      {
        "name": "Markdown",
        "desc": "Markdown returns formatted Markdown for the doc comment text.  To customize details of the Markdown, use [Package.Printer] to obtain a [comment.Printer], and configure it before calling its Markdown method."
      },
      {
        "name": "Parser",
        "desc": "Parser returns a doc comment parser configured for parsing doc comments from package p. Each call returns a new parser, so that the caller may customize it before use."
      },
      {
        "name": "Printer",
        "desc": "Printer returns a doc comment printer configured for printing doc comments from package p. Each call returns a new printer, so that the caller may customize it before use."
      },
      {
        "name": "Synopsis",
        "desc": "Synopsis returns a cleaned version of the first sentence in text. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter, or at the first paragraph break. The result string has no \\n, \\r, or \\t characters and uses only single spaces between words. If text starts with any of the [IllegalPrefixes], the result is the empty string."
      },
      {
        "name": "Text",
        "desc": "Text returns formatted text for the doc comment text, wrapped to 80 Unicode code points and using tabs for code block indentation.  To customize details of the formatting, use [Package.Printer] to obtain a [comment.Printer], and configure it before calling its Text method."
      },
      {
        "name": "collectFuncs",
        "desc": ""
      },
      {
        "name": "collectTypes",
        "desc": ""
      },
      {
        "name": "collectValues",
        "desc": ""
      },
      {
        "name": "lookupPackage",
        "desc": "lookupPackage returns the import path identified by name in the given package. If name uniquely identifies a single import, then lookupPackage returns that import. If multiple packages are imported as name, importPath returns \"\", false. Otherwise, if name is the name of p itself, importPath returns \"\", true, to signal a reference to p. Otherwise, importPath returns \"\", false."
      },
      {
        "name": "lookupSym",
        "desc": "lookupSym reports whether the package has a given symbol or method.  If recv == \"\", HasSym reports whether the package has a top-level const, func, type, or var named name.  If recv != \"\", HasSym reports whether the package has a type named recv with a method named name."
      },
      {
        "name": "add",
        "desc": "add adds method m to the method set; m is ignored if the method set already contains a method with the same name at the same or a higher level than m."
      },
      {
        "name": "set",
        "desc": "set creates the corresponding Func for f and adds it to mset. If there are multiple f's with the same name, set keeps the first one with documentation; conflicts are ignored. The boolean specifies whether to leave the AST untouched."
      },
      {
        "name": "cleanupTypes",
        "desc": "cleanupTypes removes the association of functions and methods with types that have no declaration. Instead, these functions and methods are shown at the package level. It also removes types with missing declarations or which are not visible."
      },
      {
        "name": "collectEmbeddedMethods",
        "desc": "collectEmbeddedMethods collects the embedded methods of typ in mset."
      },
      {
        "name": "computeMethodSets",
        "desc": "computeMethodSets determines the actual method sets for each type encountered."
      },
      {
        "name": "fileExports",
        "desc": "fileExports removes unexported declarations from src in place."
      },
      {
        "name": "filterDecl",
        "desc": ""
      },
      {
        "name": "filterFieldList",
        "desc": "filterFieldList removes unexported fields (field names) from the field list in place and reports whether fields were removed. Anonymous fields are recorded with the parent type. filterType is called with the types of all remaining fields."
      },
      {
        "name": "filterParamList",
        "desc": "filterParamList applies filterType to each parameter type in fields."
      },
      {
        "name": "filterSpec",
        "desc": ""
      },
      {
        "name": "filterSpecList",
        "desc": ""
      },
      {
        "name": "filterType",
        "desc": "filterType strips any unexported struct fields or method types from typ in place. If fields (or methods) have been removed, the corresponding struct or interface type has the Incomplete field set to true."
      },
      {
        "name": "isPredeclared",
        "desc": "isPredeclared reports whether n denotes a predeclared type."
      },
      {
        "name": "isVisible",
        "desc": ""
      },
      {
        "name": "lookupType",
        "desc": "lookupType returns the base type with the given name. If the base type has not been encountered yet, a new type with the given name but no associated declaration is added to the type map."
      },
      {
        "name": "readDoc",
        "desc": ""
      },
      {
        "name": "readFile",
        "desc": "readFile adds the AST for a source file to the reader."
      },
      {
        "name": "readFunc",
        "desc": "readFunc processes a func or method declaration."
      },
      {
        "name": "readNote",
        "desc": "readNote collects a single note from a sequence of comments."
      },
      {
        "name": "readNotes",
        "desc": "readNotes extracts notes from comments. A note must start at the beginning of a comment with \"MARKER(uid):\" and is followed by the note body (e.g., \"// BUG(gri): fix this\"). The note ends at the end of the comment group or at the start of another note in the same comment group, whichever comes first."
      },
      {
        "name": "readPackage",
        "desc": ""
      },
      {
        "name": "readType",
        "desc": "readType processes a type declaration."
      },
      {
        "name": "readValue",
        "desc": "readValue processes a const or var declaration."
      },
      {
        "name": "recordAnonymousField",
        "desc": "recordAnonymousField registers fieldType as the type of an anonymous field in the parent type. If the field is imported (qualified name) or the parent is nil, the field is ignored. The function returns the field name."
      },
      {
        "name": "remember",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Example",
        "desc": "An Example represents an example function found in a test source file."
      },
      {
        "name": "Filter",
        "desc": ""
      },
      {
        "name": "Func",
        "desc": "Func is the documentation for a func declaration."
      },
      {
        "name": "Mode",
        "desc": "Mode values control the operation of [New] and [NewFromFiles]."
      },
      {
        "name": "Note",
        "desc": "A Note represents a marked comment starting with \"MARKER(uid): note body\". Any note with a marker of 2 or more upper case [A-Z] letters and a uid of at least one character is recognized. The \":\" following the uid is optional. Notes are collected in the Package.Notes map indexed by the notes marker."
      },
      {
        "name": "Package",
        "desc": "Package is the documentation for an entire package."
      },
      {
        "name": "Type",
        "desc": "Type is the documentation for a type declaration."
      },
      {
        "name": "Value",
        "desc": "Value is the documentation for a (possibly grouped) var or const declaration."
      },
      {
        "name": "bundle",
        "desc": ""
      },
      {
        "name": "embeddedSet",
        "desc": "An embeddedSet describes a set of embedded types."
      },
      {
        "name": "methodSet",
        "desc": "A methodSet describes a set of methods. Entries where Decl == nil are conflict entries (more than one method with the same name at the same embedding level)."
      },
      {
        "name": "namedType",
        "desc": "A namedType represents a named unqualified (package local, or possibly predeclared) type. The namedType for a type name is always found via reader.lookupType."
      },
      {
        "name": "reader",
        "desc": "reader accumulates documentation for a single package. It modifies the AST: Comments (declaration documentation) that have been collected by the reader are set to nil in the respective AST nodes so that they are not printed twice (once when printing the documentation and once when printing the corresponding AST node)."
      }
    ]
  },
  {
    "name": "go/doc/comment",
    "desc": "Package comment implements parsing and reformatting of Go doc comments, (documentation comments), which are comments that immediately precede a top-level declaration of a package, const, func, type, or var.  Go doc comment syntax is a simplified subset of Markdown that supports links, headings, paragraphs, lists (without nesting), and preformatted text blocks. The details of the syntax are documented at https://go.dev/doc/comment.  To parse the text associated with a doc comment (after removing comment markers), use a [Parser]:  \tvar p comment.Parser \tdoc := p.Parse(text)  The result is a [*Doc]. To reformat it as a doc comment, HTML, Markdown, or plain text, use a [Printer]:  \tvar pr comment.Printer \tos.Stdout.Write(pr.Text(doc))  The [Parser] and [Printer] types are structs whose fields can be modified to customize the operations. For details, see the documentation for those types.  Use cases that need additional control over reformatting can implement their own logic by inspecting the parsed syntax itself. See the documentation for [Doc], [Block], [Text] for an overview and links to additional types.",
    "functions": [
      {
        "name": "DefaultLookupPackage",
        "desc": "DefaultLookupPackage is the default package lookup function, used when [Parser.LookupPackage] is nil. It recognizes names of the packages from the standard library with single-element import paths, such as math, which would otherwise be impossible to name.  Note that the go/doc package provides a more sophisticated lookup based on the imports used in the current package."
      },
      {
        "name": "Test52353",
        "desc": "See https://golang.org/issue/52353"
      },
      {
        "name": "TestAutoURL",
        "desc": ""
      },
      {
        "name": "TestIsOldHeading",
        "desc": ""
      },
      {
        "name": "TestStd",
        "desc": ""
      },
      {
        "name": "TestTestdata",
        "desc": ""
      },
      {
        "name": "TestWrap",
        "desc": ""
      },
      {
        "name": "autoURL",
        "desc": "autoURL checks whether s begins with a URL that should be hyperlinked. If so, it returns the URL, which is a prefix of s, and ok == true. Otherwise it returns \"\", false. The caller should skip over the first len(url) bytes of s before further processing."
      },
      {
        "name": "blankBefore",
        "desc": "blankBefore reports whether the block x requires a blank line before it. All blocks do, except for Lists that return false from x.BlankBefore()."
      },
      {
        "name": "commonPrefix",
        "desc": "commonPrefix returns the longest common prefix of a and b."
      },
      {
        "name": "dump",
        "desc": ""
      },
      {
        "name": "dumpNL",
        "desc": ""
      },
      {
        "name": "dumpTo",
        "desc": ""
      },
      {
        "name": "ident",
        "desc": "ident checks whether s begins with a Go identifier. If so, it returns the identifier, which is a prefix of s, and ok == true. Otherwise it returns \"\", false. The caller should skip over the first len(id) bytes of s before further processing."
      },
      {
        "name": "importPathOK",
        "desc": ""
      },
      {
        "name": "inc",
        "desc": "inc increments the decimal string s. For example, inc(\"1199\") == \"1200\"."
      },
      {
        "name": "indented",
        "desc": "indented reports whether line is indented (starts with a leading space or tab)."
      },
      {
        "name": "isBlank",
        "desc": "isBlank reports whether s is a blank line."
      },
      {
        "name": "isHeading",
        "desc": "isHeading reports whether line is a new-style section heading."
      },
      {
        "name": "isHost",
        "desc": "isHost reports whether c is a byte that can appear in a URL host, like www.example.com or user@[::1]:8080"
      },
      {
        "name": "isIdentASCII",
        "desc": "isIdentASCII reports whether c is an ASCII identifier byte."
      },
      {
        "name": "isList",
        "desc": "isList reports whether the line is the first line of a list, meaning starts with a list marker after any indentation. (The caller is responsible for checking the line is indented, as appropriate.)"
      },
      {
        "name": "isName",
        "desc": "isName reports whether s is a capitalized Go identifier (like Name)."
      },
      {
        "name": "isOldHeading",
        "desc": "isOldHeading reports whether line is an old-style section heading. line is all[off]."
      },
      {
        "name": "isPath",
        "desc": "isPath reports whether c is a (non-punctuation) path byte."
      },
      {
        "name": "isPunct",
        "desc": "isPunct reports whether c is a punctuation byte that can appear inside a path but not at the end."
      },
      {
        "name": "isScheme",
        "desc": "isScheme reports whether s is a recognized URL scheme. Note that if strings of new length (beyond 3-7) are added here, the fast path at the top of autoURL will need updating."
      },
      {
        "name": "isStdPkg",
        "desc": ""
      },
      {
        "name": "leadingSpace",
        "desc": "leadingSpace returns the longest prefix of s consisting of spaces and tabs."
      },
      {
        "name": "listMarker",
        "desc": "listMarker parses the line as beginning with a list marker. If it can do that, it returns the numeric marker (\"\" for a bullet list), the rest of the line, and ok == true. Otherwise, it returns \"\", \"\", false."
      },
      {
        "name": "splitDocName",
        "desc": "If text is of the form before.Name, where Name is a capitalized Go identifier, then splitDocName returns before, name, true. Otherwise it returns text, \"\", false."
      },
      {
        "name": "unindent",
        "desc": "unindent removes any common space/tab prefix from each line in lines, returning a copy of lines in which those prefixes have been trimmed from each line. It also replaces any lines containing only spaces with blank lines (empty strings)."
      },
      {
        "name": "validImportPath",
        "desc": "validImportPath reports whether path is a valid import path. It is a lightly edited copy of golang.org/x/mod/module.CheckImportPath."
      },
      {
        "name": "validImportPathElem",
        "desc": ""
      },
      {
        "name": "wrap",
        "desc": "wrap wraps words into lines of at most max runes, minimizing the sum of the squares of the leftover lengths at the end of each line (except the last, of course), with a preference for ending lines at punctuation (.,:;).  The returned slice gives the indexes of the first words on each line in the wrapped text with a final entry of len(words). Thus the lines are words[seq[0]:seq[1]], words[seq[1]:seq[2]], ..., words[seq[len(seq)-2]:seq[len(seq)-1]].  The implementation runs in O(n log n) time, where n = len(words), using the algorithm described in D. S. Hirschberg and L. L. Larmore, “[The least weight subsequence problem],” FOCS 1985, pp. 137-143.  [The least weight subsequence problem]: https://doi.org/10.1109/SFCS.1985.60"
      },
      {
        "name": "wrapPenalty",
        "desc": "wrapPenalty is the penalty for inserting a line break after word s."
      },
      {
        "name": "wrapSlow",
        "desc": "wrapSlow is an O(n²) reference implementation for wrap. It returns a minimal-score sequence along with the score. It is OK if wrap returns a different sequence as long as that sequence has the same score."
      },
      {
        "name": "writeNL",
        "desc": "writeNL calls out.WriteByte('\\n') but first trims trailing spaces on the previous line."
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "DefaultURL",
        "desc": "DefaultURL constructs and returns the documentation URL for l, using baseURL as a prefix for links to other packages.  The possible forms returned by DefaultURL are:   - baseURL/ImportPath, for a link to another package   - baseURL/ImportPath#Name, for a link to a const, func, type, or var in another package   - baseURL/ImportPath#Recv.Name, for a link to a method in another package   - #Name, for a link to a const, func, type, or var in this package   - #Recv.Name, for a link to a method in this package  If baseURL ends in a trailing slash, then DefaultURL inserts a slash between ImportPath and # in the anchored forms. For example, here are some baseURL values and URLs they can generate:  \t\"/pkg/\" → \"/pkg/math/#Sqrt\" \t\"/pkg\"  → \"/pkg/math#Sqrt\" \t\"/\"     → \"/math/#Sqrt\" \t\"\"      → \"/math#Sqrt\""
      },
      {
        "name": "text",
        "desc": ""
      },
      {
        "name": "DefaultID",
        "desc": "DefaultID returns the default anchor ID for the heading h.  The default anchor ID is constructed by converting every rune that is not alphanumeric ASCII to an underscore and then adding the prefix “hdr-”. For example, if the heading text is “Go Doc Comments”, the default ID is “hdr-Go_Doc_Comments”."
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "text",
        "desc": ""
      },
      {
        "name": "text",
        "desc": ""
      },
      {
        "name": "BlankBefore",
        "desc": "BlankBefore reports whether a reformatting of the comment should include a blank line before the list. The default rule is the same as for [BlankBetween]: if the list item content contains any blank lines (meaning at least one item has multiple paragraphs) then the list itself must be preceded by a blank line. A preceding blank line can be forced by setting [List].ForceBlankBefore."
      },
      {
        "name": "BlankBetween",
        "desc": "BlankBetween reports whether a reformatting of the comment should include a blank line between each pair of list items. The default rule is that if the list item content contains any blank lines (meaning at least one item has multiple paragraphs) then list items must themselves be separated by blank lines. Blank line separators can be forced by setting [List].ForceBlankBetween."
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "Parse",
        "desc": "Parse parses the doc comment text and returns the *[Doc] form. Comment markers (/* // and */) in the text must have already been removed."
      },
      {
        "name": "text",
        "desc": ""
      },
      {
        "name": "Comment",
        "desc": "Comment returns the standard Go formatting of the [Doc], without any comment markers."
      },
      {
        "name": "HTML",
        "desc": "HTML returns an HTML formatting of the [Doc]. See the [Printer] documentation for ways to customize the HTML output."
      },
      {
        "name": "Markdown",
        "desc": "Markdown returns a Markdown formatting of the Doc. See the [Printer] documentation for ways to customize the Markdown output."
      },
      {
        "name": "Text",
        "desc": "Text returns a textual formatting of the [Doc]. See the [Printer] documentation for ways to customize the text output."
      },
      {
        "name": "docLinkURL",
        "desc": ""
      },
      {
        "name": "headingID",
        "desc": ""
      },
      {
        "name": "headingLevel",
        "desc": ""
      },
      {
        "name": "block",
        "desc": "block prints the block x to out."
      },
      {
        "name": "indent",
        "desc": "indent prints s to out, indenting with the indent string after each newline in s."
      },
      {
        "name": "text",
        "desc": "text prints the text sequence x to out."
      },
      {
        "name": "block",
        "desc": "block prints the block x to out."
      },
      {
        "name": "escape",
        "desc": "escape prints s to out as plain text, escaping \u003c \u0026 \" ' and \u003e to avoid being misinterpreted in larger HTML constructs."
      },
      {
        "name": "text",
        "desc": "text prints the text sequence x to out."
      },
      {
        "name": "block",
        "desc": "block prints the block x to out."
      },
      {
        "name": "escape",
        "desc": "escape prints s to out as plain text, escaping special characters to avoid being misinterpreted as Markdown markup sequences."
      },
      {
        "name": "rawText",
        "desc": "rawText prints the text sequence x to out, without worrying about escaping characters that have special meaning at the start of a Markdown line."
      },
      {
        "name": "text",
        "desc": "text prints the text sequence x to out."
      },
      {
        "name": "code",
        "desc": "code returns a code block built from the lines."
      },
      {
        "name": "docLink",
        "desc": "docLink parses text, which was found inside [ ] brackets, as a doc link if possible, returning the DocLink and ok == true or else nil, false. The before and after strings are the text before the [ and after the ] on the same line. Doc links must be preceded and followed by punctuation, spaces, tabs, or the start or end of a line."
      },
      {
        "name": "heading",
        "desc": "heading returns the *Heading for the given new-style section heading line."
      },
      {
        "name": "list",
        "desc": "list returns a list built from the indented lines, using forceBlankBefore as the value of the List's ForceBlankBefore field."
      },
      {
        "name": "lookupPkg",
        "desc": "lookupPkg is called to look up the pkg in [pkg], [pkg.Name], and [pkg.Name.Recv]. If pkg has a slash, it is assumed to be the full import path and is returned with ok = true.  Otherwise, pkg is probably a simple package name like \"rand\" (not \"crypto/rand\" or \"math/rand\"). d.LookupPackage provides a way for the caller to allow resolving such names with reference to the imports in the surrounding package.  There is one collision between these two cases: single-element standard library names like \"math\" are full import paths but don't contain slashes. We let d.LookupPackage have the first chance to resolve it, in case there's a different package imported as math, and otherwise we refer to a built-in list of single-element standard library package names."
      },
      {
        "name": "oldHeading",
        "desc": "oldHeading returns the *Heading for the given old-style section heading line."
      },
      {
        "name": "paragraph",
        "desc": "paragraph returns a paragraph block built from the lines. If the lines are link definitions, paragraph adds them to d and returns nil."
      },
      {
        "name": "parseLinkedText",
        "desc": "parseLinkedText parses text that is allowed to contain explicit links, such as [math.Sin] or [Go home page], into a slice of Text items.  A “pkg” is only assumed to be a full import path if it starts with a domain name (a path element with a dot) or is one of the packages from the standard library (“[os]”, “[encoding/json]”, and so on). To avoid problems with maps, generics, and array types, doc links must be both preceded and followed by punctuation, spaces, tabs, or the start or end of a line. An example problem would be treating map[ast.Expr]TypeAndValue as containing a link."
      },
      {
        "name": "parseText",
        "desc": "parseText parses s as text and returns the result of appending those parsed Text elements to out. parseText does not handle explicit links like [math.Sin] or [Go home page]: those are handled by parseLinkedText. If autoLink is true, then parseText recognizes URLs and words from d.Words and converts those to links as appropriate."
      },
      {
        "name": "block",
        "desc": "block prints the block x to out."
      },
      {
        "name": "oneLongLine",
        "desc": "oneLongLine prints the text sequence x to out as one long line, without worrying about line wrapping. Explicit links have the [ ] dropped to improve readability."
      },
      {
        "name": "text",
        "desc": "text prints the text sequence x to out."
      }
    ],
    "types": [
      {
        "name": "Block",
        "desc": "A Block is block-level content in a doc comment, one of [*Code], [*Heading], [*List], or [*Paragraph]."
      },
      {
        "name": "Code",
        "desc": "A Code is a preformatted code block."
      },
      {
        "name": "Doc",
        "desc": "A Doc is a parsed Go doc comment."
      },
      {
        "name": "DocLink",
        "desc": "A DocLink is a link to documentation for a Go package or symbol."
      },
      {
        "name": "Heading",
        "desc": "A Heading is a doc comment heading."
      },
      {
        "name": "Italic",
        "desc": "An Italic is a string rendered as italicized text."
      },
      {
        "name": "Link",
        "desc": "A Link is a link to a specific URL."
      },
      {
        "name": "LinkDef",
        "desc": "A LinkDef is a single link definition."
      },
      {
        "name": "List",
        "desc": "A List is a numbered or bullet list. Lists are always non-empty: len(Items) \u003e 0. In a numbered list, every Items[i].Number is a non-empty string. In a bullet list, every Items[i].Number is an empty string."
      },
      {
        "name": "ListItem",
        "desc": "A ListItem is a single item in a numbered or bullet list."
      },
      {
        "name": "Paragraph",
        "desc": "A Paragraph is a paragraph of text."
      },
      {
        "name": "Parser",
        "desc": "A Parser is a doc comment parser. The fields in the struct can be filled in before calling [Parser.Parse] in order to customize the details of the parsing process."
      },
      {
        "name": "Plain",
        "desc": "A Plain is a string rendered as plain text (not italicized)."
      },
      {
        "name": "Printer",
        "desc": "A Printer is a doc comment printer. The fields in the struct can be filled in before calling any of the printing methods in order to customize the details of the printing process."
      },
      {
        "name": "Text",
        "desc": "A Text is text-level content in a doc comment, one of [Plain], [Italic], [*Link], or [*DocLink]."
      },
      {
        "name": "commentPrinter",
        "desc": ""
      },
      {
        "name": "htmlPrinter",
        "desc": "An htmlPrinter holds the state needed for printing a [Doc] as HTML."
      },
      {
        "name": "mdPrinter",
        "desc": "An mdPrinter holds the state needed for printing a Doc as Markdown."
      },
      {
        "name": "parseDoc",
        "desc": "parseDoc is parsing state for a single doc comment."
      },
      {
        "name": "span",
        "desc": "A span represents a single span of comment lines (lines[start:end]) of an identified kind (code, heading, paragraph, and so on)."
      },
      {
        "name": "spanKind",
        "desc": "A spanKind describes the kind of span."
      },
      {
        "name": "textPrinter",
        "desc": "A textPrinter holds the state needed for printing a Doc as plain text."
      }
    ]
  },
  {
    "name": "go/format",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkFormat",
        "desc": ""
      },
      {
        "name": "ExampleNode",
        "desc": ""
      },
      {
        "name": "array1",
        "desc": "array1 generates an array literal with n elements of the form:  \tvar _ = [...]byte{ \t\t// 0 \t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, \t\t0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, \t\t0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, \t\t0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, \t\t// 40 \t\t0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, \t\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, \t\t..."
      }
    ],
    "types": null
  },
  {
    "name": "go/importer",
    "desc": "Package importer provides access to export data importers.  These functions, which are mostly deprecated, date from before the introduction of modules in release Go 1.11. They should no longer be relied on except for use in test cases using small programs that depend only on the standard library. For reliable module-aware loading of type information, use the packages.Load function from golang.org/x/tools/go/packages.",
    "functions": [
      {
        "name": "Default",
        "desc": "Default returns an Importer for the compiler that built the running binary. If available, the result implements [types.ImporterFrom].  Default may be convenient for use in the simplest of cases, but most clients should instead use [ForCompiler], which accepts a [token.FileSet] from the caller; without it, all position information derived from the Importer will be incorrect and misleading. See also the package documentation."
      },
      {
        "name": "For",
        "desc": "For calls [ForCompiler] with a new FileSet.  Deprecated: Use [ForCompiler], which populates a FileSet with the positions of objects created by the importer."
      },
      {
        "name": "ForCompiler",
        "desc": "ForCompiler returns an Importer for importing from installed packages for the compilers \"gc\" and \"gccgo\", or for importing directly from the source if the compiler argument is \"source\". In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).  The lookup function is called each time the resulting importer needs to resolve an import path. In this mode the importer can only be invoked with canonical import paths (not relative or absolute ones); it is assumed that the translation to canonical import paths is being done by the client of the importer.  A lookup function must be provided for correct module-aware operation. Deprecated: If lookup is nil, for backwards-compatibility, the importer will attempt to resolve imports in the $GOPATH workspace."
      },
      {
        "name": "TestForCompiler",
        "desc": ""
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "Import",
        "desc": ""
      },
      {
        "name": "ImportFrom",
        "desc": ""
      },
      {
        "name": "Import",
        "desc": ""
      },
      {
        "name": "ImportFrom",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Lookup",
        "desc": "A Lookup function returns a reader to access package data for a given import path, or an error if no matching package is found."
      },
      {
        "name": "gccgoimports",
        "desc": ""
      },
      {
        "name": "gcimports",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/parser",
    "desc": "Package parser implements a parser for Go source files.  The [ParseFile] function reads file input from a string, []byte, or io.Reader, and produces an [ast.File] representing the complete abstract syntax tree of the file.  The [ParseExprFrom] function reads a single source-level expression and produces an [ast.Expr], the syntax tree of the expression.  The parser accepts a larger language than is syntactically permitted by the Go spec, for simplicity, and for improved robustness in the presence of syntax errors. For instance, in method declarations, the receiver is treated like an ordinary parameter list and thus may contain multiple entries where the spec permits exactly one. Consequently, the corresponding field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.  Applications that need to parse one or more complete packages of Go source code may find it more convenient not to interact directly with the parser but instead to use the Load function in package [golang.org/x/tools/go/packages].",
    "functions": [
      {
        "name": "BenchmarkParse",
        "desc": ""
      },
      {
        "name": "BenchmarkParseOnly",
        "desc": ""
      },
      {
        "name": "BenchmarkResolve",
        "desc": ""
      },
      {
        "name": "ParseDir",
        "desc": "ParseDir calls [ParseFile] for all files with names ending in \".go\" in the directory specified by path and returns a map of package name -\u003e package AST with all the packages found.  If filter != nil, only the files with [fs.FileInfo] entries passing through the filter (and ending in \".go\") are considered. The mode bits are passed to [ParseFile] unchanged. Position information is recorded in fset, which must not be nil.  If the directory couldn't be read, a nil map and the respective error are returned. If a parse error occurred, a non-nil but incomplete map and the first error encountered are returned.  Deprecated: ParseDir does not consider build tags when associating files with packages. For precise information about the relationship between packages and files, use golang.org/x/tools/go/packages, which can also optionally parse and type-check the files too."
      },
      {
        "name": "ParseExpr",
        "desc": "ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.  If syntax errors were found, the result is a partial AST (with [ast.Bad]* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position."
      },
      {
        "name": "ParseExprFrom",
        "desc": "ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for [ParseFile], but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.  If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with [ast.Bad]* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position."
      },
      {
        "name": "ParseFile",
        "desc": "ParseFile parses the source code of a single Go source file and returns the corresponding [ast.File] node. The source code may be provided via the filename of the source file, or via the src parameter.  If src != nil, ParseFile parses the source from src and the filename is only used when recording position information. The type of the argument for the src parameter must be string, []byte, or [io.Reader]. If src == nil, ParseFile parses the file specified by filename.  The mode parameter controls the amount of source text parsed and other optional parser functionality. If the [SkipObjectResolution] mode bit is set (recommended), the object resolution phase of parsing will be skipped, causing File.Scope, File.Unresolved, and all Ident.Obj fields to be nil. Those fields are deprecated; see [ast.Object] for details.  Position information is recorded in the file set fset, which must not be nil.  If the source couldn't be read, the returned AST is nil and the error indicates the specific failure. If the source was read but syntax errors were found, the result is a partial AST (with [ast.Bad]* nodes representing the fragments of erroneous source code). Multiple errors are returned via a scanner.ErrorList which is sorted by source position."
      },
      {
        "name": "TestColonEqualsScope",
        "desc": ""
      },
      {
        "name": "TestCommentGroupWithLineDirective",
        "desc": ""
      },
      {
        "name": "TestCommentGroups",
        "desc": ""
      },
      {
        "name": "TestEmptyFileHasValidStartEnd",
        "desc": "TestEmptyFileHasValidStartEnd is a regression test for #70162."
      },
      {
        "name": "TestErrors",
        "desc": ""
      },
      {
        "name": "TestFileStartEndPos",
        "desc": ""
      },
      {
        "name": "TestGoVersion",
        "desc": ""
      },
      {
        "name": "TestIncompleteSelection",
        "desc": "TestIncompleteSelection ensures that an incomplete selector expression is parsed as a (blank) *ast.SelectorExpr, not a *ast.BadExpr."
      },
      {
        "name": "TestInvalid",
        "desc": ""
      },
      {
        "name": "TestIssue42951",
        "desc": ""
      },
      {
        "name": "TestIssue57490",
        "desc": ""
      },
      {
        "name": "TestIssue59180",
        "desc": "TestIssue59180 tests that line number overflow doesn't cause an infinite loop."
      },
      {
        "name": "TestIssue9979",
        "desc": "TestIssue9979 verifies that empty statements are contained within their enclosing blocks."
      },
      {
        "name": "TestLastLineComment",
        "desc": ""
      },
      {
        "name": "TestLeadAndLineComments",
        "desc": ""
      },
      {
        "name": "TestObjects",
        "desc": ""
      },
      {
        "name": "TestParse",
        "desc": ""
      },
      {
        "name": "TestParseDepthLimit",
        "desc": ""
      },
      {
        "name": "TestParseDir",
        "desc": ""
      },
      {
        "name": "TestParseExpr",
        "desc": ""
      },
      {
        "name": "TestParseExprFrom",
        "desc": ""
      },
      {
        "name": "TestParseFile",
        "desc": ""
      },
      {
        "name": "TestParseTypeParamsAsParenExpr",
        "desc": ""
      },
      {
        "name": "TestRangePos",
        "desc": "proposal go.dev/issue/50429"
      },
      {
        "name": "TestResolution",
        "desc": "TestResolution checks that identifiers are resolved to the declarations annotated in the source, by comparing the positions of the resulting Ident.Obj.Decl to positions marked in the source via special comments.  In the test source, any comment prefixed with '=' or '@' (or both) marks the previous token position as the declaration ('=') or a use ('@') of an identifier. The text following '=' and '@' in the comment string is the label to use for the location.  Declaration labels must be unique within the file, and use labels must refer to an existing declaration label. It's OK for a comment to denote both the declaration and use of a label (e.g. '=@foo'). Leading and trailing whitespace is ignored. Any comment not beginning with '=' or '@' is ignored."
      },
      {
        "name": "TestScopeDepthLimit",
        "desc": ""
      },
      {
        "name": "TestSingle",
        "desc": "TestSingle is useful to track down a problem with a single short test program."
      },
      {
        "name": "TestUnresolved",
        "desc": ""
      },
      {
        "name": "TestValid",
        "desc": ""
      },
      {
        "name": "TestVarScope",
        "desc": ""
      },
      {
        "name": "annotatedObj",
        "desc": ""
      },
      {
        "name": "assert",
        "desc": ""
      },
      {
        "name": "checkErrors",
        "desc": ""
      },
      {
        "name": "checkFieldComments",
        "desc": ""
      },
      {
        "name": "commentText",
        "desc": "Don't use ast.CommentGroup.Text() - we want to see exact comment text."
      },
      {
        "name": "compareErrors",
        "desc": "compareErrors compares the map of expected error messages with the list of found errors and reports discrepancies."
      },
      {
        "name": "decNestLev",
        "desc": "decNestLev is used to track nesting depth during parsing to prevent stack exhaustion. It is used along with incNestLev in a similar fashion to how un and trace are used."
      },
      {
        "name": "declsFromComments",
        "desc": "declsFromComments looks at comments annotating uses and declarations, and maps each identifier use to its corresponding declaration. See the description of these annotations in the documentation for TestResolution."
      },
      {
        "name": "declsFromParser",
        "desc": "declsFromParser walks the file and collects the map associating an identifier position with its declaration position."
      },
      {
        "name": "dirFilter",
        "desc": ""
      },
      {
        "name": "expectedErrors",
        "desc": "expectedErrors collects the regular expressions of ERROR comments found in files and returns them as a map of error positions to error messages."
      },
      {
        "name": "extractName",
        "desc": "extractName splits the expression x into (name, expr) if syntactically x can be written as name expr. The split only happens if expr is a type element (per the isTypeElem predicate) or if force is set. If x is just a name, the result is (name, nil). If the split succeeds, the result is (name, expr). Otherwise the result is (nil, x). Examples:  \tx           force    name    expr \t------------------------------------ \tP*[]int     T/F      P       *[]int \tP*E         T        P       *E \tP*E         F        nil     P*E \tP([]int)    T/F      P       ([]int) \tP(E)        T        P       (E) \tP(E)        F        nil     P(E) \tP*E|F|~G    T/F      P       *E|F|~G \tP*E|F|G     T        P       *E|F|G \tP*E|F|G     F        nil     P*E|F|G"
      },
      {
        "name": "getField",
        "desc": ""
      },
      {
        "name": "getFile",
        "desc": "getFile assumes that each filename occurs at most once"
      },
      {
        "name": "getPos",
        "desc": ""
      },
      {
        "name": "isTypeElem",
        "desc": "isTypeElem reports whether x is a (possibly parenthesized) type element expression. The result is false if x could be a type element OR an ordinary (value) expression."
      },
      {
        "name": "isTypeSwitchAssert",
        "desc": ""
      },
      {
        "name": "nameFilter",
        "desc": ""
      },
      {
        "name": "packIndexExpr",
        "desc": "packIndexExpr returns an IndexExpr x[expr0] or IndexListExpr x[expr0, ...]."
      },
      {
        "name": "positionMarkers",
        "desc": "positionMarkers extracts named positions from the source denoted by comments prefixed with '=' (declarations) and '@' (uses): for example '@foo' or '=@bar'. It returns a map of name-\u003eposition for declarations, and name-\u003eposition(s) for uses."
      },
      {
        "name": "readFile",
        "desc": ""
      },
      {
        "name": "readSource",
        "desc": "If src != nil, readSource converts src to a []byte if possible; otherwise it returns an error. If src == nil, readSource returns the result of reading the file specified by filename."
      },
      {
        "name": "resolveFile",
        "desc": "resolveFile walks the given file to resolve identifiers within the file scope, updating ast.Ident.Obj fields with declaration information.  If declErr is non-nil, it is used to report declaration errors during resolution. tok is used to format position in error messages."
      },
      {
        "name": "split",
        "desc": "split splits pre«mid»post into pre, mid, post. If the string does not have that form, split returns x, \"\", \"\"."
      },
      {
        "name": "un",
        "desc": "Usage pattern: defer un(trace(p, \"...\"))"
      },
      {
        "name": "advance",
        "desc": "advance consumes tokens until the current token p.tok is in the 'to' set, or token.EOF. For error recovery."
      },
      {
        "name": "atComma",
        "desc": ""
      },
      {
        "name": "consumeComment",
        "desc": "Consume a comment and return it and the line on which it ends."
      },
      {
        "name": "consumeCommentGroup",
        "desc": "Consume a group of adjacent comments, add it to the parser's comments list, and return it together with the line at which the last comment in the group ends. A non-comment token or n empty lines terminate a comment group."
      },
      {
        "name": "embeddedElem",
        "desc": ""
      },
      {
        "name": "embeddedTerm",
        "desc": ""
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "errorExpected",
        "desc": ""
      },
      {
        "name": "expect",
        "desc": ""
      },
      {
        "name": "expect2",
        "desc": "expect2 is like expect, but it returns an invalid position if the expected token is not found."
      },
      {
        "name": "expectClosing",
        "desc": "expectClosing is like expect but provides a better error message for the common case of a missing comma before a newline."
      },
      {
        "name": "expectSemi",
        "desc": "expectSemi consumes a semicolon and returns the applicable line comment."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "isTypeSwitchGuard",
        "desc": ""
      },
      {
        "name": "lineFor",
        "desc": "lineFor returns the line of pos, ignoring line directive adjustments."
      },
      {
        "name": "makeExpr",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "Advance to the next non-comment token. In the process, collect any comment groups encountered, and remember the last lead and line comments.  A lead comment is a comment group that starts and ends in a line without any other tokens and that is followed by a non-comment token on the line immediately after the comment group.  A line comment is a comment group that follows a non-comment token on the same line, and that has no tokens after it on the line where it ends.  Lead and line comments may be considered documentation that is stored in the AST."
      },
      {
        "name": "next0",
        "desc": "Advance to the next token."
      },
      {
        "name": "parseArrayFieldOrTypeInstance",
        "desc": ""
      },
      {
        "name": "parseArrayType",
        "desc": "\"[\" has already been consumed, and lbrack is its position. If len != nil it is the already consumed array length."
      },
      {
        "name": "parseBinaryExpr",
        "desc": "parseBinaryExpr parses a (possibly) binary expression. If x is non-nil, it is used as the left operand.  TODO(rfindley): parseBinaryExpr has become overloaded. Consider refactoring."
      },
      {
        "name": "parseBlockStmt",
        "desc": ""
      },
      {
        "name": "parseBody",
        "desc": ""
      },
      {
        "name": "parseBranchStmt",
        "desc": ""
      },
      {
        "name": "parseCallExpr",
        "desc": ""
      },
      {
        "name": "parseCallOrConversion",
        "desc": ""
      },
      {
        "name": "parseCaseClause",
        "desc": ""
      },
      {
        "name": "parseChanType",
        "desc": ""
      },
      {
        "name": "parseCommClause",
        "desc": ""
      },
      {
        "name": "parseDecl",
        "desc": ""
      },
      {
        "name": "parseDeferStmt",
        "desc": ""
      },
      {
        "name": "parseDotsType",
        "desc": ""
      },
      {
        "name": "parseElement",
        "desc": ""
      },
      {
        "name": "parseElementList",
        "desc": ""
      },
      {
        "name": "parseExpr",
        "desc": "The result may be a type or even a raw type ([...]int)."
      },
      {
        "name": "parseExprList",
        "desc": "If lhs is set, result list elements which are identifiers are not resolved."
      },
      {
        "name": "parseFieldDecl",
        "desc": ""
      },
      {
        "name": "parseFile",
        "desc": ""
      },
      {
        "name": "parseForStmt",
        "desc": ""
      },
      {
        "name": "parseFuncDecl",
        "desc": ""
      },
      {
        "name": "parseFuncType",
        "desc": ""
      },
      {
        "name": "parseFuncTypeOrLit",
        "desc": ""
      },
      {
        "name": "parseGenDecl",
        "desc": ""
      },
      {
        "name": "parseGenericType",
        "desc": ""
      },
      {
        "name": "parseGoStmt",
        "desc": ""
      },
      {
        "name": "parseIdent",
        "desc": ""
      },
      {
        "name": "parseIdentList",
        "desc": ""
      },
      {
        "name": "parseIfHeader",
        "desc": "parseIfHeader is an adjusted version of parser.header in cmd/compile/internal/syntax/parser.go, which has been tuned for better error handling."
      },
      {
        "name": "parseIfStmt",
        "desc": ""
      },
      {
        "name": "parseImportSpec",
        "desc": ""
      },
      {
        "name": "parseIndexOrSliceOrInstance",
        "desc": ""
      },
      {
        "name": "parseInterfaceType",
        "desc": ""
      },
      {
        "name": "parseList",
        "desc": ""
      },
      {
        "name": "parseLiteralValue",
        "desc": ""
      },
      {
        "name": "parseMapType",
        "desc": ""
      },
      {
        "name": "parseMethodSpec",
        "desc": ""
      },
      {
        "name": "parseOperand",
        "desc": "parseOperand may return an expression or a raw type (incl. array types of the form [...]T). Callers must verify the result."
      },
      {
        "name": "parseParamDecl",
        "desc": ""
      },
      {
        "name": "parseParameterList",
        "desc": ""
      },
      {
        "name": "parseParameters",
        "desc": ""
      },
      {
        "name": "parsePointerType",
        "desc": ""
      },
      {
        "name": "parsePrimaryExpr",
        "desc": ""
      },
      {
        "name": "parseQualifiedIdent",
        "desc": ""
      },
      {
        "name": "parseReturnStmt",
        "desc": ""
      },
      {
        "name": "parseRhs",
        "desc": ""
      },
      {
        "name": "parseSelectStmt",
        "desc": ""
      },
      {
        "name": "parseSelector",
        "desc": ""
      },
      {
        "name": "parseSimpleStmt",
        "desc": "parseSimpleStmt returns true as 2nd result if it parsed the assignment of a range clause (with mode == rangeOk). The returned statement is an assignment with a right-hand side that is a single unary expression of the form \"range x\". No guarantees are given for the left-hand side."
      },
      {
        "name": "parseStmt",
        "desc": ""
      },
      {
        "name": "parseStmtList",
        "desc": ""
      },
      {
        "name": "parseStructType",
        "desc": ""
      },
      {
        "name": "parseSwitchStmt",
        "desc": ""
      },
      {
        "name": "parseType",
        "desc": ""
      },
      {
        "name": "parseTypeAssertion",
        "desc": ""
      },
      {
        "name": "parseTypeInstance",
        "desc": ""
      },
      {
        "name": "parseTypeName",
        "desc": "If the result is an identifier, it is not resolved."
      },
      {
        "name": "parseTypeParameters",
        "desc": ""
      },
      {
        "name": "parseTypeSpec",
        "desc": ""
      },
      {
        "name": "parseUnaryExpr",
        "desc": ""
      },
      {
        "name": "parseValue",
        "desc": ""
      },
      {
        "name": "parseValueSpec",
        "desc": ""
      },
      {
        "name": "printTrace",
        "desc": ""
      },
      {
        "name": "safePos",
        "desc": "safePos returns a valid file position for a given position: If pos is valid to begin with, safePos returns pos. If pos is out-of-range, safePos returns the EOF position.  This is hack to work around \"artificial\" end positions in the AST which are computed by adding 1 to (presumably valid) token positions. If the token positions are invalid due to parse errors, the resulting end position may be past the file's EOF position, which would lead to panics if used later on."
      },
      {
        "name": "tokPrec",
        "desc": ""
      },
      {
        "name": "tryIdentOrType",
        "desc": ""
      },
      {
        "name": "Visit",
        "desc": ""
      },
      {
        "name": "closeLabelScope",
        "desc": ""
      },
      {
        "name": "closeScope",
        "desc": ""
      },
      {
        "name": "declare",
        "desc": ""
      },
      {
        "name": "declareList",
        "desc": ""
      },
      {
        "name": "openLabelScope",
        "desc": ""
      },
      {
        "name": "openScope",
        "desc": ""
      },
      {
        "name": "resolve",
        "desc": "If x is an identifier, resolve attempts to resolve x by looking up the object it denotes. If no object is found and collectUnresolved is set, x is marked as unresolved and collected in the list of unresolved identifiers."
      },
      {
        "name": "resolveList",
        "desc": ""
      },
      {
        "name": "shortVarDecl",
        "desc": ""
      },
      {
        "name": "sprintf",
        "desc": ""
      },
      {
        "name": "trace",
        "desc": ""
      },
      {
        "name": "walkBody",
        "desc": ""
      },
      {
        "name": "walkExprs",
        "desc": ""
      },
      {
        "name": "walkFieldList",
        "desc": ""
      },
      {
        "name": "walkFuncType",
        "desc": ""
      },
      {
        "name": "walkLHS",
        "desc": ""
      },
      {
        "name": "walkRecv",
        "desc": ""
      },
      {
        "name": "walkStmts",
        "desc": ""
      },
      {
        "name": "walkTParams",
        "desc": "walkTParams is like walkFieldList, but declares type parameters eagerly so that they may be resolved in the constraint expressions held in the field Type."
      }
    ],
    "types": [
      {
        "name": "Mode",
        "desc": "A Mode value is a set of flags (or 0). They control the amount of source code parsed and other optional parser functionality."
      },
      {
        "name": "bailout",
        "desc": "A bailout panic is raised to indicate early termination. pos and msg are only populated when bailing out of object resolution."
      },
      {
        "name": "field",
        "desc": ""
      },
      {
        "name": "parseSpecFunction",
        "desc": ""
      },
      {
        "name": "parser",
        "desc": "The parser structure holds the parser's internal state."
      },
      {
        "name": "resolver",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/printer",
    "desc": "Package printer implements printing of AST nodes.",
    "functions": [
      {
        "name": "BenchmarkPrintDecl",
        "desc": ""
      },
      {
        "name": "BenchmarkPrintFile",
        "desc": ""
      },
      {
        "name": "Fprint",
        "desc": "Fprint \"pretty-prints\" an AST node to output. It calls [Config.Fprint] with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt."
      },
      {
        "name": "TestBadComments",
        "desc": "Verify that the printer produces a correct program even if the position information of comments introducing newlines is incorrect."
      },
      {
        "name": "TestBadNodes",
        "desc": "Verify that the printer doesn't crash if the AST contains BadXXX nodes."
      },
      {
        "name": "TestBaseIndent",
        "desc": ""
      },
      {
        "name": "TestChanType",
        "desc": "TestChanType tests that the tree for \u003c-(\u003c-chan int), without ParenExpr, is correctly formatted with parens. Test case for issue #63362."
      },
      {
        "name": "TestCommentedNode",
        "desc": ""
      },
      {
        "name": "TestDeclLists",
        "desc": ""
      },
      {
        "name": "TestEmptyDecl",
        "desc": "TestEmptyDecl tests that empty decls for const, var, import are printed with valid syntax e.g \"var ()\" instead of just \"var\", which is invalid and cannot be parsed."
      },
      {
        "name": "TestFiles",
        "desc": ""
      },
      {
        "name": "TestFuncType",
        "desc": "TestFuncType tests that an ast.FuncType with a nil Params field can be printed (per go/ast specification). Test case for issue 3870."
      },
      {
        "name": "TestIssue11151",
        "desc": ""
      },
      {
        "name": "TestIssue32854",
        "desc": "Verify that we don't print a newline between \"return\" and its results, as that would incorrectly cause a naked return."
      },
      {
        "name": "TestIssue5945",
        "desc": "Verify that the SourcePos mode doesn't emit unnecessary //line directives before empty lines."
      },
      {
        "name": "TestLineComments",
        "desc": "TestLineComments, using a simple test case, checks that consecutive line comments are properly terminated with a newline even if the AST position information is incorrect."
      },
      {
        "name": "TestParenthesizedDecl",
        "desc": "If a declaration has multiple specifications, a parenthesized declaration must be printed even if Lparen is token.NoPos."
      },
      {
        "name": "TestSourcePos",
        "desc": "Verify that the SourcePos mode emits correct //line directives by testing that position information for matching identifiers is maintained."
      },
      {
        "name": "TestSourcePosNewline",
        "desc": ""
      },
      {
        "name": "TestStmtLists",
        "desc": ""
      },
      {
        "name": "TestWriteErrors",
        "desc": "Test whether the printer stops writing after the first error"
      },
      {
        "name": "TestX",
        "desc": "TestX is a skeleton test that can be filled in for debugging one-off cases. Do not remove."
      },
      {
        "name": "allStars",
        "desc": "allStars reports whether text is the interior of an old-style /* */ comment with a star at the start of each line."
      },
      {
        "name": "appendLines",
        "desc": "appendLines is like append(x, y...) but it avoids creating doubled blank lines, which would not be gofmt-standard output. It assumes that only whole blocks of lines are being appended, not line fragments."
      },
      {
        "name": "check",
        "desc": ""
      },
      {
        "name": "checkEqual",
        "desc": "checkEqual compares a and b."
      },
      {
        "name": "combinesWithName",
        "desc": "combinesWithName reports whether a name followed by the expression x syntactically combines to another valid (value) expression. For instance using *T for x, \"name *T\" syntactically appears as the expression x*T. On the other hand, using  P|Q or *P|~Q for x, \"name P|Q\" or \"name *P|~Q\" cannot be combined into a valid (value) expression."
      },
      {
        "name": "commonPrefix",
        "desc": "commonPrefix returns the common prefix of a and b."
      },
      {
        "name": "cutoff",
        "desc": ""
      },
      {
        "name": "declToken",
        "desc": ""
      },
      {
        "name": "diffPrec",
        "desc": ""
      },
      {
        "name": "format",
        "desc": "format parses src, prints the corresponding AST, verifies the resulting src is syntactically correct, and returns the resulting src or an error if any."
      },
      {
        "name": "formatDocComment",
        "desc": "formatDocComment reformats the doc comment list, returning the canonical formatting."
      },
      {
        "name": "getDoc",
        "desc": "getDoc returns the ast.CommentGroup associated with n, if any."
      },
      {
        "name": "getLastComment",
        "desc": ""
      },
      {
        "name": "identCount",
        "desc": "identCount returns the number of identifiers found in f."
      },
      {
        "name": "identListSize",
        "desc": ""
      },
      {
        "name": "idents",
        "desc": "idents is an iterator that returns all idents in f via the result channel."
      },
      {
        "name": "init",
        "desc": "Verify that the printer can be invoked during initialization."
      },
      {
        "name": "initialize",
        "desc": "cannot initialize in init because (printer) Fprint launches goroutines."
      },
      {
        "name": "isBinary",
        "desc": ""
      },
      {
        "name": "isBlank",
        "desc": "Returns true if s contains only white space (only tabs and blanks can appear in the printer's context)."
      },
      {
        "name": "isDirective",
        "desc": "isDirective reports whether c is a comment directive. See go.dev/issue/37974. This code is also in go/ast."
      },
      {
        "name": "isNL",
        "desc": ""
      },
      {
        "name": "isTypeElem",
        "desc": "isTypeElem reports whether x is a (possibly parenthesized) type element expression. The result is false if x could be a type element OR an ordinary (value) expression."
      },
      {
        "name": "isTypeName",
        "desc": ""
      },
      {
        "name": "keepTypeColumn",
        "desc": "The keepTypeColumn function determines if the type column of a series of consecutive const or var declarations must be kept, or if initialization values (V) can be placed in the type column (T) instead. The i'th entry in the result slice is true if the type column in spec[i] must be kept.  For example, the declaration:  \t\tconst ( \t\t\tfoobar int = 42 // comment \t\t\tx          = 7  // comment \t\t\tfoo \t             bar = 991 \t\t)  leads to the type/values matrix below. A run of value columns (V) can be moved into the type column if there is no type for any of the values in that column (we only move entire columns so that they align properly).  \t\tmatrix        formatted     result \t                   matrix \t\tT  V    -\u003e    T  V     -\u003e   true      there is a T and so the type \t\t-  V          -  V          true      column must be kept \t\t-  -          -  -          false \t\t-  V          V  -          false     V is moved into T column"
      },
      {
        "name": "lineAt",
        "desc": "lineAt returns the line in text starting at offset offs."
      },
      {
        "name": "mayCombine",
        "desc": ""
      },
      {
        "name": "nlimit",
        "desc": "nlimit limits n to maxNewlines."
      },
      {
        "name": "normalizedNumber",
        "desc": "normalizedNumber rewrites base prefixes and exponents of numbers to use lower-case letters (0X123 to 0x123 and 1.2E3 to 1.2e3), and removes leading 0's from integer imaginary literals (0765i to 765i). It leaves hexadecimal digits alone.  normalizedNumber doesn't modify the ast.BasicLit value lit points to. If lit is not a number or a number in canonical format already, lit is returned as is. Otherwise a new ast.BasicLit is created."
      },
      {
        "name": "reduceDepth",
        "desc": ""
      },
      {
        "name": "runcheck",
        "desc": ""
      },
      {
        "name": "sanitizeImportPath",
        "desc": ""
      },
      {
        "name": "stripCommonPrefix",
        "desc": "stripCommonPrefix removes a common prefix from /*-style comment lines (unless no comment line is indented, all but the first line have some form of space prefix). The prefix is computed using heuristics such that is likely that the comment contents are nicely laid out after re-printing each line using the printer's current indentation."
      },
      {
        "name": "stripParens",
        "desc": ""
      },
      {
        "name": "stripParensAlways",
        "desc": ""
      },
      {
        "name": "testComment",
        "desc": "testComment verifies that f can be parsed again after printing it with its first comment set to comment at any possible source offset."
      },
      {
        "name": "testprint",
        "desc": ""
      },
      {
        "name": "trimRight",
        "desc": "trimRight returns s with trailing whitespace removed."
      },
      {
        "name": "walkBinary",
        "desc": ""
      },
      {
        "name": "Fprint",
        "desc": "Fprint \"pretty-prints\" an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *[ast.File], *[CommentedNode], [][ast.Decl], [][ast.Stmt], or assignment-compatible to [ast.Expr], [ast.Decl], [ast.Spec], or [ast.Stmt]."
      },
      {
        "name": "fprint",
        "desc": "fprint implements Fprint and takes a nodesSizes map for setting up the printer state."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "binaryExpr",
        "desc": "Format the binary expression: decide the cutoff and then format. Let's call depth == 1 Normal mode, and depth \u003e 1 Compact mode. (Algorithm suggestion by Russ Cox.)  The precedences are:  \t5             *  /  %  \u003c\u003c  \u003e\u003e  \u0026  \u0026^ \t4             +  -  |  ^ \t3             ==  !=  \u003c  \u003c=  \u003e  \u003e= \t2             \u0026\u0026 \t1             ||  The only decision is whether there will be spaces around levels 4 and 5. There are never spaces at level 6 (unary), and always spaces at levels 3 and below.  To choose the cutoff, look at the whole expression but excluding primary expressions (function calls, parenthesized exprs), and apply these rules:   1. If there is a binary operator with a right side unary operand     that would clash without a space, the cutoff must be (in order):      /*\t6     \u0026\u0026\t6     \u0026^\t6     ++\t5     --\t5      (Comparison operators always have spaces around them.)   2. If there is a mix of level 5 and level 4 operators, then the cutoff     is 5 (use spaces to distinguish precedence) in Normal mode     and 4 (never use spaces) in Compact mode.   3. If there are no level 4 operators or no level 5 operators, then the     cutoff is 6 (always use spaces) in Normal mode     and 4 (never use spaces) in Compact mode."
      },
      {
        "name": "block",
        "desc": "block prints an *ast.BlockStmt; it always spans at least two lines."
      },
      {
        "name": "bodySize",
        "desc": "bodySize is like nodeSize but it is specialized for *ast.BlockStmt's."
      },
      {
        "name": "commentBefore",
        "desc": "commentBefore reports whether the current comment group occurs before the next position in the source code and printing it does not introduce implicit semicolons."
      },
      {
        "name": "commentSizeBefore",
        "desc": "commentSizeBefore returns the estimated size of the comments on the same line before the next position."
      },
      {
        "name": "commentTextAt",
        "desc": ""
      },
      {
        "name": "commentsHaveNewline",
        "desc": "commentsHaveNewline reports whether a list of comments belonging to an *ast.CommentGroup contains newlines. Because the position information may only be partially correct, we also have to read the comment text."
      },
      {
        "name": "containsLinebreak",
        "desc": "containsLinebreak reports whether the whitespace buffer contains any line breaks."
      },
      {
        "name": "controlClause",
        "desc": ""
      },
      {
        "name": "decl",
        "desc": ""
      },
      {
        "name": "declList",
        "desc": ""
      },
      {
        "name": "distanceFrom",
        "desc": "distanceFrom returns the column difference between p.out (the current output position) and startOutCol. If the start position is on a different line from the current position (or either is unknown), the result is infinity."
      },
      {
        "name": "expr",
        "desc": ""
      },
      {
        "name": "expr0",
        "desc": ""
      },
      {
        "name": "expr1",
        "desc": ""
      },
      {
        "name": "exprList",
        "desc": "Print a list of expressions. If the list spans multiple source lines, the original line breaks are respected between expressions.  TODO(gri) Consider rewriting this to be independent of []ast.Expr so that we can use the algorithm for any kind of list  \t(e.g., pass list via a channel over which to range)."
      },
      {
        "name": "fieldList",
        "desc": ""
      },
      {
        "name": "file",
        "desc": ""
      },
      {
        "name": "fixGoBuildLines",
        "desc": ""
      },
      {
        "name": "flush",
        "desc": "flush prints any pending comments and whitespace occurring textually before the position of the next token tok. The flush result indicates if a newline was written or if a formfeed was dropped from the whitespace buffer."
      },
      {
        "name": "free",
        "desc": ""
      },
      {
        "name": "funcBody",
        "desc": "funcBody prints a function body following a function header of given headerSize. If the header's and block's size are \"small enough\" and the block is \"simple enough\", the block is printed on the current line, without line breaks, spaced from the header by sep. Otherwise the block's opening \"{\" is printed on the current line, followed by lines for the block's statements and its closing \"}\"."
      },
      {
        "name": "funcDecl",
        "desc": ""
      },
      {
        "name": "genDecl",
        "desc": ""
      },
      {
        "name": "identList",
        "desc": "If indent is set, a multi-line identifier list is indented after the first linebreak encountered."
      },
      {
        "name": "indentList",
        "desc": "indentList reports whether an expression list would look better if it were indented wholesale (starting with the very first element, rather than starting at the first line break)."
      },
      {
        "name": "internalError",
        "desc": ""
      },
      {
        "name": "intersperseComments",
        "desc": "intersperseComments consumes all comments that appear before the next token tok and prints it together with the buffered whitespace (i.e., the whitespace that needs to be written before the next token). A heuristic is used to mix the comments and whitespace. The intersperseComments result indicates if a newline was written or if a formfeed was dropped from the whitespace buffer."
      },
      {
        "name": "isOneLineFieldList",
        "desc": ""
      },
      {
        "name": "lineAt",
        "desc": ""
      },
      {
        "name": "lineFor",
        "desc": ""
      },
      {
        "name": "linebreak",
        "desc": "Print as many newlines as necessary (but at least min newlines) to get to the current line. ws is printed before the first line break. If newSection is set, the first line break is printed as formfeed. Returns 0 if no line breaks were printed, returns 1 if there was exactly one newline printed, and returns a value \u003e 1 if there was a formfeed or more than one newline printed.  TODO(gri): linebreak may add too many lines if the next statement at \"line\" is preceded by comments because the computation of n assumes the current position before the comment and the target position after the comment. Thus, after interspersing such comments, the space taken up by them is not considered to reduce the number of linebreaks. At the moment there is no easy way to know about future (not yet interspersed) comments in this function."
      },
      {
        "name": "linesFrom",
        "desc": "linesFrom returns the number of output lines between the current output line and the line argument, ignoring any pending (not yet emitted) whitespace or comments. It is used to compute an accurate size (in number of lines) for a formatted construct."
      },
      {
        "name": "nextComment",
        "desc": ""
      },
      {
        "name": "nodeSize",
        "desc": "nodeSize determines the size of n in chars after formatting. The result is \u003c= maxSize if the node fits on one line with at most maxSize chars and the formatted output doesn't contain any control chars. Otherwise, the result is \u003e maxSize."
      },
      {
        "name": "numLines",
        "desc": "numLines returns the number of lines spanned by node n in the original source."
      },
      {
        "name": "parameters",
        "desc": ""
      },
      {
        "name": "posFor",
        "desc": ""
      },
      {
        "name": "possibleSelectorExpr",
        "desc": ""
      },
      {
        "name": "print",
        "desc": "print prints a list of \"items\" (roughly corresponding to syntactic tokens, but also including whitespace and formatting information). It is the only print function that should be called directly from any of the AST printing functions in nodes.go.  Whitespace is accumulated until a non-whitespace token appears. Any comments that need to appear before that token are printed first, taking into account the amount and structure of any pending white- space for best comment placement. Then, any leftover whitespace is printed, followed by the actual token."
      },
      {
        "name": "printNode",
        "desc": ""
      },
      {
        "name": "recordLine",
        "desc": "recordLine records the output line number for the next non-whitespace token in *linePtr. It is used to compute an accurate line number for a formatted construct, independent of pending (not yet emitted) whitespace or comments."
      },
      {
        "name": "selectorExpr",
        "desc": "selectorExpr handles an *ast.SelectorExpr node and reports whether x spans multiple lines."
      },
      {
        "name": "setComment",
        "desc": "setComment sets g as the next comment if g != nil and if node comments are enabled - this mode is used when printing source code fragments such as exports only. It assumes that there is no pending comment in p.comments and at most one pending comment in the p.comment cache."
      },
      {
        "name": "setLineComment",
        "desc": ""
      },
      {
        "name": "setPos",
        "desc": ""
      },
      {
        "name": "signature",
        "desc": ""
      },
      {
        "name": "spec",
        "desc": "The parameter n is the number of specs in the group. If doIndent is set, multi-line identifier lists in the spec are indented when the first linebreak is encountered."
      },
      {
        "name": "stmt",
        "desc": ""
      },
      {
        "name": "stmtList",
        "desc": "Print the statement list indented, but without a newline after the last statement. Extra line breaks between statements in the source are respected but at most one empty line is printed between statements."
      },
      {
        "name": "valueSpec",
        "desc": ""
      },
      {
        "name": "writeByte",
        "desc": "writeByte writes ch n times to p.output and updates p.pos. Only used to write formatting (white space) characters."
      },
      {
        "name": "writeComment",
        "desc": ""
      },
      {
        "name": "writeCommentPrefix",
        "desc": "writeCommentPrefix writes the whitespace before a comment. If there is any pending whitespace, it consumes as much of it as is likely to help position the comment nicely. pos is the comment position, next the position of the item after all pending comments, prev is the previous comment in a group of comments (or nil), and tok is the next token."
      },
      {
        "name": "writeCommentSuffix",
        "desc": "writeCommentSuffix writes a line break after a comment if indicated and processes any leftover indentation information. If a line break is needed, the kind of break (newline vs formfeed) depends on the pending whitespace. The writeCommentSuffix result indicates if a newline was written or if a formfeed was dropped from the whitespace buffer."
      },
      {
        "name": "writeIndent",
        "desc": "writeIndent writes indentation."
      },
      {
        "name": "writeLineDirective",
        "desc": "writeLineDirective writes a //line directive if necessary."
      },
      {
        "name": "writeString",
        "desc": "writeString writes the string s to p.output and updates p.pos, p.out, and p.last. If isLit is set, s is escaped w/ tabwriter.Escape characters to protect s from being interpreted by the tabwriter.  Note: writeString is only used to write Go tokens, literals, and comments, all of which must be written literally. Thus, it is correct to always set isLit = true. However, setting it explicitly only when needed (i.e., when we don't know that s contains no tabs or line breaks) avoids processing extra escape characters and reduces run time of the printer benchmark by up to 10%."
      },
      {
        "name": "writeWhitespace",
        "desc": "writeWhitespace writes the first n whitespace entries."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "resetSpace",
        "desc": ""
      },
      {
        "name": "Visit",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "CommentedNode",
        "desc": "A CommentedNode bundles an AST node and corresponding comments. It may be provided as argument to any of the [Fprint] functions."
      },
      {
        "name": "Config",
        "desc": "A Config node controls the output of Fprint."
      },
      {
        "name": "Mode",
        "desc": "A Mode value is a set of flags (or 0). They control printing."
      },
      {
        "name": "checkMode",
        "desc": ""
      },
      {
        "name": "commentInfo",
        "desc": ""
      },
      {
        "name": "entry",
        "desc": ""
      },
      {
        "name": "exprListMode",
        "desc": ""
      },
      {
        "name": "limitWriter",
        "desc": ""
      },
      {
        "name": "paramMode",
        "desc": ""
      },
      {
        "name": "pmode",
        "desc": "A pmode value represents the current printer mode."
      },
      {
        "name": "printer",
        "desc": ""
      },
      {
        "name": "sizeCounter",
        "desc": "sizeCounter is an io.Writer which counts the number of bytes written, as well as whether a newline character was seen."
      },
      {
        "name": "trimmer",
        "desc": "A trimmer is an io.Writer filter for stripping tabwriter.Escape characters, trailing blanks and tabs, and for converting formfeed and vtab characters into newlines and htabs (in case no tabwriter is used). Text bracketed by tabwriter.Escape characters is passed through unchanged."
      },
      {
        "name": "visitor",
        "desc": ""
      },
      {
        "name": "whiteSpace",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/scanner",
    "desc": "Package scanner implements a scanner for Go source text. It takes a []byte as source which can then be tokenized through repeated calls to the Scan method.",
    "functions": [
      {
        "name": "BenchmarkScan",
        "desc": ""
      },
      {
        "name": "BenchmarkScanFiles",
        "desc": ""
      },
      {
        "name": "PrintError",
        "desc": "PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an [ErrorList]. Otherwise it prints the err string."
      },
      {
        "name": "TestInit",
        "desc": "Verify that initializing the same scanner more than once works correctly."
      },
      {
        "name": "TestInvalidLineDirectives",
        "desc": "Verify that invalid line directives get the correct error message."
      },
      {
        "name": "TestIssue10213",
        "desc": "Verify that no comments show up as literal values when skipping comments."
      },
      {
        "name": "TestIssue28112",
        "desc": ""
      },
      {
        "name": "TestLineDirectives",
        "desc": "Verify that line directives are interpreted correctly."
      },
      {
        "name": "TestNumbers",
        "desc": ""
      },
      {
        "name": "TestScan",
        "desc": "Verify that calling Scan() provides the correct results."
      },
      {
        "name": "TestScanErrors",
        "desc": ""
      },
      {
        "name": "TestSemicolons",
        "desc": ""
      },
      {
        "name": "TestStdErrorHandler",
        "desc": ""
      },
      {
        "name": "TestStripCR",
        "desc": ""
      },
      {
        "name": "TestUTF16",
        "desc": ""
      },
      {
        "name": "checkError",
        "desc": ""
      },
      {
        "name": "checkPos",
        "desc": ""
      },
      {
        "name": "checkSemi",
        "desc": ""
      },
      {
        "name": "digitVal",
        "desc": ""
      },
      {
        "name": "invalidSep",
        "desc": "invalidSep returns the index of the first invalid separator in x, or -1."
      },
      {
        "name": "isDecimal",
        "desc": ""
      },
      {
        "name": "isDigit",
        "desc": ""
      },
      {
        "name": "isHex",
        "desc": ""
      },
      {
        "name": "isLetter",
        "desc": ""
      },
      {
        "name": "litname",
        "desc": ""
      },
      {
        "name": "lower",
        "desc": ""
      },
      {
        "name": "newlineCount",
        "desc": ""
      },
      {
        "name": "stripCR",
        "desc": ""
      },
      {
        "name": "testSegments",
        "desc": ""
      },
      {
        "name": "tokenclass",
        "desc": ""
      },
      {
        "name": "trailingDigits",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": "Error implements the error interface."
      },
      {
        "name": "Add",
        "desc": "Add adds an [Error] with given position and error message to an [ErrorList]."
      },
      {
        "name": "Err",
        "desc": "Err returns an error equivalent to this error list. If the list is empty, Err returns nil."
      },
      {
        "name": "Error",
        "desc": "An [ErrorList] implements the error interface."
      },
      {
        "name": "Len",
        "desc": "[ErrorList] implements the sort Interface."
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "RemoveMultiples",
        "desc": "RemoveMultiples sorts an [ErrorList] and removes all but the first error per line."
      },
      {
        "name": "Reset",
        "desc": "Reset resets an [ErrorList] to no errors."
      },
      {
        "name": "Sort",
        "desc": "Sort sorts an [ErrorList]. *[Error] entries are sorted by position, other errors are sorted by error message, and before any *[Error] entry."
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Init",
        "desc": "Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.  Calls to [Scanner.Scan] will invoke the error handler err if they encounter a syntax error and err is not nil. Also, for each error encountered, the [Scanner] field ErrorCount is incremented by one. The mode parameter determines how comments are handled.  Note that Init may call err if there is an error in the first character of the file."
      },
      {
        "name": "Scan",
        "desc": "Scan scans the next token and returns the token position, the token, and its literal string if applicable. The source end is indicated by [token.EOF].  If the returned token is a literal ([token.IDENT], [token.INT], [token.FLOAT], [token.IMAG], [token.CHAR], [token.STRING]) or [token.COMMENT], the literal string has the corresponding value.  If the returned token is a keyword, the literal string is the keyword.  If the returned token is [token.SEMICOLON], the corresponding literal string is \";\" if the semicolon was present in the source, and \"\\n\" if the semicolon was inserted because of a newline or at EOF.  If the returned token is [token.ILLEGAL], the literal string is the offending character.  In all other cases, Scan returns an empty literal string.  For more tolerant parsing, Scan will return a valid token if possible even if a syntax error was encountered. Thus, even if the resulting token sequence contains no illegal tokens, a client may not assume that no error occurred. Instead it must check the scanner's ErrorCount or the number of calls of the error handler, if there was one installed.  Scan adds line information to the file added to the file set with Init. Token positions are relative to that file and thus relative to the file set."
      },
      {
        "name": "digits",
        "desc": "digits accepts the sequence { digit | '_' }. If base \u003c= 10, digits accepts any decimal digit but records the offset (relative to the source start) of a digit \u003e= base in *invalid, if *invalid \u003c 0. digits returns a bitset describing whether the sequence contained digits (bit 0 is set), or separators '_' (bit 1 is set)."
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "errorf",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "Read the next Unicode char into s.ch. s.ch \u003c 0 means end-of-file.  For optimization, there is some overlap between this method and s.scanIdentifier."
      },
      {
        "name": "peek",
        "desc": "peek returns the byte following the most recently read character without advancing the scanner. If the scanner is at EOF, peek returns 0."
      },
      {
        "name": "scanComment",
        "desc": "scanComment returns the text of the comment and (if nonzero) the offset of the first newline within it, which implies a /*...*/ comment."
      },
      {
        "name": "scanEscape",
        "desc": "scanEscape parses an escape sequence where rune is the accepted escaped quote. In case of a syntax error, it stops at the offending character (without consuming it) and returns false. Otherwise it returns true."
      },
      {
        "name": "scanIdentifier",
        "desc": "scanIdentifier reads the string of valid identifier characters at s.offset. It must only be called when s.ch is known to be a valid letter.  Be careful when making changes to this function: it is optimized and affects scanning performance significantly."
      },
      {
        "name": "scanNumber",
        "desc": ""
      },
      {
        "name": "scanRawString",
        "desc": ""
      },
      {
        "name": "scanRune",
        "desc": ""
      },
      {
        "name": "scanString",
        "desc": ""
      },
      {
        "name": "skipWhitespace",
        "desc": ""
      },
      {
        "name": "switch2",
        "desc": ""
      },
      {
        "name": "switch3",
        "desc": ""
      },
      {
        "name": "switch4",
        "desc": ""
      },
      {
        "name": "updateLineInfo",
        "desc": "updateLineInfo parses the incoming comment text at offset offs as a line directive. If successful, it updates the line info table for the position next per the line directive."
      }
    ],
    "types": [
      {
        "name": "Error",
        "desc": "In an [ErrorList], an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg."
      },
      {
        "name": "ErrorHandler",
        "desc": "An ErrorHandler may be provided to [Scanner.Init]. If a syntax error is encountered and a handler was installed, the handler is called with a position and an error message. The position points to the beginning of the offending token."
      },
      {
        "name": "ErrorList",
        "desc": "ErrorList is a list of *Errors. The zero value for an ErrorList is an empty ErrorList ready to use."
      },
      {
        "name": "Mode",
        "desc": "A mode value is a set of flags (or 0). They control scanner behavior."
      },
      {
        "name": "Scanner",
        "desc": "A Scanner holds the scanner's internal state while processing a given text. It can be allocated as part of another data structure but must be initialized via [Scanner.Init] before use."
      },
      {
        "name": "elt",
        "desc": ""
      },
      {
        "name": "errorCollector",
        "desc": ""
      },
      {
        "name": "segment",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/token",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkFileSet_AddExistingFiles",
        "desc": ""
      },
      {
        "name": "BenchmarkFileSet_Position",
        "desc": ""
      },
      {
        "name": "BenchmarkSearchInts",
        "desc": ""
      },
      {
        "name": "Example_retrievePositionInfo",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "go/types",
    "desc": "Package types declares the data types and implements the algorithms for type-checking of Go packages. Use [Config.Check] to invoke the type checker for a package. Alternatively, create a new type checker with [NewChecker] and invoke it incrementally by calling [Checker.Files].  Type-checking consists of several interdependent phases:  Name resolution maps each identifier ([ast.Ident]) in the program to the symbol ([Object]) it denotes. Use the Defs and Uses fields of [Info] or the [Info.ObjectOf] method to find the symbol for an identifier, and use the Implicits field of [Info] to find the symbol for certain other kinds of syntax node.  Constant folding computes the exact constant value ([constant.Value]) of every expression ([ast.Expr]) that is a compile-time constant. Use the Types field of [Info] to find the results of constant folding for an expression.  Type deduction computes the type ([Type]) of every expression ([ast.Expr]) and checks for compliance with the language specification. Use the Types field of [Info] for the results of type deduction.  Applications that need to type-check one or more complete packages of Go source code may find it more convenient not to invoke the type checker directly but instead to use the Load function in package [golang.org/x/tools/go/packages].  For a tutorial, see https://go.dev/s/types-tutorial.",
    "functions": [
      {
        "name": "AssertableTo",
        "desc": "AssertableTo reports whether a value of type V can be asserted to have type T.  The behavior of AssertableTo is unspecified in three cases:   - if T is Typ[Invalid]   - if V is a generalized interface; i.e., an interface that may only be used     as a type constraint in Go code   - if T is an uninstantiated generic type"
      },
      {
        "name": "AssignableTo",
        "desc": "AssignableTo reports whether a value of type V is assignable to a variable of type T.  The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an uninstantiated generic type."
      },
      {
        "name": "CheckExpr",
        "desc": "CheckExpr type checks the expression expr as if it had appeared at position pos of package pkg. [Type] information about the expression is recorded in info. The expression may be an identifier denoting an uninstantiated generic function or type.  If pkg == nil, the [Universe] scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package.  An error is returned if pos is not within the package or if the node cannot be type-checked.  Note: [Eval] and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather than the respective context-specific type."
      },
      {
        "name": "CmpPos",
        "desc": ""
      },
      {
        "name": "Comparable",
        "desc": "Comparable reports whether values of type T are comparable."
      },
      {
        "name": "ConvertibleTo",
        "desc": "ConvertibleTo reports whether a value of type V is convertible to a value of type T.  The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an uninstantiated generic type."
      },
      {
        "name": "DefPredeclaredTestFuncs",
        "desc": "DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only."
      },
      {
        "name": "ExprString",
        "desc": "ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax."
      },
      {
        "name": "Id",
        "desc": "Id returns name if it is exported, otherwise it returns the name qualified with the package path."
      },
      {
        "name": "Identical",
        "desc": "Identical reports whether x and y are identical types. Receivers of [Signature] types are ignored.  Predicates such as [Identical], [Implements], and [Satisfies] assume that both operands belong to a consistent collection of symbols ([Object] values). For example, two [Named] types can be identical only if their [Named.Obj] methods return the same [TypeName] symbol. A collection of symbols is consistent if, for each logical package whose path is P, the creation of those symbols involved at most one call to [NewPackage](P, ...). To ensure consistency, use a single [Importer] for all loaded packages and their dependencies. For more information, see https://github.com/golang/go/issues/57497."
      },
      {
        "name": "IdenticalIgnoreTags",
        "desc": "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of [Signature] types are ignored."
      },
      {
        "name": "Implements",
        "desc": "Implements reports whether type V implements interface T.  The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated generic type."
      },
      {
        "name": "IsInterface",
        "desc": "IsInterface reports whether t is an interface type."
      },
      {
        "name": "ObjectScopePos",
        "desc": ""
      },
      {
        "name": "ObjectString",
        "desc": "ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil."
      },
      {
        "name": "Satisfies",
        "desc": "Satisfies reports whether type V satisfies the constraint T.  The behavior of Satisfies is unspecified if V is Typ[Invalid] or an uninstantiated generic type."
      },
      {
        "name": "ScopeComment",
        "desc": ""
      },
      {
        "name": "SelectionString",
        "desc": "SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.  Examples:  \t\"field (T) f int\" \t\"method (T) f(X) Y\" \t\"method expr (T) f(X) Y\""
      },
      {
        "name": "TestAssignOp",
        "desc": ""
      },
      {
        "name": "TestContextHashCollisions",
        "desc": ""
      },
      {
        "name": "TestError",
        "desc": ""
      },
      {
        "name": "TestInvalidTypeSet",
        "desc": ""
      },
      {
        "name": "TestSizeof",
        "desc": "Signal size changes of important structures."
      },
      {
        "name": "TestStripAnnotations",
        "desc": ""
      },
      {
        "name": "TestTermDisjoint",
        "desc": ""
      },
      {
        "name": "TestTermEqual",
        "desc": ""
      },
      {
        "name": "TestTermIncludes",
        "desc": ""
      },
      {
        "name": "TestTermIntersection",
        "desc": ""
      },
      {
        "name": "TestTermString",
        "desc": ""
      },
      {
        "name": "TestTermSubsetOf",
        "desc": ""
      },
      {
        "name": "TestTermUnion",
        "desc": ""
      },
      {
        "name": "TestTermlistAll",
        "desc": ""
      },
      {
        "name": "TestTermlistEqual",
        "desc": ""
      },
      {
        "name": "TestTermlistIncludes",
        "desc": ""
      },
      {
        "name": "TestTermlistIntersect",
        "desc": ""
      },
      {
        "name": "TestTermlistIsAll",
        "desc": ""
      },
      {
        "name": "TestTermlistIsEmpty",
        "desc": ""
      },
      {
        "name": "TestTermlistNorm",
        "desc": ""
      },
      {
        "name": "TestTermlistString",
        "desc": ""
      },
      {
        "name": "TestTermlistSubsetOf",
        "desc": ""
      },
      {
        "name": "TestTermlistSupersetOf",
        "desc": ""
      },
      {
        "name": "TestTermlistUnion",
        "desc": ""
      },
      {
        "name": "TestTypeSetString",
        "desc": ""
      },
      {
        "name": "TestZeroTok",
        "desc": ""
      },
      {
        "name": "TypeString",
        "desc": "TypeString returns the string representation of typ. The [Qualifier] controls the printing of package-level objects, and may be nil."
      },
      {
        "name": "WriteExpr",
        "desc": "WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax."
      },
      {
        "name": "WriteSignature",
        "desc": "WriteSignature writes the representation of the signature sig to buf, without a leading \"func\" keyword. The [Qualifier] controls the printing of package-level objects, and may be nil."
      },
      {
        "name": "WriteType",
        "desc": "WriteType writes the string representation of typ to buf. The [Qualifier] controls the printing of package-level objects, and may be nil."
      },
      {
        "name": "_IsSyncAtomicAlign64",
        "desc": ""
      },
      {
        "name": "aliasAny",
        "desc": ""
      },
      {
        "name": "align",
        "desc": "align returns the smallest y \u003e= x such that y % a == 0. a must be within 1 and 8 and it must be a power of 2. The result may be negative due to overflow."
      },
      {
        "name": "allBasic",
        "desc": "allBasic reports whether under(t) is a basic type with the specified info. If t is a type parameter, the result is true if isBasic(t, info) is true for all specific types of the type parameter's type set."
      },
      {
        "name": "allBoolean",
        "desc": ""
      },
      {
        "name": "allInteger",
        "desc": ""
      },
      {
        "name": "allNumeric",
        "desc": ""
      },
      {
        "name": "allNumericOrString",
        "desc": ""
      },
      {
        "name": "allOrdered",
        "desc": ""
      },
      {
        "name": "allString",
        "desc": ""
      },
      {
        "name": "allUnsigned",
        "desc": ""
      },
      {
        "name": "assert",
        "desc": ""
      },
      {
        "name": "assertSortedMethods",
        "desc": ""
      },
      {
        "name": "assignOp",
        "desc": ""
      },
      {
        "name": "clone",
        "desc": "clone makes a \"flat copy\" of *p and returns a pointer to the copy."
      },
      {
        "name": "cmpPos",
        "desc": "cmpPos compares the positions p and q and returns a result r as follows:  r \u003c  0: p is before q r == 0: p and q are the same position (but may not be identical) r \u003e  0: p is after q  If p and q are in different files, p is before q if the filename of p sorts lexicographically before the filename of q."
      },
      {
        "name": "commonUnder",
        "desc": "If t is a type parameter, cond is nil, and t's type set contains no channel types, commonUnder returns the common underlying type of all types in t's type set if it exists, or nil and a type error otherwise.  If t is a type parameter, cond is nil, and there are channel types, t's type set must only contain channel types, they must all have the same element types, channel directions must not conflict, and commonUnder returns one of the most restricted channels. Otherwise, the function returns nil and a type error.  If cond != nil, each pair (t, u) of type and underlying type in t's type set must satisfy the condition expressed by cond. If the result of cond is != nil, commonUnder returns nil and the type error reported by cond. Note that cond is called before any other conditions are checked; specifically cond may be called with (nil, nil) if the type set contains no specific types.  If t is not a type parameter, commonUnder behaves as if t was a type parameter with the single type t in its type set."
      },
      {
        "name": "compareFunc",
        "desc": ""
      },
      {
        "name": "compositeKind",
        "desc": "compositeKind returns the kind of the given composite type (\"array\", \"slice\", etc.) or the empty string if typ is not composite but a basic type."
      },
      {
        "name": "concat",
        "desc": "concat returns the result of concatenating list and i. The result does not share its underlying array with list."
      },
      {
        "name": "def",
        "desc": "Objects with names containing blanks are internal and not entered into a scope. Objects with exported names are inserted in the unsafe package scope; other objects are inserted in the universe scope."
      },
      {
        "name": "defPredeclaredConsts",
        "desc": ""
      },
      {
        "name": "defPredeclaredFuncs",
        "desc": ""
      },
      {
        "name": "defPredeclaredNil",
        "desc": ""
      },
      {
        "name": "defPredeclaredTypes",
        "desc": ""
      },
      {
        "name": "dir",
        "desc": "dir makes a good-faith attempt to return the directory portion of path. If path is empty, the result is \".\". (Per the go/build package dependency tests, we cannot import path/filepath and simply use filepath.Dir.)"
      },
      {
        "name": "embeddedFieldIdent",
        "desc": ""
      },
      {
        "name": "endPos",
        "desc": "endPos returns the position of the first character immediately after node n."
      },
      {
        "name": "fieldIndex",
        "desc": "fieldIndex returns the index for the field with matching package and name, or a value \u003c 0. See Object.sameId for the meaning of foldCase."
      },
      {
        "name": "firstInSrc",
        "desc": "firstInSrc reports the index of the object with the \"smallest\" source position in path. path must not be empty."
      },
      {
        "name": "fitsFloat32",
        "desc": ""
      },
      {
        "name": "fitsFloat64",
        "desc": ""
      },
      {
        "name": "flattenUnion",
        "desc": "flattenUnion walks a union type expression of the form A | B | C | ..., extracting both the binary exprs (blist) and leaf types (tlist)."
      },
      {
        "name": "goTypeName",
        "desc": "goTypeName returns the Go type name for typ and removes any occurrences of \"types.\" from that name."
      },
      {
        "name": "goVal",
        "desc": "goVal returns the Go value for val, or nil."
      },
      {
        "name": "hasBreak",
        "desc": "hasBreak reports if s is or contains a break statement referring to the label-ed statement or implicit-ly the closest outer breakable statement."
      },
      {
        "name": "hasBreakList",
        "desc": ""
      },
      {
        "name": "hasDots",
        "desc": "hasDots reports whether the last argument in the call is followed by ..."
      },
      {
        "name": "hasEmptyTypeset",
        "desc": "hasEmptyTypeset reports whether t is a type parameter with an empty type set. The function does not force the computation of the type set and so is safe to use anywhere, but it may report a false negative if the type set has not been computed yet."
      },
      {
        "name": "hasInvalidEmbeddedFields",
        "desc": "hasInvalidEmbeddedFields reports whether T is a struct (or a pointer to a struct) that contains (directly or indirectly) embedded fields with invalid types."
      },
      {
        "name": "hasName",
        "desc": "hasName reports whether t has a name. This includes predeclared types, defined types, and type parameters. hasName may be called with types that are not fully set up."
      },
      {
        "name": "hasNil",
        "desc": "hasNil reports whether type t includes the nil value."
      },
      {
        "name": "hasVarSize",
        "desc": "hasVarSize reports if the size of type t is variable due to type parameters or if the type is infinitely-sized due to a cycle for which the type has not yet been checked."
      },
      {
        "name": "identicalInstance",
        "desc": "identicalInstance reports if two type instantiations are identical. Instantiations are identical if their origin and type arguments are identical."
      },
      {
        "name": "identicalOrigin",
        "desc": "identicalOrigin reports whether x and y originated in the same declaration."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "instantiatedIdent",
        "desc": "instantiatedIdent determines the identifier of the type instantiated in expr. Helper function for recordInstance in recording.go."
      },
      {
        "name": "isBasic",
        "desc": "isBasic reports whether under(t) is a basic type with the specified info. If t is a type parameter the result is false; i.e., isBasic does not look inside a type parameter."
      },
      {
        "name": "isBoolean",
        "desc": ""
      },
      {
        "name": "isBytesOrRunes",
        "desc": ""
      },
      {
        "name": "isCGoTypeObj",
        "desc": "isCGoTypeObj reports whether the given type name was created by cgo."
      },
      {
        "name": "isComparison",
        "desc": ""
      },
      {
        "name": "isComplex",
        "desc": ""
      },
      {
        "name": "isConstType",
        "desc": ""
      },
      {
        "name": "isExported",
        "desc": ""
      },
      {
        "name": "isFloat",
        "desc": ""
      },
      {
        "name": "isGeneric",
        "desc": "isGeneric reports whether a type is a generic, uninstantiated type (generic signatures are not included). TODO(gri) should we include signatures or assert that they are not present?"
      },
      {
        "name": "isInteger",
        "desc": ""
      },
      {
        "name": "isIntegerOrFloat",
        "desc": ""
      },
      {
        "name": "isInterfacePtr",
        "desc": ""
      },
      {
        "name": "isNonTypeParamInterface",
        "desc": "isNonTypeParamInterface reports whether t is an interface type but not a type parameter."
      },
      {
        "name": "isNumeric",
        "desc": ""
      },
      {
        "name": "isParameterized",
        "desc": "isParameterized reports whether typ contains any of the type parameters of tparams. If typ is a generic function, isParameterized ignores the type parameter declarations; it only considers the signature proper (incoming and result parameters)."
      },
      {
        "name": "isPointer",
        "desc": ""
      },
      {
        "name": "isShift",
        "desc": ""
      },
      {
        "name": "isString",
        "desc": ""
      },
      {
        "name": "isTypeLit",
        "desc": "isTypeLit reports whether t is a type literal. This includes all non-defined types, but also basic types. isTypeLit may be called with types that are not fully set up."
      },
      {
        "name": "isTypeParam",
        "desc": "isTypeParam reports whether t is a type parameter."
      },
      {
        "name": "isTyped",
        "desc": "isTyped reports whether t is typed; i.e., not an untyped constant or boolean. Safe to call from types that are not fully set up."
      },
      {
        "name": "isUintptr",
        "desc": ""
      },
      {
        "name": "isUnsafePointer",
        "desc": ""
      },
      {
        "name": "isUnsigned",
        "desc": ""
      },
      {
        "name": "isUntyped",
        "desc": "isUntyped(t) is the same as !isTyped(t). Safe to call from types that are not fully set up."
      },
      {
        "name": "isUntypedNumeric",
        "desc": "isUntypedNumeric reports whether t is an untyped numeric type. Safe to call from types that are not fully set up."
      },
      {
        "name": "isValid",
        "desc": "isValid reports whether t is a valid type."
      },
      {
        "name": "isValidName",
        "desc": "isValidName reports whether s is a valid Go identifier."
      },
      {
        "name": "isdddArray",
        "desc": "isdddArray reports whether atyp is of the form [...]E."
      },
      {
        "name": "keyVal",
        "desc": "keyVal maps a complex, float, integer, string or boolean constant value to the corresponding complex128, float64, int64, uint64, string, or bool Go value if possible; otherwise it returns x. A complex constant that can be represented as a float (such as 1.2 + 0i) is returned as a floating point value; if a floating point value can be represented as an integer (such as 1.0) it is returned as an integer value. This ensures that constants of different kind but equal value (such as 1.0 + 0i, 1.0, 1) result in the same value."
      },
      {
        "name": "killCycles",
        "desc": "killCycles walks through the given type parameters and looks for cycles created by type parameters whose inferred types refer back to that type parameter, either directly or indirectly. If such a cycle is detected, it is killed by setting the corresponding inferred type to nil.  TODO(gri) Determine if we can simply abort inference as soon as we have found a single cycle."
      },
      {
        "name": "lookupType",
        "desc": ""
      },
      {
        "name": "makeFromLiteral",
        "desc": "makeFromLiteral returns the constant value for the given literal string and kind."
      },
      {
        "name": "measure",
        "desc": ""
      },
      {
        "name": "mentions",
        "desc": "mentions reports whether type T \"mentions\" typ in an (embedded) element or term of T (whether typ is in the type set of T or not). For better error messages."
      },
      {
        "name": "ndigits",
        "desc": "ndigits returns the number of decimal digits in x. For x \u003c 10, the result is always 1. For x \u003e 100, the result is always 3."
      },
      {
        "name": "nextID",
        "desc": "nextID returns a value increasing monotonically by 1 with each call, starting with 1. It may be called concurrently."
      },
      {
        "name": "opName",
        "desc": "opName returns the name of the operation if x is an operation that might overflow; otherwise it returns the empty string."
      },
      {
        "name": "opPos",
        "desc": "opPos returns the position of the operator if x is an operation; otherwise it returns the start position of x."
      },
      {
        "name": "operandString",
        "desc": "Operand string formats (not all \"untyped\" cases can appear due to the type system, but they fall out naturally here)  mode       format  invalid    \u003cexpr\u003e (               \u003cmode\u003e                    ) novalue    \u003cexpr\u003e (               \u003cmode\u003e                    ) builtin    \u003cexpr\u003e (               \u003cmode\u003e                    ) typexpr    \u003cexpr\u003e (               \u003cmode\u003e                    )  constant   \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) constant   \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e) constant   \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e \u003cval\u003e              ) constant   \u003cexpr\u003e (               \u003cmode\u003e \u003cval\u003e of type \u003ctyp\u003e)  variable   \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) variable   \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e)  mapindex   \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) mapindex   \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e)  value      \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) value      \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e)  nilvalue   untyped nil nilvalue   nil    (                            of type \u003ctyp\u003e)  commaok    \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) commaok    \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e)  commaerr   \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) commaerr   \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e)  cgofunc    \u003cexpr\u003e (\u003cuntyped kind\u003e \u003cmode\u003e                    ) cgofunc    \u003cexpr\u003e (               \u003cmode\u003e       of type \u003ctyp\u003e)"
      },
      {
        "name": "overlappingTerm",
        "desc": "overlappingTerm reports the index of the term x in terms which is overlapping (not disjoint) from y. The result is \u003c 0 if there is no such term. The type of term y must not be an interface, and terms with an interface type are ignored in the terms list."
      },
      {
        "name": "packagePrefix",
        "desc": ""
      },
      {
        "name": "pathString",
        "desc": "pathString returns a string of the form a-\u003eb-\u003e ... -\u003eg for a path [a, b, ... g]."
      },
      {
        "name": "representableConst",
        "desc": "representableConst reports whether x can be represented as value of the given basic type and for the configuration provided (only needed for int/uint sizes).  If rounded != nil, *rounded is set to the rounded value of x for representable floating-point and complex values, and to an Int value for integer values; it is left alone otherwise. It is ok to provide the addressof the first argument for rounded.  The check parameter may be nil if representableConst is invoked (indirectly) through an exported API call (AssignableTo, ConvertibleTo) because we don't need the Checker's config for those calls."
      },
      {
        "name": "roundFloat32",
        "desc": ""
      },
      {
        "name": "roundFloat64",
        "desc": ""
      },
      {
        "name": "samePkg",
        "desc": "samePkg reports whether packages a and b are the same."
      },
      {
        "name": "setDefType",
        "desc": ""
      },
      {
        "name": "sliceElem",
        "desc": "sliceElem returns the slice element type for a slice operand x or a type error if x is not a slice (or a type set of slices)."
      },
      {
        "name": "sortMethods",
        "desc": ""
      },
      {
        "name": "split",
        "desc": ""
      },
      {
        "name": "sprintf",
        "desc": ""
      },
      {
        "name": "srcimporter_setUsesCgo",
        "desc": ""
      },
      {
        "name": "startPos",
        "desc": "startPos returns the start position of node n."
      },
      {
        "name": "stripAnnotations",
        "desc": "stripAnnotations removes internal (type) annotations from s."
      },
      {
        "name": "subscript",
        "desc": "subscript returns the decimal (utf8) representation of x using subscript digits."
      },
      {
        "name": "substList",
        "desc": "substList applies subst to each element of the incoming slice. If at least one element changes, the result is a new slice with all the (possibly updated) elements of the incoming slice; otherwise the result it nil. The incoming slice is unchanged."
      },
      {
        "name": "tail",
        "desc": "tail returns the string s without its first (UTF-8) character. If len(s) == 0, the result is s."
      },
      {
        "name": "trimTrailingEmptyStmts",
        "desc": ""
      },
      {
        "name": "typeParamsString",
        "desc": "typeParamsString produces a string containing all the type parameter names in list suitable for human consumption."
      },
      {
        "name": "typeset",
        "desc": "typeset is an iterator over the (type/underlying type) pairs of the specific type terms of the type set implied by t. If t is a type parameter, the implied type set is the type set of t's constraint. In that case, if there are no specific terms, typeset calls yield with (nil, nil). If t is not a type parameter, the implied type set consists of just t. In any case, typeset is guaranteed to call yield at least once."
      },
      {
        "name": "underIs",
        "desc": "If typ is a type parameter, underIs returns the result of typ.underIs(f). Otherwise, underIs returns the result of f(under(typ))."
      },
      {
        "name": "validatedImportPath",
        "desc": ""
      },
      {
        "name": "writeExprList",
        "desc": ""
      },
      {
        "name": "writeFieldList",
        "desc": ""
      },
      {
        "name": "writeFuncName",
        "desc": ""
      },
      {
        "name": "writeIdentList",
        "desc": ""
      },
      {
        "name": "writeObject",
        "desc": ""
      },
      {
        "name": "writeSigExpr",
        "desc": ""
      },
      {
        "name": "Obj",
        "desc": "Obj returns the type name for the declaration defining the alias type a. For instantiated types, this is same as the type name of the origin type."
      },
      {
        "name": "Origin",
        "desc": "Origin returns the generic Alias type of which a is an instance. If a is not an instance of a generic alias, Origin returns a."
      },
      {
        "name": "Rhs",
        "desc": "Rhs returns the type R on the right-hand side of an alias declaration \"type A = R\", which may be another alias."
      },
      {
        "name": "SetTypeParams",
        "desc": "SetTypeParams sets the type parameters of the alias type a. The alias a must not have type arguments."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "TypeArgs",
        "desc": "TypeArgs returns the type arguments used to instantiate the Alias type. If a is not an instance of a generic alias, the result is nil."
      },
      {
        "name": "TypeParams",
        "desc": "TypeParams returns the type parameters of the alias type a, or nil. A generic Alias and its instances have the same type parameters."
      },
      {
        "name": "Underlying",
        "desc": "Underlying returns the [underlying type] of the alias type a, which is the underlying type of the aliased type. Underlying types are never Named, TypeParam, or Alias types.  [underlying type]: https://go.dev/ref/spec#Underlying_types."
      },
      {
        "name": "cleanup",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Elem",
        "desc": "Elem returns element type of array a."
      },
      {
        "name": "Len",
        "desc": "Len returns the length of array a. A negative result indicates an unknown length."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Info",
        "desc": "Info returns information about properties of basic type b."
      },
      {
        "name": "Kind",
        "desc": "Kind returns the kind of basic type b."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of basic type b."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "Dir",
        "desc": "Dir returns the direction of channel c."
      },
      {
        "name": "Elem",
        "desc": "Elem returns the element type of channel c."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Files",
        "desc": "Files checks the provided files as part of the checker's package."
      },
      {
        "name": "addDeclDep",
        "desc": "addDeclDep adds the dependency edge (check.decl -\u003e to) if check.decl exists"
      },
      {
        "name": "allowVersion",
        "desc": "allowVersion reports whether the current effective Go version (which may vary from one file to another) is allowed to use the feature version (want)."
      },
      {
        "name": "applyTypeFunc",
        "desc": "applyTypeFunc applies f to x. If x is a type parameter, the result is a type parameter constrained by a new interface bound. The type bounds for that interface are computed by applying f to each of the type bounds of x. If any of these applications of f return nil, applyTypeFunc returns nil. If x is not a type parameter, the result is f(x)."
      },
      {
        "name": "arguments",
        "desc": "arguments type-checks arguments passed to a function call with the given signature. The function and its arguments may be generic, and possibly partially instantiated. targs and xlist are the function's type arguments (and corresponding expressions). args are the function arguments. If an argument args[i] is a partially instantiated generic function, atargs[i] are the corresponding type arguments. If the callee is variadic, arguments adjusts its signature to match the provided arguments. The type parameters and arguments of the callee and all its arguments are used together to infer any missing type arguments, and the callee and argument functions are instantiated as necessary. The result signature is the (possibly adjusted and instantiated) function signature. If an error occurred, the result signature is the incoming sig."
      },
      {
        "name": "arityMatch",
        "desc": "arityMatch checks that the lhs and rhs of a const or var decl have the appropriate number of names and init exprs. For const decls, init is the value spec providing the init exprs; for var decls, init is nil (the init exprs are in s in this case)."
      },
      {
        "name": "arrayLength",
        "desc": "arrayLength type-checks the array length expression e and returns the constant length \u003e= 0, or a value \u003c 0 to indicate an error (and thus an unknown length)."
      },
      {
        "name": "assertableTo",
        "desc": "assertableTo reports whether a value of type V can be asserted to have type T. The receiver may be nil if assertableTo is invoked through an exported API call (such as AssertableTo), i.e., when all methods have been type-checked. The underlying type of V must be an interface. If the result is false and cause is not nil, *cause describes the error. TODO(gri) replace calls to this function with calls to newAssertableTo."
      },
      {
        "name": "assignError",
        "desc": ""
      },
      {
        "name": "assignVar",
        "desc": "assignVar checks the assignment lhs = rhs (if x == nil), or lhs = x (if x != nil). If x != nil, it must be the evaluation of rhs (and rhs will be ignored). If the assignment check fails and x != nil, x.mode is set to invalid."
      },
      {
        "name": "assignVars",
        "desc": "assignVars type-checks assignments of expressions orig_rhs to variables lhs."
      },
      {
        "name": "assignment",
        "desc": "assignment reports whether x can be assigned to a variable of type T, if necessary by attempting to convert untyped values to the appropriate type. context describes the context in which the assignment takes place. Use T == nil to indicate assignment to an untyped blank identifier. If the assignment check fails, x.mode is set to invalid."
      },
      {
        "name": "basicLit",
        "desc": ""
      },
      {
        "name": "binary",
        "desc": "If e != nil, it must be the binary expression; it may be nil for non-constant expressions (when invoked for an assignment operation where the binary expression is implicit)."
      },
      {
        "name": "blockBranches",
        "desc": "blockBranches processes a block's statement list and returns the set of outgoing forward jumps. all is the scope of all declared labels, parent the set of labels declared in the immediately enclosing block, and lstmt is the labeled statement this block is associated with (or nil)."
      },
      {
        "name": "bound",
        "desc": ""
      },
      {
        "name": "brokenAlias",
        "desc": "brokenAlias records that alias doesn't have a determined type yet. It also sets alias.typ to Typ[Invalid]. Not used if check.conf._EnableAlias is set."
      },
      {
        "name": "builtin",
        "desc": "builtin type-checks a call to the built-in specified by id and reports whether the call is valid, with *x holding the result; but x.expr is not set. If the call is invalid, the result is false, and *x is undefined."
      },
      {
        "name": "callExpr",
        "desc": ""
      },
      {
        "name": "caseTypes",
        "desc": "caseTypes typechecks the type expressions of a type case, checks for duplicate types using the seen map, and verifies that each type is valid with respect to the type of the operand x corresponding to the type switch expression. If that expression is not valid, x must be nil.  \tswitch \u003cx\u003e.(type) { \tcase \u003ctypes\u003e: ... \t... \t}  caseTypes returns the case-specific type for a variable v introduced through a short variable declaration by the type switch:  \tswitch v := \u003cx\u003e.(type) { \tcase \u003ctypes\u003e: // T is the type of \u003cv\u003e in this case \t... \t}  If there is exactly one type expression, T is the type of that expression. If there are multiple type expressions, or if predeclared nil is among the types, the result is the type of x. If x is invalid (nil), the result is the invalid type."
      },
      {
        "name": "caseTypes_currently_unused",
        "desc": "TODO(gri) Once we are certain that typeHash is correct in all situations, use this version of caseTypes instead. (Currently it may be possible that different types have identical names and import paths due to ImporterFrom.)"
      },
      {
        "name": "caseValues",
        "desc": ""
      },
      {
        "name": "chanElem",
        "desc": "chanElem returns the channel element type of x for a receive from x (recv == true) or send to x (recv == false) operation. If the operation is not valid, chanElem reports an error and returns nil."
      },
      {
        "name": "checkFieldUniqueness",
        "desc": ""
      },
      {
        "name": "checkFiles",
        "desc": "checkFiles type-checks the specified files. Errors are reported as a side effect, not by returning early, to ensure that well-formed syntax is properly type annotated even in a package containing errors."
      },
      {
        "name": "cleanup",
        "desc": "cleanup runs cleanup for all collected cleaners."
      },
      {
        "name": "closeScope",
        "desc": ""
      },
      {
        "name": "collectMethods",
        "desc": ""
      },
      {
        "name": "collectObjects",
        "desc": "collectObjects collects all file and package objects and inserts them into their respective scopes. It also performs imports and associates methods with receiver base type names."
      },
      {
        "name": "collectParams",
        "desc": "collectParams collects (but does not declare) all parameter/result variables of list and returns the list of names and corresponding variables, and whether the (parameter) list is variadic. Anonymous parameters are recorded with nil names."
      },
      {
        "name": "collectRecv",
        "desc": "collectRecv extracts the method receiver and its type parameters (if any) from rparam. It declares the type parameters (but not the receiver) in the current scope, and returns the receiver variable and its type parameter list (if any)."
      },
      {
        "name": "collectTypeParams",
        "desc": ""
      },
      {
        "name": "comparison",
        "desc": "If switchCase is true, the operator op is ignored."
      },
      {
        "name": "compositeLit",
        "desc": ""
      },
      {
        "name": "constDecl",
        "desc": ""
      },
      {
        "name": "context",
        "desc": "context returns the type-checker context."
      },
      {
        "name": "conversion",
        "desc": "conversion type-checks the conversion T(x). The result is in x."
      },
      {
        "name": "convertUntyped",
        "desc": "convertUntyped attempts to set the type of an untyped value to the target type."
      },
      {
        "name": "cycleError",
        "desc": "cycleError reports a declaration cycle starting with the object at cycle[start]."
      },
      {
        "name": "declStmt",
        "desc": ""
      },
      {
        "name": "declare",
        "desc": ""
      },
      {
        "name": "declareInSet",
        "desc": ""
      },
      {
        "name": "declareParams",
        "desc": "declareParams declares each named parameter in the current scope."
      },
      {
        "name": "declarePkgObj",
        "desc": "declarePkgObj declares obj in the package scope, records its ident -\u003e obj mapping, and updates check.objMap. The object must not be a function or method."
      },
      {
        "name": "declareTypeParam",
        "desc": ""
      },
      {
        "name": "definedType",
        "desc": "definedType is like typ but also accepts a type name def. If def != nil, e is the type specification for the type named def, declared in a type declaration, and def.typ.underlying will be set to the type of e before any components of e are type-checked."
      },
      {
        "name": "dump",
        "desc": "dump is only needed for debugging"
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "errorUnusedPkg",
        "desc": ""
      },
      {
        "name": "errorf",
        "desc": ""
      },
      {
        "name": "exclude",
        "desc": "exclude reports an error if x.mode is in modeset and sets x.mode to invalid. The modeset may contain any of 1\u003c\u003cnovalue, 1\u003c\u003cbuiltin, 1\u003c\u003ctypexpr."
      },
      {
        "name": "expr",
        "desc": "expr typechecks expression e and initializes x with the expression value. If a non-nil target T is given and e is a generic function or a function call, T is used to infer the type arguments for e. The result must be a single value. If an error occurred, x.mode is set to invalid."
      },
      {
        "name": "exprInternal",
        "desc": "exprInternal contains the core of type checking of expressions. Must only be called by rawExpr. (See rawExpr for an explanation of the parameters.)"
      },
      {
        "name": "exprList",
        "desc": "exprList evaluates a list of expressions and returns the corresponding operands. A single-element expression list may evaluate to multiple operands."
      },
      {
        "name": "exprOrType",
        "desc": "exprOrType typechecks expression or type e and initializes x with the expression value or type. If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function value. If an error occurred, x.mode is set to invalid."
      },
      {
        "name": "exprWithHint",
        "desc": "exprWithHint typechecks expression e and initializes x with the expression value; hint is the type of a composite literal element. If an error occurred, x.mode is set to invalid."
      },
      {
        "name": "filename",
        "desc": "filename returns a filename suitable for debugging output."
      },
      {
        "name": "funcBody",
        "desc": "decl may be nil"
      },
      {
        "name": "funcDecl",
        "desc": ""
      },
      {
        "name": "funcInst",
        "desc": "funcInst type-checks a function instantiation. The incoming x must be a generic function. If ix != nil, it provides some or all of the type arguments (ix.Indices). If target != nil, it may be used to infer missing type arguments of x, if any. At least one of T or ix must be provided.  There are two modes of operation:   1. If infer == true, funcInst infers missing type arguments as needed and     instantiates the function x. The returned results are nil.   2. If infer == false and inst provides all type arguments, funcInst     instantiates the function x. The returned results are nil.     If inst doesn't provide enough type arguments, funcInst returns the     available arguments; x remains unchanged.  If an error (other than a version error) occurs in any case, it is reported and x.mode is set to invalid."
      },
      {
        "name": "funcLit",
        "desc": ""
      },
      {
        "name": "funcString",
        "desc": "funcString returns a string of the form name + signature for f. check may be nil."
      },
      {
        "name": "funcType",
        "desc": "funcType type-checks a function or method type."
      },
      {
        "name": "genericExpr",
        "desc": "genericExpr is like expr but the result may also be generic."
      },
      {
        "name": "genericExprList",
        "desc": "genericExprList is like exprList but result operands may be uninstantiated or partially instantiated generic functions (where constraint information is insufficient to infer the missing type arguments) for Go 1.21 and later. For each non-generic or uninstantiated generic operand, the corresponding targsList and elements do not exist (targsList is nil) or the elements are nil. For each partially instantiated generic function operand, the corresponding targsList elements are the operand's partial type arguments."
      },
      {
        "name": "genericType",
        "desc": "genericType is like typ but the type must be an (uninstantiated) generic type. If cause is non-nil and the type expression was a valid type but not generic, cause will be populated with a message describing the error.  Note: If the type expression was invalid and an error was reported before, cause will not be populated; thus cause alone cannot be used to determine if an error occurred."
      },
      {
        "name": "handleBailout",
        "desc": ""
      },
      {
        "name": "handleError",
        "desc": "handleError should only be called by error_.report."
      },
      {
        "name": "hasAllMethods",
        "desc": "hasAllMethods is similar to checkMissingMethod but instead reports whether all methods are present. If V is not a valid type, or if it is a struct containing embedded fields with invalid types, the result is true because it is not possible to say with certainty whether a method is missing or not (an embedded field may have the method in question). If the result is false and cause is not nil, *cause describes the error. Use hasAllMethods to avoid follow-on errors due to incorrect types."
      },
      {
        "name": "ident",
        "desc": "ident type-checks identifier e and initializes x with the value or type of e. If an error occurred, x.mode is set to invalid. For the meaning of def, see Checker.definedType, below. If wantType is set, the identifier e is expected to denote a type."
      },
      {
        "name": "implements",
        "desc": "implements checks if V implements T. The receiver may be nil if implements is called through an exported API call such as AssignableTo. If constraint is set, T is a type constraint.  If the provided cause is non-nil, it may be set to an error string explaining why V does not implement (or satisfy, for constraints) T."
      },
      {
        "name": "implicitTypeAndValue",
        "desc": "implicitTypeAndValue returns the implicit type of x when used in a context where the target type is expected. If no such implicit conversion is possible, it returns a nil Type and non-zero error code.  If x is a constant operand, the returned constant.Value will be the representation of x in this context."
      },
      {
        "name": "importPackage",
        "desc": ""
      },
      {
        "name": "incomparableCause",
        "desc": "incomparableCause returns a more specific cause why typ is not comparable. If there is no more specific cause, the result is \"\"."
      },
      {
        "name": "index",
        "desc": "index checks an index expression for validity. If max \u003e= 0, it is the upper bound for index. If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type. If the result val \u003e= 0, index is valid and val is its constant int value."
      },
      {
        "name": "indexExpr",
        "desc": "If e is a valid function instantiation, indexExpr returns true. In that case x represents the uninstantiated function value and it is the caller's responsibility to instantiate the function."
      },
      {
        "name": "indexedElts",
        "desc": "indexedElts checks the elements (elts) of an array or slice composite literal against the literal's element type (typ), and the element indices against the literal length if known (length \u003e= 0). It returns the length of the literal (maximum index value + 1)."
      },
      {
        "name": "infer",
        "desc": "infer attempts to infer the complete set of type arguments for generic function instantiation/call based on the given type parameters tparams, type arguments targs, function parameters params, and function arguments args, if any. There must be at least one type parameter, no more type arguments than type parameters, and params and args must match in number (incl. zero). If reverse is set, an error message's contents are reversed for a better error message for some errors related to reverse type inference (where the function call is synthetic). If successful, infer returns the complete list of given and inferred type arguments, one for each type parameter. Otherwise the result is nil. Errors are reported through the err parameter. Note: infer may fail (return nil) due to invalid args operands without reporting additional errors."
      },
      {
        "name": "initConst",
        "desc": ""
      },
      {
        "name": "initFiles",
        "desc": "initFiles initializes the files-specific portion of checker. The provided files must all belong to the same package."
      },
      {
        "name": "initOrder",
        "desc": "initOrder computes the Info.InitOrder for package variables."
      },
      {
        "name": "initVar",
        "desc": "initVar checks the initialization lhs = x in a variable declaration. If lhs doesn't have a type yet, it is given the type of x, or Typ[Invalid] in case of an error. If the initialization check fails, x.mode is set to invalid."
      },
      {
        "name": "initVars",
        "desc": "initVars type-checks assignments of initialization expressions orig_rhs to variables lhs. If returnStmt is non-nil, initVars type-checks the implicit assignment of result expressions orig_rhs to function result parameters lhs."
      },
      {
        "name": "instance",
        "desc": "instance instantiates the given original (generic) function or type with the provided type arguments and returns the resulting instance. If an identical instance exists already in the given contexts, it returns that instance, otherwise it creates a new one. If there is an error (such as wrong number of type arguments), the result is Typ[Invalid].  If expanding is non-nil, it is the Named instance type currently being expanded. If ctxt is non-nil, it is the context associated with the current type-checking pass or call to Instantiate. At least one of expanding or ctxt must be non-nil.  For Named types the resulting instance may be unexpanded.  check may be nil (when not type-checking syntax); pos is used only only if check is non-nil."
      },
      {
        "name": "instantiateSignature",
        "desc": ""
      },
      {
        "name": "instantiatedType",
        "desc": ""
      },
      {
        "name": "interfacePtrError",
        "desc": "check may be nil."
      },
      {
        "name": "interfaceType",
        "desc": ""
      },
      {
        "name": "invalidConversion",
        "desc": ""
      },
      {
        "name": "isBrokenAlias",
        "desc": "isBrokenAlias reports whether alias doesn't have a determined type yet."
      },
      {
        "name": "isImportedConstraint",
        "desc": "isImportedConstraint reports whether typ is an imported type constraint."
      },
      {
        "name": "isNil",
        "desc": "isNil reports whether the expression e denotes the predeclared value nil."
      },
      {
        "name": "isTerminating",
        "desc": "isTerminating reports if s is a terminating statement. If s is labeled, label is the label name; otherwise s is \"\"."
      },
      {
        "name": "isTerminatingList",
        "desc": ""
      },
      {
        "name": "isTerminatingSwitch",
        "desc": ""
      },
      {
        "name": "isValidIndex",
        "desc": ""
      },
      {
        "name": "labels",
        "desc": "labels checks correct label use in body."
      },
      {
        "name": "langCompat",
        "desc": "langCompat reports an error if the representation of a numeric literal is not compatible with the current language version."
      },
      {
        "name": "later",
        "desc": "later pushes f on to the stack of actions that will be processed later; either at the end of the current statement, or in case of a local constant or variable declaration, before the constant or variable is in scope (so that f still sees the scope before any new declarations). later returns the pushed action so one can provide a description via action.describef for debugging, if desired."
      },
      {
        "name": "lhsVar",
        "desc": "lhsVar checks a lhs variable in an assignment and returns its type. lhsVar takes care of not counting a lhs identifier as a \"use\" of that identifier. The result is nil if it is the blank identifier, and Typ[Invalid] if it is an invalid lhs expression."
      },
      {
        "name": "lookup",
        "desc": "lookup is like lookupScope but it only returns the object (or nil)."
      },
      {
        "name": "lookupError",
        "desc": "lookupError returns a case-specific error when a lookup of selector sel in the given type fails but an object with alternative spelling (case folding) is found. If structLit is set, the error message is specifically for struct literal fields."
      },
      {
        "name": "lookupScope",
        "desc": "lookupScope looks up name in the current environment and if an object is found it returns the scope containing the object and the object. Otherwise it returns (nil, nil).  Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Scope.Insert). This can only happen for dot-imported objects whose parent is the scope of the package that exported them."
      },
      {
        "name": "markImports",
        "desc": "markImports recursively walks pkg and its imports, to record unique import paths in pkgPathMap."
      },
      {
        "name": "matchTypes",
        "desc": "matchTypes attempts to convert any untyped types x and y such that they match. If an error occurs, x.mode is set to invalid."
      },
      {
        "name": "missingMethod",
        "desc": "missingMethod is like MissingMethod but accepts a *Checker as receiver, a comparator equivalent for type comparison, and a *string for error causes. The receiver may be nil if missingMethod is invoked through an exported API call (such as MissingMethod), i.e., when all methods have been type- checked. The underlying type of T must be an interface; T (rather than its under- lying type) is used for better error messages (reported through *cause). The comparator is used to compare signatures. If a method is missing and cause is not nil, *cause describes the error."
      },
      {
        "name": "monomorph",
        "desc": ""
      },
      {
        "name": "multiExpr",
        "desc": "multiExpr typechecks e and returns its value (or values) in list. If allowCommaOk is set and e is a map index, comma-ok, or comma-err expression, the result is a two-element list containing the value of e, and an untyped bool value or an error value, respectively. If an error occurred, list[0] is not valid."
      },
      {
        "name": "multipleDefaults",
        "desc": ""
      },
      {
        "name": "needsCleanup",
        "desc": "needsCleanup records objects/types that implement the cleanup method which will be called at the end of type-checking."
      },
      {
        "name": "newAlias",
        "desc": "newAlias creates a new Alias type with the given type name and rhs. rhs must not be nil."
      },
      {
        "name": "newAliasInstance",
        "desc": "newAliasInstance creates a new alias instance for the given origin and type arguments, recording pos as the position of its synthetic object (for error reporting)."
      },
      {
        "name": "newAssertableTo",
        "desc": "newAssertableTo reports whether a value of type V can be asserted to have type T. It also implements behavior for interfaces that currently are only permitted in constraint position (we have not yet defined that behavior in the spec). The underlying type of V must be an interface. If the result is false and cause is not nil, *cause is set to the error cause."
      },
      {
        "name": "newError",
        "desc": "newError returns a new error_ with the given error code."
      },
      {
        "name": "newInterface",
        "desc": "check may be nil"
      },
      {
        "name": "newNamed",
        "desc": "newNamed is like NewNamed but with a *Checker receiver."
      },
      {
        "name": "newNamedInstance",
        "desc": "newNamedInstance creates a new named instance for the given origin and type arguments, recording pos as the position of its synthetic object (for error reporting).  If set, expanding is the named type instance currently being expanded, that led to the creation of this instance."
      },
      {
        "name": "newTypeParam",
        "desc": "check may be nil"
      },
      {
        "name": "nonGeneric",
        "desc": "If x is a generic type, or a generic function whose type arguments cannot be inferred from a non-nil target T, nonGeneric reports an error and invalidates x.mode and x.typ. Otherwise it leaves x alone."
      },
      {
        "name": "objDecl",
        "desc": "objDecl type-checks the declaration of obj in its respective (file) environment. For the meaning of def, see Checker.definedType, in typexpr.go."
      },
      {
        "name": "op",
        "desc": ""
      },
      {
        "name": "openScope",
        "desc": ""
      },
      {
        "name": "overflow",
        "desc": "overflow checks that the constant x is representable by its type. For untyped constants, it checks that the value doesn't become arbitrarily large."
      },
      {
        "name": "packageObjects",
        "desc": "packageObjects typechecks all package objects, but not function bodies."
      },
      {
        "name": "pop",
        "desc": "pop pops and returns the topmost object from the object path."
      },
      {
        "name": "popPos",
        "desc": "popPos pops from the pos stack."
      },
      {
        "name": "processDelayed",
        "desc": "processDelayed processes all delayed actions pushed after top."
      },
      {
        "name": "push",
        "desc": "push pushes obj onto the object path and returns its index in the path."
      },
      {
        "name": "pushPos",
        "desc": "pushPos pushes pos onto the pos stack."
      },
      {
        "name": "qualifier",
        "desc": ""
      },
      {
        "name": "rangeStmt",
        "desc": "rangeStmt type-checks a range statement of form  \tfor sKey, sValue = range rangeVar { ... }  where sKey, sValue, sExtra may be nil. isDef indicates whether these variables are assigned to only (=) or whether there is a short variable declaration (:=). If the latter and there are no variables, an error is reported at noNewVarPos."
      },
      {
        "name": "rawExpr",
        "desc": "rawExpr typechecks expression e and initializes x with the expression value or type. If an error occurred, x.mode is set to invalid. If a non-nil target T is given and e is a generic function, T is used to infer the type arguments for e. If hint != nil, it is the type of a composite literal element. If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function value."
      },
      {
        "name": "record",
        "desc": ""
      },
      {
        "name": "recordBuiltinType",
        "desc": ""
      },
      {
        "name": "recordCommaOkTypes",
        "desc": "recordCommaOkTypes updates recorded types to reflect that x is used in a commaOk context (and therefore has tuple type)."
      },
      {
        "name": "recordCommaOkTypesInSyntax",
        "desc": "go/types doesn't support recording of types directly in the AST. dummy function to match types2 code."
      },
      {
        "name": "recordDef",
        "desc": ""
      },
      {
        "name": "recordImplicit",
        "desc": ""
      },
      {
        "name": "recordInstance",
        "desc": "recordInstance records instantiation information into check.Info, if the Instances map is non-nil. The given expr must be an ident, selector, or index (list) expr with ident or selector operand.  TODO(rfindley): the expr parameter is fragile. See if we can access the instantiated identifier in some other way."
      },
      {
        "name": "recordParenthesizedRecvTypes",
        "desc": "recordParenthesizedRecvTypes records parenthesized intermediate receiver type expressions that all map to the same type, by recursively unpacking expr and recording the corresponding type for it. Example:  \texpression  --\u003e  type \t---------------------- \t(*(T[P]))        *T[P] \t *(T[P])         *T[P] \t  (T[P])          T[P] \t   T[P]           T[P]"
      },
      {
        "name": "recordScope",
        "desc": ""
      },
      {
        "name": "recordSelection",
        "desc": ""
      },
      {
        "name": "recordTypeAndValue",
        "desc": ""
      },
      {
        "name": "recordTypeAndValueInSyntax",
        "desc": "go/types doesn't support recording of types directly in the AST. dummy function to match types2 code."
      },
      {
        "name": "recordUntyped",
        "desc": ""
      },
      {
        "name": "recordUse",
        "desc": ""
      },
      {
        "name": "rememberUntyped",
        "desc": ""
      },
      {
        "name": "renameTParams",
        "desc": "renameTParams renames the type parameters in the given type such that each type parameter is given a new identity. renameTParams returns the new type parameters and updated type. If the result type is unchanged from the argument type, none of the type parameters in tparams occurred in the type. If typ is a generic function, type parameters held with typ are not changed and must be updated separately if desired. The positions is only used for debug traces."
      },
      {
        "name": "reportCycle",
        "desc": "reportCycle reports an error for the given cycle."
      },
      {
        "name": "reportInstanceLoop",
        "desc": ""
      },
      {
        "name": "representable",
        "desc": "representable checks that a constant operand is representable in the given basic type."
      },
      {
        "name": "representation",
        "desc": "representation returns the representation of the constant operand x as the basic type typ.  If no such representation is possible, it returns a non-zero error code."
      },
      {
        "name": "resolveBaseTypeName",
        "desc": "resolveBaseTypeName returns the non-alias base type name for the given name, and whether there was a pointer indirection to get to it. The base type name must be declared in package scope, and there can be at most one pointer indirection. Traversals through generic alias types are not permitted. If no such type name exists, the returned base is nil."
      },
      {
        "name": "returnError",
        "desc": ""
      },
      {
        "name": "selector",
        "desc": ""
      },
      {
        "name": "shift",
        "desc": "If e != nil, it must be the shift expression; it may be nil for non-constant shifts."
      },
      {
        "name": "shortVarDecl",
        "desc": ""
      },
      {
        "name": "simpleStmt",
        "desc": ""
      },
      {
        "name": "singleIndex",
        "desc": "singleIndex returns the (single) index from the index expression e. If the index is missing, or if there are multiple indices, an error is reported and the result is nil."
      },
      {
        "name": "singleValue",
        "desc": "singleValue reports an error if x describes a tuple and sets x.mode to invalid."
      },
      {
        "name": "sliceExpr",
        "desc": ""
      },
      {
        "name": "softErrorf",
        "desc": ""
      },
      {
        "name": "sprintf",
        "desc": "check may be nil."
      },
      {
        "name": "stmt",
        "desc": "stmt typechecks statement s."
      },
      {
        "name": "stmtList",
        "desc": ""
      },
      {
        "name": "structType",
        "desc": ""
      },
      {
        "name": "subst",
        "desc": "subst returns the type typ with its type parameters tpars replaced by the corresponding type arguments targs, recursively. subst doesn't modify the incoming type. If a substitution took place, the result type is different from the incoming type.  If expanding is non-nil, it is the instance type currently being expanded. One of expanding or ctxt must be non-nil."
      },
      {
        "name": "suspendedCall",
        "desc": ""
      },
      {
        "name": "tag",
        "desc": ""
      },
      {
        "name": "trace",
        "desc": ""
      },
      {
        "name": "typ",
        "desc": "typ type-checks the type expression e and returns its type, or Typ[Invalid]. The type must not be an (uninstantiated) generic type."
      },
      {
        "name": "typInternal",
        "desc": "typInternal drives type checking of types. Must only be called by definedType or genericType."
      },
      {
        "name": "typeAssertion",
        "desc": "typeAssertion checks x.(T). The type of x must be an interface."
      },
      {
        "name": "typeDecl",
        "desc": ""
      },
      {
        "name": "typeList",
        "desc": "typeList provides the list of types corresponding to the incoming expression list. If an error occurred, the result is nil, but all list elements were type-checked."
      },
      {
        "name": "typesSummary",
        "desc": "typesSummary returns a string of the form \"(t1, t2, ...)\" where the ti's are user-friendly string representations for the given types. If variadic is set and the last type is a slice, its string is of the form \"...E\" where E is the slice's element type. If hasDots is set, the last argument string is of the form \"T...\" where T is the last type. Only one of variadic and hasDots may be set."
      },
      {
        "name": "unary",
        "desc": "The unary expression e may be nil. It's passed in for better error messages only."
      },
      {
        "name": "unpackRecv",
        "desc": "unpackRecv unpacks a receiver type expression and returns its components: ptr indicates whether rtyp is a pointer receiver, base is the receiver base type expression stripped of its type parameters (if any), and tparams are its type parameter names, if any. The type parameters are only unpacked if unpackParams is set. For instance, given the rtyp  \t*T[A, _]  ptr is true, base is T, and tparams is [A, _] (assuming unpackParams is set). Note that base may not be a *ast.Ident for erroneous programs."
      },
      {
        "name": "unusedImports",
        "desc": "unusedImports checks for unused imports."
      },
      {
        "name": "updateExprType",
        "desc": "updateExprType updates the type of x to typ and invokes itself recursively for the operands of x, depending on expression kind. If typ is still an untyped and not the final type, updateExprType only updates the recorded untyped type for x and possibly its operands. Otherwise (i.e., typ is not an untyped type anymore, or it is the final type for x), the type and value are recorded. Also, if x is a constant, it must be representable as a value of typ, and if x is the (formerly untyped) lhs operand of a non-constant shift, it must be an integer value."
      },
      {
        "name": "updateExprVal",
        "desc": "updateExprVal updates the value of x to val."
      },
      {
        "name": "usage",
        "desc": ""
      },
      {
        "name": "use",
        "desc": "use type-checks each argument. Useful to make sure expressions are evaluated (and variables are \"used\") in the presence of other errors. Arguments may be nil. Reports if all arguments evaluated without error."
      },
      {
        "name": "use1",
        "desc": ""
      },
      {
        "name": "useLHS",
        "desc": "useLHS is like use, but doesn't \"use\" top-level identifiers. It should be called instead of use if the arguments are expressions on the lhs of an assignment."
      },
      {
        "name": "useN",
        "desc": ""
      },
      {
        "name": "validAlias",
        "desc": "validAlias records that alias has the valid type typ (possibly Typ[Invalid])."
      },
      {
        "name": "validCycle",
        "desc": "validCycle checks if the cycle starting with obj is valid and reports an error if it is not."
      },
      {
        "name": "validRecv",
        "desc": "validRecv verifies that the receiver satisfies its respective spec requirements and reports an error otherwise."
      },
      {
        "name": "validType",
        "desc": "validType verifies that the given type does not \"expand\" indefinitely producing a cycle in the type graph. (Cycles involving alias types, as in \"type A = [10]A\" are detected earlier, via the objDecl cycle detection mechanism.)"
      },
      {
        "name": "validType0",
        "desc": "validType0 checks if the given type is valid. If typ is a type parameter its value is looked up in the type argument list of the instantiated (enclosing) type, if it exists. Otherwise the type parameter must be from an enclosing function and can be ignored. The nest list describes the stack (the \"nest in memory\") of types which contain (or embed in the case of interfaces) other types. For instance, a struct named S which contains a field of named type F contains (the memory of) F in S, leading to the nest S-\u003eF. If a type appears in its own nest (say S-\u003eF-\u003eS) we have an invalid recursive type. The path list is the full path of named types in a cycle, it is only needed for error reporting."
      },
      {
        "name": "validVarType",
        "desc": "validVarType reports an error if typ is a constraint interface. The expression e is used for error reporting, if any."
      },
      {
        "name": "validateTArgLen",
        "desc": "validateTArgLen checks that the number of type arguments (got) matches the number of type parameters (want); if they don't match an error is reported. If validation fails and check is nil, validateTArgLen panics."
      },
      {
        "name": "varDecl",
        "desc": ""
      },
      {
        "name": "varType",
        "desc": "varType type-checks the type expression e and returns its type, or Typ[Invalid]. The type must not be an (uninstantiated) generic type and it must not be a constraint interface."
      },
      {
        "name": "verify",
        "desc": "check may be nil; pos is used only if check is non-nil."
      },
      {
        "name": "verifyVersionf",
        "desc": "verifyVersionf is like allowVersion but also accepts a format string and arguments which are used to report a version error if allowVersion returns false."
      },
      {
        "name": "versionErrorf",
        "desc": ""
      },
      {
        "name": "walkDecl",
        "desc": ""
      },
      {
        "name": "walkDecls",
        "desc": ""
      },
      {
        "name": "Check",
        "desc": "Check type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the [Info] struct.  The package is marked as complete if no errors occurred, otherwise it is incomplete. See [Config.Error] for controlling behavior in the presence of errors.  The package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (\".\")."
      },
      {
        "name": "alignof",
        "desc": ""
      },
      {
        "name": "offsetof",
        "desc": "offsetof returns the offset of the field specified via the index sequence relative to T. All embedded fields must be structs (rather than pointers to structs). If the offset is too large (because T is too large), the result is negative."
      },
      {
        "name": "offsetsof",
        "desc": ""
      },
      {
        "name": "sizeof",
        "desc": "sizeof returns the size of T. If T is too large, the result is negative."
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "Val",
        "desc": "Val returns the constant's value."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "isDependency",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "getID",
        "desc": "getID returns a unique ID for the type t."
      },
      {
        "name": "instanceHash",
        "desc": "instanceHash returns a string representation of typ instantiated with targs. The hash should be a perfect hash, though out of caution the type checker does not assume this. The result is guaranteed to not contain blanks."
      },
      {
        "name": "lookup",
        "desc": "lookup returns an existing instantiation of orig with targs, if it exists. Otherwise, it returns nil."
      },
      {
        "name": "update",
        "desc": "update de-duplicates inst against previously seen types with the hash h. If an identical type is found with the type hash h, the previously seen type is returned. Otherwise, inst is returned, and recorded in the Context for the hash h."
      },
      {
        "name": "Error",
        "desc": "Error returns an error string formatted as follows: filename:line:column: message"
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "FullName",
        "desc": "FullName returns the package- or receiver-type-qualified name of function or method obj."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Origin",
        "desc": "Origin returns the canonical Func for its receiver, i.e. the Func object recorded in Info.Defs.  For synthetic functions created during instantiation (such as methods on an instantiated Named type or interface methods that depend on type arguments), this will be the corresponding Func on the generic (uninstantiated) type. For all other Funcs Origin returns the receiver."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the function belongs.  The result is nil for methods of types in the Universe scope, like method Error of the error built-in interface type."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "Scope",
        "desc": "Scope returns the scope of the function's body block. The result is nil for imported or instantiated functions and methods (but there is also no mechanism to get to an instantiated function)."
      },
      {
        "name": "Signature",
        "desc": "Signature returns the signature (type) of the function or method."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "hasPtrRecv",
        "desc": "hasPtrRecv reports whether the receiver is of the form *T for the given method obj."
      },
      {
        "name": "isDependency",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "ObjectOf",
        "desc": "ObjectOf returns the object denoted by the specified id, or nil if not found.  If id is an embedded struct field, [Info.ObjectOf] returns the field (*[Var]) it defines, not the type (*[TypeName]) it uses.  Precondition: the Uses and Defs maps are populated."
      },
      {
        "name": "PkgNameOf",
        "desc": "PkgNameOf returns the local package name defined by the import, or nil if not found.  For dot-imports, the package name is \".\".  Precondition: the Defs and Implicts maps are populated."
      },
      {
        "name": "TypeOf",
        "desc": "TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated."
      },
      {
        "name": "recordTypes",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Complete",
        "desc": "Complete computes the interface's type set. It must be called by users of [NewInterfaceType] and [NewInterface] after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. The interface must not contain duplicate methods or a panic occurs. Complete returns the receiver.  Interface types that have been completed are safe for concurrent use."
      },
      {
        "name": "Embedded",
        "desc": "Embedded returns the i'th embedded defined (*[Named]) type of interface t for 0 \u003c= i \u003c t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type.  Deprecated: Use [Interface.EmbeddedType] which is not restricted to defined (*[Named]) types."
      },
      {
        "name": "EmbeddedType",
        "desc": "EmbeddedType returns the i'th embedded type of interface t for 0 \u003c= i \u003c t.NumEmbeddeds()."
      },
      {
        "name": "EmbeddedTypes",
        "desc": "EmbeddedTypes returns a go1.23 iterator over the types embedded within an interface.  Example: for e := range t.EmbeddedTypes() { ... }"
      },
      {
        "name": "Empty",
        "desc": "Empty reports whether t is the empty interface."
      },
      {
        "name": "ExplicitMethod",
        "desc": "ExplicitMethod returns the i'th explicitly declared method of interface t for 0 \u003c= i \u003c t.NumExplicitMethods(). The methods are ordered by their unique [Id]."
      },
      {
        "name": "ExplicitMethods",
        "desc": "ExplicitMethods returns a go1.23 iterator over the explicit methods of an interface, ordered by Id.  Example: for m := range t.ExplicitMethods() { ... }"
      },
      {
        "name": "IsComparable",
        "desc": "IsComparable reports whether each type in interface t's type set is comparable."
      },
      {
        "name": "IsImplicit",
        "desc": "IsImplicit reports whether the interface t is a wrapper for a type set literal."
      },
      {
        "name": "IsMethodSet",
        "desc": "IsMethodSet reports whether the interface t is fully described by its method set."
      },
      {
        "name": "MarkImplicit",
        "desc": "MarkImplicit marks the interface t as implicit, meaning this interface corresponds to a constraint literal such as ~T or A|B without explicit interface embedding. MarkImplicit should be called before any concurrent use of implicit interfaces."
      },
      {
        "name": "Method",
        "desc": "Method returns the i'th method of interface t for 0 \u003c= i \u003c t.NumMethods(). The methods are ordered by their unique Id."
      },
      {
        "name": "Methods",
        "desc": "Methods returns a go1.23 iterator over all the methods of an interface, ordered by Id.  Example: for m := range t.Methods() { ... }"
      },
      {
        "name": "NumEmbeddeds",
        "desc": "NumEmbeddeds returns the number of embedded types in interface t."
      },
      {
        "name": "NumExplicitMethods",
        "desc": "NumExplicitMethods returns the number of explicitly declared methods of interface t."
      },
      {
        "name": "NumMethods",
        "desc": "NumMethods returns the total number of methods of interface t."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "cleanup",
        "desc": ""
      },
      {
        "name": "typeSet",
        "desc": "typeSet returns the type set for interface t."
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "Elem",
        "desc": "Elem returns the element type of map m."
      },
      {
        "name": "Key",
        "desc": "Key returns the key type of map m."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "At",
        "desc": "At returns the i'th method in s for 0 \u003c= i \u003c s.Len()."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of methods in s."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the method with matching package and name, or nil if not found."
      },
      {
        "name": "Methods",
        "desc": "Methods returns a go1.23 iterator over the methods of a method set.  Example: for method := range s.Methods() { ... }"
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "AddMethod",
        "desc": "AddMethod adds method m unless it is already in the method list. The method must be in the same package as t, and t must not have type arguments."
      },
      {
        "name": "Method",
        "desc": "Method returns the i'th method of named type t for 0 \u003c= i \u003c t.NumMethods().  For an ordinary or instantiated type t, the receiver base type of this method is the named type t. For an uninstantiated generic type t, each method receiver is instantiated with its receiver type parameters.  Methods are numbered deterministically: given the same list of source files presented to the type checker, or the same sequence of NewMethod and AddMethod calls, the mapping from method index to corresponding method remains the same. But the specific ordering is not specified and must not be relied on as it may change in the future."
      },
      {
        "name": "Methods",
        "desc": "Methods returns a go1.23 iterator over the declared methods of a named type.  Example: for m := range t.Methods() { ... }"
      },
      {
        "name": "NumMethods",
        "desc": "NumMethods returns the number of explicit methods defined for t."
      },
      {
        "name": "Obj",
        "desc": "Obj returns the type name for the declaration defining the named type t. For instantiated types, this is same as the type name of the origin type."
      },
      {
        "name": "Origin",
        "desc": "Origin returns the generic type from which the named type t is instantiated. If t is not an instantiated type, the result is t."
      },
      {
        "name": "SetTypeParams",
        "desc": "SetTypeParams sets the type parameters of the named type t. t must not have type arguments."
      },
      {
        "name": "SetUnderlying",
        "desc": "SetUnderlying sets the underlying type and marks t as complete. t must not have type arguments."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "TypeArgs",
        "desc": "TypeArgs returns the type arguments used to instantiate the named type t."
      },
      {
        "name": "TypeParams",
        "desc": "TypeParams returns the type parameters of the named type t, or nil. The result is non-nil for an (originally) generic type even if it is instantiated."
      },
      {
        "name": "Underlying",
        "desc": "Underlying returns the [underlying type] of the named type t, resolving all forwarding declarations. Underlying types are never Named, TypeParam, or Alias types.  [underlying type]: https://go.dev/ref/spec#Underlying_types."
      },
      {
        "name": "cleanup",
        "desc": ""
      },
      {
        "name": "expandMethod",
        "desc": "expandMethod substitutes type arguments in the i'th method for an instantiated receiver."
      },
      {
        "name": "expandUnderlying",
        "desc": "expandUnderlying substitutes type arguments in the underlying type n.orig, returning the result. Returns Typ[Invalid] if there was an error."
      },
      {
        "name": "lookupMethod",
        "desc": ""
      },
      {
        "name": "methodIndex",
        "desc": "methodIndex returns the index of the method with the given name. If foldCase is set, capitalization in the name is ignored. The result is negative if no such method exists."
      },
      {
        "name": "resolve",
        "desc": "resolve resolves the type parameters, methods, and underlying type of n. This information may be loaded from a provided loader function, or computed from an origin type (in the case of instances).  After resolution, the type parameters, methods, and underlying type of n are accessible; but if n is an instantiated type, its methods may still be unexpanded."
      },
      {
        "name": "setState",
        "desc": "setState atomically stores the given state for n. Must only be called while holding n.mu."
      },
      {
        "name": "state",
        "desc": "state atomically accesses the current state of the receiver."
      },
      {
        "name": "under",
        "desc": "under returns the expanded underlying type of n0; possibly by following forward chains of named types. If an underlying type is found, resolve the chain by setting the underlying type for each defined type in the chain before returning it. If no underlying type is found or a cycle is detected, the result is Typ[Invalid]. If a cycle is detected and n0.check != nil, the cycle is reported.  This is necessary because the underlying type of named may be itself a named type that is incomplete:  \ttype ( \t\tA B \t\tB *C \t\tC A \t)  The type of C is the (named) type of A which is incomplete, and which has as its underlying type the named type B."
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "Complete",
        "desc": "A package is complete if its scope contains (at least) all exported objects; otherwise it is incomplete."
      },
      {
        "name": "GoVersion",
        "desc": "GoVersion returns the minimum Go version required by this package. If the minimum version is unknown, GoVersion returns the empty string. Individual source files may specify a different minimum Go version, as reported in the [go/ast.File.GoVersion] field."
      },
      {
        "name": "Imports",
        "desc": "Imports returns the list of packages directly imported by pkg; the list is in source order.  If pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code.  If pkg uses cgo and the FakeImportC configuration option was enabled, the imports list may contain a fake \"C\" package."
      },
      {
        "name": "MarkComplete",
        "desc": "MarkComplete marks a package as complete."
      },
      {
        "name": "Name",
        "desc": "Name returns the package name."
      },
      {
        "name": "Path",
        "desc": "Path returns the package path."
      },
      {
        "name": "Scope",
        "desc": "Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs). For a nil pkg receiver, Scope returns the Universe scope."
      },
      {
        "name": "SetImports",
        "desc": "SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique."
      },
      {
        "name": "SetName",
        "desc": "SetName sets the package name."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Imported",
        "desc": "Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "Elem",
        "desc": "Elem returns the element type for the given pointer p."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Child",
        "desc": "Child returns the i'th child scope for 0 \u003c= i \u003c NumChildren()."
      },
      {
        "name": "Children",
        "desc": "Children returns a go1.23 iterator over the child scopes nested within scope s.  Example: for child := range scope.Children() { ... }"
      },
      {
        "name": "Contains",
        "desc": "Contains reports whether pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information."
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Innermost",
        "desc": "Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information."
      },
      {
        "name": "Insert",
        "desc": "Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of scope elements."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil."
      },
      {
        "name": "LookupParent",
        "desc": "LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil). The results are guaranteed to be valid only if the type-checked AST has complete position information.  Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert). This can only happen for dot-imported objects whose parent is the scope of the package that exported them."
      },
      {
        "name": "Names",
        "desc": "Names returns the scope's element names in sorted order."
      },
      {
        "name": "NumChildren",
        "desc": "NumChildren returns the number of scopes nested in s."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope's containing (parent) scope."
      },
      {
        "name": "Pos",
        "desc": "Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes."
      },
      {
        "name": "String",
        "desc": "String returns a string representation of the scope, for debugging."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n \u003e= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes."
      },
      {
        "name": "_InsertLazy",
        "desc": "InsertLazy is like Insert, but allows deferring construction of the inserted object until it's accessed with Lookup. The Object returned by resolve must have the same name as given to InsertLazy. If s already contains an alternative object with the same name, InsertLazy leaves s unchanged and returns false. Otherwise it records the binding and returns true. The object's parent scope will be set to s after resolve is called."
      },
      {
        "name": "insert",
        "desc": ""
      },
      {
        "name": "lookupIgnoringCase",
        "desc": "lookupIgnoringCase returns the objects in scope s whose names match the given name ignoring case. If exported is set, only exported names are returned."
      },
      {
        "name": "Index",
        "desc": "Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:   1. the list of declared methods of a named type; or  2. the list of methods of an interface type; or  3. the list of fields of a struct type.  The earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0."
      },
      {
        "name": "Indirect",
        "desc": "Indirect reports whether any pointer indirection was required to get from x to f in x.f.  Beware: Indirect spuriously returns true (Go issue #8353) for a MethodVal selection in which the receiver argument and parameter both have type *T so there is no indirection. Unfortunately, a fix is too risky."
      },
      {
        "name": "Kind",
        "desc": "Kind returns the selection kind."
      },
      {
        "name": "Obj",
        "desc": "Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases."
      },
      {
        "name": "Recv",
        "desc": "Recv returns the type of x in x.f."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the type of x.f, which may be different from the type of f. See Selection for more information."
      },
      {
        "name": "Params",
        "desc": "Params returns the parameters of signature s, or nil."
      },
      {
        "name": "Recv",
        "desc": "Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.  For an abstract method, Recv returns the enclosing interface either as a *[Named] or an *[Interface]. Due to embedding, an interface may contain methods whose receiver type is a different interface."
      },
      {
        "name": "RecvTypeParams",
        "desc": "RecvTypeParams returns the receiver type parameters of signature s, or nil."
      },
      {
        "name": "Results",
        "desc": "Results returns the results of signature s, or nil."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "TypeParams",
        "desc": "TypeParams returns the type parameters of signature s, or nil."
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Variadic",
        "desc": "Variadic reports whether the signature s is variadic."
      },
      {
        "name": "Elem",
        "desc": "Elem returns the element type of slice s."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Alignof",
        "desc": ""
      },
      {
        "name": "Offsetsof",
        "desc": ""
      },
      {
        "name": "Sizeof",
        "desc": ""
      },
      {
        "name": "Field",
        "desc": "Field returns the i'th field for 0 \u003c= i \u003c NumFields()."
      },
      {
        "name": "Fields",
        "desc": "Fields returns a go1.23 iterator over the fields of a struct type.  Example: for field := range s.Fields() { ... }"
      },
      {
        "name": "NumFields",
        "desc": "NumFields returns the number of fields in the struct (including blank and embedded fields)."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Tag",
        "desc": "Tag returns the i'th field tag for 0 \u003c= i \u003c NumFields()."
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "markComplete",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Tilde",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "At",
        "desc": "At returns the i'th variable of tuple t."
      },
      {
        "name": "Len",
        "desc": "Len returns the number variables of tuple t."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Variables",
        "desc": "Variables returns a go1.23 iterator over the variables of a tuple type.  Example: for v := range tuple.Variables() { ... }"
      },
      {
        "name": "Addressable",
        "desc": "Addressable reports whether the corresponding expression is addressable (https://golang.org/ref/spec#Address_operators)."
      },
      {
        "name": "Assignable",
        "desc": "Assignable reports whether the corresponding expression is assignable to (provided a value of the right type)."
      },
      {
        "name": "HasOk",
        "desc": "HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment."
      },
      {
        "name": "IsBuiltin",
        "desc": "IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function."
      },
      {
        "name": "IsNil",
        "desc": "IsNil reports whether the corresponding expression denotes the predeclared value nil."
      },
      {
        "name": "IsType",
        "desc": "IsType reports whether the corresponding expression specifies a type."
      },
      {
        "name": "IsValue",
        "desc": "IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value."
      },
      {
        "name": "IsVoid",
        "desc": "IsVoid reports whether the corresponding expression is a function call without results."
      },
      {
        "name": "At",
        "desc": "At returns the i'th type in the list."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of types in the list. It is safe to call on a nil receiver."
      },
      {
        "name": "Types",
        "desc": "Types returns a go1.23 iterator over the elements of a list of types.  Example: for t := range l.Types() { ... }"
      },
      {
        "name": "list",
        "desc": "list is for internal use where we expect a []Type. TODO(rfindley): list should probably be eliminated: we can pass around a TypeList instead."
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "IsAlias",
        "desc": "IsAlias reports whether obj is an alias name for a type."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "Constraint",
        "desc": "Constraint returns the type constraint specified for t."
      },
      {
        "name": "Index",
        "desc": "Index returns the index of the type param within its param list, or -1 if the type parameter has not yet been bound to a type."
      },
      {
        "name": "Obj",
        "desc": "Obj returns the type name for the type parameter t."
      },
      {
        "name": "SetConstraint",
        "desc": "SetConstraint sets the type constraint for t.  It must be called by users of NewTypeParam after the bound's underlying is fully defined, and before using the type parameter in any way other than to form other types. Once SetConstraint returns the receiver, t is safe for concurrent use."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Underlying",
        "desc": "Underlying returns the [underlying type] of the type parameter t, which is the underlying type of its constraint. This type is always an interface.  [underlying type]: https://go.dev/ref/spec#Underlying_types."
      },
      {
        "name": "cleanup",
        "desc": ""
      },
      {
        "name": "iface",
        "desc": "iface returns the constraint interface of t."
      },
      {
        "name": "is",
        "desc": "is calls f with the specific type terms of t's constraint and reports whether all calls to f returned true. If there are no specific terms, is returns the result of f(nil)."
      },
      {
        "name": "typeset",
        "desc": "typeset is an iterator over the (type/underlying type) pairs of the specific type terms of t's constraint. If there are no specific terms, typeset calls yield with (nil, nil). In any case, typeset is guaranteed to call yield at least once."
      },
      {
        "name": "At",
        "desc": "At returns the i'th type parameter in the list."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of type parameters in the list. It is safe to call on a nil receiver."
      },
      {
        "name": "TypeParams",
        "desc": "TypeParams returns a go1.23 iterator over a list of type parameters.  Example: for tparam := range l.TypeParams() { ... }"
      },
      {
        "name": "list",
        "desc": "list is for internal use where we expect a []*TypeParam. TODO(rfindley): list should probably be eliminated: we can pass around a TypeParamList instead."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Term",
        "desc": ""
      },
      {
        "name": "Terms",
        "desc": "Terms returns a go1.23 iterator over the terms of a union.  Example: for term := range union.Terms() { ... }"
      },
      {
        "name": "Underlying",
        "desc": ""
      },
      {
        "name": "Anonymous",
        "desc": "Anonymous reports whether the variable is an embedded field. Same as Embedded; only present for backward-compatibility."
      },
      {
        "name": "Embedded",
        "desc": "Embedded reports whether the variable is an embedded field."
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "IsField",
        "desc": "IsField reports whether the variable is a struct field."
      },
      {
        "name": "Kind",
        "desc": "Kind reports what kind of variable v is."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Origin",
        "desc": "Origin returns the canonical Var for its receiver, i.e. the Var object recorded in Info.Defs.  For synthetic Vars created during instantiation (such as struct fields or function parameters that depend on type arguments), this will be the corresponding Var on the generic (uninstantiated) type. For all other Vars Origin returns the receiver."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "SetKind",
        "desc": "SetKind sets the kind of the variable. It should be used only immediately after [NewVar] or [NewParam]."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "isDependency",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "IsAll",
        "desc": "IsAll reports whether s is the set of all types (corresponding to the empty interface)."
      },
      {
        "name": "IsComparable",
        "desc": "IsComparable reports whether each type in the set is comparable."
      },
      {
        "name": "IsEmpty",
        "desc": "IsEmpty reports whether s is the empty set."
      },
      {
        "name": "IsMethodSet",
        "desc": "IsMethodSet reports whether the interface t is fully described by its method set."
      },
      {
        "name": "LookupMethod",
        "desc": "LookupMethod returns the index of and method with matching package and name, or (-1, nil)."
      },
      {
        "name": "Method",
        "desc": "Method returns the i'th method of s for 0 \u003c= i \u003c s.NumMethods(). The methods are ordered by their unique ID."
      },
      {
        "name": "NumMethods",
        "desc": "NumMethods returns the number of methods available."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "hasTerms",
        "desc": "hasTerms reports whether s has specific type terms."
      },
      {
        "name": "is",
        "desc": "is calls f with the specific type terms of s and reports whether all calls to f returned true. If there are no specific terms, is returns the result of f(nil)."
      },
      {
        "name": "subsetOf",
        "desc": "subsetOf reports whether s1 ⊆ s2."
      },
      {
        "name": "typeset",
        "desc": "typeset is an iterator over the (type/underlying type) pairs in s. If s has no specific terms, typeset calls yield with (nil, nil). In any case, typeset is guaranteed to call yield at least once."
      },
      {
        "name": "describef",
        "desc": "If debug is set, describef sets a printf-formatted description for action a. Otherwise, it is a no-op."
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "enclosingTarget",
        "desc": "enclosingTarget returns the innermost enclosing labeled statement with the given label name, or nil."
      },
      {
        "name": "gotoTarget",
        "desc": "gotoTarget returns the labeled statement in the current or an enclosing block with the given label name, or nil."
      },
      {
        "name": "insert",
        "desc": "insert records a new label declaration for the current block. The label must not have been declared before in any block."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "identical",
        "desc": "For changes to this code the corresponding changes should be made to unifier.nify."
      },
      {
        "name": "node",
        "desc": ""
      },
      {
        "name": "typ",
        "desc": ""
      },
      {
        "name": "varList",
        "desc": ""
      },
      {
        "name": "addDep",
        "desc": "addDep adds obj to the set of objects d's init expression depends on."
      },
      {
        "name": "hasInitializer",
        "desc": "hasInitializer reports whether the declared object has an initialization expression or function body."
      },
      {
        "name": "lookup",
        "desc": "lookup is like lookupScope but it only returns the object (or nil)."
      },
      {
        "name": "lookupScope",
        "desc": "lookupScope looks up name in the current environment and if an object is found it returns the scope containing the object and the object. Otherwise it returns (nil, nil).  Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Scope.Insert). This can only happen for dot-imported objects whose parent is the scope of the package that exported them."
      },
      {
        "name": "addAltDecl",
        "desc": "addAltDecl is a specialized form of addf reporting another declaration of obj."
      },
      {
        "name": "addf",
        "desc": "addf adds formatted error information to err. It may be called multiple times to provide additional information. The position of the first call to addf determines the position of the reported Error. Subsequent calls to addf provide additional information in the form of additional lines in the error message (types2) or continuation errors identified by a tab-indented error message (go/types)."
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "msg",
        "desc": "msg returns the formatted error message without the primary error position pos()."
      },
      {
        "name": "posn",
        "desc": ""
      },
      {
        "name": "report",
        "desc": "report reports the error err, setting check.firstError if necessary."
      },
      {
        "name": "node",
        "desc": ""
      },
      {
        "name": "Alignof",
        "desc": ""
      },
      {
        "name": "Offsetsof",
        "desc": ""
      },
      {
        "name": "Sizeof",
        "desc": ""
      },
      {
        "name": "cmp",
        "desc": "cmp returns -1, 0, or +1 depending on whether x \u003c y, x == y, or x \u003e y, interpreted as Go versions."
      },
      {
        "name": "isValid",
        "desc": "isValid reports whether v is a valid Go version."
      },
      {
        "name": "cost",
        "desc": "cost returns the cost of removing this node, which involves copying each predecessor to each successor (and vice-versa)."
      },
      {
        "name": "identical",
        "desc": ""
      },
      {
        "name": "node",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "Exported",
        "desc": ""
      },
      {
        "name": "Id",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Parent",
        "desc": "stub implementations so *lazyObject implements Object and we can store them directly into Scope.elems."
      },
      {
        "name": "Pkg",
        "desc": ""
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "Add adds all functions in list to the method set s. If multiples is set, every function in list appears multiple times and is treated as a collision."
      },
      {
        "name": "addOne",
        "desc": ""
      },
      {
        "name": "addEdge",
        "desc": ""
      },
      {
        "name": "assign",
        "desc": "assign records that tpar was instantiated as targ at pos."
      },
      {
        "name": "localNamedVertex",
        "desc": "localNamedVertex returns the index of the vertex representing named, or -1 if named doesn't need representation."
      },
      {
        "name": "recordCanon",
        "desc": "recordCanon records that tpar is the canonical type parameter corresponding to method type parameter mpar."
      },
      {
        "name": "recordInstance",
        "desc": "recordInstance records that the given type parameters were instantiated with the corresponding type arguments."
      },
      {
        "name": "typeParamVertex",
        "desc": "typeParamVertex returns the index of the vertex representing tpar."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Pop",
        "desc": ""
      },
      {
        "name": "Push",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "Exported",
        "desc": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not."
      },
      {
        "name": "Id",
        "desc": "Id is a wrapper for Id(obj.Pkg(), obj.Name())."
      },
      {
        "name": "Name",
        "desc": "Name returns the object's (package-local, unqualified) name."
      },
      {
        "name": "Parent",
        "desc": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields."
      },
      {
        "name": "Pkg",
        "desc": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the declaration position of the object's identifier."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns the object's type."
      },
      {
        "name": "cmp",
        "desc": "cmp reports whether object a is ordered before object b. cmp returns:  \t-1 if a is before b \t 0 if a is equivalent to b \t+1 if a is behind b  Objects are ordered nil before non-nil, exported before non-exported, then by name, and finally (for non-exported functions) by package path."
      },
      {
        "name": "color",
        "desc": ""
      },
      {
        "name": "order",
        "desc": ""
      },
      {
        "name": "sameId",
        "desc": ""
      },
      {
        "name": "scopePos",
        "desc": ""
      },
      {
        "name": "setColor",
        "desc": ""
      },
      {
        "name": "setOrder",
        "desc": ""
      },
      {
        "name": "setParent",
        "desc": ""
      },
      {
        "name": "setScopePos",
        "desc": ""
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "insert",
        "desc": "insert attempts to insert an object obj into objset s. If s already contains an alternative object alt with the same name, insert leaves s unchanged and returns alt. Otherwise it inserts obj and returns nil."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the position of the expression corresponding to x. If x is invalid the position is nopos."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "assignableTo",
        "desc": "assignableTo reports whether x is assignable to a variable of type T. If the result is false and a non-nil cause is provided, it may be set to a more detailed explanation of the failure (result != \"\"). The returned error code is only valid if the (first) result is false. The check parameter may be nil if assignableTo is invoked through an exported API call, i.e., when all methods have been type-checked."
      },
      {
        "name": "convertibleTo",
        "desc": "convertibleTo reports whether T(x) is valid. In the failure case, *cause may be set to the cause for the failure. The check parameter may be nil if convertibleTo is invoked through an exported API call, i.e., when all methods have been type-checked."
      },
      {
        "name": "isNil",
        "desc": "isNil reports whether x is the (untyped) nil value."
      },
      {
        "name": "setConst",
        "desc": "setConst sets x to the untyped constant for literal lit."
      },
      {
        "name": "Pos",
        "desc": ""
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "func_",
        "desc": ""
      },
      {
        "name": "term",
        "desc": ""
      },
      {
        "name": "tuple",
        "desc": ""
      },
      {
        "name": "typ",
        "desc": ""
      },
      {
        "name": "typOrNil",
        "desc": "typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid]. A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_)) where an array/slice element is accessed before it is set up."
      },
      {
        "name": "var_",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "disjoint",
        "desc": "disjoint reports whether x ∩ y == ∅. x.typ and y.typ must not be nil."
      },
      {
        "name": "equal",
        "desc": "equal reports whether x and y represent the same type set."
      },
      {
        "name": "includes",
        "desc": "includes reports whether t ∈ x."
      },
      {
        "name": "intersect",
        "desc": "intersect returns the intersection x ∩ y."
      },
      {
        "name": "subsetOf",
        "desc": "subsetOf reports whether x ⊆ y."
      },
      {
        "name": "union",
        "desc": "union returns the union x ∪ y: zero, one, or two non-nil terms."
      },
      {
        "name": "String",
        "desc": "String prints the termlist exactly (without normalization)."
      },
      {
        "name": "equal",
        "desc": "equal reports whether xl and yl represent the same type set."
      },
      {
        "name": "includes",
        "desc": "includes reports whether t ∈ xl."
      },
      {
        "name": "intersect",
        "desc": "intersect returns the intersection xl ∩ yl."
      },
      {
        "name": "isAll",
        "desc": "isAll reports whether the termlist xl represents the set of all types."
      },
      {
        "name": "isEmpty",
        "desc": "isEmpty reports whether the termlist xl represents the empty set of types."
      },
      {
        "name": "norm",
        "desc": "norm returns the normal form of xl."
      },
      {
        "name": "subsetOf",
        "desc": "subsetOf reports whether xl ⊆ yl."
      },
      {
        "name": "supersetOf",
        "desc": "supersetOf reports whether y ⊆ xl."
      },
      {
        "name": "union",
        "desc": "union returns the union xl ∪ yl."
      },
      {
        "name": "isParameterized",
        "desc": ""
      },
      {
        "name": "varList",
        "desc": ""
      },
      {
        "name": "node",
        "desc": ""
      },
      {
        "name": "format",
        "desc": "format formats a type error as a string. check may be nil."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "byte",
        "desc": ""
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "signature",
        "desc": ""
      },
      {
        "name": "string",
        "desc": ""
      },
      {
        "name": "tParamList",
        "desc": ""
      },
      {
        "name": "tuple",
        "desc": ""
      },
      {
        "name": "typ",
        "desc": ""
      },
      {
        "name": "typeList",
        "desc": ""
      },
      {
        "name": "typeName",
        "desc": ""
      },
      {
        "name": "typeSet",
        "desc": "typeSet writes a canonical hash for an interface type set."
      },
      {
        "name": "String",
        "desc": "String returns a string representation of the current mapping from type parameters to types."
      },
      {
        "name": "asBoundTypeParam",
        "desc": "asBoundTypeParam returns x.(*TypeParam) if x is a type parameter recorded with u. Otherwise, the result is nil."
      },
      {
        "name": "at",
        "desc": "at returns the (possibly nil) type for type parameter x."
      },
      {
        "name": "inferred",
        "desc": "inferred returns the list of inferred types for the given type parameter list. The result is never nil and has the same length as tparams; result types that could not be inferred are nil. Corresponding type parameters and result types have identical indices."
      },
      {
        "name": "join",
        "desc": "join unifies the given type parameters x and y. If both type parameters already have a type associated with them and they are not joined, join fails and returns false."
      },
      {
        "name": "nify",
        "desc": "nify implements the core unification algorithm which is an adapted version of Checker.identical. For changes to that code the corresponding changes should be made here. Must not be called directly from outside the unifier."
      },
      {
        "name": "set",
        "desc": "set sets the type t for type parameter x; t must not be nil."
      },
      {
        "name": "setHandle",
        "desc": "setHandle sets the handle for type parameter x (and all its joined type parameters) to h."
      },
      {
        "name": "tracef",
        "desc": ""
      },
      {
        "name": "unify",
        "desc": "unify attempts to unify x and y and reports whether it succeeded. As a side-effect, types may be inferred for type parameters. The mode parameter controls how types are compared."
      },
      {
        "name": "unknowns",
        "desc": "unknowns returns the number of type parameters for which no type has been set yet."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "node",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Alias",
        "desc": "An Alias represents an alias type.  Alias types are created by alias declarations such as:  \ttype A = int  The type on the right-hand side of the declaration can be accessed using [Alias.Rhs]. This type may itself be an alias. Call [Unalias] to obtain the first non-alias type in a chain of alias type declarations.  Like a defined ([Named]) type, an alias type has a name. Use the [Alias.Obj] method to access its [TypeName] object.  Historically, Alias types were not materialized so that, in the example above, A's type was represented by a Basic (int), not an Alias whose [Alias.Rhs] is int. But Go 1.24 allows you to declare an alias type with type parameters or arguments:  \ttype Set[K comparable] = map[K]bool \ts := make(Set[String])  and this requires that Alias types be materialized. Use the [Alias.TypeParams] and [Alias.TypeArgs] methods to access them.  To ease the transition, the Alias type was introduced in go1.22, but the type-checker would not construct values of this type unless the GODEBUG=gotypesalias=1 environment variable was provided. Starting in go1.23, this variable is enabled by default. This setting also causes the predeclared type \"any\" to be represented as an Alias, not a bare [Interface]."
      },
      {
        "name": "ArgumentError",
        "desc": "An ArgumentError holds an error associated with an argument index."
      },
      {
        "name": "Array",
        "desc": "An Array represents an array type."
      },
      {
        "name": "Basic",
        "desc": "A Basic represents a basic type."
      },
      {
        "name": "BasicInfo",
        "desc": "BasicInfo is a set of flags describing properties of a basic type."
      },
      {
        "name": "BasicKind",
        "desc": "BasicKind describes the kind of basic type."
      },
      {
        "name": "Builtin",
        "desc": "A Builtin represents a built-in function. Builtins don't have a valid type."
      },
      {
        "name": "Chan",
        "desc": "A Chan represents a channel type."
      },
      {
        "name": "ChanDir",
        "desc": "A ChanDir value indicates a channel direction."
      },
      {
        "name": "Checker",
        "desc": "A Checker maintains the state of the type checker. It must be created with [NewChecker]."
      },
      {
        "name": "Config",
        "desc": "A Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration."
      },
      {
        "name": "Const",
        "desc": "A Const represents a declared constant."
      },
      {
        "name": "Context",
        "desc": "A Context is an opaque type checking context. It may be used to share identical type instances across type-checked packages or calls to Instantiate. Contexts are safe for concurrent use.  The use of a shared context does not guarantee that identical instances are deduplicated in all cases."
      },
      {
        "name": "Error",
        "desc": "An Error describes a type-checking error; it implements the error interface. A \"soft\" error is an error that still permits a valid interpretation of a package (such as \"unused variable\"); \"hard\" errors may lead to unpredictable behavior if ignored."
      },
      {
        "name": "Func",
        "desc": "A Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a *Signature. An abstract method may belong to many interfaces due to embedding."
      },
      {
        "name": "ImportMode",
        "desc": "ImportMode is reserved for future use."
      },
      {
        "name": "Importer",
        "desc": "An Importer resolves import paths to Packages.  CAUTION: This interface does not support the import of locally vendored packages. See https://golang.org/s/go15vendor. If possible, external implementations should implement [ImporterFrom]."
      },
      {
        "name": "ImporterFrom",
        "desc": "An ImporterFrom resolves import paths to packages; it supports vendoring per https://golang.org/s/go15vendor. Use go/importer to obtain an ImporterFrom implementation."
      },
      {
        "name": "Info",
        "desc": "Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete."
      },
      {
        "name": "Initializer",
        "desc": "An Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression."
      },
      {
        "name": "Instance",
        "desc": "Instance reports the type arguments and instantiated type for type and function instantiations. For type instantiations, [Type] will be of dynamic type *[Named]. For function instantiations, [Type] will be of dynamic type *Signature."
      },
      {
        "name": "Interface",
        "desc": "An Interface represents an interface type."
      },
      {
        "name": "Label",
        "desc": "A Label represents a declared label. Labels don't have a type."
      },
      {
        "name": "Map",
        "desc": "A Map represents a map type."
      },
      {
        "name": "MethodSet",
        "desc": "A MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a [MethodVal] selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set."
      },
      {
        "name": "Named",
        "desc": "A Named represents a named (defined) type.  A declaration such as:  \ttype S struct { ... }  creates a defined type whose underlying type is a struct, and binds this type to the object S, a [TypeName]. Use [Named.Underlying] to access the underlying type. Use [Named.Obj] to obtain the object S.  Before type aliases (Go 1.9), the spec called defined types \"named types\"."
      },
      {
        "name": "Nil",
        "desc": "Nil represents the predeclared value nil."
      },
      {
        "name": "Object",
        "desc": "An Object is a named language entity. An Object may be a constant ([Const]), type name ([TypeName]), variable or struct field ([Var]), function or method ([Func]), imported package ([PkgName]), label ([Label]), built-in function ([Builtin]), or the predeclared identifier 'nil' ([Nil]).  The environment, which is structured as a tree of Scopes, maps each name to the unique Object that it denotes."
      },
      {
        "name": "Package",
        "desc": "A Package describes a Go package."
      },
      {
        "name": "PkgName",
        "desc": "A PkgName represents an imported Go package. PkgNames don't have a type."
      },
      {
        "name": "Pointer",
        "desc": "A Pointer represents a pointer type."
      },
      {
        "name": "Qualifier",
        "desc": "A Qualifier controls how named package-level objects are printed in calls to [TypeString], [ObjectString], and [SelectionString].  These three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed.  Using a nil Qualifier is equivalent to using (*[Package]).Path: the object is qualified by the import path, e.g., \"encoding/json.Marshal\"."
      },
      {
        "name": "Scope",
        "desc": "A Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope."
      },
      {
        "name": "Selection",
        "desc": "A Selection describes a selector expression x.f. For the declarations:  \ttype T struct{ x int; E } \ttype E struct{} \tfunc (e E) m() {} \tvar p *T  the following relations exist:  \tSelector    Kind          Recv    Obj    Type       Index     Indirect  \tp.x         FieldVal      T       x      int        {0}       true \tp.m         MethodVal     *T      m      func()     {1, 0}    true \tT.m         MethodExpr    T       m      func(T)    {1, 0}    false"
      },
      {
        "name": "SelectionKind",
        "desc": "SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).  If x is a struct or *struct, a selector expression x.f may denote a sequence of selection operations x.a.b.c.f. The SelectionKind describes the kind of the final (explicit) operation; all the previous (implicit) operations are always field selections. Each element of Indices specifies an implicit field (a, b, c) by its index in the struct type of the field selection operand.  For a FieldVal operation, the final selection refers to the field specified by Selection.Obj.  For a MethodVal operation, the final selection refers to a method. If the \"pointerness\" of the method's declared receiver does not match that of the effective receiver after implicit field selection, then an \u0026 or * operation is implicitly applied to the receiver variable or value. So, x.f denotes (\u0026x.a.b.c).f when f requires a pointer receiver but x.a.b.c is a non-pointer variable; and it denotes (*x.a.b.c).f when f requires a non-pointer receiver but x.a.b.c is a pointer value.  All pointer indirections, whether due to implicit or explicit field selections or * operations inserted for \"pointerness\", panic if applied to a nil pointer, so a method call x.f() may panic even before the function call.  By contrast, a MethodExpr operation T.f is essentially equivalent to a function literal of the form:  \tfunc(x T, args) (results) { return x.f(args) }  Consequently, any implicit field selections and * operations inserted for \"pointerness\" are not evaluated until the function is called, so a T.f or (*T).f expression never panics."
      },
      {
        "name": "Signature",
        "desc": "A Signature represents a (non-builtin) function or method type. The receiver is ignored when comparing signatures for identity."
      },
      {
        "name": "Sizes",
        "desc": "Sizes defines the sizing functions for package unsafe."
      },
      {
        "name": "Slice",
        "desc": "A Slice represents a slice type."
      },
      {
        "name": "StdSizes",
        "desc": "StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:    - The size of explicitly sized basic types (int16, etc.) is the     specified size.   - The size of strings and interfaces is 2*WordSize.   - The size of slices is 3*WordSize.   - The size of an array of n elements corresponds to the size of     a struct of n consecutive fields of the array's element type.   - The size of a struct is the offset of the last field plus that     field's size. As with all element types, if the struct is used     in an array its size must first be aligned to a multiple of the     struct's alignment.   - All other types have size WordSize.   - Arrays and structs are aligned per spec definition; all other     types are naturally aligned with a maximum alignment MaxAlign.  *StdSizes implements Sizes."
      },
      {
        "name": "Struct",
        "desc": "A Struct represents a struct type."
      },
      {
        "name": "Term",
        "desc": "A Term represents a term in a [Union]."
      },
      {
        "name": "Tuple",
        "desc": "A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go."
      },
      {
        "name": "Type",
        "desc": "A Type represents a type of Go. All types implement the Type interface."
      },
      {
        "name": "TypeAndValue",
        "desc": "TypeAndValue reports the type and value (for constants) of the corresponding expression."
      },
      {
        "name": "TypeList",
        "desc": "TypeList holds a list of types."
      },
      {
        "name": "TypeName",
        "desc": "A TypeName is an [Object] that represents a type with a name: a defined type ([Named]), an alias type ([Alias]), a type parameter ([TypeParam]), or a predeclared type such as int or error."
      },
      {
        "name": "TypeParam",
        "desc": "A TypeParam represents the type of a type parameter in a generic declaration.  A TypeParam has a name; use the [TypeParam.Obj] method to access its [TypeName] object."
      },
      {
        "name": "TypeParamList",
        "desc": "TypeParamList holds a list of type parameters."
      },
      {
        "name": "Union",
        "desc": "A Union represents a union of terms embedded in an interface."
      },
      {
        "name": "Var",
        "desc": "A Variable represents a declared variable (including function parameters and results, and struct fields)."
      },
      {
        "name": "VarKind",
        "desc": "A VarKind discriminates the various kinds of variables."
      },
      {
        "name": "_TypeSet",
        "desc": "A _TypeSet represents the type set of an interface. Because of existing language restrictions, methods can be \"factored out\" from the terms. The actual type set is the intersection of the type set implied by the methods and the type set described by the terms and the comparable bit. To test whether a type is included in a type set (\"implements\" relation), the type must implement all methods _and_ be an element of the type set described by the terms and the comparable bit. If the term list describes the set of all types and comparable is true, only comparable types are meant; in all other cases comparable is false."
      },
      {
        "name": "action",
        "desc": "An action describes a (delayed) action."
      },
      {
        "name": "actionDesc",
        "desc": "An actionDesc provides information on an action. For debugging only."
      },
      {
        "name": "atPos",
        "desc": "atPos wraps a token.Pos to implement the positioner interface."
      },
      {
        "name": "bailout",
        "desc": "A bailout panic is used for early termination."
      },
      {
        "name": "block",
        "desc": "A block tracks label declarations in a block and its enclosing blocks."
      },
      {
        "name": "builtinId",
        "desc": "A builtinId is the id of a builtin function."
      },
      {
        "name": "cleaner",
        "desc": ""
      },
      {
        "name": "color",
        "desc": "color encodes the color of an object (see Checker.objDecl for details)."
      },
      {
        "name": "comparer",
        "desc": "A comparer is used to compare types."
      },
      {
        "name": "constDecl",
        "desc": ""
      },
      {
        "name": "ctxtEntry",
        "desc": ""
      },
      {
        "name": "cycleFinder",
        "desc": ""
      },
      {
        "name": "decl",
        "desc": ""
      },
      {
        "name": "declInfo",
        "desc": "A declInfo describes a package-level const, type, var, or func declaration."
      },
      {
        "name": "dependency",
        "desc": "A dependency is an object that may be a dependency in an initialization expression. Only constants, variables, and functions can be dependencies. Constants are here because constant expression cycles are reported during initialization order computation."
      },
      {
        "name": "dotImportKey",
        "desc": "A dotImportKey describes a dot-imported object in the given scope."
      },
      {
        "name": "embeddedType",
        "desc": "embeddedType represents an embedded type"
      },
      {
        "name": "environment",
        "desc": "An environment represents the environment within which an object is type-checked."
      },
      {
        "name": "errorDesc",
        "desc": "An errorDesc describes part of a type-checking error."
      },
      {
        "name": "error_",
        "desc": "An error_ represents a type-checking error. A new error_ is created with Checker.newError. To report an error_, call error_.report."
      },
      {
        "name": "exprInfo",
        "desc": "exprInfo stores information about an untyped expression."
      },
      {
        "name": "exprKind",
        "desc": "exprKind describes the kind of an expression; the kind determines if an expression is valid in 'statement context'."
      },
      {
        "name": "funcDecl",
        "desc": ""
      },
      {
        "name": "gcSizes",
        "desc": ""
      },
      {
        "name": "genericType",
        "desc": "A genericType implements access to its type parameters."
      },
      {
        "name": "goVersion",
        "desc": "A goVersion is a Go language version string of the form \"go1.%d\" where d is the minor version number. goVersion strings don't contain release numbers (\"go1.20.1\" is not a valid goVersion)."
      },
      {
        "name": "graphNode",
        "desc": "A graphNode represents a node in the object dependency graph. Each node p in n.pred represents an edge p-\u003en, and each node s in n.succ represents an edge n-\u003es; with a-\u003eb indicating that a depends on b."
      },
      {
        "name": "ifacePair",
        "desc": "An ifacePair is a node in a stack of interface type pairs compared for identity."
      },
      {
        "name": "importDecl",
        "desc": ""
      },
      {
        "name": "importKey",
        "desc": "An importKey identifies an imported package by import path and source directory (directory containing the file containing the import). In practice, the directory may always be the same, or may not matter. Given an (import path, directory), an importer must always return the same package (but given two different import paths, an importer may still return the same package by mapping them to the same package paths)."
      },
      {
        "name": "indexedExpr",
        "desc": "indexedExpr wraps an ast.IndexExpr or ast.IndexListExpr.  Orig holds the original ast.Expr from which this indexedExpr was derived.  Note: indexedExpr (intentionally) does not wrap ast.Expr, as that leads to accidental misuse such as encountered in golang/go#63933.  TODO(rfindley): remove this helper, in favor of just having a helper function that returns indices."
      },
      {
        "name": "instance",
        "desc": "instance holds information that is only necessary for instantiated named types."
      },
      {
        "name": "instanceLookup",
        "desc": ""
      },
      {
        "name": "lazyObject",
        "desc": "A lazyObject represents an imported Object that has not been fully resolved yet by its importer."
      },
      {
        "name": "methodSet",
        "desc": "A methodSet is a set of methods and name collisions. A collision indicates that multiple methods with the same unique id, or a field with that id appeared."
      },
      {
        "name": "monoEdge",
        "desc": ""
      },
      {
        "name": "monoGraph",
        "desc": ""
      },
      {
        "name": "monoVertex",
        "desc": ""
      },
      {
        "name": "namedState",
        "desc": "namedState represents the possible states that a named type may assume."
      },
      {
        "name": "nodeQueue",
        "desc": "nodeQueue implements the container/heap interface; a nodeQueue may be used as a priority queue."
      },
      {
        "name": "nodeSet",
        "desc": ""
      },
      {
        "name": "object",
        "desc": "An object implements the common parts of an Object."
      },
      {
        "name": "objset",
        "desc": "An objset is a set of objects identified by their unique id. The zero value for objset is a ready-to-use empty objset."
      },
      {
        "name": "opPredicates",
        "desc": ""
      },
      {
        "name": "operand",
        "desc": "An operand represents an intermediate value during type checking. Operands have an (addressing) mode, the expression evaluating to the operand, the operand's type, a value for constants, and an id for built-in functions. The zero value of operand is a ready to use invalid operand."
      },
      {
        "name": "operandMode",
        "desc": "An operandMode specifies the (addressing) mode of an operand."
      },
      {
        "name": "posSpan",
        "desc": "posSpan holds a position range along with a highlighted position within that range. This is used for positioning errors, with pos by convention being the first position in the source where the error is known to exist, and start and end defining the full span of syntax being considered when the error was detected. Invariant: start \u003c= pos \u003c end || start == pos == end."
      },
      {
        "name": "positioner",
        "desc": "The positioner interface is used to extract the position of type-checker errors."
      },
      {
        "name": "stmtContext",
        "desc": "stmtContext is a bitset describing which control-flow statements are permissible, and provides additional context information for better error messages."
      },
      {
        "name": "substMap",
        "desc": ""
      },
      {
        "name": "subster",
        "desc": ""
      },
      {
        "name": "target",
        "desc": "target represent the (signature) type and description of the LHS variable of an assignment, or of a function result variable."
      },
      {
        "name": "term",
        "desc": "A term describes elementary type sets:  \t ∅:  (*term)(nil)     == ∅                      // set of no types (empty set) \t 𝓤:  \u0026term{}          == 𝓤                      // set of all types (𝓤niverse) \t T:  \u0026term{false, T}  == {T}                    // set of type T \t~t:  \u0026term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t"
      },
      {
        "name": "termlist",
        "desc": "A termlist represents the type set represented by the union t1 ∪ y2 ∪ ... tn of the type sets of the terms t1 to tn. A termlist is in normal form if all terms are disjoint. termlist operations don't require the operands to be in normal form."
      },
      {
        "name": "tpWalker",
        "desc": ""
      },
      {
        "name": "typeDecl",
        "desc": ""
      },
      {
        "name": "typeError",
        "desc": "A typeError describes a type error."
      },
      {
        "name": "typeParamsById",
        "desc": ""
      },
      {
        "name": "typeWriter",
        "desc": ""
      },
      {
        "name": "unifier",
        "desc": "A unifier maintains a list of type parameters and corresponding types inferred for each type parameter. A unifier is created by calling newUnifier."
      },
      {
        "name": "unifyMode",
        "desc": "unifyMode controls the behavior of the unifier."
      },
      {
        "name": "valueMap",
        "desc": "A valueMap maps a case value (of a basic Go type) to a list of positions where the same case value appeared, together with the corresponding case types. Since two case values may have the same \"underlying\" value but different types we need to also check the value's types (e.g., byte(1) vs myByte(1)) when the switch expression is of interface type."
      },
      {
        "name": "valueType",
        "desc": "A valueMap maps a case value (of a basic Go type) to a list of positions where the same case value appeared, together with the corresponding case types. Since two case values may have the same \"underlying\" value but different types we need to also check the value's types (e.g., byte(1) vs myByte(1)) when the switch expression is of interface type."
      },
      {
        "name": "varDecl",
        "desc": ""
      }
    ]
  },
  {
    "name": "go/version",
    "desc": "Package version provides operations on [Go versions] in [Go toolchain name syntax]: strings like \"go1.20\", \"go1.21.0\", \"go1.22rc2\", and \"go1.23.4-bigcorp\".  [Go versions]: https://go.dev/doc/toolchain#version [Go toolchain name syntax]: https://go.dev/doc/toolchain#name",
    "functions": [
      {
        "name": "Compare",
        "desc": "Compare returns -1, 0, or +1 depending on whether x \u003c y, x == y, or x \u003e y, interpreted as Go versions. The versions x and y must begin with a \"go\" prefix: \"go1.21\" not \"1.21\". Invalid versions, including the empty string, compare less than valid versions and equal to each other. The language version \"go1.21\" compares less than the release candidate and eventual releases \"go1.21rc1\" and \"go1.21.0\"."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether the version x is valid."
      },
      {
        "name": "Lang",
        "desc": "Lang returns the Go language version for version x. If x is not a valid version, Lang returns the empty string. For example:  \tLang(\"go1.21rc2\") = \"go1.21\" \tLang(\"go1.21.2\") = \"go1.21\" \tLang(\"go1.21\") = \"go1.21\" \tLang(\"go1\") = \"go1\" \tLang(\"bad\") = \"\" \tLang(\"1.21\") = \"\""
      },
      {
        "name": "TestCompare",
        "desc": ""
      },
      {
        "name": "TestIsValid",
        "desc": ""
      },
      {
        "name": "TestLang",
        "desc": ""
      },
      {
        "name": "stripGo",
        "desc": "stripGo converts from a \"go1.21-bigcorp\" version to a \"1.21\" version. If v does not start with \"go\", stripGo returns the empty string (a known invalid version)."
      },
      {
        "name": "test1",
        "desc": ""
      },
      {
        "name": "test2",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "testCase1",
        "desc": ""
      },
      {
        "name": "testCase2",
        "desc": ""
      }
    ]
  },
  {
    "name": "hash",
    "desc": "",
    "functions": [
      {
        "name": "Example_binaryMarshaler",
        "desc": ""
      },
      {
        "name": "TestMarshalHash",
        "desc": ""
      },
      {
        "name": "fromHex",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "hash/adler32",
    "desc": "Package adler32 implements the Adler-32 checksum.  It is defined in RFC 1950:  \tAdler-32 is composed of two sums accumulated per byte: s1 is \tthe sum of all bytes, s2 is the sum of all s1 values. Both sums \tare done modulo 65521. s1 is initialized to 1, s2 to zero.  The \tAdler-32 checksum is stored as s2*65536 + s1 in most- \tsignificant-byte first (network) order.",
    "functions": [
      {
        "name": "BenchmarkAdler32KB",
        "desc": ""
      },
      {
        "name": "Checksum",
        "desc": "Checksum returns the Adler-32 checksum of data."
      },
      {
        "name": "New",
        "desc": "New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "TestGolden",
        "desc": ""
      },
      {
        "name": "TestGoldenMarshal",
        "desc": ""
      },
      {
        "name": "TestHashInterface",
        "desc": ""
      },
      {
        "name": "checksum",
        "desc": "checksum is a slow but simple implementation of the Adler-32 checksum. It is a straight port of the sample code in RFC 1950 section 9."
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum32",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "digest",
        "desc": "digest represents the partial evaluation of a checksum. The low 16 bits are s1, the high 16 bits are s2."
      }
    ]
  },
  {
    "name": "hash/crc32",
    "desc": "Package crc32 implements the 32-bit cyclic redundancy check, or CRC-32, checksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for information.  Polynomials are represented in LSB-first form also known as reversed representation.  See https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials for information.",
    "functions": [
      {
        "name": "BenchmarkCRC32",
        "desc": ""
      },
      {
        "name": "Checksum",
        "desc": "Checksum returns the CRC-32 checksum of data using the polynomial represented by the [Table]."
      },
      {
        "name": "ChecksumIEEE",
        "desc": "ChecksumIEEE returns the CRC-32 checksum of data using the [IEEE] polynomial."
      },
      {
        "name": "New",
        "desc": "New creates a new [hash.Hash32] computing the CRC-32 checksum using the polynomial represented by the [Table]. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "NewIEEE",
        "desc": "NewIEEE creates a new [hash.Hash32] computing the CRC-32 checksum using the [IEEE] polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "TestArchCastagnoli",
        "desc": ""
      },
      {
        "name": "TestArchIEEE",
        "desc": ""
      },
      {
        "name": "TestCastagnoliRace",
        "desc": "First test, so that it can be the one to initialize castagnoliTable."
      },
      {
        "name": "TestGolden",
        "desc": ""
      },
      {
        "name": "TestGoldenMarshal",
        "desc": ""
      },
      {
        "name": "TestHashInterface",
        "desc": ""
      },
      {
        "name": "TestMarshalTableMismatch",
        "desc": ""
      },
      {
        "name": "TestSimple",
        "desc": "TestSimple tests the simple generic algorithm."
      },
      {
        "name": "TestSlicing",
        "desc": "TestSlicing tests the slicing-by-8 algorithm."
      },
      {
        "name": "Update",
        "desc": "Update returns the result of adding the bytes in p to the crc."
      },
      {
        "name": "archAvailableCastagnoli",
        "desc": ""
      },
      {
        "name": "archAvailableIEEE",
        "desc": ""
      },
      {
        "name": "archInitCastagnoli",
        "desc": ""
      },
      {
        "name": "archInitIEEE",
        "desc": ""
      },
      {
        "name": "archUpdateCastagnoli",
        "desc": "archUpdateCastagnoli calculates the checksum of p using vectorizedCastagnoli."
      },
      {
        "name": "archUpdateIEEE",
        "desc": "archUpdateIEEE calculates the checksum of p using vectorizedIEEE."
      },
      {
        "name": "benchmark",
        "desc": ""
      },
      {
        "name": "benchmarkAll",
        "desc": ""
      },
      {
        "name": "castagnoliSSE42",
        "desc": "castagnoliSSE42 is defined in crc32_amd64.s and uses the SSE 4.2 CRC32 instruction."
      },
      {
        "name": "castagnoliSSE42Triple",
        "desc": "castagnoliSSE42Triple is defined in crc32_amd64.s and uses the SSE 4.2 CRC32 instruction."
      },
      {
        "name": "castagnoliShift",
        "desc": "castagnoliShift computes the CRC32-C of K1 or K2 zeroes (depending on the table given) with the given initial crc value. This corresponds to CRC(crc, O) in the description in updateCastagnoli."
      },
      {
        "name": "castagnoliUpdate",
        "desc": ""
      },
      {
        "name": "ieeeCLMUL",
        "desc": "ieeeCLMUL is defined in crc_amd64.s and uses the PCLMULQDQ instruction as well as SSE 4.1."
      },
      {
        "name": "ieeeUpdate",
        "desc": ""
      },
      {
        "name": "ppc64SlicingUpdateBy8",
        "desc": ""
      },
      {
        "name": "simplePopulateTable",
        "desc": "simplePopulateTable constructs a Table for the specified polynomial, suitable for use with simpleUpdate."
      },
      {
        "name": "simpleUpdate",
        "desc": "simpleUpdate uses the simple algorithm to update the CRC, given a table that was previously computed using simpleMakeTable."
      },
      {
        "name": "slicingUpdate",
        "desc": "slicingUpdate uses the slicing-by-8 algorithm to update the CRC, given a table that was previously computed using slicingMakeTable."
      },
      {
        "name": "tableSum",
        "desc": "tableSum returns the IEEE checksum of table t."
      },
      {
        "name": "testCrossCheck",
        "desc": "testCrossCheck generates random buffers of various lengths and verifies that the two \"update\" functions return the same result."
      },
      {
        "name": "testGoldenCastagnoli",
        "desc": "testGoldenCastagnoli verifies that the given function returns correct IEEE checksums."
      },
      {
        "name": "testGoldenIEEE",
        "desc": "testGoldenIEEE verifies that the given function returns correct IEEE checksums."
      },
      {
        "name": "update",
        "desc": ""
      },
      {
        "name": "vectorCrc32",
        "desc": "this function requires the buffer to be 16 byte aligned and \u003e 16 bytes long."
      },
      {
        "name": "vectorizedCastagnoli",
        "desc": "vectorizedCastagnoli implements CRC32 using vector instructions. It is defined in crc32_s390x.s."
      },
      {
        "name": "vectorizedIEEE",
        "desc": "vectorizedIEEE implements CRC32 using vector instructions. It is defined in crc32_s390x.s."
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum32",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Table",
        "desc": "Table is a 256-word table representing the polynomial for efficient processing."
      },
      {
        "name": "digest",
        "desc": "digest represents the partial evaluation of a checksum."
      },
      {
        "name": "slicing8Table",
        "desc": "slicing8Table is array of 8 Tables, used by the slicing-by-8 algorithm."
      },
      {
        "name": "sse42Table",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      }
    ]
  },
  {
    "name": "hash/crc64",
    "desc": "Package crc64 implements the 64-bit cyclic redundancy check, or CRC-64, checksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for information.",
    "functions": [
      {
        "name": "BenchmarkCrc64",
        "desc": ""
      },
      {
        "name": "Checksum",
        "desc": "Checksum returns the CRC-64 checksum of data using the polynomial represented by the [Table]."
      },
      {
        "name": "New",
        "desc": "New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the [Table]. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements [encoding.BinaryMarshaler] and [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal state of the hash."
      },
      {
        "name": "TestCRC64Hash",
        "desc": ""
      },
      {
        "name": "TestGolden",
        "desc": ""
      },
      {
        "name": "TestGoldenMarshal",
        "desc": ""
      },
      {
        "name": "TestMarshalTableMismatch",
        "desc": ""
      },
      {
        "name": "Update",
        "desc": "Update returns the result of adding the bytes in p to the crc."
      },
      {
        "name": "bench",
        "desc": ""
      },
      {
        "name": "buildSlicing8Tables",
        "desc": ""
      },
      {
        "name": "makeSlicingBy8Table",
        "desc": ""
      },
      {
        "name": "tableSum",
        "desc": "tableSum returns the ISO checksum of table t."
      },
      {
        "name": "update",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum64",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Table",
        "desc": "Table is a 256-word table representing the polynomial for efficient processing."
      },
      {
        "name": "digest",
        "desc": "digest represents the partial evaluation of a checksum."
      },
      {
        "name": "test",
        "desc": ""
      }
    ]
  },
  {
    "name": "hash/fnv",
    "desc": "Package fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function.  All the hash.Hash implementations returned by this package also implement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
    "functions": [
      {
        "name": "BenchmarkFnv128KB",
        "desc": ""
      },
      {
        "name": "BenchmarkFnv128aKB",
        "desc": ""
      },
      {
        "name": "BenchmarkFnv32KB",
        "desc": ""
      },
      {
        "name": "BenchmarkFnv32aKB",
        "desc": ""
      },
      {
        "name": "BenchmarkFnv64KB",
        "desc": ""
      },
      {
        "name": "BenchmarkFnv64aKB",
        "desc": ""
      },
      {
        "name": "New128",
        "desc": "New128 returns a new 128-bit FNV-1 [hash.Hash]. Its Sum method will lay the value out in big-endian byte order."
      },
      {
        "name": "New128a",
        "desc": "New128a returns a new 128-bit FNV-1a [hash.Hash]. Its Sum method will lay the value out in big-endian byte order."
      },
      {
        "name": "New32",
        "desc": "New32 returns a new 32-bit FNV-1 [hash.Hash]. Its Sum method will lay the value out in big-endian byte order."
      },
      {
        "name": "New32a",
        "desc": "New32a returns a new 32-bit FNV-1a [hash.Hash]. Its Sum method will lay the value out in big-endian byte order."
      },
      {
        "name": "New64",
        "desc": "New64 returns a new 64-bit FNV-1 [hash.Hash]. Its Sum method will lay the value out in big-endian byte order."
      },
      {
        "name": "New64a",
        "desc": "New64a returns a new 64-bit FNV-1a [hash.Hash]. Its Sum method will lay the value out in big-endian byte order."
      },
      {
        "name": "TestGolden128",
        "desc": ""
      },
      {
        "name": "TestGolden128a",
        "desc": ""
      },
      {
        "name": "TestGolden32",
        "desc": ""
      },
      {
        "name": "TestGolden32a",
        "desc": ""
      },
      {
        "name": "TestGolden64",
        "desc": ""
      },
      {
        "name": "TestGolden64a",
        "desc": ""
      },
      {
        "name": "TestGoldenMarshal",
        "desc": ""
      },
      {
        "name": "TestHashInterface",
        "desc": ""
      },
      {
        "name": "TestIntegrity128",
        "desc": ""
      },
      {
        "name": "TestIntegrity128a",
        "desc": ""
      },
      {
        "name": "TestIntegrity32",
        "desc": ""
      },
      {
        "name": "TestIntegrity32a",
        "desc": ""
      },
      {
        "name": "TestIntegrity64",
        "desc": ""
      },
      {
        "name": "TestIntegrity64a",
        "desc": ""
      },
      {
        "name": "benchmarkKB",
        "desc": ""
      },
      {
        "name": "testGolden",
        "desc": ""
      },
      {
        "name": "testIntegrity",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum32",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum32",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum64",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "AppendBinary",
        "desc": ""
      },
      {
        "name": "BlockSize",
        "desc": ""
      },
      {
        "name": "Clone",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sum",
        "desc": ""
      },
      {
        "name": "Sum64",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "golden",
        "desc": ""
      },
      {
        "name": "sum128",
        "desc": ""
      },
      {
        "name": "sum128a",
        "desc": ""
      },
      {
        "name": "sum32",
        "desc": ""
      },
      {
        "name": "sum32a",
        "desc": ""
      },
      {
        "name": "sum64",
        "desc": ""
      },
      {
        "name": "sum64a",
        "desc": ""
      }
    ]
  },
  {
    "name": "hash/maphash",
    "desc": "",
    "functions": [
      {
        "name": "Example",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "html",
    "desc": "Package html provides functions for escaping and unescaping HTML text.",
    "functions": [
      {
        "name": "BenchmarkEscape",
        "desc": ""
      },
      {
        "name": "BenchmarkEscapeNone",
        "desc": ""
      },
      {
        "name": "BenchmarkUnescape",
        "desc": ""
      },
      {
        "name": "BenchmarkUnescapeDense",
        "desc": ""
      },
      {
        "name": "BenchmarkUnescapeNone",
        "desc": ""
      },
      {
        "name": "BenchmarkUnescapeSparse",
        "desc": ""
      },
      {
        "name": "EscapeString",
        "desc": "EscapeString escapes special characters like \"\u003c\" to become \"\u0026lt;\". It escapes only five such characters: \u003c, \u003e, \u0026, ' and \". [UnescapeString](EscapeString(s)) == s always holds, but the converse isn't always true."
      },
      {
        "name": "FuzzEscapeUnescape",
        "desc": ""
      },
      {
        "name": "TestEntityLength",
        "desc": ""
      },
      {
        "name": "TestUnescape",
        "desc": ""
      },
      {
        "name": "TestUnescapeEscape",
        "desc": ""
      },
      {
        "name": "UnescapeString",
        "desc": "UnescapeString unescapes entities like \"\u0026lt;\" to become \"\u003c\". It unescapes a larger range of entities than [EscapeString] escapes. For example, \"\u0026aacute;\" unescapes to \"á\", as does \"\u0026#225;\" and \"\u0026#xE1;\". UnescapeString([EscapeString](s)) == s always holds, but the converse isn't always true."
      },
      {
        "name": "unescapeEntity",
        "desc": "unescapeEntity reads an entity like \"\u0026lt;\" from b[src:] and writes the corresponding \"\u003c\" to b[dst:], returning the incremented dst and src cursors. Precondition: b[src] == '\u0026' \u0026\u0026 dst \u003c= src."
      }
    ],
    "types": [
      {
        "name": "unescapeTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "html/template",
    "desc": "Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as [text/template] and should be used instead of [text/template] whenever the output is HTML.  The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for [text/template].  # Introduction  This package wraps [text/template] so you can share its template API to parse and execute HTML templates safely.  \ttmpl, err := template.New(\"name\").Parse(...) \t// Error checking elided \terr = tmpl.Execute(out, data)  If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.  HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts.  Comments are stripped from output, except for those passed in via the [HTML], [CSS], and [JS] types for their respective contexts.  The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below.  Example  \timport \"text/template\" \t... \tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`) \terr = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")  produces  \tHello, \u003cscript\u003ealert('you have been pwned')\u003c/script\u003e!  but the contextual autoescaping in html/template  \timport \"html/template\" \t... \tt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`) \terr = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\")  produces safe, escaped HTML output  \tHello, \u0026lt;script\u0026gt;alert(\u0026#39;you have been pwned\u0026#39;)\u0026lt;/script\u0026gt;!  # Contexts  This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt  \t\u003ca href=\"/search?q={{.}}\"\u003e{{.}}\u003c/a\u003e  At parse time each {{.}} is overwritten to add escaping functions as necessary. In this case it becomes  \t\u003ca href=\"/search?q={{. | urlescaper | attrescaper}}\"\u003e{{. | htmlescaper}}\u003c/a\u003e  where urlescaper, attrescaper, and htmlescaper are aliases for internal escaping functions.  For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string.  # Namespaced and data- attributes  Attributes with a namespace are treated as if they had no namespace. Given the excerpt  \t\u003ca my:href=\"{{.}}\"\u003e\u003c/a\u003e  At parse time the attribute will be treated as if it were just \"href\". So at parse time the template becomes:  \t\u003ca my:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e  Similarly to attributes with namespaces, attributes with a \"data-\" prefix are treated as if they had no \"data-\" prefix. So given  \t\u003ca data-href=\"{{.}}\"\u003e\u003c/a\u003e  At parse time this becomes  \t\u003ca data-href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e  If an attribute has both a namespace and a \"data-\" prefix, only the namespace will be removed when determining the context. For example  \t\u003ca my:data-href=\"{{.}}\"\u003e\u003c/a\u003e  This is handled as if \"my:data-href\" was just \"data-href\" and not \"href\" as it would be if the \"data-\" prefix were to be ignored too. Thus at parse time this becomes just  \t\u003ca my:data-href=\"{{. | attrescaper}}\"\u003e\u003c/a\u003e  As a special case, attributes with the namespace \"xmlns\" are always treated as containing URLs. Given the excerpts  \t\u003ca xmlns:title=\"{{.}}\"\u003e\u003c/a\u003e \t\u003ca xmlns:href=\"{{.}}\"\u003e\u003c/a\u003e \t\u003ca xmlns:onclick=\"{{.}}\"\u003e\u003c/a\u003e  At parse time they become:  \t\u003ca xmlns:title=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e \t\u003ca xmlns:href=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e \t\u003ca xmlns:onclick=\"{{. | urlescaper | attrescaper}}\"\u003e\u003c/a\u003e  # Errors  See the documentation of ErrorCode for details.  # A fuller picture  The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details.  # Contexts  Assuming {{.}} is `O'Reilly: How are \u003ci\u003eyou\u003c/i\u003e?`, the table below shows how {{.}} appears when used in the context to the left.  \tContext                          {{.}} After \t{{.}}                            O'Reilly: How are \u0026lt;i\u0026gt;you\u0026lt;/i\u0026gt;? \t\u003ca title='{{.}}'\u003e                O\u0026#39;Reilly: How are you? \t\u003ca href=\"/{{.}}\"\u003e                O\u0026#39;Reilly: How are %3ci%3eyou%3c/i%3e? \t\u003ca href=\"?q={{.}}\"\u003e              O\u0026#39;Reilly%3a%20How%20are%3ci%3e...%3f \t\u003ca onx='f(\"{{.}}\")'\u003e             O\\x27Reilly: How are \\x3ci\\x3eyou...? \t\u003ca onx='f({{.}})'\u003e               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\" \t\u003ca onx='pattern = /{{.}}/;'\u003e     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f  If used in an unsafe context, then the value might be filtered out:  \tContext                          {{.}} After \t\u003ca href=\"{{.}}\"\u003e                 #ZgotmplZ  since \"O'Reilly:\" is not an allowed protocol like \"http:\".  If {{.}} is the innocuous word, `left`, then it can appear more widely,  \tContext                              {{.}} After \t{{.}}                                left \t\u003ca title='{{.}}'\u003e                    left \t\u003ca href='{{.}}'\u003e                     left \t\u003ca href='/{{.}}'\u003e                    left \t\u003ca href='?dir={{.}}'\u003e                left \t\u003ca style=\"border-{{.}}: 4px\"\u003e        left \t\u003ca style=\"align: {{.}}\"\u003e             left \t\u003ca style=\"background: '{{.}}'\u003e       left \t\u003ca style=\"background: url('{{.}}')\u003e  left \t\u003cstyle\u003ep.{{.}} {color:red}\u003c/style\u003e   left  Non-string values can be used in JavaScript contexts. If {{.}} is  \tstruct{A,B string}{ \"foo\", \"bar\" }  in the escaped template  \t\u003cscript\u003evar pair = {{.}};\u003c/script\u003e  then the template output is  \t\u003cscript\u003evar pair = {\"A\": \"foo\", \"B\": \"bar\"};\u003c/script\u003e  See package json to understand how non-string content is marshaled for embedding in JavaScript contexts.  # Typed Strings  By default, this package assumes that all pipelines produce a plain text string. It adds escaping pipeline stages necessary to correctly and safely embed that plain text string in the appropriate context.  When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type.  Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping.  The template  \tHello, {{.}}!  can be invoked with  \ttmpl.Execute(out, template.HTML(`\u003cb\u003eWorld\u003c/b\u003e`))  to produce  \tHello, \u003cb\u003eWorld\u003c/b\u003e!  instead of the  \tHello, \u0026lt;b\u0026gt;World\u0026lt;b\u0026gt;!  that would have been produced if {{.}} was a regular string.  # Security Model  https://web.archive.org/web/20160501113828/http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition defines \"safe\" as used by this package.  This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data:  Structure Preservation Property: \"... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.\"  Code Effect Property: \"... only code specified by the template author should run as a result of injecting the template output into a page and all code specified by the template author should run as a result of the same.\"  Least Surprise Property: \"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.\"  Previously, ECMAScript 6 template literal were disabled by default, and could be enabled with the GODEBUG=jstmpllitinterp=1 environment variable. Template literals are now supported by default, and setting jstmpllitinterp has no effect.",
    "functions": [
      {
        "name": "BenchmarkCSSEscaper",
        "desc": ""
      },
      {
        "name": "BenchmarkCSSEscaperNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkCSSValueFilter",
        "desc": ""
      },
      {
        "name": "BenchmarkCSSValueFilterOk",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeCSS",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeCSSNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkEscapedExecute",
        "desc": ""
      },
      {
        "name": "BenchmarkHTMLNospaceEscaper",
        "desc": ""
      },
      {
        "name": "BenchmarkHTMLNospaceEscaperNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkJSRegexpEscaper",
        "desc": ""
      },
      {
        "name": "BenchmarkJSRegexpEscaperNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkJSStrEscaper",
        "desc": ""
      },
      {
        "name": "BenchmarkJSStrEscaperNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkJSValEscaperWithNum",
        "desc": ""
      },
      {
        "name": "BenchmarkJSValEscaperWithObj",
        "desc": ""
      },
      {
        "name": "BenchmarkJSValEscaperWithObjNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkJSValEscaperWithStr",
        "desc": ""
      },
      {
        "name": "BenchmarkJSValEscaperWithStrNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkSrcsetFilter",
        "desc": ""
      },
      {
        "name": "BenchmarkSrcsetFilterNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkStripTags",
        "desc": ""
      },
      {
        "name": "BenchmarkStripTagsNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkTemplateSpecialTags",
        "desc": ""
      },
      {
        "name": "BenchmarkURLEscaper",
        "desc": ""
      },
      {
        "name": "BenchmarkURLEscaperNoSpecials",
        "desc": ""
      },
      {
        "name": "BenchmarkURLNormalizer",
        "desc": ""
      },
      {
        "name": "BenchmarkURLNormalizerNoSpecials",
        "desc": ""
      },
      {
        "name": "HTMLEscape",
        "desc": "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b."
      },
      {
        "name": "HTMLEscapeString",
        "desc": "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s."
      },
      {
        "name": "HTMLEscaper",
        "desc": "HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments."
      },
      {
        "name": "IsTrue",
        "desc": "IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions."
      },
      {
        "name": "JSEscape",
        "desc": "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b."
      },
      {
        "name": "JSEscapeString",
        "desc": "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s."
      },
      {
        "name": "JSEscaper",
        "desc": "JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments."
      },
      {
        "name": "TestAddParseTreeHTML",
        "desc": ""
      },
      {
        "name": "TestAddParseTreeToUnparsedTemplate",
        "desc": "Issue 7032"
      },
      {
        "name": "TestAddrOfIndex",
        "desc": ""
      },
      {
        "name": "TestAliasedParseTreeDoesNotOverescape",
        "desc": "Covers issue 21844."
      },
      {
        "name": "TestBadFuncNames",
        "desc": ""
      },
      {
        "name": "TestBlock",
        "desc": ""
      },
      {
        "name": "TestCSSEscaper",
        "desc": ""
      },
      {
        "name": "TestCSSValueFilter",
        "desc": ""
      },
      {
        "name": "TestClone",
        "desc": ""
      },
      {
        "name": "TestCloneCrash",
        "desc": "This used to crash; https://golang.org/issue/3281"
      },
      {
        "name": "TestCloneGrowth",
        "desc": ""
      },
      {
        "name": "TestClonePipe",
        "desc": "Issue 24791."
      },
      {
        "name": "TestCloneRedefinedName",
        "desc": "https://golang.org/issue/17735"
      },
      {
        "name": "TestCloneThenParse",
        "desc": "Ensure that this guarantee from the docs is upheld: \"Further calls to Parse in the copy will add templates to the copy but not to the original.\""
      },
      {
        "name": "TestComparison",
        "desc": ""
      },
      {
        "name": "TestDecodeCSS",
        "desc": ""
      },
      {
        "name": "TestDelims",
        "desc": ""
      },
      {
        "name": "TestEmptyTemplate",
        "desc": ""
      },
      {
        "name": "TestEmptyTemplateCloneCrash",
        "desc": "Issue 10879"
      },
      {
        "name": "TestEmptyTemplateHTML",
        "desc": "This is a test for issue 3272."
      },
      {
        "name": "TestEndsWithCSSKeyword",
        "desc": ""
      },
      {
        "name": "TestEnsurePipelineContains",
        "desc": ""
      },
      {
        "name": "TestErrorOnUndefined",
        "desc": "Unlike text/template, html/template crashed if given an incomplete template, that is, a template that had been named but not given any content. This is issue #10204."
      },
      {
        "name": "TestErrors",
        "desc": ""
      },
      {
        "name": "TestEscape",
        "desc": ""
      },
      {
        "name": "TestEscapeErrorsNotIgnorable",
        "desc": ""
      },
      {
        "name": "TestEscapeMalformedPipelines",
        "desc": ""
      },
      {
        "name": "TestEscapeMap",
        "desc": ""
      },
      {
        "name": "TestEscapeRace",
        "desc": ""
      },
      {
        "name": "TestEscapeSet",
        "desc": ""
      },
      {
        "name": "TestEscapeSetErrorsNotIgnorable",
        "desc": ""
      },
      {
        "name": "TestEscapeText",
        "desc": ""
      },
      {
        "name": "TestEscapersOnLower7AndSelectHighCodepoints",
        "desc": ""
      },
      {
        "name": "TestEscapingNilNonemptyInterfaces",
        "desc": "https://golang.org/issue/5982"
      },
      {
        "name": "TestEvalFieldErrors",
        "desc": ""
      },
      {
        "name": "TestExecError",
        "desc": "Check that an error from a nested template contains all the relevant information."
      },
      {
        "name": "TestExecute",
        "desc": ""
      },
      {
        "name": "TestExecuteError",
        "desc": "Check that an error from a method flows back to the top."
      },
      {
        "name": "TestExecuteGivesExecError",
        "desc": ""
      },
      {
        "name": "TestExecuteOnNewTemplate",
        "desc": ""
      },
      {
        "name": "TestExecutePanicDuringCall",
        "desc": "Check that panics during calls are recovered and returned as errors."
      },
      {
        "name": "TestFinalForPrintf",
        "desc": ""
      },
      {
        "name": "TestFindEndTag",
        "desc": ""
      },
      {
        "name": "TestFuncMapWorksAfterClone",
        "desc": "https://golang.org/issue/5980"
      },
      {
        "name": "TestGoodFuncNames",
        "desc": ""
      },
      {
        "name": "TestHTMLNospaceEscaper",
        "desc": ""
      },
      {
        "name": "TestHexDecode",
        "desc": ""
      },
      {
        "name": "TestIdempotentExecute",
        "desc": "This covers issue #20842."
      },
      {
        "name": "TestIndirectPrint",
        "desc": ""
      },
      {
        "name": "TestInterfaceValues",
        "desc": ""
      },
      {
        "name": "TestIsCSSNmchar",
        "desc": ""
      },
      {
        "name": "TestIsJsMimeType",
        "desc": ""
      },
      {
        "name": "TestIssue19294",
        "desc": "Issue 19249 was a regression in 1.8 caused by the handling of empty templates added in that release, which got different answers depending on the order templates appeared in the internal map."
      },
      {
        "name": "TestIssue31810",
        "desc": "Issue 31810. Check that a parenthesized first argument behaves properly."
      },
      {
        "name": "TestJSEscaping",
        "desc": ""
      },
      {
        "name": "TestJSRegexpEscaper",
        "desc": ""
      },
      {
        "name": "TestJSStrEscaper",
        "desc": ""
      },
      {
        "name": "TestJSValEscaper",
        "desc": ""
      },
      {
        "name": "TestMaxExecDepth",
        "desc": ""
      },
      {
        "name": "TestMessageForExecuteEmpty",
        "desc": ""
      },
      {
        "name": "TestMissingMapKey",
        "desc": ""
      },
      {
        "name": "TestMultiExecute",
        "desc": ""
      },
      {
        "name": "TestNextJsCtx",
        "desc": ""
      },
      {
        "name": "TestOrphanedTemplate",
        "desc": "Covers issue 22780."
      },
      {
        "name": "TestParse",
        "desc": ""
      },
      {
        "name": "TestParseFS",
        "desc": ""
      },
      {
        "name": "TestParseFiles",
        "desc": ""
      },
      {
        "name": "TestParseFilesWithData",
        "desc": ""
      },
      {
        "name": "TestParseGlob",
        "desc": ""
      },
      {
        "name": "TestParseGlobWithData",
        "desc": ""
      },
      {
        "name": "TestParseZipFS",
        "desc": ""
      },
      {
        "name": "TestPipeToMethodIsEscaped",
        "desc": "This is a test for issue 7379: type assertion error caused panic, and then the code to handle the panic breaks escaping. It's hard to see the second problem once the first is fixed, but its fix is trivial so we let that go. See the discussion for issue 7379."
      },
      {
        "name": "TestRecursiveExecute",
        "desc": ""
      },
      {
        "name": "TestRecursiveExecuteViaMethod",
        "desc": ""
      },
      {
        "name": "TestRedefinition",
        "desc": ""
      },
      {
        "name": "TestRedundantFuncs",
        "desc": ""
      },
      {
        "name": "TestSkipCSSSpace",
        "desc": ""
      },
      {
        "name": "TestSrcsetFilter",
        "desc": ""
      },
      {
        "name": "TestStringer",
        "desc": ""
      },
      {
        "name": "TestStripTags",
        "desc": ""
      },
      {
        "name": "TestTemplateCloneExecuteRace",
        "desc": "https://golang.org/issue/16101"
      },
      {
        "name": "TestTemplateCloneLookup",
        "desc": ""
      },
      {
        "name": "TestTemplateFuncsAfterClone",
        "desc": "Issue 43295."
      },
      {
        "name": "TestTemplateLookUp",
        "desc": "Issue 10910, 10926"
      },
      {
        "name": "TestTemplates",
        "desc": ""
      },
      {
        "name": "TestTree",
        "desc": ""
      },
      {
        "name": "TestTypedContent",
        "desc": ""
      },
      {
        "name": "TestURLFilters",
        "desc": ""
      },
      {
        "name": "TestURLNormalizer",
        "desc": ""
      },
      {
        "name": "TestUnterminatedStringError",
        "desc": "Test that the error message for multiline unterminated string refers to the line number of the opening quote."
      },
      {
        "name": "URLQueryEscaper",
        "desc": "URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query."
      },
      {
        "name": "_",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "appendCmd",
        "desc": "appendCmd appends the given command to the end of the command pipeline unless it is redundant with the last command."
      },
      {
        "name": "asciiAlpha",
        "desc": "asciiAlpha reports whether c is an ASCII letter."
      },
      {
        "name": "asciiAlphaNum",
        "desc": "asciiAlphaNum reports whether c is an ASCII letter or digit."
      },
      {
        "name": "attrEscaper",
        "desc": "attrEscaper escapes for inclusion in quoted attribute values."
      },
      {
        "name": "commentEscaper",
        "desc": "commentEscaper returns the empty string regardless of input. Comment content does not correspond to any parsed structure or human-readable content, so the simplest and most secure policy is to drop content interpolated into comments. This approach is equally valid whether or not static comment content is removed from the template."
      },
      {
        "name": "containsSpecialScriptTag",
        "desc": ""
      },
      {
        "name": "count",
        "desc": "count returns a channel that will deliver n sequential 1-letter strings starting at \"a\""
      },
      {
        "name": "cssEscaper",
        "desc": "cssEscaper escapes HTML and CSS special characters using \\\u003chex\u003e+ escapes."
      },
      {
        "name": "cssValueFilter",
        "desc": "cssValueFilter allows innocuous CSS values in the output including CSS quantities (10px or 25%), ID or class literals (#foo, .bar), keyword values (inherit, blue), and colors (#888). It filters out unsafe values, such as those that affect token boundaries, and anything that might execute scripts."
      },
      {
        "name": "dddArg",
        "desc": ""
      },
      {
        "name": "decodeCSS",
        "desc": "decodeCSS decodes CSS3 escapes given a sequence of stringchars. If there is no change, it returns the input, otherwise it returns a slice backed by a new array. https://www.w3.org/TR/css3-syntax/#SUBTOK-stringchar defines stringchar."
      },
      {
        "name": "eatWhiteSpace",
        "desc": "eatWhiteSpace returns the largest j such that s[i:j] is white space."
      },
      {
        "name": "echo",
        "desc": ""
      },
      {
        "name": "endsWithCSSKeyword",
        "desc": "endsWithCSSKeyword reports whether b ends with an ident that case-insensitively matches the lower-case kw."
      },
      {
        "name": "ensurePipelineContains",
        "desc": "ensurePipelineContains ensures that the pipeline ends with the commands with the identifiers in s in order. If the pipeline ends with a predefined escaper (i.e. \"html\" or \"urlquery\"), merge it with the identifiers in s."
      },
      {
        "name": "escFnsEq",
        "desc": "escFnsEq reports whether the two escaping functions are equivalent."
      },
      {
        "name": "escapeSpecialScriptTags",
        "desc": ""
      },
      {
        "name": "escapeTemplate",
        "desc": "escapeTemplate rewrites the named template, which must be associated with t, to guarantee that the output of any of the named templates is properly escaped. If no error is returned, then the named templates have been modified. Otherwise the named templates have been rendered unusable."
      },
      {
        "name": "evalArgs",
        "desc": "evalArgs formats the list of arguments into a string. It is equivalent to fmt.Sprint(args...), except that it dereferences all pointers."
      },
      {
        "name": "filterSrcsetElement",
        "desc": ""
      },
      {
        "name": "funcNameTestFunc",
        "desc": ""
      },
      {
        "name": "hexDecode",
        "desc": "hexDecode decodes a short hex digit sequence: \"10\" -\u003e 16."
      },
      {
        "name": "htmlEscaper",
        "desc": "htmlEscaper escapes for inclusion in HTML text."
      },
      {
        "name": "htmlNameFilter",
        "desc": "htmlNameFilter accepts valid parts of an HTML attribute or tag name or a known-safe HTML attribute."
      },
      {
        "name": "htmlNospaceEscaper",
        "desc": "htmlNospaceEscaper escapes for inclusion in unquoted attribute values."
      },
      {
        "name": "htmlReplacer",
        "desc": "htmlReplacer returns s with runes replaced according to replacementTable and when badRunes is true, certain bad runes are allowed through unescaped."
      },
      {
        "name": "indexTagEnd",
        "desc": "indexTagEnd finds the index of a special tag end in a case insensitive way, or returns -1"
      },
      {
        "name": "indirect",
        "desc": "indirect returns the value, after dereferencing as many times as necessary to reach the base type (or nil)."
      },
      {
        "name": "indirectToJSONMarshaler",
        "desc": "indirectToJSONMarshaler returns the value, after dereferencing as many times as necessary to reach the base type (or nil) or an implementation of json.Marshal."
      },
      {
        "name": "indirectToStringerOrError",
        "desc": "indirectToStringerOrError returns the value, after dereferencing as many times as necessary to reach the base type (or nil) or an implementation of fmt.Stringer or error."
      },
      {
        "name": "isCSSNmchar",
        "desc": "isCSSNmchar reports whether rune is allowed anywhere in a CSS identifier."
      },
      {
        "name": "isCSSSpace",
        "desc": "isCSSSpace reports whether b is a CSS space char as defined in wc."
      },
      {
        "name": "isComment",
        "desc": "isComment is true for any state that contains content meant for template authors \u0026 maintainers, not for end-users or machines."
      },
      {
        "name": "isHTMLSpace",
        "desc": "isHTMLSpace is true iff c is a whitespace character per https://infra.spec.whatwg.org/#ascii-whitespace"
      },
      {
        "name": "isHTMLSpaceOrASCIIAlnum",
        "desc": ""
      },
      {
        "name": "isHex",
        "desc": "isHex reports whether the given character is a hex digit."
      },
      {
        "name": "isInScriptLiteral",
        "desc": "isInScriptLiteral returns true if s is one of the literal states within a \u003cscript\u003e tag, and as such occurrences of \"\u003c!--\", \"\u003cscript\", and \"\u003c/script\" need to be treated specially."
      },
      {
        "name": "isInTag",
        "desc": "isInTag return whether s occurs solely inside an HTML tag."
      },
      {
        "name": "isJSIdentPart",
        "desc": "isJSIdentPart reports whether the given rune is a JS identifier part. It does not handle all the non-Latin letters, joiners, and combining marks, but it does handle every codepoint that can occur in a numeric literal or a keyword."
      },
      {
        "name": "isJSType",
        "desc": "isJSType reports whether the given MIME type should be considered JavaScript.  It is used to determine whether a script tag with a type attribute is a javascript container."
      },
      {
        "name": "isSafeURL",
        "desc": "isSafeURL is true if s is a relative URL or if URL has a protocol in (http, https, mailto)."
      },
      {
        "name": "jsRegexpEscaper",
        "desc": "jsRegexpEscaper behaves like jsStrEscaper but escapes regular expression specials so the result is treated literally when included in a regular expression literal. /foo{{.X}}bar/ matches the string \"foo\" followed by the literal text of {{.X}} followed by the string \"bar\"."
      },
      {
        "name": "jsStrEscaper",
        "desc": "jsStrEscaper produces a string that can be included between quotes in JavaScript source, in JavaScript embedded in an HTML5 \u003cscript\u003e element, or in an HTML5 event handler attribute such as onclick."
      },
      {
        "name": "jsTmplLitEscaper",
        "desc": ""
      },
      {
        "name": "jsValEscaper",
        "desc": "jsValEscaper escapes its inputs to a JS Expression (section 11.14) that has neither side-effects nor free variables outside (NaN, Infinity)."
      },
      {
        "name": "makemap",
        "desc": ""
      },
      {
        "name": "mapOfThree",
        "desc": ""
      },
      {
        "name": "newIdentCmd",
        "desc": "newIdentCmd produces a command containing a single identifier node."
      },
      {
        "name": "newInt",
        "desc": "Helpers for creation."
      },
      {
        "name": "newIntSlice",
        "desc": ""
      },
      {
        "name": "newString",
        "desc": ""
      },
      {
        "name": "normalizeEscFn",
        "desc": "normalizeEscFn(a) is equal to normalizeEscFn(b) for any pair of names of escaper functions a and b that are equivalent."
      },
      {
        "name": "oneArg",
        "desc": ""
      },
      {
        "name": "processURLOnto",
        "desc": "processURLOnto appends a normalized URL corresponding to its input to b and reports whether the appended content differs from s."
      },
      {
        "name": "rcdataEscaper",
        "desc": "rcdataEscaper escapes for inclusion in an RCDATA element body."
      },
      {
        "name": "readFileFS",
        "desc": ""
      },
      {
        "name": "readFileOS",
        "desc": ""
      },
      {
        "name": "replace",
        "desc": "replace replaces each rune r of s with replacementTable[r], provided that r \u003c len(replacementTable). If replacementTable[r] is the empty string then no replacement is made. It also replaces runes U+2028 and U+2029 with the raw strings `\\u2028` and `\\u2029`."
      },
      {
        "name": "returnInt",
        "desc": "returnInt returns an int"
      },
      {
        "name": "skipCSSSpace",
        "desc": "skipCSSSpace returns a suffix of c, skipping over a single space."
      },
      {
        "name": "srcsetFilterAndEscaper",
        "desc": "Filters and normalizes srcset values which are comma separated URLs followed by metadata."
      },
      {
        "name": "stringer",
        "desc": ""
      },
      {
        "name": "stripTags",
        "desc": "stripTags takes a snippet of HTML and returns only the text content. For example, `\u003cb\u003e\u0026iexcl;Hi!\u003c/b\u003e \u003cscript\u003e...\u003c/script\u003e` -\u003e `\u0026iexcl;Hi! `."
      },
      {
        "name": "testBadFuncName",
        "desc": ""
      },
      {
        "name": "testExecute",
        "desc": ""
      },
      {
        "name": "twoArgs",
        "desc": ""
      },
      {
        "name": "typeOf",
        "desc": ""
      },
      {
        "name": "urlEscaper",
        "desc": "urlEscaper produces an output that can be embedded in a URL query. The output can be embedded in an HTML attribute without further escaping."
      },
      {
        "name": "urlFilter",
        "desc": "urlFilter returns its input unless it contains an unsafe scheme in which case it defangs the entire URL.  Schemes that cause unintended side effects that are irreversible without user interaction are considered unsafe. For example, clicking on a \"javascript:\" link can immediately trigger JavaScript code execution.  This filter conservatively assumes that all schemes other than the following are unsafe:   - http:   Navigates to a new website, and may open a new window or tab.     These side effects can be reversed by navigating back to the     previous website, or closing the window or tab. No irreversible     changes will take place without further user interaction with     the new website.   - https:  Same as http.   - mailto: Opens an email program and starts a new draft. This side effect     is not irreversible until the user explicitly clicks send; it     can be undone by closing the email program.  To allow URLs containing other schemes to bypass this filter, developers must explicitly indicate that such a URL is expected and safe by encapsulating it in a template.URL value."
      },
      {
        "name": "urlNormalizer",
        "desc": "urlNormalizer normalizes URL content so it can be embedded in a quote-delimited string or parenthesis delimited url(...). The normalizer does not encode all HTML specials. Specifically, it does not encode '\u0026' so correct embedding in an HTML attribute requires escaping of '\u0026' to '\u0026amp;'."
      },
      {
        "name": "urlProcessor",
        "desc": "urlProcessor normalizes (when norm is true) or escapes its input to produce a valid hierarchical or opaque URL part."
      },
      {
        "name": "valueString",
        "desc": "valueString takes a string, not a pointer."
      },
      {
        "name": "vfunc",
        "desc": "vfunc takes a *V and a V"
      },
      {
        "name": "zeroArgs",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "SomeMethod",
        "desc": ""
      },
      {
        "name": "Method0",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "GetU",
        "desc": "A few methods to test chaining."
      },
      {
        "name": "MAdd",
        "desc": ""
      },
      {
        "name": "Method0",
        "desc": "Simple methods with and without arguments."
      },
      {
        "name": "Method1",
        "desc": ""
      },
      {
        "name": "Method2",
        "desc": ""
      },
      {
        "name": "Method3",
        "desc": ""
      },
      {
        "name": "MyError",
        "desc": "MyError returns a value and an error according to its argument."
      },
      {
        "name": "AddParseTree",
        "desc": "AddParseTree creates a new template with the name and parse tree and associates it with t.  It returns an error if t or any associated template has already been executed."
      },
      {
        "name": "Clone",
        "desc": "Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to [Template.Parse] in the copy will add templates to the copy but not to the original. [Template.Clone] can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made.  It returns an error if t has already been executed."
      },
      {
        "name": "DefinedTemplates",
        "desc": "DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. Used to generate an error message."
      },
      {
        "name": "Delims",
        "desc": "Delims sets the action delimiters to the specified strings, to be used in subsequent calls to [Template.Parse], [ParseFiles], or [ParseGlob]. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained."
      },
      {
        "name": "Execute",
        "desc": "Execute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved."
      },
      {
        "name": "ExecuteTemplate",
        "desc": "ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved."
      },
      {
        "name": "Funcs",
        "desc": "Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the template with the given name that is associated with t, or nil if there is no such template."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the template."
      },
      {
        "name": "New",
        "desc": "New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.  If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t."
      },
      {
        "name": "Option",
        "desc": "Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.  Known options:  missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map.  \t\"missingkey=default\" or \"missingkey=invalid\" \t\tThe default behavior: Do nothing and continue execution. \t\tIf printed, the result of the index operation is the string \t\t\"\u003cno value\u003e\". \t\"missingkey=zero\" \t\tThe operation returns the zero value for the map type's element. \t\"missingkey=error\" \t\tExecution stops immediately with an error."
      },
      {
        "name": "Parse",
        "desc": "Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.  Templates can be redefined in successive calls to Parse, before the first use of [Template.Execute] on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body."
      },
      {
        "name": "ParseFS",
        "desc": "ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.)"
      },
      {
        "name": "ParseFiles",
        "desc": "ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file.  When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.  ParseFiles returns an error if t or any associated template has already been executed."
      },
      {
        "name": "ParseGlob",
        "desc": "ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.  When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results.  ParseGlob returns an error if t or any associated template has already been executed."
      },
      {
        "name": "Templates",
        "desc": "Templates returns a slice of the templates associated with t, including t itself."
      },
      {
        "name": "checkCanParse",
        "desc": "checkCanParse checks whether it is OK to parse templates. If not, it returns an error."
      },
      {
        "name": "escape",
        "desc": "escape escapes all associated templates."
      },
      {
        "name": "lookupAndEscapeTemplate",
        "desc": "lookupAndEscapeTemplate guarantees that the template with the given name is escaped, or returns an error if it cannot be. It returns the named template."
      },
      {
        "name": "new",
        "desc": "new is the implementation of New, without the lock."
      },
      {
        "name": "TrueFalse",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "eq",
        "desc": "eq reports whether two contexts are equal."
      },
      {
        "name": "mangle",
        "desc": "mangle produces an identifier that includes a suffix that distinguishes it from template names mangled with different contexts."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "arbitraryTemplate",
        "desc": "arbitraryTemplate returns an arbitrary template from the name space associated with e and panics if no templates are found."
      },
      {
        "name": "commit",
        "desc": "commit applies changes to actions and template calls needed to contextually autoescape content and adds any derived templates to the set."
      },
      {
        "name": "computeOutCtx",
        "desc": "computeOutCtx takes a template and its start context and computes the output context while storing any inferences in e."
      },
      {
        "name": "editActionNode",
        "desc": "editActionNode records a change to an action pipeline for later commit."
      },
      {
        "name": "editTemplateNode",
        "desc": "editTemplateNode records a change to a {{template}} callee for later commit."
      },
      {
        "name": "editTextNode",
        "desc": "editTextNode records a change to a text node for later commit."
      },
      {
        "name": "escape",
        "desc": "escape escapes a template node."
      },
      {
        "name": "escapeAction",
        "desc": "escapeAction escapes an action template node."
      },
      {
        "name": "escapeBranch",
        "desc": "escapeBranch escapes a branch template node: \"if\", \"range\" and \"with\"."
      },
      {
        "name": "escapeList",
        "desc": "escapeList escapes a list template node."
      },
      {
        "name": "escapeListConditionally",
        "desc": "escapeListConditionally escapes a list node but only preserves edits and inferences in e if the inferences and output context satisfy filter. It returns the best guess at an output context, and the result of the filter which is the same as whether e was updated."
      },
      {
        "name": "escapeTemplate",
        "desc": "escapeTemplate escapes a {{template}} call node."
      },
      {
        "name": "escapeTemplateBody",
        "desc": "escapeTemplateBody escapes the given template assuming the given output context, and returns the best guess at the output context and whether the assumption was correct."
      },
      {
        "name": "escapeText",
        "desc": "escapeText escapes a text template node."
      },
      {
        "name": "escapeTree",
        "desc": "escapeTree escapes the named template starting in the given context as necessary and returns its output context."
      },
      {
        "name": "template",
        "desc": "template returns the named template given a mangled template name."
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Recur",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "CSS",
        "desc": "CSS encapsulates known safe content that matches any of:   1. The CSS3 stylesheet production, such as `p { color: purple }`.   2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.   3. CSS3 declaration productions, such as `color: red; margin: 2px`.   4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`. See https://www.w3.org/TR/css3-syntax/#parsing and https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output."
      },
      {
        "name": "Error",
        "desc": "Error describes a problem encountered during template Escaping."
      },
      {
        "name": "ErrorCode",
        "desc": "ErrorCode is a code for a kind of error."
      },
      {
        "name": "ErrorWriter",
        "desc": ""
      },
      {
        "name": "FuncMap",
        "desc": ""
      },
      {
        "name": "HTML",
        "desc": "HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output."
      },
      {
        "name": "HTMLAttr",
        "desc": "HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=\"ltr\"`.  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output."
      },
      {
        "name": "I",
        "desc": "A non-empty interface."
      },
      {
        "name": "Issue7379",
        "desc": ""
      },
      {
        "name": "JS",
        "desc": "JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like \"{ foo: bar() }\\n['foo']()\", which is both a valid Expression and a valid Program with a very different meaning.  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output.  Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context."
      },
      {
        "name": "JSStr",
        "desc": "JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:   StringCharacter :: SourceCharacter but not `\\` or LineTerminator                    | EscapeSequence Note that LineContinuations are not allowed. JSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not.  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output."
      },
      {
        "name": "S",
        "desc": ""
      },
      {
        "name": "Srcset",
        "desc": "Srcset encapsulates a known safe srcset attribute (see https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset).  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output."
      },
      {
        "name": "T",
        "desc": "T has lots of interesting pieces to use to test execution."
      },
      {
        "name": "Template",
        "desc": "Template is a specialized Template from \"text/template\" that produces a safe HTML document fragment."
      },
      {
        "name": "Tree",
        "desc": ""
      },
      {
        "name": "U",
        "desc": ""
      },
      {
        "name": "URL",
        "desc": "URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.  Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output."
      },
      {
        "name": "V",
        "desc": ""
      },
      {
        "name": "W",
        "desc": ""
      },
      {
        "name": "attr",
        "desc": "attr identifies the current HTML attribute when inside the attribute, that is, starting from stateAttrName until stateTag/stateText (exclusive)."
      },
      {
        "name": "badMarshaler",
        "desc": ""
      },
      {
        "name": "cmpTest",
        "desc": ""
      },
      {
        "name": "contentType",
        "desc": ""
      },
      {
        "name": "context",
        "desc": "context describes the state an HTML parser must be in when it reaches the portion of HTML produced by evaluating a particular template node.  The zero value of type context is the start context for a template that produces an HTML fragment as defined at https://www.w3.org/TR/html5/syntax.html#the-end where the context element is null."
      },
      {
        "name": "delim",
        "desc": "delim is the delimiter that will end the current HTML attribute."
      },
      {
        "name": "element",
        "desc": "element identifies the HTML element when inside a start tag or special body. Certain HTML element (for example \u003cscript\u003e and \u003cstyle\u003e) have bodies that are treated differently from stateText so the element type is necessary to transition into the correct context at the end of a tag and to identify the end delimiter for the body."
      },
      {
        "name": "errorer",
        "desc": ""
      },
      {
        "name": "escaper",
        "desc": "escaper collects type inferences about templates and changes needed to make templates injection safe."
      },
      {
        "name": "execTest",
        "desc": ""
      },
      {
        "name": "goodMarshaler",
        "desc": ""
      },
      {
        "name": "jsCtx",
        "desc": "jsCtx determines whether a '/' starts a regular expression literal or a division operator."
      },
      {
        "name": "jsonErrType",
        "desc": ""
      },
      {
        "name": "myStringer",
        "desc": "Test that we print using the String method. Was issue 3073."
      },
      {
        "name": "nameSpace",
        "desc": "nameSpace is the data structure shared by all templates in an association."
      },
      {
        "name": "rangeContext",
        "desc": "rangeContext holds information about the current range loop."
      },
      {
        "name": "recursiveInvoker",
        "desc": "recursiveInvoker is for TestRecursiveExecuteViaMethod."
      },
      {
        "name": "state",
        "desc": "state describes a high-level HTML parser state.  It bounds the top of the element stack, and by extension the HTML insertion mode, but also contains state that does not correspond to anything in the HTML5 parsing algorithm because a single token production in the HTML grammar may contain embedded actions in a template. For instance, the quoted HTML attribute produced by  \t\u003cdiv title=\"Hello {{.World}}\"\u003e  is a single token in HTML's grammar but in a template spans several nodes."
      },
      {
        "name": "urlPart",
        "desc": "urlPart identifies a part in an RFC 3986 hierarchical URL to allow different encoding strategies."
      }
    ]
  },
  {
    "name": "image",
    "desc": "Package image implements a basic 2-D image library.  The fundamental interface is called [Image]. An [Image] contains colors, which are described in the image/color package.  Values of the [Image] interface are created either by calling functions such as [NewRGBA] and [NewPaletted], or by calling [Decode] on an [io.Reader] containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have  \timport _ \"image/png\"  in a program's main package. The _ means to import a package purely for its initialization side effects.  See \"The Go image package\" for more details: https://golang.org/doc/articles/image_package.html  # Security Considerations  The image package can be used to parse arbitrarily large images, which can cause resource exhaustion on machines which do not have enough memory to store them. When operating on arbitrary images, [DecodeConfig] should be called before [Decode], so that the program can decide whether the image, as defined in the returned header, can be safely decoded with the available resources. A call to [Decode] which produces an extremely large image, as defined in the header returned by [DecodeConfig], is not considered a security issue, regardless of whether the image is itself malformed or not. A call to [DecodeConfig] which returns a header which does not match the image returned by [Decode] may be considered a security issue, and should be reported per the [Go Security Policy](https://go.dev/security/policy).",
    "functions": [
      {
        "name": "BenchmarkAlpha16At",
        "desc": ""
      },
      {
        "name": "BenchmarkAlphaAt",
        "desc": ""
      },
      {
        "name": "BenchmarkAlphaSetAlpha",
        "desc": ""
      },
      {
        "name": "BenchmarkAlphaSetAlpha16",
        "desc": ""
      },
      {
        "name": "BenchmarkAt",
        "desc": ""
      },
      {
        "name": "BenchmarkGray16At",
        "desc": ""
      },
      {
        "name": "BenchmarkGrayAt",
        "desc": ""
      },
      {
        "name": "BenchmarkGraySetGray",
        "desc": ""
      },
      {
        "name": "BenchmarkGraySetGray16",
        "desc": ""
      },
      {
        "name": "BenchmarkNRGBA64At",
        "desc": ""
      },
      {
        "name": "BenchmarkNRGBA64SetNRGBA64",
        "desc": ""
      },
      {
        "name": "BenchmarkNRGBAAt",
        "desc": ""
      },
      {
        "name": "BenchmarkNRGBASetNRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBA64At",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBA64SetRGBA64",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBAAt",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBASetRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkSet",
        "desc": ""
      },
      {
        "name": "RegisterFormat",
        "desc": "RegisterFormat registers an image format for use by [Decode]. Name is the name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix that identifies the format's encoding. The magic string can contain \"?\" wildcards that each match any one byte. [Decode] is the function that decodes the encoded image. [DecodeConfig] is the function that decodes just its configuration."
      },
      {
        "name": "Test16BitsPerColorChannel",
        "desc": ""
      },
      {
        "name": "TestImage",
        "desc": ""
      },
      {
        "name": "TestNewXxxBadRectangle",
        "desc": ""
      },
      {
        "name": "TestRGBA64Image",
        "desc": ""
      },
      {
        "name": "TestRectangle",
        "desc": ""
      },
      {
        "name": "TestYCbCr",
        "desc": ""
      },
      {
        "name": "TestYCbCrSlicesDontOverlap",
        "desc": ""
      },
      {
        "name": "add2NonNeg",
        "desc": "add2NonNeg returns (x + y), unless at least one argument is negative or if the computation overflows the int type, in which case it returns -1."
      },
      {
        "name": "cmp",
        "desc": ""
      },
      {
        "name": "match",
        "desc": "match reports whether magic matches b. Magic may contain \"?\" wildcards."
      },
      {
        "name": "mul3NonNeg",
        "desc": "mul3NonNeg returns (x * y * z), unless at least one argument is negative or if the computation overflows the int type, in which case it returns -1."
      },
      {
        "name": "pixelBufferLength",
        "desc": "pixelBufferLength returns the length of the []uint8 typed Pix slice field for the NewXxx functions. Conceptually, this is just (bpp * width * height), but this function panics if at least one of those is negative or if the computation would overflow the int type.  This panics instead of returning an error because of backwards compatibility. The NewXxx functions do not return an error."
      },
      {
        "name": "testYCbCr",
        "desc": ""
      },
      {
        "name": "yCbCrSize",
        "desc": ""
      },
      {
        "name": "AlphaAt",
        "desc": ""
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetAlpha",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "Alpha16At",
        "desc": ""
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetAlpha16",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "CMYKAt",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetCMYK",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "GrayAt",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetGray",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Gray16At",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetGray16",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "NRGBAAt",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetNRGBA",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "NRGBA64At",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetNRGBA64",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "AOffset",
        "desc": "AOffset returns the index of the first element of A that corresponds to the pixel at (x, y)."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "NYCbCrAAt",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorIndexAt",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetColorIndex",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "Add",
        "desc": "Add returns the vector p+q."
      },
      {
        "name": "Div",
        "desc": "Div returns the vector p/k."
      },
      {
        "name": "Eq",
        "desc": "Eq reports whether p and q are equal."
      },
      {
        "name": "In",
        "desc": "In reports whether p is in r."
      },
      {
        "name": "Mod",
        "desc": "Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height."
      },
      {
        "name": "Mul",
        "desc": "Mul returns the vector p*k."
      },
      {
        "name": "String",
        "desc": "String returns a string representation of p like \"(3,4)\"."
      },
      {
        "name": "Sub",
        "desc": "Sub returns the vector p-q."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "RGBAAt",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetRGBA",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "PixOffset",
        "desc": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y)."
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "Add",
        "desc": "Add returns the rectangle r translated by p."
      },
      {
        "name": "At",
        "desc": "At implements the [Image] interface."
      },
      {
        "name": "Bounds",
        "desc": "Bounds implements the [Image] interface."
      },
      {
        "name": "Canon",
        "desc": "Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed."
      },
      {
        "name": "ColorModel",
        "desc": "ColorModel implements the [Image] interface."
      },
      {
        "name": "Dx",
        "desc": "Dx returns r's width."
      },
      {
        "name": "Dy",
        "desc": "Dy returns r's height."
      },
      {
        "name": "Empty",
        "desc": "Empty reports whether the rectangle contains no points."
      },
      {
        "name": "Eq",
        "desc": "Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal."
      },
      {
        "name": "In",
        "desc": "In reports whether every point in r is in s."
      },
      {
        "name": "Inset",
        "desc": "Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned."
      },
      {
        "name": "Intersect",
        "desc": "Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned."
      },
      {
        "name": "Overlaps",
        "desc": "Overlaps reports whether r and s have a non-empty intersection."
      },
      {
        "name": "RGBA64At",
        "desc": "RGBA64At implements the [RGBA64Image] interface."
      },
      {
        "name": "Size",
        "desc": "Size returns r's width and height."
      },
      {
        "name": "String",
        "desc": "String returns a string representation of r like \"(3,4)-(6,5)\"."
      },
      {
        "name": "Sub",
        "desc": "Sub returns the rectangle r translated by -p."
      },
      {
        "name": "Union",
        "desc": "Union returns the smallest rectangle that contains both r and s."
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Convert",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": "Opaque scans the entire image and reports whether it is fully opaque."
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "COffset",
        "desc": "COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y)."
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "Opaque",
        "desc": ""
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "SubImage",
        "desc": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image."
      },
      {
        "name": "YCbCrAt",
        "desc": ""
      },
      {
        "name": "YOffset",
        "desc": "YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y)."
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Alpha",
        "desc": "Alpha is an in-memory image whose At method returns [color.Alpha] values."
      },
      {
        "name": "Alpha16",
        "desc": "Alpha16 is an in-memory image whose At method returns [color.Alpha16] values."
      },
      {
        "name": "CMYK",
        "desc": "CMYK is an in-memory image whose At method returns [color.CMYK] values."
      },
      {
        "name": "Config",
        "desc": "Config holds an image's color model and dimensions."
      },
      {
        "name": "Gray",
        "desc": "Gray is an in-memory image whose At method returns [color.Gray] values."
      },
      {
        "name": "Gray16",
        "desc": "Gray16 is an in-memory image whose At method returns [color.Gray16] values."
      },
      {
        "name": "Image",
        "desc": "Image is a finite rectangular grid of [color.Color] values taken from a color model."
      },
      {
        "name": "NRGBA",
        "desc": "NRGBA is an in-memory image whose At method returns [color.NRGBA] values."
      },
      {
        "name": "NRGBA64",
        "desc": "NRGBA64 is an in-memory image whose At method returns [color.NRGBA64] values."
      },
      {
        "name": "NYCbCrA",
        "desc": "NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr."
      },
      {
        "name": "Paletted",
        "desc": "Paletted is an in-memory image of uint8 indices into a given palette."
      },
      {
        "name": "PalettedImage",
        "desc": "PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a [color.Palette] p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined."
      },
      {
        "name": "Point",
        "desc": "A Point is an X, Y coordinate pair. The axes increase right and down."
      },
      {
        "name": "RGBA",
        "desc": "RGBA is an in-memory image whose At method returns [color.RGBA] values."
      },
      {
        "name": "RGBA64",
        "desc": "RGBA64 is an in-memory image whose At method returns [color.RGBA64] values."
      },
      {
        "name": "RGBA64Image",
        "desc": "RGBA64Image is an [Image] whose pixels can be converted directly to a color.RGBA64."
      },
      {
        "name": "Rectangle",
        "desc": "A Rectangle contains the points with Min.X \u003c= X \u003c Max.X, Min.Y \u003c= Y \u003c Max.Y. It is well-formed if Min.X \u003c= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs.  A Rectangle is also an [Image] whose bounds are the rectangle itself. At returns color.Opaque for points in the rectangle and color.Transparent otherwise."
      },
      {
        "name": "Uniform",
        "desc": "Uniform is an infinite-sized [Image] of uniform color. It implements the [color.Color], [color.Model], and [Image] interfaces."
      },
      {
        "name": "YCbCr",
        "desc": "YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and:  \tFor 4:4:4, CStride == YStride/1 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/1. \tFor 4:2:2, CStride == YStride/2 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/2. \tFor 4:2:0, CStride == YStride/2 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/4. \tFor 4:4:0, CStride == YStride/1 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/2. \tFor 4:1:1, CStride == YStride/4 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/4. \tFor 4:1:0, CStride == YStride/4 \u0026\u0026 len(Cb) == len(Cr) == len(Y)/8."
      },
      {
        "name": "YCbCrSubsampleRatio",
        "desc": "YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image."
      },
      {
        "name": "format",
        "desc": "A format holds an image format's name, magic header and how to decode it."
      },
      {
        "name": "image",
        "desc": ""
      },
      {
        "name": "reader",
        "desc": "A reader is an io.Reader that can also peek ahead."
      }
    ]
  },
  {
    "name": "image/color",
    "desc": "Package color implements a basic color library.",
    "functions": [
      {
        "name": "BenchmarkNYCbCrAToRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBToYCbCr",
        "desc": ""
      },
      {
        "name": "BenchmarkYCbCrToRGB",
        "desc": ""
      },
      {
        "name": "BenchmarkYCbCrToRGBA",
        "desc": ""
      },
      {
        "name": "CMYKToRGB",
        "desc": "CMYKToRGB converts a [CMYK] quadruple to an RGB triple."
      },
      {
        "name": "RGBToCMYK",
        "desc": "RGBToCMYK converts an RGB triple to a CMYK quadruple."
      },
      {
        "name": "RGBToYCbCr",
        "desc": "RGBToYCbCr converts an RGB triple to a Y'CbCr triple."
      },
      {
        "name": "TestCMYKGray",
        "desc": "TestCMYKGray tests that CMYK colors are a superset of Gray colors."
      },
      {
        "name": "TestCMYKRoundtrip",
        "desc": "TestCMYKRoundtrip tests that a subset of RGB space can be converted to CMYK and back to within 1/256 tolerance."
      },
      {
        "name": "TestCMYKToRGBConsistency",
        "desc": "TestCMYKToRGBConsistency tests that calling the RGBA method (16 bit color) then truncating to 8 bits is equivalent to calling the CMYKToRGB function (8 bit color)."
      },
      {
        "name": "TestNYCbCrAAlpha",
        "desc": "TestNYCbCrAAlpha tests that NYCbCrA colors are a superset of Alpha colors."
      },
      {
        "name": "TestNYCbCrAYCbCr",
        "desc": "TestNYCbCrAYCbCr tests that NYCbCrA colors are a superset of YCbCr colors."
      },
      {
        "name": "TestPalette",
        "desc": ""
      },
      {
        "name": "TestSqDiff",
        "desc": ""
      },
      {
        "name": "TestYCbCrGray",
        "desc": "TestYCbCrGray tests that YCbCr colors are a superset of Gray colors."
      },
      {
        "name": "TestYCbCrRoundtrip",
        "desc": "TestYCbCrRoundtrip tests that a subset of RGB space can be converted to YCbCr and back to within 2/256 tolerance."
      },
      {
        "name": "TestYCbCrToRGBConsistency",
        "desc": "TestYCbCrToRGBConsistency tests that calling the RGBA method (16 bit color) then truncating to 8 bits is equivalent to calling the YCbCrToRGB function (8 bit color)."
      },
      {
        "name": "YCbCrToRGB",
        "desc": "YCbCrToRGB converts a Y'CbCr triple to an RGB triple."
      },
      {
        "name": "delta",
        "desc": ""
      },
      {
        "name": "eq",
        "desc": ""
      },
      {
        "name": "sqDiff",
        "desc": "sqDiff returns the squared-difference of x and y, shifted by 2 so that adding four of those won't overflow a uint32.  x and y are both assumed to be in the range [0, 0xffff]."
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "Convert",
        "desc": "Convert returns the palette color closest to c in Euclidean R,G,B space."
      },
      {
        "name": "Index",
        "desc": "Index returns the index of the palette color closest to c in Euclidean R,G,B,A space."
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "RGBA",
        "desc": ""
      },
      {
        "name": "Convert",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Alpha",
        "desc": "Alpha represents an 8-bit alpha color."
      },
      {
        "name": "Alpha16",
        "desc": "Alpha16 represents a 16-bit alpha color."
      },
      {
        "name": "CMYK",
        "desc": "CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan, magenta, yellow and black.  It is not associated with any particular color profile."
      },
      {
        "name": "Color",
        "desc": "Color can convert itself to alpha-premultiplied 16-bits per channel RGBA. The conversion may be lossy."
      },
      {
        "name": "Gray",
        "desc": "Gray represents an 8-bit grayscale color."
      },
      {
        "name": "Gray16",
        "desc": "Gray16 represents a 16-bit grayscale color."
      },
      {
        "name": "Model",
        "desc": "Model can convert any [Color] to one from its own color model. The conversion may be lossy."
      },
      {
        "name": "NRGBA",
        "desc": "NRGBA represents a non-alpha-premultiplied 32-bit color."
      },
      {
        "name": "NRGBA64",
        "desc": "NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha."
      },
      {
        "name": "NYCbCrA",
        "desc": "NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component."
      },
      {
        "name": "Palette",
        "desc": "Palette is a palette of colors."
      },
      {
        "name": "RGBA",
        "desc": "RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.  An alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 \u003c= C \u003c= A."
      },
      {
        "name": "RGBA64",
        "desc": "RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.  An alpha-premultiplied color component C has been scaled by alpha (A), so has valid values 0 \u003c= C \u003c= A."
      },
      {
        "name": "YCbCr",
        "desc": "YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for one luma and two chroma components.  JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.  Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly different formulae for converting between the two. This package follows the JFIF specification at https://www.w3.org/Graphics/JPEG/jfif3.pdf."
      },
      {
        "name": "modelFunc",
        "desc": ""
      }
    ]
  },
  {
    "name": "image/color/palette",
    "desc": "Package palette provides standard color palettes.",
    "functions": null,
    "types": null
  },
  {
    "name": "image/draw",
    "desc": "Package draw provides image composition functions.  See \"The Go image/draw package\" for an introduction to this package: https://golang.org/doc/articles/image_draw.html",
    "functions": [
      {
        "name": "BenchmarkCMYK",
        "desc": ""
      },
      {
        "name": "BenchmarkCopyOver",
        "desc": ""
      },
      {
        "name": "BenchmarkCopySrc",
        "desc": ""
      },
      {
        "name": "BenchmarkFillOver",
        "desc": ""
      },
      {
        "name": "BenchmarkFillSrc",
        "desc": ""
      },
      {
        "name": "BenchmarkGenericMaskOver",
        "desc": ""
      },
      {
        "name": "BenchmarkGenericMaskSrc",
        "desc": ""
      },
      {
        "name": "BenchmarkGenericOver",
        "desc": ""
      },
      {
        "name": "BenchmarkGenericSrc",
        "desc": ""
      },
      {
        "name": "BenchmarkGlyphOver",
        "desc": ""
      },
      {
        "name": "BenchmarkGray",
        "desc": ""
      },
      {
        "name": "BenchmarkGrayMaskOver",
        "desc": ""
      },
      {
        "name": "BenchmarkNRGBAOver",
        "desc": ""
      },
      {
        "name": "BenchmarkNRGBASrc",
        "desc": ""
      },
      {
        "name": "BenchmarkPalettedFill",
        "desc": ""
      },
      {
        "name": "BenchmarkPalettedRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBA64ImageMaskOver",
        "desc": ""
      },
      {
        "name": "BenchmarkRGBAMaskOver",
        "desc": ""
      },
      {
        "name": "BenchmarkYCbCr",
        "desc": ""
      },
      {
        "name": "Draw",
        "desc": "Draw calls [DrawMask] with a nil mask."
      },
      {
        "name": "DrawMask",
        "desc": "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque."
      },
      {
        "name": "TestClip",
        "desc": ""
      },
      {
        "name": "TestDraw",
        "desc": ""
      },
      {
        "name": "TestDrawOverlap",
        "desc": ""
      },
      {
        "name": "TestDrawSrcNonpremultiplied",
        "desc": ""
      },
      {
        "name": "TestFill",
        "desc": ""
      },
      {
        "name": "TestFloydSteinbergCheckerboard",
        "desc": "TestFloydSteinbergCheckerboard tests that the result of Floyd-Steinberg error diffusion of a uniform 50% gray source image with a black-and-white palette is a checkerboard pattern."
      },
      {
        "name": "TestNonZeroSrcPt",
        "desc": "TestNonZeroSrcPt checks drawing with a non-zero src point parameter."
      },
      {
        "name": "TestPaletted",
        "desc": "TestPaletted tests that the drawPaletted function behaves the same regardless of whether dst is an *image.Paletted."
      },
      {
        "name": "TestSqDiff",
        "desc": ""
      },
      {
        "name": "bench",
        "desc": "bench benchmarks drawing src and mask images onto a dst image with the given op and the color models to create those images from. The created images' pixels are initialized to non-zero values."
      },
      {
        "name": "clamp",
        "desc": "clamp clamps i to the interval [0, 0xffff]."
      },
      {
        "name": "clip",
        "desc": "clip clips r against each image's bounds (after translating into the destination image's coordinate space) and shifts the points sp and mp by the same amount as the change in r.Min."
      },
      {
        "name": "drawCMYK",
        "desc": ""
      },
      {
        "name": "drawCopyOver",
        "desc": ""
      },
      {
        "name": "drawCopySrc",
        "desc": "drawCopySrc copies bytes to dstPix from srcPix. These arguments roughly correspond to the Pix fields of the image package's concrete image.Image implementations, but are offset (dstPix is dst.Pix[dpOffset:] not dst.Pix)."
      },
      {
        "name": "drawFillOver",
        "desc": ""
      },
      {
        "name": "drawFillSrc",
        "desc": ""
      },
      {
        "name": "drawGlyphOver",
        "desc": ""
      },
      {
        "name": "drawGray",
        "desc": ""
      },
      {
        "name": "drawGrayMaskOver",
        "desc": ""
      },
      {
        "name": "drawNRGBAOver",
        "desc": ""
      },
      {
        "name": "drawNRGBASrc",
        "desc": ""
      },
      {
        "name": "drawPaletted",
        "desc": ""
      },
      {
        "name": "drawRGBA",
        "desc": ""
      },
      {
        "name": "drawRGBA64ImageMaskOver",
        "desc": ""
      },
      {
        "name": "drawRGBAMaskOver",
        "desc": ""
      },
      {
        "name": "eq",
        "desc": ""
      },
      {
        "name": "fillAlpha",
        "desc": ""
      },
      {
        "name": "fillBlue",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "makeGolden",
        "desc": ""
      },
      {
        "name": "processBackward",
        "desc": ""
      },
      {
        "name": "sqDiff",
        "desc": "sqDiff returns the squared-difference of x and y, shifted by 2 so that adding four of those won't overflow a uint32.  x and y are both assumed to be in the range [0, 0xffff]."
      },
      {
        "name": "vgradAlpha",
        "desc": ""
      },
      {
        "name": "vgradCr",
        "desc": ""
      },
      {
        "name": "vgradGray",
        "desc": ""
      },
      {
        "name": "vgradGreen",
        "desc": ""
      },
      {
        "name": "vgradGreenNRGBA",
        "desc": ""
      },
      {
        "name": "vgradMagenta",
        "desc": ""
      },
      {
        "name": "Draw",
        "desc": "Draw implements the [Drawer] interface by calling the Draw function with this [Op]."
      },
      {
        "name": "Draw",
        "desc": ""
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "PixOffset",
        "desc": ""
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "SetRGBA64",
        "desc": ""
      },
      {
        "name": "At",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "ColorModel",
        "desc": ""
      },
      {
        "name": "PixOffset",
        "desc": ""
      },
      {
        "name": "RGBA64At",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Drawer",
        "desc": "Drawer contains the [Draw] method."
      },
      {
        "name": "Image",
        "desc": "Image is an image.Image with a Set method to change a single pixel."
      },
      {
        "name": "Op",
        "desc": "Op is a Porter-Duff compositing operator."
      },
      {
        "name": "Quantizer",
        "desc": "Quantizer produces a palette for an image."
      },
      {
        "name": "RGBA64Image",
        "desc": "RGBA64Image extends both the [Image] and [image.RGBA64Image] interfaces with a SetRGBA64 method to change a single pixel. SetRGBA64 is equivalent to calling Set, but it can avoid allocations from converting concrete color types to the [color.Color] interface type."
      },
      {
        "name": "clipTest",
        "desc": ""
      },
      {
        "name": "drawTest",
        "desc": ""
      },
      {
        "name": "embeddedPaletted",
        "desc": "embeddedPaletted is an Image that behaves like an *image.Paletted but whose type is not *image.Paletted."
      },
      {
        "name": "floydSteinberg",
        "desc": ""
      },
      {
        "name": "slowerRGBA",
        "desc": "slowerRGBA is a draw.Image like image.RGBA but it is a different type and therefore does not trigger the draw.go fastest code paths.  Unlike slowestRGBA, it still implements the draw.RGBA64Image interface."
      },
      {
        "name": "slowestRGBA",
        "desc": "slowestRGBA is a draw.Image like image.RGBA, but it is a different type and therefore does not trigger the draw.go fastest code paths.  Unlike slowerRGBA, it does not implement the draw.RGBA64Image interface."
      }
    ]
  },
  {
    "name": "image/gif",
    "desc": "Package gif implements a GIF image decoder and encoder.  The GIF specification is at https://www.w3.org/Graphics/GIF/spec-gif89a.txt.",
    "functions": [
      {
        "name": "BenchmarkDecode",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeRandomPaletted",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeRandomRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeRealisticPaletted",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeRealisticRGBA",
        "desc": ""
      },
      {
        "name": "Decode",
        "desc": "Decode reads a GIF image from r and returns the first embedded image as an [image.Image]."
      },
      {
        "name": "DecodeConfig",
        "desc": "DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image."
      },
      {
        "name": "Encode",
        "desc": "Encode writes the Image m to w in GIF format."
      },
      {
        "name": "EncodeAll",
        "desc": "EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames."
      },
      {
        "name": "FuzzDecode",
        "desc": ""
      },
      {
        "name": "TestBounds",
        "desc": ""
      },
      {
        "name": "TestColorTablesMatch",
        "desc": ""
      },
      {
        "name": "TestDecode",
        "desc": ""
      },
      {
        "name": "TestDecodeMemoryConsumption",
        "desc": "See golang.org/issue/22237"
      },
      {
        "name": "TestEncodeAllFramesOutOfBounds",
        "desc": ""
      },
      {
        "name": "TestEncodeAllGo1Dot4",
        "desc": ""
      },
      {
        "name": "TestEncodeAllGo1Dot5",
        "desc": ""
      },
      {
        "name": "TestEncodeAllGo1Dot5GlobalColorModel",
        "desc": ""
      },
      {
        "name": "TestEncodeBadPalettes",
        "desc": ""
      },
      {
        "name": "TestEncodeCroppedSubImages",
        "desc": ""
      },
      {
        "name": "TestEncodeImplicitConfigSize",
        "desc": ""
      },
      {
        "name": "TestEncodeMismatchDelay",
        "desc": ""
      },
      {
        "name": "TestEncodeNonZeroMinPoint",
        "desc": ""
      },
      {
        "name": "TestEncodePalettes",
        "desc": ""
      },
      {
        "name": "TestEncodeWrappedImage",
        "desc": ""
      },
      {
        "name": "TestEncodeZeroGIF",
        "desc": ""
      },
      {
        "name": "TestLoopCount",
        "desc": ""
      },
      {
        "name": "TestNoPalette",
        "desc": ""
      },
      {
        "name": "TestPixelOutsidePaletteRange",
        "desc": ""
      },
      {
        "name": "TestReencodeExtendedPalette",
        "desc": ""
      },
      {
        "name": "TestSubImage",
        "desc": ""
      },
      {
        "name": "TestTransparentIndex",
        "desc": ""
      },
      {
        "name": "TestTransparentPixelOutsidePaletteRange",
        "desc": ""
      },
      {
        "name": "TestUnexpectedEOF",
        "desc": ""
      },
      {
        "name": "TestWriter",
        "desc": ""
      },
      {
        "name": "averageDelta",
        "desc": "averageDelta returns the average delta in RGB space. The two images must have the same bounds."
      },
      {
        "name": "averageDeltaBound",
        "desc": "averageDeltaBound returns the average delta in RGB space. The average delta is calculated in the specified bounds."
      },
      {
        "name": "delta",
        "desc": ""
      },
      {
        "name": "encodeColorTable",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "log2",
        "desc": ""
      },
      {
        "name": "lzwEncode",
        "desc": "lzwEncode returns an LZW encoding (with 2-bit literals) of in."
      },
      {
        "name": "palettesEqual",
        "desc": "palettesEqual reports whether two color.Palette values are equal, ignoring any trailing opaque-black palette entries."
      },
      {
        "name": "readByte",
        "desc": ""
      },
      {
        "name": "readFull",
        "desc": ""
      },
      {
        "name": "readImg",
        "desc": ""
      },
      {
        "name": "testEncodeAll",
        "desc": ""
      },
      {
        "name": "try",
        "desc": ""
      },
      {
        "name": "uninterlace",
        "desc": "uninterlace rearranges the pixels in m to account for interlaced input."
      },
      {
        "name": "Read",
        "desc": "blockReader must implement io.Reader, but its Read shouldn't ever actually be called in practice. The compress/lzw package will only call [blockReader.ReadByte]."
      },
      {
        "name": "ReadByte",
        "desc": ""
      },
      {
        "name": "close",
        "desc": "close primarily detects whether or not a block terminator was encountered after reading a sequence of data sub-blocks. It allows at most one trailing sub-block worth of data. I.e., if some number of bytes exist in one sub-block following the end of LZW data, the very next sub-block must be the block terminator. If the very end of LZW data happened to fill one sub-block, at most one more sub-block of length 1 may exist before the block-terminator. These accommodations allow us to support GIFs created by less strict encoders. See https://golang.org/issue/16146."
      },
      {
        "name": "fill",
        "desc": ""
      },
      {
        "name": "Flush",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": "blockWriter must be an io.Writer for lzw.NewWriter, but this is never actually called."
      },
      {
        "name": "WriteByte",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "setup",
        "desc": ""
      },
      {
        "name": "decode",
        "desc": "decode reads a GIF image from r and stores the result in d."
      },
      {
        "name": "newImageFromDescriptor",
        "desc": ""
      },
      {
        "name": "readBlock",
        "desc": ""
      },
      {
        "name": "readColorTable",
        "desc": ""
      },
      {
        "name": "readExtension",
        "desc": ""
      },
      {
        "name": "readGraphicControl",
        "desc": ""
      },
      {
        "name": "readHeaderAndScreenDescriptor",
        "desc": ""
      },
      {
        "name": "readImageDescriptor",
        "desc": ""
      },
      {
        "name": "colorTablesMatch",
        "desc": ""
      },
      {
        "name": "flush",
        "desc": ""
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeByte",
        "desc": ""
      },
      {
        "name": "writeHeader",
        "desc": ""
      },
      {
        "name": "writeImageBlock",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "GIF",
        "desc": "GIF represents the possibly multiple images stored in a GIF file."
      },
      {
        "name": "Options",
        "desc": "Options are the encoding parameters."
      },
      {
        "name": "blockReader",
        "desc": "blockReader parses the block structure of GIF image data, which comprises (n, (n bytes)) blocks, with 1 \u003c= n \u003c= 255. It is the reader given to the LZW decoder, which is thus immune to the blocking. After the LZW decoder completes, there will be a 0-byte block remaining (0, ()), which is consumed when checking that the blockReader is exhausted.  To avoid the allocation of a bufio.Reader for the lzw Reader, blockReader implements io.ByteReader and buffers blocks into the decoder's \"tmp\" buffer."
      },
      {
        "name": "blockWriter",
        "desc": "blockWriter writes the block structure of GIF image data, which comprises (n, (n bytes)) blocks, with 1 \u003c= n \u003c= 255. It is the writer given to the LZW encoder, which is thus immune to the blocking."
      },
      {
        "name": "decoder",
        "desc": "decoder is the type used to decode a GIF file."
      },
      {
        "name": "encoder",
        "desc": "encoder encodes an image to the GIF format."
      },
      {
        "name": "interlaceScan",
        "desc": "interlaceScan defines the ordering for a pass of the interlace algorithm."
      },
      {
        "name": "offsetImage",
        "desc": ""
      },
      {
        "name": "reader",
        "desc": "If the io.Reader does not also have ReadByte, then decode will introduce its own buffering."
      },
      {
        "name": "writer",
        "desc": "writer is a buffered writer."
      }
    ]
  },
  {
    "name": "image/jpeg",
    "desc": "Package jpeg implements a JPEG image decoder and encoder.  JPEG is defined in ITU-T T.81: https://www.w3.org/Graphics/JPEG/itu-t81.pdf.",
    "functions": [
      {
        "name": "BenchmarkDecodeBaseline",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeProgressive",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeRGBA",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeYCbCr",
        "desc": ""
      },
      {
        "name": "BenchmarkFDCT",
        "desc": ""
      },
      {
        "name": "BenchmarkIDCT",
        "desc": ""
      },
      {
        "name": "Decode",
        "desc": "Decode reads a JPEG image from r and returns it as an [image.Image]."
      },
      {
        "name": "DecodeConfig",
        "desc": "DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image."
      },
      {
        "name": "Encode",
        "desc": "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil *[Options] is passed."
      },
      {
        "name": "FuzzDecode",
        "desc": ""
      },
      {
        "name": "TestBadRestartMarker",
        "desc": ""
      },
      {
        "name": "TestDCT",
        "desc": ""
      },
      {
        "name": "TestDecodeEOF",
        "desc": ""
      },
      {
        "name": "TestDecodeProgressive",
        "desc": "TestDecodeProgressive tests that decoding the baseline and progressive versions of the same image result in exactly the same pixel data, in YCbCr space for color images, and Y space for grayscale images."
      },
      {
        "name": "TestEncodeYCbCr",
        "desc": ""
      },
      {
        "name": "TestExtraneousData",
        "desc": ""
      },
      {
        "name": "TestIssue56724",
        "desc": ""
      },
      {
        "name": "TestLargeImageWithShortData",
        "desc": ""
      },
      {
        "name": "TestPaddedRSTMarker",
        "desc": ""
      },
      {
        "name": "TestTruncatedSOSDataDoesntPanic",
        "desc": ""
      },
      {
        "name": "TestUnscaledQuant",
        "desc": ""
      },
      {
        "name": "TestWriteGrayscale",
        "desc": "TestWriteGrayscale tests that a grayscale images survives a round-trip through encode/decode cycle."
      },
      {
        "name": "TestWriter",
        "desc": ""
      },
      {
        "name": "TestZigUnzig",
        "desc": ""
      },
      {
        "name": "alpha",
        "desc": "alpha returns 1 if i is 0 and returns √2 otherwise."
      },
      {
        "name": "averageDelta",
        "desc": "averageDelta returns the average delta in RGB space. The two images must have the same bounds."
      },
      {
        "name": "benchmarkDCT",
        "desc": ""
      },
      {
        "name": "benchmarkDecode",
        "desc": ""
      },
      {
        "name": "check",
        "desc": "check checks that the two pix data are equal, within the given bounds."
      },
      {
        "name": "decodeFile",
        "desc": ""
      },
      {
        "name": "delta",
        "desc": ""
      },
      {
        "name": "differ",
        "desc": "differ reports whether any pair-wise elements in b0 and b1 differ by 2 or more. That tolerance is because there isn't a single definitive decoding of a given JPEG image, even before the YCbCr to RGB conversion; implementations can have different IDCT rounding errors."
      },
      {
        "name": "div",
        "desc": "div returns a/b rounded to the nearest integer, instead of rounded to zero."
      },
      {
        "name": "fdct",
        "desc": "fdct performs a forward DCT on an 8x8 block of coefficients, including a level shift."
      },
      {
        "name": "grayToY",
        "desc": "grayToY stores the 8x8 region of m whose top-left corner is p in yBlock."
      },
      {
        "name": "idct",
        "desc": "idct performs a 2-D Inverse Discrete Cosine Transformation.  The input coefficients should already have been multiplied by the appropriate quantization table. We use fixed-point computation, with the number of bits for the fractional component varying over the intermediate stages.  For more on the actual algorithm, see Z. Wang, \"Fast algorithms for the discrete W transform and for the discrete Fourier transform\", IEEE Trans. on ASSP, Vol. ASSP- 32, pp. 803-816, Aug. 1984."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "pixString",
        "desc": ""
      },
      {
        "name": "readPng",
        "desc": ""
      },
      {
        "name": "rgbaToYCbCr",
        "desc": "rgbaToYCbCr is a specialized version of toYCbCr for image.RGBA images."
      },
      {
        "name": "scale",
        "desc": "scale scales the 16x16 region represented by the 4 src blocks to the 8x8 dst block."
      },
      {
        "name": "slowFDCT",
        "desc": "slowFDCT performs the 8*8 2-dimensional forward discrete cosine transform:  \tdst[u,v] = (1/8) * Σ_x Σ_y alpha(u) * alpha(v) * src[x,y] * \t\tcos((π/2) * (2*x + 1) * u / 8) * \t\tcos((π/2) * (2*y + 1) * v / 8)  x and y are in pixel space, and u and v are in transform space.  b acts as both dst and src."
      },
      {
        "name": "slowIDCT",
        "desc": "slowIDCT performs the 8*8 2-dimensional inverse discrete cosine transform:  \tdst[x,y] = (1/8) * Σ_u Σ_v alpha(u) * alpha(v) * src[u,v] * \t\tcos((π/2) * (2*x + 1) * u / 8) * \t\tcos((π/2) * (2*y + 1) * v / 8)  x and y are in pixel space, and u and v are in transform space.  b acts as both dst and src."
      },
      {
        "name": "toYCbCr",
        "desc": "toYCbCr converts the 8x8 region of m whose top-left corner is p to its YCbCr values."
      },
      {
        "name": "yCbCrToYCbCr",
        "desc": "yCbCrToYCbCr is a specialized version of toYCbCr for image.YCbCr images."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "applyBlack",
        "desc": "applyBlack combines d.img3 and d.blackPix into a CMYK image. The formula used depends on whether the JPEG image is stored as CMYK or YCbCrK, indicated by the APP14 (Adobe) metadata.  Adobe CMYK JPEG images are inverted, where 255 means no ink instead of full ink, so we apply \"v = 255 - v\" at various points. Note that a double inversion is a no-op, so inversions might be implicit in the code below."
      },
      {
        "name": "convertToRGB",
        "desc": ""
      },
      {
        "name": "decode",
        "desc": "decode reads a JPEG image from r and returns it as an image.Image."
      },
      {
        "name": "decodeBit",
        "desc": ""
      },
      {
        "name": "decodeBits",
        "desc": ""
      },
      {
        "name": "decodeHuffman",
        "desc": "decodeHuffman returns the next Huffman-coded value from the bit-stream, decoded according to h."
      },
      {
        "name": "ensureNBits",
        "desc": "ensureNBits reads bytes from the byte buffer to ensure that d.bits.n is at least n. For best performance (avoiding function calls inside hot loops), the caller is the one responsible for first checking that d.bits.n \u003c n."
      },
      {
        "name": "fill",
        "desc": "fill fills up the d.bytes.buf buffer from the underlying io.Reader. It should only be called when there are no unread bytes in d.bytes."
      },
      {
        "name": "findRST",
        "desc": "findRST advances past the next RST restart marker that matches expectedRST. Other than I/O errors, it is also an error if we encounter an {0xFF, M} two-byte marker sequence where M is not 0x00, 0xFF or the expectedRST.  This is similar to libjpeg's jdmarker.c's next_marker function. https://github.com/libjpeg-turbo/libjpeg-turbo/blob/2dfe6c0fe9e18671105e94f7cbf044d4a1d157e6/jdmarker.c#L892-L935  Precondition: d.tmp[:2] holds the next two bytes of JPEG-encoded input (input in the d.readFull sense)."
      },
      {
        "name": "ignore",
        "desc": "ignore ignores the next n bytes."
      },
      {
        "name": "isRGB",
        "desc": ""
      },
      {
        "name": "makeImg",
        "desc": "makeImg allocates and initializes the destination image."
      },
      {
        "name": "processApp0Marker",
        "desc": ""
      },
      {
        "name": "processApp14Marker",
        "desc": ""
      },
      {
        "name": "processDHT",
        "desc": "processDHT processes a Define Huffman Table marker, and initializes a huffman struct from its contents. Specified in section B.2.4.2."
      },
      {
        "name": "processDQT",
        "desc": "Specified in section B.2.4.1."
      },
      {
        "name": "processDRI",
        "desc": "Specified in section B.2.4.4."
      },
      {
        "name": "processSOF",
        "desc": "Specified in section B.2.2."
      },
      {
        "name": "processSOS",
        "desc": "Specified in section B.2.3."
      },
      {
        "name": "readByte",
        "desc": "readByte returns the next byte, whether buffered or not buffered. It does not care about byte stuffing."
      },
      {
        "name": "readByteStuffedByte",
        "desc": "readByteStuffedByte is like readByte but is for byte-stuffed Huffman data."
      },
      {
        "name": "readFull",
        "desc": "readFull reads exactly len(p) bytes into p. It does not care about byte stuffing."
      },
      {
        "name": "receiveExtend",
        "desc": "receiveExtend is the composition of RECEIVE and EXTEND, specified in section F.2.2.1."
      },
      {
        "name": "reconstructBlock",
        "desc": "reconstructBlock dequantizes, performs the inverse DCT and stores the block to the image."
      },
      {
        "name": "reconstructProgressiveImage",
        "desc": ""
      },
      {
        "name": "refine",
        "desc": "refine decodes a successive approximation refinement block, as specified in section G.1.2."
      },
      {
        "name": "refineNonZeroes",
        "desc": "refineNonZeroes refines non-zero entries of b in zig-zag order. If nz \u003e= 0, the first nz zero entries are skipped over."
      },
      {
        "name": "unreadByteStuffedByte",
        "desc": "unreadByteStuffedByte undoes the most recent readByteStuffedByte call, giving a byte of data back from d.bits to d.bytes. The Huffman look-up table requires at least 8 bits for look-up, which means that Huffman decoding can sometimes overshoot and read one or two too many bytes. Two-byte overshoot can happen when expecting to read a 0xff 0x00 byte-stuffed byte."
      },
      {
        "name": "emit",
        "desc": "emit emits the least significant nBits bits of bits to the bit-stream. The precondition is bits \u003c 1\u003c\u003cnBits \u0026\u0026 nBits \u003c= 16."
      },
      {
        "name": "emitHuff",
        "desc": "emitHuff emits the given value with the given Huffman encoder."
      },
      {
        "name": "emitHuffRLE",
        "desc": "emitHuffRLE emits a run of runLength copies of value encoded with the given Huffman encoder."
      },
      {
        "name": "flush",
        "desc": ""
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeBlock",
        "desc": "writeBlock writes a block of pixel data using the given quantization table, returning the post-quantized DC value of the DCT-transformed block. b is in natural (not zig-zag) order."
      },
      {
        "name": "writeByte",
        "desc": ""
      },
      {
        "name": "writeDHT",
        "desc": "writeDHT writes the Define Huffman Table marker."
      },
      {
        "name": "writeDQT",
        "desc": "writeDQT writes the Define Quantization Table marker."
      },
      {
        "name": "writeMarkerHeader",
        "desc": "writeMarkerHeader writes the header for a marker with the given length."
      },
      {
        "name": "writeSOF0",
        "desc": "writeSOF0 writes the Start Of Frame (Baseline Sequential) marker."
      },
      {
        "name": "writeSOS",
        "desc": "writeSOS writes the StartOfScan marker."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "FormatError",
        "desc": "A FormatError reports that the input is not a valid JPEG."
      },
      {
        "name": "Options",
        "desc": "Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better."
      },
      {
        "name": "Reader",
        "desc": "Deprecated: Reader is not used by the [image/jpeg] package and should not be used by others. It is kept for compatibility."
      },
      {
        "name": "UnsupportedError",
        "desc": "An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature."
      },
      {
        "name": "bits",
        "desc": "bits holds the unprocessed bits that have been taken from the byte-stream. The n least significant bits of a form the unread bits, to be read in MSB to LSB order."
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "component",
        "desc": "Component specification, specified in section B.2.2."
      },
      {
        "name": "decoder",
        "desc": ""
      },
      {
        "name": "encoder",
        "desc": "encoder encodes an image to the JPEG format."
      },
      {
        "name": "eofReader",
        "desc": ""
      },
      {
        "name": "huffIndex",
        "desc": ""
      },
      {
        "name": "huffman",
        "desc": "huffman is a Huffman decoder, specified in section C."
      },
      {
        "name": "huffmanLUT",
        "desc": "huffmanLUT is a compiled look-up table representation of a huffmanSpec. Each value maps to a uint32 of which the 8 most significant bits hold the codeword size in bits and the 24 least significant bits hold the codeword. The maximum codeword size is 16 bits."
      },
      {
        "name": "huffmanSpec",
        "desc": "huffmanSpec specifies a Huffman encoding."
      },
      {
        "name": "quantIndex",
        "desc": ""
      },
      {
        "name": "writer",
        "desc": "writer is a buffered writer."
      }
    ]
  },
  {
    "name": "image/png",
    "desc": "",
    "functions": [
      {
        "name": "ExampleDecode",
        "desc": ""
      },
      {
        "name": "ExampleEncode",
        "desc": ""
      },
      {
        "name": "gopherPNG",
        "desc": "gopherPNG creates an io.Reader by decoding the base64 encoded image data string in the gopher constant."
      }
    ],
    "types": null
  },
  {
    "name": "index/suffixarray",
    "desc": "",
    "functions": [
      {
        "name": "ExampleIndex_Lookup",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "io",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkCopyNLarge",
        "desc": ""
      },
      {
        "name": "BenchmarkCopyNSmall",
        "desc": ""
      },
      {
        "name": "ExampleCopy",
        "desc": ""
      },
      {
        "name": "ExampleCopyBuffer",
        "desc": ""
      },
      {
        "name": "ExampleCopyN",
        "desc": ""
      },
      {
        "name": "ExampleLimitReader",
        "desc": ""
      },
      {
        "name": "ExampleMultiReader",
        "desc": ""
      },
      {
        "name": "ExampleMultiWriter",
        "desc": ""
      },
      {
        "name": "ExamplePipe",
        "desc": ""
      },
      {
        "name": "ExampleReadAll",
        "desc": ""
      },
      {
        "name": "ExampleReadAtLeast",
        "desc": ""
      },
      {
        "name": "ExampleReadFull",
        "desc": ""
      },
      {
        "name": "ExampleSectionReader",
        "desc": ""
      },
      {
        "name": "ExampleSectionReader_Read",
        "desc": ""
      },
      {
        "name": "ExampleSectionReader_ReadAt",
        "desc": ""
      },
      {
        "name": "ExampleSectionReader_Seek",
        "desc": ""
      },
      {
        "name": "ExampleSectionReader_Size",
        "desc": ""
      },
      {
        "name": "ExampleSeeker_Seek",
        "desc": ""
      },
      {
        "name": "ExampleTeeReader",
        "desc": ""
      },
      {
        "name": "ExampleWriteString",
        "desc": ""
      },
      {
        "name": "TestCopy",
        "desc": ""
      },
      {
        "name": "TestCopyBuffer",
        "desc": ""
      },
      {
        "name": "TestCopyBufferNil",
        "desc": ""
      },
      {
        "name": "TestCopyLargeWriter",
        "desc": ""
      },
      {
        "name": "TestCopyN",
        "desc": ""
      },
      {
        "name": "TestCopyNEOF",
        "desc": ""
      },
      {
        "name": "TestCopyNReadFrom",
        "desc": ""
      },
      {
        "name": "TestCopyNWriteTo",
        "desc": ""
      },
      {
        "name": "TestCopyNegative",
        "desc": ""
      },
      {
        "name": "TestCopyPriority",
        "desc": "It's preferable to choose WriterTo over ReaderFrom, since a WriterTo can issue one large write, while the ReaderFrom must read until EOF, potentially allocating when running out of buffer. Make sure that we choose WriterTo when both are implemented."
      },
      {
        "name": "TestCopyReadErrWriteErr",
        "desc": "In case a Read results in an error with non-zero bytes read, and the subsequent Write also results in an error, the error from Write is returned, as it is the one that prevented progressing further."
      },
      {
        "name": "TestCopyReadFrom",
        "desc": ""
      },
      {
        "name": "TestCopyWriteTo",
        "desc": ""
      },
      {
        "name": "TestInterleavedMultiReader",
        "desc": ""
      },
      {
        "name": "TestMultiReader",
        "desc": ""
      },
      {
        "name": "TestMultiReaderAsWriterTo",
        "desc": ""
      },
      {
        "name": "TestMultiReaderCopy",
        "desc": "Test that MultiReader copies the input slice and is insulated from future modification."
      },
      {
        "name": "TestMultiReaderFinalEOF",
        "desc": "Test that a reader returning (n, EOF) at the end of a MultiReader chain continues to return EOF on its final read, rather than yielding a (0, EOF)."
      },
      {
        "name": "TestMultiReaderFlatten",
        "desc": "Test that MultiReader properly flattens chained multiReaders when Read is called"
      },
      {
        "name": "TestMultiReaderFreesExhaustedReaders",
        "desc": ""
      },
      {
        "name": "TestMultiReaderSingleByteWithEOF",
        "desc": "This used to yield bytes forever; issue 16795."
      },
      {
        "name": "TestMultiWriter",
        "desc": ""
      },
      {
        "name": "TestMultiWriterCopy",
        "desc": "Test that MultiWriter copies the input slice and is insulated from future modification."
      },
      {
        "name": "TestMultiWriterError",
        "desc": ""
      },
      {
        "name": "TestMultiWriterSingleChainFlatten",
        "desc": "Test that MultiWriter properly flattens chained multiWriters."
      },
      {
        "name": "TestMultiWriter_String",
        "desc": ""
      },
      {
        "name": "TestMultiWriter_StringCheckCall",
        "desc": ""
      },
      {
        "name": "TestMultiWriter_WriteStringSingleAlloc",
        "desc": "Test that a multiWriter.WriteString calls results in at most 1 allocation, even if multiple targets don't support WriteString."
      },
      {
        "name": "TestNopCloserWriterToForwarding",
        "desc": ""
      },
      {
        "name": "TestOffsetWriter_Seek",
        "desc": ""
      },
      {
        "name": "TestOffsetWriter_Write",
        "desc": ""
      },
      {
        "name": "TestOffsetWriter_WriteAt",
        "desc": ""
      },
      {
        "name": "TestPipe1",
        "desc": "Test a single read/write pair."
      },
      {
        "name": "TestPipe2",
        "desc": "Test a sequence of read/write pairs."
      },
      {
        "name": "TestPipe3",
        "desc": ""
      },
      {
        "name": "TestPipeAllocations",
        "desc": ""
      },
      {
        "name": "TestPipeCloseError",
        "desc": ""
      },
      {
        "name": "TestPipeConcurrent",
        "desc": ""
      },
      {
        "name": "TestPipeReadClose",
        "desc": ""
      },
      {
        "name": "TestPipeReadClose2",
        "desc": "Test close on Read side during Read."
      },
      {
        "name": "TestPipeWriteClose",
        "desc": ""
      },
      {
        "name": "TestPipeWriteClose2",
        "desc": "Test close on Write side during Write."
      },
      {
        "name": "TestReadAtLeast",
        "desc": ""
      },
      {
        "name": "TestReadAtLeastWithDataAndEOF",
        "desc": ""
      },
      {
        "name": "TestReadAtLeastWithDataAndError",
        "desc": ""
      },
      {
        "name": "TestSectionReader_Max",
        "desc": ""
      },
      {
        "name": "TestSectionReader_ReadAt",
        "desc": ""
      },
      {
        "name": "TestSectionReader_Seek",
        "desc": ""
      },
      {
        "name": "TestSectionReader_Size",
        "desc": ""
      },
      {
        "name": "TestTeeReader",
        "desc": ""
      },
      {
        "name": "TestWriteAfterWriterClose",
        "desc": ""
      },
      {
        "name": "TestWriteAt_PositionPriorToBase",
        "desc": ""
      },
      {
        "name": "TestWriteEmpty",
        "desc": ""
      },
      {
        "name": "TestWriteNil",
        "desc": ""
      },
      {
        "name": "callDepth",
        "desc": "callDepth returns the logical call depth for the given PCs."
      },
      {
        "name": "checkWrite",
        "desc": ""
      },
      {
        "name": "delayClose",
        "desc": ""
      },
      {
        "name": "reader",
        "desc": ""
      },
      {
        "name": "sortBytesInGroups",
        "desc": ""
      },
      {
        "name": "testMultiWriter",
        "desc": ""
      },
      {
        "name": "testReadAtLeast",
        "desc": ""
      },
      {
        "name": "writer",
        "desc": "Test a large write that requires multiple reads to satisfy."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteString",
        "desc": ""
      },
      {
        "name": "WriteTo",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Buffer",
        "desc": "A version of bytes.Buffer without ReadFrom and WriteTo"
      },
      {
        "name": "byteAndEOFReader",
        "desc": "byteAndEOFReader is a Reader which reads one byte (the underlying byte) and EOF at once in its Read call."
      },
      {
        "name": "closer",
        "desc": ""
      },
      {
        "name": "dataAndErrorBuffer",
        "desc": "A version of bytes.Buffer that returns n \u003e 0, err on Read when the input is exhausted."
      },
      {
        "name": "errWriter",
        "desc": ""
      },
      {
        "name": "largeWriter",
        "desc": "largeWriter returns an invalid count that is larger than the number of bytes provided (issue 39978)."
      },
      {
        "name": "noReadFrom",
        "desc": ""
      },
      {
        "name": "pipeReturn",
        "desc": ""
      },
      {
        "name": "pipeTest",
        "desc": ""
      },
      {
        "name": "readerFunc",
        "desc": "readerFunc is a Reader implemented by the underlying func."
      },
      {
        "name": "wantedAndErrReader",
        "desc": ""
      },
      {
        "name": "writeStringChecker",
        "desc": ""
      },
      {
        "name": "writeToChecker",
        "desc": "Version of bytes.Buffer that checks whether WriteTo was called or not"
      },
      {
        "name": "writerFunc",
        "desc": "writerFunc is a Writer implemented by the underlying func."
      },
      {
        "name": "zeroErrReader",
        "desc": ""
      }
    ]
  },
  {
    "name": "io/fs",
    "desc": "",
    "functions": [
      {
        "name": "ExampleGlob",
        "desc": ""
      },
      {
        "name": "ExampleReadFile",
        "desc": ""
      },
      {
        "name": "ExampleValidPath",
        "desc": ""
      },
      {
        "name": "ExampleWalkDir",
        "desc": ""
      },
      {
        "name": "TestCVE202230630",
        "desc": ""
      },
      {
        "name": "TestFileInfoToDirEntry",
        "desc": ""
      },
      {
        "name": "TestFormatDirEntry",
        "desc": ""
      },
      {
        "name": "TestFormatFileInfo",
        "desc": ""
      },
      {
        "name": "TestGlob",
        "desc": ""
      },
      {
        "name": "TestGlobError",
        "desc": ""
      },
      {
        "name": "TestGlobMethod",
        "desc": ""
      },
      {
        "name": "TestIssue51617",
        "desc": ""
      },
      {
        "name": "TestLstat",
        "desc": ""
      },
      {
        "name": "TestReadDir",
        "desc": ""
      },
      {
        "name": "TestReadDirPath",
        "desc": ""
      },
      {
        "name": "TestReadFile",
        "desc": ""
      },
      {
        "name": "TestReadFilePath",
        "desc": ""
      },
      {
        "name": "TestReadLink",
        "desc": ""
      },
      {
        "name": "TestStat",
        "desc": ""
      },
      {
        "name": "TestSub",
        "desc": ""
      },
      {
        "name": "TestValidPath",
        "desc": ""
      },
      {
        "name": "TestWalkDir",
        "desc": ""
      },
      {
        "name": "TestWalkDirSymlink",
        "desc": ""
      },
      {
        "name": "errorPath",
        "desc": ""
      },
      {
        "name": "makeTree",
        "desc": ""
      },
      {
        "name": "mark",
        "desc": "Assumes that each node name is unique. Good enough for a test. If clear is true, any incoming error is cleared before return. The errors are always accumulated, though."
      },
      {
        "name": "walkTree",
        "desc": ""
      },
      {
        "name": "Info",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Node",
        "desc": ""
      },
      {
        "name": "formatTest",
        "desc": "formatTest implements FileInfo to test FormatFileInfo, and implements DirEntry to test FormatDirEntry."
      },
      {
        "name": "globOnly",
        "desc": ""
      },
      {
        "name": "openOnly",
        "desc": ""
      },
      {
        "name": "readDirOnly",
        "desc": ""
      },
      {
        "name": "readFileOnly",
        "desc": ""
      },
      {
        "name": "statOnly",
        "desc": ""
      },
      {
        "name": "subOnly",
        "desc": ""
      }
    ]
  },
  {
    "name": "io/ioutil",
    "desc": "",
    "functions": [
      {
        "name": "ExampleReadAll",
        "desc": ""
      },
      {
        "name": "ExampleReadDir",
        "desc": ""
      },
      {
        "name": "ExampleReadFile",
        "desc": ""
      },
      {
        "name": "ExampleTempDir",
        "desc": ""
      },
      {
        "name": "ExampleTempDir_suffix",
        "desc": ""
      },
      {
        "name": "ExampleTempFile",
        "desc": ""
      },
      {
        "name": "ExampleTempFile_suffix",
        "desc": ""
      },
      {
        "name": "ExampleWriteFile",
        "desc": ""
      },
      {
        "name": "TestReadDir",
        "desc": ""
      },
      {
        "name": "TestReadFile",
        "desc": ""
      },
      {
        "name": "TestReadOnlyWriteFile",
        "desc": ""
      },
      {
        "name": "TestTempDir",
        "desc": ""
      },
      {
        "name": "TestTempDir_BadDir",
        "desc": "test that we return a nice error message if the dir argument to TempDir doesn't exist (or that it's empty and os.TempDir doesn't exist)"
      },
      {
        "name": "TestTempDir_BadPattern",
        "desc": ""
      },
      {
        "name": "TestTempFile",
        "desc": ""
      },
      {
        "name": "TestTempFile_BadPattern",
        "desc": ""
      },
      {
        "name": "TestTempFile_pattern",
        "desc": ""
      },
      {
        "name": "TestWriteFile",
        "desc": ""
      },
      {
        "name": "checkSize",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "iter",
    "desc": "Package iter provides basic definitions and operations related to iterators over sequences.  # Iterators  An iterator is a function that passes successive elements of a sequence to a callback function, conventionally named yield. The function stops either when the sequence is finished or when yield returns false, indicating to stop the iteration early. This package defines [Seq] and [Seq2] (pronounced like seek—the first syllable of sequence) as shorthands for iterators that pass 1 or 2 values per sequence element to yield:  \ttype ( \t\tSeq[V any]     func(yield func(V) bool) \t\tSeq2[K, V any] func(yield func(K, V) bool) \t)  Seq2 represents a sequence of paired values, conventionally key-value or index-value pairs.  Yield returns true if the iterator should continue with the next element in the sequence, false if it should stop.  For instance, [maps.Keys] returns an iterator that produces the sequence of keys of the map m, implemented as follows:  \tfunc Keys[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[K] { \t\treturn func(yield func(K) bool) { \t\t\tfor k := range m { \t\t\t\tif !yield(k) { \t\t\t\t\treturn \t\t\t\t} \t\t\t} \t\t} \t}  Further examples can be found in [The Go Blog: Range Over Function Types].  Iterator functions are most often called by a [range loop], as in:  \tfunc PrintAll[V any](seq iter.Seq[V]) { \t\tfor v := range seq { \t\t\tfmt.Println(v) \t\t} \t}  # Naming Conventions  Iterator functions and methods are named for the sequence being walked:  \t// All returns an iterator over all elements in s. \tfunc (s *Set[V]) All() iter.Seq[V]  The iterator method on a collection type is conventionally named All, because it iterates a sequence of all the values in the collection.  For a type containing multiple possible sequences, the iterator's name can indicate which sequence is being provided:  \t// Cities returns an iterator over the major cities in the country. \tfunc (c *Country) Cities() iter.Seq[*City]  \t// Languages returns an iterator over the official spoken languages of the country. \tfunc (c *Country) Languages() iter.Seq[string]  If an iterator requires additional configuration, the constructor function can take additional configuration arguments:  \t// Scan returns an iterator over key-value pairs with min ≤ key ≤ max. \tfunc (m *Map[K, V]) Scan(min, max K) iter.Seq2[K, V]  \t// Split returns an iterator over the (possibly-empty) substrings of s \t// separated by sep. \tfunc Split(s, sep string) iter.Seq[string]  When there are multiple possible iteration orders, the method name may indicate that order:  \t// All returns an iterator over the list from head to tail. \tfunc (l *List[V]) All() iter.Seq[V]  \t// Backward returns an iterator over the list from tail to head. \tfunc (l *List[V]) Backward() iter.Seq[V]  \t// Preorder returns an iterator over all nodes of the syntax tree \t// beneath (and including) the specified root, in depth-first preorder, \t// visiting a parent node before its children. \tfunc Preorder(root Node) iter.Seq[Node]  # Single-Use Iterators  Most iterators provide the ability to walk an entire sequence: when called, the iterator does any setup necessary to start the sequence, then calls yield on successive elements of the sequence, and then cleans up before returning. Calling the iterator again walks the sequence again.  Some iterators break that convention, providing the ability to walk a sequence only once. These “single-use iterators” typically report values from a data stream that cannot be rewound to start over. Calling the iterator again after stopping early may continue the stream, but calling it again after the sequence is finished will yield no values at all. Doc comments for functions or methods that return single-use iterators should document this fact:  \t// Lines returns an iterator over lines read from r. \t// It returns a single-use iterator. \tfunc (r *Reader) Lines() iter.Seq[string]  # Pulling Values  Functions and methods that accept or return iterators should use the standard [Seq] or [Seq2] types, to ensure compatibility with range loops and other iterator adapters. The standard iterators can be thought of as “push iterators”, which push values to the yield function.  Sometimes a range loop is not the most natural way to consume values of the sequence. In this case, [Pull] converts a standard push iterator to a “pull iterator”, which can be called to pull one value at a time from the sequence. [Pull] starts an iterator and returns a pair of functions—next and stop—which return the next value from the iterator and stop it, respectively.  For example:  \t// Pairs returns an iterator over successive pairs of values from seq. \tfunc Pairs[V any](seq iter.Seq[V]) iter.Seq2[V, V] { \t\treturn func(yield func(V, V) bool) { \t\t\tnext, stop := iter.Pull(seq) \t\t\tdefer stop() \t\t\tfor { \t\t\t\tv1, ok1 := next() \t\t\t\tif !ok1 { \t\t\t\t\treturn \t\t\t\t} \t\t\t\tv2, ok2 := next() \t\t\t\t// If ok2 is false, v2 should be the \t\t\t\t// zero value; yield one last pair. \t\t\t\tif !yield(v1, v2) { \t\t\t\t\treturn \t\t\t\t} \t\t\t\tif !ok2 { \t\t\t\t\treturn \t\t\t\t} \t\t\t} \t\t} \t}  If clients do not consume the sequence to completion, they must call stop, which allows the iterator function to finish and return. As shown in the example, the conventional way to ensure this is to use defer.  # Standard Library Usage  A few packages in the standard library provide iterator-based APIs, most notably the [maps] and [slices] packages. For example, [maps.Keys] returns an iterator over the keys of a map, while [slices.Sorted] collects the values of an iterator into a slice, sorts them, and returns the slice, so to iterate over the sorted keys of a map:  \tfor _, key := range slices.Sorted(maps.Keys(m)) { \t\t... \t}  # Mutation  Iterators provide only the values of the sequence, not any direct way to modify it. If an iterator wishes to provide a mechanism for modifying a sequence during iteration, the usual approach is to define a position type with the extra operations and then provide an iterator over positions.  For example, a tree implementation might provide:  \t// Positions returns an iterator over positions in the sequence. \tfunc (t *Tree[V]) Positions() iter.Seq[*Pos[V]]  \t// A Pos represents a position in the sequence. \t// It is only valid during the yield call it is passed to. \ttype Pos[V any] struct { ... }  \t// Pos returns the value at the cursor. \tfunc (p *Pos[V]) Value() V  \t// Delete deletes the value at this point in the iteration. \tfunc (p *Pos[V]) Delete()  \t// Set changes the value v at the cursor. \tfunc (p *Pos[V]) Set(v V)  And then a client could delete boring values from the tree using:  \tfor p := range t.Positions() { \t\tif boring(p.Value()) { \t\t\tp.Delete() \t\t} \t}  [The Go Blog: Range Over Function Types]: https://go.dev/blog/range-functions [range loop]: https://go.dev/ref/spec#For_range",
    "functions": [
      {
        "name": "Pull",
        "desc": "Pull converts the “push-style” iterator sequence seq into a “pull-style” iterator accessed by the two functions next and stop.  Next returns the next value in the sequence and a boolean indicating whether the value is valid. When the sequence is over, next returns the zero V and false. It is valid to call next after reaching the end of the sequence or after calling stop. These calls will continue to return the zero V and false.  Stop ends the iteration. It must be called when the caller is no longer interested in next values and next has not yet signaled that the sequence is over (with a false boolean return). It is valid to call stop multiple times and when next has already returned false. Typically, callers should “defer stop()”.  It is an error to call next or stop from multiple goroutines simultaneously.  If the iterator panics during a call to next (or stop), then next (or stop) itself panics with the same value."
      },
      {
        "name": "Pull2",
        "desc": "Pull2 converts the “push-style” iterator sequence seq into a “pull-style” iterator accessed by the two functions next and stop.  Next returns the next pair in the sequence and a boolean indicating whether the pair is valid. When the sequence is over, next returns a pair of zero values and false. It is valid to call next after reaching the end of the sequence or after calling stop. These calls will continue to return a pair of zero values and false.  Stop ends the iteration. It must be called when the caller is no longer interested in next values and next has not yet signaled that the sequence is over (with a false boolean return). It is valid to call stop multiple times and when next has already returned false. Typically, callers should “defer stop()”.  It is an error to call next or stop from multiple goroutines simultaneously.  If the iterator panics during a call to next (or stop), then next (or stop) itself panics with the same value."
      },
      {
        "name": "coroswitch",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Seq",
        "desc": "Seq is an iterator over sequences of individual values. When called as seq(yield), seq calls yield(v) for each value v in the sequence, stopping early if yield returns false. See the [iter] package documentation for more details."
      },
      {
        "name": "Seq2",
        "desc": "Seq2 is an iterator over sequences of pairs of values, most commonly key-value pairs. When called as seq(yield), seq calls yield(k, v) for each pair (k, v) in the sequence, stopping early if yield returns false. See the [iter] package documentation for more details."
      },
      {
        "name": "coro",
        "desc": ""
      }
    ]
  },
  {
    "name": "log",
    "desc": "",
    "functions": [
      {
        "name": "ExampleLogger",
        "desc": ""
      },
      {
        "name": "ExampleLogger_Output",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "log/slog",
    "desc": "Package slog provides structured logging, in which log records include a message, a severity level, and various other attributes expressed as key-value pairs.  It defines a type, [Logger], which provides several methods (such as [Logger.Info] and [Logger.Error]) for reporting events of interest.  Each Logger is associated with a [Handler]. A Logger output method creates a [Record] from the method arguments and passes it to the Handler, which decides how to handle it. There is a default Logger accessible through top-level functions (such as [Info] and [Error]) that call the corresponding Logger methods.  A log record consists of a time, a level, a message, and a set of key-value pairs, where the keys are strings and the values may be of any type. As an example,  \tslog.Info(\"hello\", \"count\", 3)  creates a record containing the time of the call, a level of Info, the message \"hello\", and a single pair with key \"count\" and value 3.  The [Info] top-level function calls the [Logger.Info] method on the default Logger. In addition to [Logger.Info], there are methods for Debug, Warn and Error levels. Besides these convenience methods for common levels, there is also a [Logger.Log] method which takes the level as an argument. Each of these methods has a corresponding top-level function that uses the default logger.  The default handler formats the log record's message, time, level, and attributes as a string and passes it to the [log] package.  \t2022/11/08 15:28:26 INFO hello count=3  For more control over the output format, create a logger with a different handler. This statement uses [New] to create a new logger with a [TextHandler] that writes structured records in text form to standard error:  \tlogger := slog.New(slog.NewTextHandler(os.Stderr, nil))  [TextHandler] output is a sequence of key=value pairs, easily and unambiguously parsed by machine. This statement:  \tlogger.Info(\"hello\", \"count\", 3)  produces this output:  \ttime=2022-11-08T15:28:26.000-05:00 level=INFO msg=hello count=3  The package also provides [JSONHandler], whose output is line-delimited JSON:  \tlogger := slog.New(slog.NewJSONHandler(os.Stdout, nil)) \tlogger.Info(\"hello\", \"count\", 3)  produces this output:  \t{\"time\":\"2022-11-08T15:28:26.000000000-05:00\",\"level\":\"INFO\",\"msg\":\"hello\",\"count\":3}  Both [TextHandler] and [JSONHandler] can be configured with [HandlerOptions]. There are options for setting the minimum level (see Levels, below), displaying the source file and line of the log call, and modifying attributes before they are logged.  Setting a logger as the default with  \tslog.SetDefault(logger)  will cause the top-level functions like [Info] to use it. [SetDefault] also updates the default logger used by the [log] package, so that existing applications that use [log.Printf] and related functions will send log records to the logger's handler without needing to be rewritten.  Some attributes are common to many log calls. For example, you may wish to include the URL or trace identifier of a server request with all log events arising from the request. Rather than repeat the attribute with every log call, you can use [Logger.With] to construct a new Logger containing the attributes:  \tlogger2 := logger.With(\"url\", r.URL)  The arguments to With are the same key-value pairs used in [Logger.Info]. The result is a new Logger with the same handler as the original, but additional attributes that will appear in the output of every call.  # Levels  A [Level] is an integer representing the importance or severity of a log event. The higher the level, the more severe the event. This package defines constants for the most common levels, but any int can be used as a level.  In an application, you may wish to log messages only at a certain level or greater. One common configuration is to log messages at Info or higher levels, suppressing debug logging until it is needed. The built-in handlers can be configured with the minimum level to output by setting [HandlerOptions.Level]. The program's `main` function typically does this. The default value is LevelInfo.  Setting the [HandlerOptions.Level] field to a [Level] value fixes the handler's minimum level throughout its lifetime. Setting it to a [LevelVar] allows the level to be varied dynamically. A LevelVar holds a Level and is safe to read or write from multiple goroutines. To vary the level dynamically for an entire program, first initialize a global LevelVar:  \tvar programLevel = new(slog.LevelVar) // Info by default  Then use the LevelVar to construct a handler, and make it the default:  \th := slog.NewJSONHandler(os.Stderr, \u0026slog.HandlerOptions{Level: programLevel}) \tslog.SetDefault(slog.New(h))  Now the program can change its logging level with a single statement:  \tprogramLevel.Set(slog.LevelDebug)  # Groups  Attributes can be collected into groups. A group has a name that is used to qualify the names of its attributes. How this qualification is displayed depends on the handler. [TextHandler] separates the group and attribute names with a dot. [JSONHandler] treats each group as a separate JSON object, with the group name as the key.  Use [Group] to create a Group attribute from a name and a list of key-value pairs:  \tslog.Group(\"request\", \t    \"method\", r.Method, \t    \"url\", r.URL)  TextHandler would display this group as  \trequest.method=GET request.url=http://example.com  JSONHandler would display it as  \t\"request\":{\"method\":\"GET\",\"url\":\"http://example.com\"}  Use [Logger.WithGroup] to qualify all of a Logger's output with a group name. Calling WithGroup on a Logger results in a new Logger with the same Handler as the original, but with all its attributes qualified by the group name.  This can help prevent duplicate attribute keys in large systems, where subsystems might use the same keys. Pass each subsystem a different Logger with its own group name so that potential duplicates are qualified:  \tlogger := slog.Default().With(\"id\", systemID) \tparserLogger := logger.WithGroup(\"parser\") \tparseInput(input, parserLogger)  When parseInput logs with parserLogger, its keys will be qualified with \"parser\", so even if it uses the common key \"id\", the log line will have distinct keys.  # Contexts  Some handlers may wish to include information from the [context.Context] that is available at the call site. One example of such information is the identifier for the current span when tracing is enabled.  The [Logger.Log] and [Logger.LogAttrs] methods take a context as a first argument, as do their corresponding top-level functions.  Although the convenience methods on Logger (Info and so on) and the corresponding top-level functions do not take a context, the alternatives ending in \"Context\" do. For example,  \tslog.InfoContext(ctx, \"message\")  It is recommended to pass a context to an output method if one is available.  # Attrs and Values  An [Attr] is a key-value pair. The Logger output methods accept Attrs as well as alternating keys and values. The statement  \tslog.Info(\"hello\", slog.Int(\"count\", 3))  behaves the same as  \tslog.Info(\"hello\", \"count\", 3)  There are convenience constructors for [Attr] such as [Int], [String], and [Bool] for common types, as well as the function [Any] for constructing Attrs of any type.  The value part of an Attr is a type called [Value]. Like an [any], a Value can hold any Go value, but it can represent typical values, including all numbers and strings, without an allocation.  For the most efficient log output, use [Logger.LogAttrs]. It is similar to [Logger.Log] but accepts only Attrs, not alternating keys and values; this allows it, too, to avoid allocation.  The call  \tlogger.LogAttrs(ctx, slog.LevelInfo, \"hello\", slog.Int(\"count\", 3))  is the most efficient way to achieve the same output as  \tslog.InfoContext(ctx, \"hello\", \"count\", 3)  # Customizing a type's logging behavior  If a type implements the [LogValuer] interface, the [Value] returned from its LogValue method is used for logging. You can use this to control how values of the type appear in logs. For example, you can redact secret information like passwords, or gather a struct's fields in a Group. See the examples under [LogValuer] for details.  A LogValue method may return a Value that itself implements [LogValuer]. The [Value.Resolve] method handles these cases carefully, avoiding infinite loops and unbounded recursion. Handler authors and others may wish to use [Value.Resolve] instead of calling LogValue directly.  # Wrapping output methods  The logger functions use reflection over the call stack to find the file name and line number of the logging call within the application. This can produce incorrect source information for functions that wrap slog. For instance, if you define this function in file mylog.go:  \tfunc Infof(logger *slog.Logger, format string, args ...any) { \t    logger.Info(fmt.Sprintf(format, args...)) \t}  and you call it like this in main.go:  \tInfof(slog.Default(), \"hello, %s\", \"world\")  then slog will report the source file as mylog.go, not main.go.  A correct implementation of Infof will obtain the source location (pc) and pass it to NewRecord. The Infof function in the package-level example called \"wrapping\" demonstrates how to do this.  # Working with Records  Sometimes a Handler will need to modify a Record before passing it on to another Handler or backend. A Record contains a mixture of simple public fields (e.g. Time, Level, Message) and hidden fields that refer to state (such as attributes) indirectly. This means that modifying a simple copy of a Record (e.g. by calling [Record.Add] or [Record.AddAttrs] to add attributes) may have unexpected effects on the original. Before modifying a Record, use [Record.Clone] to create a copy that shares no state with the original, or create a new Record with [NewRecord] and build up its Attrs by traversing the old ones with [Record.Attrs].  # Performance considerations  If profiling your application demonstrates that logging is taking significant time, the following suggestions may help.  If many log lines have a common attribute, use [Logger.With] to create a Logger with that attribute. The built-in handlers will format that attribute only once, at the call to [Logger.With]. The [Handler] interface is designed to allow that optimization, and a well-written Handler should take advantage of it.  The arguments to a log call are always evaluated, even if the log event is discarded. If possible, defer computation so that it happens only if the value is actually logged. For example, consider the call  \tslog.Info(\"starting request\", \"url\", r.URL.String())  // may compute String unnecessarily  The URL.String method will be called even if the logger discards Info-level events. Instead, pass the URL directly:  \tslog.Info(\"starting request\", \"url\", \u0026r.URL) // calls URL.String only if needed  The built-in [TextHandler] will call its String method, but only if the log event is enabled. Avoiding the call to String also preserves the structure of the underlying value. For example [JSONHandler] emits the components of the parsed URL as a JSON object. If you want to avoid eagerly paying the cost of the String call without causing the handler to potentially inspect the structure of the value, wrap the value in a fmt.Stringer implementation that hides its Marshal methods.  You can also use the [LogValuer] interface to avoid unnecessary work in disabled log calls. Say you need to log some expensive value:  \tslog.Debug(\"frobbing\", \"value\", computeExpensiveValue(arg))  Even if this line is disabled, computeExpensiveValue will be called. To avoid that, define a type implementing LogValuer:  \ttype expensive struct { arg int }  \tfunc (e expensive) LogValue() slog.Value { \t    return slog.AnyValue(computeExpensiveValue(e.arg)) \t}  Then use a value of that type in log calls:  \tslog.Debug(\"frobbing\", \"value\", expensive{arg})  Now computeExpensiveValue will only be called when the line is enabled.  The built-in handlers acquire a lock before calling [io.Writer.Write] to ensure that exactly one [Record] is written at a time in its entirety. Although each log record has a timestamp, the built-in handlers do not use that time to sort the written records. User-defined handlers are responsible for their own locking and sorting.  # Writing a handler  For a guide to writing a custom handler, see https://golang.org/s/slog-handler-guide.",
    "functions": [
      {
        "name": "BenchmarkAppendKey",
        "desc": ""
      },
      {
        "name": "BenchmarkAttrString",
        "desc": ""
      },
      {
        "name": "BenchmarkDispatch",
        "desc": "The \"As\" form is the slowest. The switch-panic and visitor times are almost the same. BenchmarkDispatch/switch-checked-8         \t 8669427\t       137.7 ns/op BenchmarkDispatch/As-8                     \t 8212087\t       145.3 ns/op BenchmarkDispatch/Visit-8                  \t 8926146\t       135.3 ns/op"
      },
      {
        "name": "BenchmarkJSONEncoding",
        "desc": ""
      },
      {
        "name": "BenchmarkJSONHandler",
        "desc": ""
      },
      {
        "name": "BenchmarkNopLog",
        "desc": "This is a simple benchmark. See the benchmarks subdirectory for more extensive ones."
      },
      {
        "name": "BenchmarkPC",
        "desc": "Currently, pc(2) takes over 400ns, which is too expensive to call it for every log message."
      },
      {
        "name": "BenchmarkPreformatting",
        "desc": ""
      },
      {
        "name": "BenchmarkRecord",
        "desc": ""
      },
      {
        "name": "BenchmarkUnsafeStrings",
        "desc": "Run this with and without -tags unsafe_kvs to compare."
      },
      {
        "name": "BenchmarkWriteTime",
        "desc": ""
      },
      {
        "name": "Debug",
        "desc": "Debug calls [Logger.Debug] on the default logger."
      },
      {
        "name": "DebugContext",
        "desc": "DebugContext calls [Logger.DebugContext] on the default logger."
      },
      {
        "name": "Error",
        "desc": "Error calls [Logger.Error] on the default logger."
      },
      {
        "name": "ErrorContext",
        "desc": "ErrorContext calls [Logger.ErrorContext] on the default logger."
      },
      {
        "name": "Info",
        "desc": "Info calls [Logger.Info] on the default logger."
      },
      {
        "name": "InfoContext",
        "desc": "InfoContext calls [Logger.InfoContext] on the default logger."
      },
      {
        "name": "Log",
        "desc": "Log calls [Logger.Log] on the default logger."
      },
      {
        "name": "LogAttrs",
        "desc": "LogAttrs calls [Logger.LogAttrs] on the default logger."
      },
      {
        "name": "NewLogLogger",
        "desc": "NewLogLogger returns a new [log.Logger] such that each call to its Output method dispatches a Record to the specified handler. The logger acts as a bridge from the older log API to newer structured logging handlers."
      },
      {
        "name": "SetDefault",
        "desc": "SetDefault makes l the default [Logger], which is used by the top-level functions [Info], [Debug] and so on. After this call, output from the log package's default Logger (as with [log.Print], etc.) will be logged using l's Handler, at a level controlled by [SetLogLoggerLevel]."
      },
      {
        "name": "TestAliasingAndClone",
        "desc": ""
      },
      {
        "name": "TestAlloc",
        "desc": ""
      },
      {
        "name": "TestAnyLevelAlloc",
        "desc": ""
      },
      {
        "name": "TestAnyValue",
        "desc": ""
      },
      {
        "name": "TestAppendJSONValue",
        "desc": ""
      },
      {
        "name": "TestAttrNoAlloc",
        "desc": ""
      },
      {
        "name": "TestAttrs",
        "desc": ""
      },
      {
        "name": "TestCallDepth",
        "desc": ""
      },
      {
        "name": "TestCallDepthConnection",
        "desc": ""
      },
      {
        "name": "TestConcurrentWrites",
        "desc": ""
      },
      {
        "name": "TestConnections",
        "desc": ""
      },
      {
        "name": "TestContext",
        "desc": ""
      },
      {
        "name": "TestDefaultHandle",
        "desc": ""
      },
      {
        "name": "TestDiscardHandler",
        "desc": ""
      },
      {
        "name": "TestEmptyGroup",
        "desc": ""
      },
      {
        "name": "TestHandlerEnabled",
        "desc": ""
      },
      {
        "name": "TestJSONAndTextHandlers",
        "desc": "Verify the common parts of TextHandler and JSONHandler."
      },
      {
        "name": "TestJSONAndTextHandlersWithUnavailableSource",
        "desc": ""
      },
      {
        "name": "TestJSONAppendAttrValueSpecial",
        "desc": ""
      },
      {
        "name": "TestJSONHandler",
        "desc": ""
      },
      {
        "name": "TestKindString",
        "desc": ""
      },
      {
        "name": "TestLevelAppendText",
        "desc": ""
      },
      {
        "name": "TestLevelFlag",
        "desc": ""
      },
      {
        "name": "TestLevelMarshalJSON",
        "desc": ""
      },
      {
        "name": "TestLevelMarshalText",
        "desc": ""
      },
      {
        "name": "TestLevelParse",
        "desc": ""
      },
      {
        "name": "TestLevelParseError",
        "desc": ""
      },
      {
        "name": "TestLevelString",
        "desc": ""
      },
      {
        "name": "TestLevelVar",
        "desc": ""
      },
      {
        "name": "TestLevelVarAppendText",
        "desc": ""
      },
      {
        "name": "TestLevelVarFlag",
        "desc": ""
      },
      {
        "name": "TestLevelVarMarshalText",
        "desc": ""
      },
      {
        "name": "TestLevelVarString",
        "desc": ""
      },
      {
        "name": "TestLogLoggerLevelForDefaultHandler",
        "desc": "Test defaultHandler minimum level without calling slog.SetDefault."
      },
      {
        "name": "TestLogLoggerLevelForHandlerWriter",
        "desc": "Test handlerWriter minimum level by calling slog.SetDefault."
      },
      {
        "name": "TestLogTextHandler",
        "desc": ""
      },
      {
        "name": "TestLogValue",
        "desc": ""
      },
      {
        "name": "TestLoggerError",
        "desc": ""
      },
      {
        "name": "TestLoggerNoOps",
        "desc": ""
      },
      {
        "name": "TestNeedsQuoting",
        "desc": ""
      },
      {
        "name": "TestNewLogLogger",
        "desc": ""
      },
      {
        "name": "TestPanics",
        "desc": ""
      },
      {
        "name": "TestRecordAttrs",
        "desc": ""
      },
      {
        "name": "TestRecordSource",
        "desc": ""
      },
      {
        "name": "TestReplaceAttrGroups",
        "desc": ""
      },
      {
        "name": "TestSecondWith",
        "desc": ""
      },
      {
        "name": "TestSetAttrs",
        "desc": ""
      },
      {
        "name": "TestSetDefault",
        "desc": ""
      },
      {
        "name": "TestTextHandler",
        "desc": ""
      },
      {
        "name": "TestTextHandlerAlloc",
        "desc": ""
      },
      {
        "name": "TestTextHandlerPreformatted",
        "desc": ""
      },
      {
        "name": "TestValueAny",
        "desc": ""
      },
      {
        "name": "TestValueEqual",
        "desc": ""
      },
      {
        "name": "TestValueNoAlloc",
        "desc": ""
      },
      {
        "name": "TestValueString",
        "desc": ""
      },
      {
        "name": "TestValueTime",
        "desc": ""
      },
      {
        "name": "TestWriteTimeRFC3339",
        "desc": ""
      },
      {
        "name": "Warn",
        "desc": "Warn calls [Logger.Warn] on the default logger."
      },
      {
        "name": "WarnContext",
        "desc": "WarnContext calls [Logger.WarnContext] on the default logger."
      },
      {
        "name": "appendEscapedJSONString",
        "desc": "appendEscapedJSONString escapes s for JSON and appends it to buf. It does not surround the string in quotation marks.  Modified from encoding/json/encode.go:encodeState.string, with escapeHTML set to false."
      },
      {
        "name": "appendJSONMarshal",
        "desc": ""
      },
      {
        "name": "appendJSONTime",
        "desc": "Adapted from time.Time.MarshalJSON to avoid allocation."
      },
      {
        "name": "appendJSONValue",
        "desc": ""
      },
      {
        "name": "appendRFC3339Millis",
        "desc": ""
      },
      {
        "name": "appendTextValue",
        "desc": ""
      },
      {
        "name": "attrsEqual",
        "desc": ""
      },
      {
        "name": "byteSlice",
        "desc": "byteSlice returns its argument as a []byte if the argument's underlying type is []byte, along with a second return value of true. Otherwise it returns nil, false."
      },
      {
        "name": "callerPC",
        "desc": "callerPC returns the program counter at the given stack depth."
      },
      {
        "name": "checkLogOutput",
        "desc": ""
      },
      {
        "name": "clean",
        "desc": "clean prepares log output for comparison."
      },
      {
        "name": "concat",
        "desc": "concat returns a new slice with the elements of s1 followed by those of s2. The slice has no additional capacity."
      },
      {
        "name": "countAttrs",
        "desc": "countAttrs returns the number of Attrs that would be created from args."
      },
      {
        "name": "countEmptyGroups",
        "desc": "countEmptyGroups returns the number of empty group values in its argument."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "jsonValueString",
        "desc": ""
      },
      {
        "name": "marshalJSON",
        "desc": ""
      },
      {
        "name": "needsQuoting",
        "desc": ""
      },
      {
        "name": "panics",
        "desc": ""
      },
      {
        "name": "removeKeys",
        "desc": "removeKeys returns a function suitable for HandlerOptions.ReplaceAttr that removes all Attrs with the given keys."
      },
      {
        "name": "stack",
        "desc": ""
      },
      {
        "name": "wantAllocs",
        "desc": ""
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether a and b have equal keys and values."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isEmpty",
        "desc": "isEmpty reports whether a has an empty key and a nil value. That can be written as Attr{} or Any(\"\", nil)."
      },
      {
        "name": "Enabled",
        "desc": "Enabled reports whether the handler handles records at the given level. The handler ignores records whose level is lower."
      },
      {
        "name": "Handle",
        "desc": "Handle formats its argument [Record] as a JSON object on a single line.  If the Record's time is zero, the time is omitted. Otherwise, the key is \"time\" and the value is output as with json.Marshal.  The level's key is \"level\" and its value is the result of calling [Level.String].  If the AddSource option is set and source information is available, the key is \"source\", and the value is a record of type [Source].  The message's key is \"msg\".  To modify these or other attributes, or remove them from the output, use [HandlerOptions.ReplaceAttr].  Values are formatted as with an [encoding/json.Encoder] with SetEscapeHTML(false), with two exceptions.  First, an Attr whose Value is of type error is formatted as a string, by calling its Error method. Only errors in Attrs receive this special treatment, not errors embedded in structs, slices, maps or other data structures that are processed by the [encoding/json] package.  Second, an encoding failure does not cause Handle to return an error. Instead, the error message is formatted as a string.  Each call to Handle results in a single serialized call to io.Writer.Write."
      },
      {
        "name": "WithAttrs",
        "desc": "WithAttrs returns a new [JSONHandler] whose attributes consists of h's attributes followed by attrs."
      },
      {
        "name": "WithGroup",
        "desc": ""
      },
      {
        "name": "attrSep",
        "desc": "attrSep returns the separator between attributes."
      },
      {
        "name": "clone",
        "desc": ""
      },
      {
        "name": "enabled",
        "desc": "enabled reports whether l is greater than or equal to the minimum level."
      },
      {
        "name": "handle",
        "desc": "handle is the internal implementation of Handler.Handle used by TextHandler and JSONHandler."
      },
      {
        "name": "newHandleState",
        "desc": ""
      },
      {
        "name": "withAttrs",
        "desc": ""
      },
      {
        "name": "withGroup",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements [encoding.TextAppender] by calling [Level.String]."
      },
      {
        "name": "Level",
        "desc": "Level returns the receiver. It implements [Leveler]."
      },
      {
        "name": "MarshalJSON",
        "desc": "MarshalJSON implements [encoding/json.Marshaler] by quoting the output of [Level.String]."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements [encoding.TextMarshaler] by calling [Level.AppendText]."
      },
      {
        "name": "String",
        "desc": "String returns a name for the level. If the level has a name, then that name in uppercase is returned. If the level is between named values, then an integer is appended to the uppercased name. Examples:  \tLevelWarn.String() =\u003e \"WARN\" \t(LevelInfo+2).String() =\u003e \"INFO+2\""
      },
      {
        "name": "UnmarshalJSON",
        "desc": "UnmarshalJSON implements [encoding/json.Unmarshaler] It accepts any string produced by [Level.MarshalJSON], ignoring case. It also accepts numeric offsets that would result in a different string on output. For example, \"Error-8\" would marshal as \"INFO\"."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements [encoding.TextUnmarshaler]. It accepts any string produced by [Level.MarshalText], ignoring case. It also accepts numeric offsets that would result in a different string on output. For example, \"Error-8\" would marshal as \"INFO\"."
      },
      {
        "name": "parse",
        "desc": ""
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements [encoding.TextAppender] by calling [Level.AppendText]."
      },
      {
        "name": "Level",
        "desc": "Level returns v's level."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements [encoding.TextMarshaler] by calling [LevelVar.AppendText]."
      },
      {
        "name": "Set",
        "desc": "Set sets v's level to l."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements [encoding.TextUnmarshaler] by calling [Level.UnmarshalText]."
      },
      {
        "name": "Debug",
        "desc": "Debug logs at [LevelDebug]."
      },
      {
        "name": "DebugContext",
        "desc": "DebugContext logs at [LevelDebug] with the given context."
      },
      {
        "name": "Enabled",
        "desc": "Enabled reports whether l emits log records at the given context and level."
      },
      {
        "name": "Error",
        "desc": "Error logs at [LevelError]."
      },
      {
        "name": "ErrorContext",
        "desc": "ErrorContext logs at [LevelError] with the given context."
      },
      {
        "name": "Handler",
        "desc": "Handler returns l's Handler."
      },
      {
        "name": "Info",
        "desc": "Info logs at [LevelInfo]."
      },
      {
        "name": "InfoContext",
        "desc": "InfoContext logs at [LevelInfo] with the given context."
      },
      {
        "name": "Log",
        "desc": "Log emits a log record with the current time and the given level and message. The Record's Attrs consist of the Logger's attributes followed by the Attrs specified by args.  The attribute arguments are processed as follows:   - If an argument is an Attr, it is used as is.   - If an argument is a string and this is not the last argument,     the following argument is treated as the value and the two are combined     into an Attr.   - Otherwise, the argument is treated as a value with key \"!BADKEY\"."
      },
      {
        "name": "LogAttrs",
        "desc": "LogAttrs is a more efficient version of [Logger.Log] that accepts only Attrs."
      },
      {
        "name": "Warn",
        "desc": "Warn logs at [LevelWarn]."
      },
      {
        "name": "WarnContext",
        "desc": "WarnContext logs at [LevelWarn] with the given context."
      },
      {
        "name": "With",
        "desc": "With returns a Logger that includes the given attributes in each output operation. Arguments are converted to attributes as if by [Logger.Log]."
      },
      {
        "name": "WithGroup",
        "desc": "WithGroup returns a Logger that starts a group, if name is non-empty. The keys of all attributes added to the Logger will be qualified by the given name. (How that qualification happens depends on the [Handler.WithGroup] method of the Logger's Handler.)  If name is empty, WithGroup returns the receiver."
      },
      {
        "name": "clone",
        "desc": ""
      },
      {
        "name": "log",
        "desc": "log is the low-level logging method for methods that take ...any. It must always be called directly by an exported logging method or function, because it uses a fixed call depth to obtain the pc."
      },
      {
        "name": "logAttrs",
        "desc": "logAttrs is like [Logger.log], but for methods that take ...Attr."
      },
      {
        "name": "Add",
        "desc": "Add converts the args to Attrs as described in [Logger.Log], then appends the Attrs to the [Record]'s list of Attrs. It omits empty groups."
      },
      {
        "name": "AddAttrs",
        "desc": "AddAttrs appends the given Attrs to the [Record]'s list of Attrs. It omits empty groups."
      },
      {
        "name": "Attrs",
        "desc": "Attrs calls f on each Attr in the [Record]. Iteration stops if f returns false."
      },
      {
        "name": "Clone",
        "desc": "Clone returns a copy of the record with no shared state. The original record and the clone can both be modified without interfering with each other."
      },
      {
        "name": "NumAttrs",
        "desc": "NumAttrs returns the number of attributes in the [Record]."
      },
      {
        "name": "Source",
        "desc": "Source returns a new Source for the log event using r's PC. If the PC field is zero, meaning the Record was created without the necessary information or the location is unavailable, then nil is returned."
      },
      {
        "name": "group",
        "desc": "group returns the non-zero fields of s as a slice of attrs. It is similar to a LogValue method, but we don't want Source to implement LogValuer because it would be resolved before the ReplaceAttr function was called."
      },
      {
        "name": "isEmpty",
        "desc": "isEmpty returns whether the Source struct is nil or only contains zero fields."
      },
      {
        "name": "Enabled",
        "desc": "Enabled reports whether the handler handles records at the given level. The handler ignores records whose level is lower."
      },
      {
        "name": "Handle",
        "desc": "Handle formats its argument [Record] as a single line of space-separated key=value items.  If the Record's time is zero, the time is omitted. Otherwise, the key is \"time\" and the value is output in RFC3339 format with millisecond precision.  The level's key is \"level\" and its value is the result of calling [Level.String].  If the AddSource option is set and source information is available, the key is \"source\" and the value is output as FILE:LINE.  The message's key is \"msg\".  To modify these or other attributes, or remove them from the output, use [HandlerOptions.ReplaceAttr].  If a value implements [encoding.TextMarshaler], the result of MarshalText is written. Otherwise, the result of [fmt.Sprint] is written.  Keys and values are quoted with [strconv.Quote] if they contain Unicode space characters, non-printing characters, '\"' or '='.  Keys inside groups consist of components (keys or group names) separated by dots. No further escaping is performed. Thus there is no way to determine from the key \"a.b.c\" whether there are two groups \"a\" and \"b\" and a key \"c\", or a single group \"a.b\" and a key \"c\", or single group \"a\" and a key \"b.c\". If it is necessary to reconstruct the group structure of a key even in the presence of dots inside components, use [HandlerOptions.ReplaceAttr] to encode that information in the key.  Each call to Handle results in a single serialized call to io.Writer.Write."
      },
      {
        "name": "WithAttrs",
        "desc": "WithAttrs returns a new [TextHandler] whose attributes consists of h's attributes followed by attrs."
      },
      {
        "name": "WithGroup",
        "desc": ""
      },
      {
        "name": "attrSep",
        "desc": "attrSep returns the separator between attributes."
      },
      {
        "name": "clone",
        "desc": ""
      },
      {
        "name": "enabled",
        "desc": "enabled reports whether l is greater than or equal to the minimum level."
      },
      {
        "name": "handle",
        "desc": "handle is the internal implementation of Handler.Handle used by TextHandler and JSONHandler."
      },
      {
        "name": "newHandleState",
        "desc": ""
      },
      {
        "name": "withAttrs",
        "desc": ""
      },
      {
        "name": "withGroup",
        "desc": ""
      },
      {
        "name": "Any",
        "desc": "Any returns v's value as an any."
      },
      {
        "name": "AsAny",
        "desc": ""
      },
      {
        "name": "AsBool",
        "desc": ""
      },
      {
        "name": "AsDuration",
        "desc": ""
      },
      {
        "name": "AsFloat64",
        "desc": ""
      },
      {
        "name": "AsInt64",
        "desc": ""
      },
      {
        "name": "AsString",
        "desc": ""
      },
      {
        "name": "AsUint64",
        "desc": ""
      },
      {
        "name": "Bool",
        "desc": "Bool returns v's value as a bool. It panics if v is not a bool."
      },
      {
        "name": "Duration",
        "desc": "Duration returns v's value as a [time.Duration]. It panics if v is not a time.Duration."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether v and w represent the same Go value."
      },
      {
        "name": "Float64",
        "desc": "Float64 returns v's value as a float64. It panics if v is not a float64."
      },
      {
        "name": "Group",
        "desc": "Group returns v's value as a []Attr. It panics if v's [Kind] is not [KindGroup]."
      },
      {
        "name": "Int64",
        "desc": "Int64 returns v's value as an int64. It panics if v is not a signed integer."
      },
      {
        "name": "Kind",
        "desc": "Kind returns v's Kind."
      },
      {
        "name": "LogValuer",
        "desc": "LogValuer returns v's value as a LogValuer. It panics if v is not a LogValuer."
      },
      {
        "name": "Resolve",
        "desc": "Resolve repeatedly calls LogValue on v while it implements [LogValuer], and returns the result. If v resolves to a group, the group's attributes' values are not recursively resolved. If the number of LogValue calls exceeds a threshold, a Value containing an error is returned. Resolve's return value is guaranteed not to be of Kind [KindLogValuer]."
      },
      {
        "name": "String",
        "desc": "String returns Value's value as a string, formatted like [fmt.Sprint]. Unlike the methods Int64, Float64, and so on, which panic if v is of the wrong kind, String never panics."
      },
      {
        "name": "Time",
        "desc": "Time returns v's value as a [time.Time]. It panics if v is not a time.Time."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 returns v's value as a uint64. It panics if v is not an unsigned integer."
      },
      {
        "name": "Visit",
        "desc": ""
      },
      {
        "name": "append",
        "desc": "append appends a text representation of v to dst. v is formatted as with fmt.Sprint."
      },
      {
        "name": "bool",
        "desc": ""
      },
      {
        "name": "duration",
        "desc": ""
      },
      {
        "name": "float",
        "desc": ""
      },
      {
        "name": "group",
        "desc": ""
      },
      {
        "name": "isEmptyGroup",
        "desc": "isEmptyGroup reports whether v is a group that has no attributes."
      },
      {
        "name": "str",
        "desc": ""
      },
      {
        "name": "time",
        "desc": "See TimeValue to understand how times are represented."
      },
      {
        "name": "Enabled",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": ""
      },
      {
        "name": "WithAttrs",
        "desc": ""
      },
      {
        "name": "WithGroup",
        "desc": ""
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "attrSep",
        "desc": "attrSep returns the separator between attributes."
      },
      {
        "name": "clone",
        "desc": ""
      },
      {
        "name": "enabled",
        "desc": "enabled reports whether l is greater than or equal to the minimum level."
      },
      {
        "name": "handle",
        "desc": "handle is the internal implementation of Handler.Handle used by TextHandler and JSONHandler."
      },
      {
        "name": "newHandleState",
        "desc": ""
      },
      {
        "name": "withAttrs",
        "desc": ""
      },
      {
        "name": "withGroup",
        "desc": ""
      },
      {
        "name": "Enabled",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": "Collect the level, attributes and message in a string and write it with the default log.Logger. Let the log.Logger handle time and file/line."
      },
      {
        "name": "WithAttrs",
        "desc": ""
      },
      {
        "name": "WithGroup",
        "desc": ""
      },
      {
        "name": "Enabled",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": ""
      },
      {
        "name": "WithAttrs",
        "desc": ""
      },
      {
        "name": "WithGroup",
        "desc": ""
      },
      {
        "name": "Enabled",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": ""
      },
      {
        "name": "WithAttrs",
        "desc": ""
      },
      {
        "name": "WithGroup",
        "desc": ""
      },
      {
        "name": "appendAttr",
        "desc": "appendAttr appends the Attr's key and value. It handles replacement and checking for an empty key. It reports whether something was appended."
      },
      {
        "name": "appendAttrs",
        "desc": "appendAttrs appends the slice of Attrs. It reports whether something was appended."
      },
      {
        "name": "appendError",
        "desc": ""
      },
      {
        "name": "appendKey",
        "desc": ""
      },
      {
        "name": "appendNonBuiltIns",
        "desc": ""
      },
      {
        "name": "appendString",
        "desc": ""
      },
      {
        "name": "appendTime",
        "desc": ""
      },
      {
        "name": "appendTwoStrings",
        "desc": "appendTwoStrings implements appendString(prefix + key), but faster."
      },
      {
        "name": "appendValue",
        "desc": ""
      },
      {
        "name": "closeGroup",
        "desc": "closeGroup ends the group with the given name."
      },
      {
        "name": "free",
        "desc": ""
      },
      {
        "name": "openGroup",
        "desc": "openGroup starts a new group of attributes with the given name."
      },
      {
        "name": "openGroups",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "LogValue",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "MarshalJSON",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "LogValue",
        "desc": ""
      },
      {
        "name": "LogValue",
        "desc": ""
      },
      {
        "name": "Any",
        "desc": ""
      },
      {
        "name": "Bool",
        "desc": ""
      },
      {
        "name": "Duration",
        "desc": ""
      },
      {
        "name": "Float64",
        "desc": ""
      },
      {
        "name": "Int64",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Uint64",
        "desc": ""
      },
      {
        "name": "MarshalText",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Enabled",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": ""
      },
      {
        "name": "WithAttrs",
        "desc": ""
      },
      {
        "name": "WithGroup",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Attr",
        "desc": "An Attr is a key-value pair."
      },
      {
        "name": "Handler",
        "desc": "A Handler handles log records produced by a Logger.  A typical handler may print log records to standard error, or write them to a file or database, or perhaps augment them with additional attributes and pass them on to another handler.  Any of the Handler's methods may be called concurrently with itself or with other methods. It is the responsibility of the Handler to manage this concurrency.  Users of the slog package should not invoke Handler methods directly. They should use the methods of [Logger] instead.  Before implementing your own handler, consult https://go.dev/s/slog-handler-guide."
      },
      {
        "name": "HandlerOptions",
        "desc": "HandlerOptions are options for a [TextHandler] or [JSONHandler]. A zero HandlerOptions consists entirely of default values."
      },
      {
        "name": "JSONHandler",
        "desc": "JSONHandler is a [Handler] that writes Records to an [io.Writer] as line-delimited JSON objects."
      },
      {
        "name": "Kind",
        "desc": "Kind is the kind of a [Value]."
      },
      {
        "name": "Level",
        "desc": "A Level is the importance or severity of a log event. The higher the level, the more important or severe the event."
      },
      {
        "name": "LevelVar",
        "desc": "A LevelVar is a [Level] variable, to allow a [Handler] level to change dynamically. It implements [Leveler] as well as a Set method, and it is safe for use by multiple goroutines. The zero LevelVar corresponds to [LevelInfo]."
      },
      {
        "name": "Leveler",
        "desc": "A Leveler provides a [Level] value.  As Level itself implements Leveler, clients typically supply a Level value wherever a Leveler is needed, such as in [HandlerOptions]. Clients who need to vary the level dynamically can provide a more complex Leveler implementation such as *[LevelVar]."
      },
      {
        "name": "LogValuer",
        "desc": "A LogValuer is any Go value that can convert itself into a Value for logging.  This mechanism may be used to defer expensive operations until they are needed, or to expand a single value into a sequence of components."
      },
      {
        "name": "Logger",
        "desc": "A Logger records structured information about each call to its Log, Debug, Info, Warn, and Error methods. For each call, it creates a [Record] and passes it to a [Handler].  To create a new Logger, call [New] or a Logger method that begins \"With\"."
      },
      {
        "name": "Record",
        "desc": "A Record holds information about a log event. Copies of a Record share state. Do not modify a Record after handing out a copy to it. Call [NewRecord] to create a new Record. Use [Record.Clone] to create a copy with no shared state."
      },
      {
        "name": "Source",
        "desc": "Source describes the location of a line of source code."
      },
      {
        "name": "TextHandler",
        "desc": "TextHandler is a [Handler] that writes Records to an [io.Writer] as a sequence of key=value pairs separated by spaces and followed by a newline."
      },
      {
        "name": "Value",
        "desc": "A Value can represent any Go value, but unlike type any, it can represent most small values without an allocation. The zero Value corresponds to nil."
      },
      {
        "name": "Visitor",
        "desc": "Problem: adding a type means adding a method, which is a breaking change. Using an unexported method to force embedding will make programs compile, But they will panic at runtime when we call the new method."
      },
      {
        "name": "captureHandler",
        "desc": ""
      },
      {
        "name": "commonHandler",
        "desc": ""
      },
      {
        "name": "defaultHandler",
        "desc": ""
      },
      {
        "name": "discardHandler",
        "desc": ""
      },
      {
        "name": "discardTestHandler",
        "desc": ""
      },
      {
        "name": "groupptr",
        "desc": ""
      },
      {
        "name": "handleState",
        "desc": "handleState holds state for a single call to commonHandler.handle. The initial value of sep determines whether to emit a separator before the next key, after which it stays true."
      },
      {
        "name": "handlerWriter",
        "desc": "handlerWriter is an io.Writer that calls a Handler. It is used to link the default log.Logger to the default slog.Logger."
      },
      {
        "name": "jsonMarshaler",
        "desc": "for testing json.Marshaler"
      },
      {
        "name": "jsonMarshalerError",
        "desc": ""
      },
      {
        "name": "kind",
        "desc": "Unexported version of Kind, just so we can store Kinds in Values. (No user-provided value has this type.)"
      },
      {
        "name": "logValueName",
        "desc": ""
      },
      {
        "name": "name",
        "desc": "for testing fmt.Sprint"
      },
      {
        "name": "panicTextAndJsonMarshaler",
        "desc": "panicTextAndJsonMarshaler is a type that panics in MarshalText and MarshalJSON."
      },
      {
        "name": "panickingLogValue",
        "desc": ""
      },
      {
        "name": "replace",
        "desc": ""
      },
      {
        "name": "setVisitor",
        "desc": ""
      },
      {
        "name": "stringptr",
        "desc": ""
      },
      {
        "name": "text",
        "desc": "for testing TextMarshaler"
      },
      {
        "name": "timeLocation",
        "desc": "Unexported version of *time.Location, just so we can store *time.Locations in Values. (No user-provided value has this type.)"
      },
      {
        "name": "timeTime",
        "desc": "timeTime is for times where UnixNano is undefined."
      },
      {
        "name": "wrappingHandler",
        "desc": ""
      }
    ]
  },
  {
    "name": "log/syslog",
    "desc": "Package syslog provides a simple interface to the system log service. It can send messages to the syslog daemon using UNIX domain sockets, UDP or TCP.  Only one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again.  The syslog package is frozen and is not accepting new features. Some external packages provide more functionality. See:  \thttps://godoc.org/?q=syslog",
    "functions": [
      {
        "name": "NewLogger",
        "desc": "NewLogger creates a [log.Logger] whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to [log.New] to create the Logger."
      },
      {
        "name": "TestConcurrentReconnect",
        "desc": ""
      },
      {
        "name": "TestConcurrentWrite",
        "desc": ""
      },
      {
        "name": "TestDial",
        "desc": ""
      },
      {
        "name": "TestFlap",
        "desc": ""
      },
      {
        "name": "TestNew",
        "desc": ""
      },
      {
        "name": "TestNewLogger",
        "desc": ""
      },
      {
        "name": "TestWithSimulated",
        "desc": ""
      },
      {
        "name": "TestWrite",
        "desc": ""
      },
      {
        "name": "check",
        "desc": ""
      },
      {
        "name": "runPktSyslog",
        "desc": ""
      },
      {
        "name": "runStreamSyslog",
        "desc": ""
      },
      {
        "name": "startServer",
        "desc": ""
      },
      {
        "name": "testableNetwork",
        "desc": ""
      },
      {
        "name": "Alert",
        "desc": "Alert logs a message with severity [LOG_ALERT], ignoring the severity passed to New."
      },
      {
        "name": "Close",
        "desc": "Close closes a connection to the syslog daemon."
      },
      {
        "name": "Crit",
        "desc": "Crit logs a message with severity [LOG_CRIT], ignoring the severity passed to New."
      },
      {
        "name": "Debug",
        "desc": "Debug logs a message with severity [LOG_DEBUG], ignoring the severity passed to New."
      },
      {
        "name": "Emerg",
        "desc": "Emerg logs a message with severity [LOG_EMERG], ignoring the severity passed to New."
      },
      {
        "name": "Err",
        "desc": "Err logs a message with severity [LOG_ERR], ignoring the severity passed to New."
      },
      {
        "name": "Info",
        "desc": "Info logs a message with severity [LOG_INFO], ignoring the severity passed to New."
      },
      {
        "name": "Notice",
        "desc": "Notice logs a message with severity [LOG_NOTICE], ignoring the severity passed to New."
      },
      {
        "name": "Warning",
        "desc": "Warning logs a message with severity [LOG_WARNING], ignoring the severity passed to New."
      },
      {
        "name": "Write",
        "desc": "Write sends a log message to the syslog daemon."
      },
      {
        "name": "connect",
        "desc": "connect makes a connection to the syslog server. It must be called with w.mu held."
      },
      {
        "name": "write",
        "desc": "write generates and writes a syslog formatted string. The format is as follows: \u003cPRI\u003eTIMESTAMP HOSTNAME TAG[PID]: MSG"
      },
      {
        "name": "writeAndRetry",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "writeString",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Priority",
        "desc": "The Priority is a combination of the syslog facility and severity. For example, [LOG_ALERT] | [LOG_FTP] sends an alert severity message from the FTP facility. The default severity is [LOG_EMERG]; the default facility is [LOG_KERN]."
      },
      {
        "name": "Writer",
        "desc": "A Writer is a connection to a syslog server."
      },
      {
        "name": "netConn",
        "desc": ""
      },
      {
        "name": "serverConn",
        "desc": "This interface and the separate syslog_unix.go file exist for Solaris support as implemented by gccgo. On Solaris you cannot simply open a TCP connection to the syslog daemon. The gccgo sources have a syslog_solaris.go file that implements unixSyslog to return a type that satisfies this interface and simply calls the C library syslog function."
      }
    ]
  },
  {
    "name": "maps",
    "desc": "",
    "functions": [
      {
        "name": "ExampleAll",
        "desc": ""
      },
      {
        "name": "ExampleClone",
        "desc": ""
      },
      {
        "name": "ExampleCollect",
        "desc": ""
      },
      {
        "name": "ExampleCopy",
        "desc": ""
      },
      {
        "name": "ExampleDeleteFunc",
        "desc": ""
      },
      {
        "name": "ExampleEqual",
        "desc": ""
      },
      {
        "name": "ExampleEqualFunc",
        "desc": ""
      },
      {
        "name": "ExampleInsert",
        "desc": ""
      },
      {
        "name": "ExampleKeys",
        "desc": ""
      },
      {
        "name": "ExampleValues",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "math",
    "desc": "Tests whether the non vector routines are working, even when the tests are run on a vector-capable machine.",
    "functions": [
      {
        "name": "BenchmarkAbs",
        "desc": ""
      },
      {
        "name": "BenchmarkAcos",
        "desc": ""
      },
      {
        "name": "BenchmarkAcosh",
        "desc": ""
      },
      {
        "name": "BenchmarkAsin",
        "desc": ""
      },
      {
        "name": "BenchmarkAsinh",
        "desc": ""
      },
      {
        "name": "BenchmarkAtan",
        "desc": ""
      },
      {
        "name": "BenchmarkAtan2",
        "desc": ""
      },
      {
        "name": "BenchmarkAtanh",
        "desc": ""
      },
      {
        "name": "BenchmarkCbrt",
        "desc": ""
      },
      {
        "name": "BenchmarkCeil",
        "desc": ""
      },
      {
        "name": "BenchmarkCopysign",
        "desc": ""
      },
      {
        "name": "BenchmarkCos",
        "desc": ""
      },
      {
        "name": "BenchmarkCosh",
        "desc": ""
      },
      {
        "name": "BenchmarkDim",
        "desc": ""
      },
      {
        "name": "BenchmarkErf",
        "desc": ""
      },
      {
        "name": "BenchmarkErfc",
        "desc": ""
      },
      {
        "name": "BenchmarkErfcinv",
        "desc": ""
      },
      {
        "name": "BenchmarkErfinv",
        "desc": ""
      },
      {
        "name": "BenchmarkExp",
        "desc": ""
      },
      {
        "name": "BenchmarkExp2",
        "desc": ""
      },
      {
        "name": "BenchmarkExp2Go",
        "desc": ""
      },
      {
        "name": "BenchmarkExpGo",
        "desc": ""
      },
      {
        "name": "BenchmarkExpm1",
        "desc": ""
      },
      {
        "name": "BenchmarkFMA",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat32bits",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat32frombits",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat64bits",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat64frombits",
        "desc": ""
      },
      {
        "name": "BenchmarkFloor",
        "desc": ""
      },
      {
        "name": "BenchmarkFrexp",
        "desc": ""
      },
      {
        "name": "BenchmarkGamma",
        "desc": ""
      },
      {
        "name": "BenchmarkHypot",
        "desc": ""
      },
      {
        "name": "BenchmarkHypotGo",
        "desc": ""
      },
      {
        "name": "BenchmarkIlogb",
        "desc": ""
      },
      {
        "name": "BenchmarkJ0",
        "desc": ""
      },
      {
        "name": "BenchmarkJ1",
        "desc": ""
      },
      {
        "name": "BenchmarkJn",
        "desc": ""
      },
      {
        "name": "BenchmarkLdexp",
        "desc": ""
      },
      {
        "name": "BenchmarkLgamma",
        "desc": ""
      },
      {
        "name": "BenchmarkLog",
        "desc": ""
      },
      {
        "name": "BenchmarkLog10",
        "desc": ""
      },
      {
        "name": "BenchmarkLog1p",
        "desc": ""
      },
      {
        "name": "BenchmarkLog2",
        "desc": ""
      },
      {
        "name": "BenchmarkLogb",
        "desc": ""
      },
      {
        "name": "BenchmarkMax",
        "desc": ""
      },
      {
        "name": "BenchmarkMin",
        "desc": ""
      },
      {
        "name": "BenchmarkMod",
        "desc": ""
      },
      {
        "name": "BenchmarkModf",
        "desc": ""
      },
      {
        "name": "BenchmarkNextafter32",
        "desc": ""
      },
      {
        "name": "BenchmarkNextafter64",
        "desc": ""
      },
      {
        "name": "BenchmarkPow10Neg",
        "desc": ""
      },
      {
        "name": "BenchmarkPow10Pos",
        "desc": ""
      },
      {
        "name": "BenchmarkPowFrac",
        "desc": ""
      },
      {
        "name": "BenchmarkPowInt",
        "desc": ""
      },
      {
        "name": "BenchmarkRemainder",
        "desc": ""
      },
      {
        "name": "BenchmarkRound",
        "desc": ""
      },
      {
        "name": "BenchmarkRoundToEven",
        "desc": ""
      },
      {
        "name": "BenchmarkSignbit",
        "desc": ""
      },
      {
        "name": "BenchmarkSin",
        "desc": ""
      },
      {
        "name": "BenchmarkSincos",
        "desc": ""
      },
      {
        "name": "BenchmarkSinh",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrtGoLatency",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrtIndirect",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrtIndirectLatency",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrtLatency",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrtPrime",
        "desc": ""
      },
      {
        "name": "BenchmarkTan",
        "desc": ""
      },
      {
        "name": "BenchmarkTanh",
        "desc": ""
      },
      {
        "name": "BenchmarkTrunc",
        "desc": ""
      },
      {
        "name": "BenchmarkY0",
        "desc": ""
      },
      {
        "name": "BenchmarkY1",
        "desc": ""
      },
      {
        "name": "BenchmarkYn",
        "desc": ""
      },
      {
        "name": "ExampleAbs",
        "desc": ""
      },
      {
        "name": "ExampleAcos",
        "desc": ""
      },
      {
        "name": "ExampleAcosh",
        "desc": ""
      },
      {
        "name": "ExampleAsin",
        "desc": ""
      },
      {
        "name": "ExampleAsinh",
        "desc": ""
      },
      {
        "name": "ExampleAtan",
        "desc": ""
      },
      {
        "name": "ExampleAtan2",
        "desc": ""
      },
      {
        "name": "ExampleAtanh",
        "desc": ""
      },
      {
        "name": "ExampleCbrt",
        "desc": ""
      },
      {
        "name": "ExampleCeil",
        "desc": ""
      },
      {
        "name": "ExampleCopysign",
        "desc": ""
      },
      {
        "name": "ExampleCos",
        "desc": ""
      },
      {
        "name": "ExampleCosh",
        "desc": ""
      },
      {
        "name": "ExampleDim",
        "desc": ""
      },
      {
        "name": "ExampleExp",
        "desc": ""
      },
      {
        "name": "ExampleExp2",
        "desc": ""
      },
      {
        "name": "ExampleExpm1",
        "desc": ""
      },
      {
        "name": "ExampleFloor",
        "desc": ""
      },
      {
        "name": "ExampleLog",
        "desc": ""
      },
      {
        "name": "ExampleLog10",
        "desc": ""
      },
      {
        "name": "ExampleLog2",
        "desc": ""
      },
      {
        "name": "ExampleMod",
        "desc": ""
      },
      {
        "name": "ExampleModf",
        "desc": ""
      },
      {
        "name": "ExamplePow",
        "desc": ""
      },
      {
        "name": "ExamplePow10",
        "desc": ""
      },
      {
        "name": "ExampleRemainder",
        "desc": ""
      },
      {
        "name": "ExampleRound",
        "desc": ""
      },
      {
        "name": "ExampleRoundToEven",
        "desc": ""
      },
      {
        "name": "ExampleSin",
        "desc": ""
      },
      {
        "name": "ExampleSincos",
        "desc": ""
      },
      {
        "name": "ExampleSinh",
        "desc": ""
      },
      {
        "name": "ExampleSqrt",
        "desc": ""
      },
      {
        "name": "ExampleTan",
        "desc": ""
      },
      {
        "name": "ExampleTanh",
        "desc": ""
      },
      {
        "name": "ExampleTrunc",
        "desc": ""
      },
      {
        "name": "TestAbs",
        "desc": ""
      },
      {
        "name": "TestAcos",
        "desc": ""
      },
      {
        "name": "TestAcosNovec",
        "desc": ""
      },
      {
        "name": "TestAcosh",
        "desc": ""
      },
      {
        "name": "TestAcoshNovec",
        "desc": ""
      },
      {
        "name": "TestAsin",
        "desc": ""
      },
      {
        "name": "TestAsinNovec",
        "desc": ""
      },
      {
        "name": "TestAsinh",
        "desc": ""
      },
      {
        "name": "TestAsinhNovec",
        "desc": ""
      },
      {
        "name": "TestAtan",
        "desc": ""
      },
      {
        "name": "TestAtan2",
        "desc": ""
      },
      {
        "name": "TestAtan2Novec",
        "desc": ""
      },
      {
        "name": "TestAtanNovec",
        "desc": ""
      },
      {
        "name": "TestAtanh",
        "desc": ""
      },
      {
        "name": "TestAtanhNovec",
        "desc": ""
      },
      {
        "name": "TestCbrt",
        "desc": ""
      },
      {
        "name": "TestCbrtNovec",
        "desc": ""
      },
      {
        "name": "TestCeil",
        "desc": ""
      },
      {
        "name": "TestCopysign",
        "desc": ""
      },
      {
        "name": "TestCos",
        "desc": ""
      },
      {
        "name": "TestCosNovec",
        "desc": ""
      },
      {
        "name": "TestCosh",
        "desc": ""
      },
      {
        "name": "TestCoshNovec",
        "desc": ""
      },
      {
        "name": "TestDim",
        "desc": ""
      },
      {
        "name": "TestErf",
        "desc": ""
      },
      {
        "name": "TestErfNovec",
        "desc": ""
      },
      {
        "name": "TestErfc",
        "desc": ""
      },
      {
        "name": "TestErfcNovec",
        "desc": ""
      },
      {
        "name": "TestErfcinv",
        "desc": ""
      },
      {
        "name": "TestErfinv",
        "desc": ""
      },
      {
        "name": "TestExp",
        "desc": ""
      },
      {
        "name": "TestExp2",
        "desc": ""
      },
      {
        "name": "TestExpNovec",
        "desc": ""
      },
      {
        "name": "TestExpm1",
        "desc": ""
      },
      {
        "name": "TestExpm1Novec",
        "desc": ""
      },
      {
        "name": "TestFMA",
        "desc": ""
      },
      {
        "name": "TestFMANegativeArgs",
        "desc": ""
      },
      {
        "name": "TestFloat32Sqrt",
        "desc": "TestFloat32Sqrt checks the correctness of the float32 square root optimization result."
      },
      {
        "name": "TestFloatMinMax",
        "desc": ""
      },
      {
        "name": "TestFloatMinima",
        "desc": ""
      },
      {
        "name": "TestFloor",
        "desc": ""
      },
      {
        "name": "TestFrexp",
        "desc": ""
      },
      {
        "name": "TestGamma",
        "desc": ""
      },
      {
        "name": "TestHugeCos",
        "desc": "Check that trig values of huge angles return accurate results. This confirms that argument reduction works for very large values up to MaxFloat64."
      },
      {
        "name": "TestHugeSin",
        "desc": ""
      },
      {
        "name": "TestHugeSinCos",
        "desc": ""
      },
      {
        "name": "TestHugeTan",
        "desc": ""
      },
      {
        "name": "TestHypot",
        "desc": ""
      },
      {
        "name": "TestHypotGo",
        "desc": ""
      },
      {
        "name": "TestIlogb",
        "desc": ""
      },
      {
        "name": "TestJ0",
        "desc": ""
      },
      {
        "name": "TestJ1",
        "desc": ""
      },
      {
        "name": "TestJn",
        "desc": ""
      },
      {
        "name": "TestLargeCos",
        "desc": "Check that math functions of high angle values return accurate results. [Since (vf[i] + large) - large != vf[i], testing for Trig(vf[i] + large) == Trig(vf[i]), where large is a multiple of 2*Pi, is misleading.]"
      },
      {
        "name": "TestLargeCosNovec",
        "desc": "Check that math functions of high angle values return accurate results. [Since (vf[i] + large) - large != vf[i], testing for Trig(vf[i] + large) == Trig(vf[i]), where large is a multiple of 2*Pi, is misleading.]"
      },
      {
        "name": "TestLargeSin",
        "desc": ""
      },
      {
        "name": "TestLargeSinNovec",
        "desc": ""
      },
      {
        "name": "TestLargeSincos",
        "desc": ""
      },
      {
        "name": "TestLargeTan",
        "desc": ""
      },
      {
        "name": "TestLargeTanNovec",
        "desc": ""
      },
      {
        "name": "TestLdexp",
        "desc": ""
      },
      {
        "name": "TestLgamma",
        "desc": ""
      },
      {
        "name": "TestLog",
        "desc": ""
      },
      {
        "name": "TestLog10",
        "desc": ""
      },
      {
        "name": "TestLog10Novec",
        "desc": ""
      },
      {
        "name": "TestLog1p",
        "desc": ""
      },
      {
        "name": "TestLog1pNovec",
        "desc": ""
      },
      {
        "name": "TestLog2",
        "desc": ""
      },
      {
        "name": "TestLogNovec",
        "desc": ""
      },
      {
        "name": "TestLogb",
        "desc": ""
      },
      {
        "name": "TestMax",
        "desc": ""
      },
      {
        "name": "TestMaxInt",
        "desc": ""
      },
      {
        "name": "TestMaxUint",
        "desc": ""
      },
      {
        "name": "TestMin",
        "desc": ""
      },
      {
        "name": "TestMod",
        "desc": ""
      },
      {
        "name": "TestModf",
        "desc": ""
      },
      {
        "name": "TestNaN",
        "desc": ""
      },
      {
        "name": "TestNextafter32",
        "desc": ""
      },
      {
        "name": "TestNextafter64",
        "desc": ""
      },
      {
        "name": "TestPow",
        "desc": ""
      },
      {
        "name": "TestPow10",
        "desc": ""
      },
      {
        "name": "TestPowNovec",
        "desc": ""
      },
      {
        "name": "TestRemainder",
        "desc": ""
      },
      {
        "name": "TestRound",
        "desc": ""
      },
      {
        "name": "TestRoundToEven",
        "desc": ""
      },
      {
        "name": "TestSignbit",
        "desc": ""
      },
      {
        "name": "TestSin",
        "desc": ""
      },
      {
        "name": "TestSinNovec",
        "desc": ""
      },
      {
        "name": "TestSincos",
        "desc": ""
      },
      {
        "name": "TestSinh",
        "desc": ""
      },
      {
        "name": "TestSinhNovec",
        "desc": ""
      },
      {
        "name": "TestSqrt",
        "desc": ""
      },
      {
        "name": "TestTan",
        "desc": ""
      },
      {
        "name": "TestTanNovec",
        "desc": ""
      },
      {
        "name": "TestTanh",
        "desc": ""
      },
      {
        "name": "TestTanhNovec",
        "desc": ""
      },
      {
        "name": "TestTrigReduce",
        "desc": "Check that trigReduce matches the standard reduction results for input values below reduceThreshold."
      },
      {
        "name": "TestTrunc",
        "desc": ""
      },
      {
        "name": "TestY0",
        "desc": ""
      },
      {
        "name": "TestY1",
        "desc": ""
      },
      {
        "name": "TestYn",
        "desc": ""
      },
      {
        "name": "alike",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "fmsub",
        "desc": ""
      },
      {
        "name": "fnmadd",
        "desc": ""
      },
      {
        "name": "fnmsub",
        "desc": ""
      },
      {
        "name": "isPrime",
        "desc": ""
      },
      {
        "name": "soclose",
        "desc": ""
      },
      {
        "name": "testExp",
        "desc": ""
      },
      {
        "name": "testExp2",
        "desc": ""
      },
      {
        "name": "testExpNovec",
        "desc": ""
      },
      {
        "name": "tolerance",
        "desc": ""
      },
      {
        "name": "veryclose",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "fi",
        "desc": ""
      },
      {
        "name": "floatTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "math/big",
    "desc": "Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported:  \tInt    signed integers \tRat    rational numbers \tFloat  floating-point numbers  The zero value for an [Int], [Rat], or [Float] correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization:  \tvar x Int        // \u0026x is an *Int of value 0 \tvar r = \u0026Rat{}   // r is a *Rat of value 0 \ty := new(Float)  // y is a *Float of value 0  Alternatively, new values can be allocated and initialized with factory functions of the form:  \tfunc NewT(v V) *T  For instance, [NewInt](x) returns an *[Int] set to the value of the int64 argument x, [NewRat](a, b) returns a *[Rat] set to the fraction a/b where a and b are int64 values, and [NewFloat](f) returns a *[Float] initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance:  \tvar z1 Int \tz1.SetUint64(123)                 // z1 := 123 \tz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4 \tz3 := new(Float).SetInt(z1)       // z3 := 123.0  Setters, numeric operations and predicates are represented as methods of the form:  \tfunc (z *T) SetV(v V) *T          // z = v \tfunc (z *T) Unary(x *T) *T        // z = unary x \tfunc (z *T) Binary(x, y *T) *T    // z = x binary y \tfunc (x *T) Pred() P              // p = pred(x)  with T one of [Int], [Rat], or [Float]. For unary and binary operations, the result is the receiver (usually named z in that case; see below); if it is one of the operands x or y it may be safely overwritten (and its memory reused).  Arithmetic expressions are typically written as a sequence of individual method calls, with each call corresponding to an operation. The receiver denotes the result and the method arguments are the operation's operands. For instance, given three *Int values a, b and c, the invocation  \tc.Add(a, b)  computes the sum a + b and stores the result in c, overwriting whatever value was held in c before. Unless specified otherwise, operations permit aliasing of parameters, so it is perfectly ok to write  \tsum.Add(sum, x)  to accumulate values x in a sum.  (By always passing in a result value via the receiver, memory use can be much better controlled. Instead of having to allocate new memory for each result, an operation can reuse the space allocated for the result value, and overwrite that value with the new result in the process.)  Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).  For instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z:  \tfunc (z *Int) Add(x, y *Int) *Int  Methods of this form typically return the incoming receiver as well, to enable simple call chaining.  Methods which don't require a result value to be passed in (for instance, [Int.Sign]), simply return the result. In this case, the receiver is typically the first operand, named x:  \tfunc (x *Int) Sign() int  Various methods support conversions between strings and corresponding numeric values, and vice versa: *[Int], *[Rat], and *[Float] values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation).  Finally, *[Int], *[Rat], and *[Float] satisfy [fmt.Scanner] for scanning and (except for *[Rat]) the Formatter interface for formatted printing.",
    "functions": [
      {
        "name": "BenchmarkAddMulVVWW",
        "desc": ""
      },
      {
        "name": "BenchmarkAddVV",
        "desc": ""
      },
      {
        "name": "BenchmarkAddVW",
        "desc": ""
      },
      {
        "name": "BenchmarkArithVV",
        "desc": ""
      },
      {
        "name": "BenchmarkBinomial",
        "desc": ""
      },
      {
        "name": "BenchmarkBitset",
        "desc": ""
      },
      {
        "name": "BenchmarkBitsetNeg",
        "desc": ""
      },
      {
        "name": "BenchmarkBitsetNegOrig",
        "desc": ""
      },
      {
        "name": "BenchmarkBitsetOrig",
        "desc": ""
      },
      {
        "name": "BenchmarkCopyVV",
        "desc": ""
      },
      {
        "name": "BenchmarkDecimalConversion",
        "desc": ""
      },
      {
        "name": "BenchmarkDiv",
        "desc": ""
      },
      {
        "name": "BenchmarkDivWVW",
        "desc": ""
      },
      {
        "name": "BenchmarkExp",
        "desc": ""
      },
      {
        "name": "BenchmarkExp2",
        "desc": ""
      },
      {
        "name": "BenchmarkExp3Power",
        "desc": ""
      },
      {
        "name": "BenchmarkExpMont",
        "desc": ""
      },
      {
        "name": "BenchmarkFibo",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatAdd",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatPrecExact",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatPrecInexact",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatPrecMixed",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatSqrt",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatString",
        "desc": ""
      },
      {
        "name": "BenchmarkFloatSub",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD100000x100000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10000x10000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10000x100000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD1000x1000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD1000x10000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD1000x100000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD100x100",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD100x1000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD100x10000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD100x100000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10x10",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10x100",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10x1000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10x10000",
        "desc": ""
      },
      {
        "name": "BenchmarkGCD10x100000",
        "desc": ""
      },
      {
        "name": "BenchmarkHilbert",
        "desc": ""
      },
      {
        "name": "BenchmarkIntSqr",
        "desc": ""
      },
      {
        "name": "BenchmarkLeafSize",
        "desc": ""
      },
      {
        "name": "BenchmarkLshVU",
        "desc": ""
      },
      {
        "name": "BenchmarkModInverse",
        "desc": ""
      },
      {
        "name": "BenchmarkModSqrt225_3Mod4",
        "desc": ""
      },
      {
        "name": "BenchmarkModSqrt225_Tonelli",
        "desc": ""
      },
      {
        "name": "BenchmarkModSqrt231_5Mod8",
        "desc": ""
      },
      {
        "name": "BenchmarkModSqrt231_Tonelli",
        "desc": ""
      },
      {
        "name": "BenchmarkMulAddVWW",
        "desc": ""
      },
      {
        "name": "BenchmarkNatMul",
        "desc": ""
      },
      {
        "name": "BenchmarkNatSetBytes",
        "desc": ""
      },
      {
        "name": "BenchmarkNatSqr",
        "desc": ""
      },
      {
        "name": "BenchmarkParseFloatLargeExp",
        "desc": ""
      },
      {
        "name": "BenchmarkParseFloatSmallExp",
        "desc": ""
      },
      {
        "name": "BenchmarkProbablyPrime",
        "desc": ""
      },
      {
        "name": "BenchmarkQuoRem",
        "desc": ""
      },
      {
        "name": "BenchmarkRatCmp",
        "desc": ""
      },
      {
        "name": "BenchmarkRshVU",
        "desc": ""
      },
      {
        "name": "BenchmarkScan",
        "desc": ""
      },
      {
        "name": "BenchmarkScanPi",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrt",
        "desc": ""
      },
      {
        "name": "BenchmarkString",
        "desc": ""
      },
      {
        "name": "BenchmarkStringPiParallel",
        "desc": ""
      },
      {
        "name": "BenchmarkSubVV",
        "desc": ""
      },
      {
        "name": "BenchmarkSubVW",
        "desc": ""
      },
      {
        "name": "BenchmarkZeroShifts",
        "desc": ""
      },
      {
        "name": "FuzzExpMont",
        "desc": ""
      },
      {
        "name": "Jacobi",
        "desc": "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer."
      },
      {
        "name": "LeafSizeHelper",
        "desc": ""
      },
      {
        "name": "ParseFloat",
        "desc": "ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode."
      },
      {
        "name": "TestAbsZ",
        "desc": ""
      },
      {
        "name": "TestAdd",
        "desc": ""
      },
      {
        "name": "TestAddMulVVWW",
        "desc": ""
      },
      {
        "name": "TestAddMulVVWWNoADX",
        "desc": ""
      },
      {
        "name": "TestAddVV",
        "desc": ""
      },
      {
        "name": "TestAddVVNoVec",
        "desc": ""
      },
      {
        "name": "TestAddVW",
        "desc": ""
      },
      {
        "name": "TestAppendText",
        "desc": ""
      },
      {
        "name": "TestBinomial",
        "desc": ""
      },
      {
        "name": "TestBit",
        "desc": ""
      },
      {
        "name": "TestBitLen",
        "desc": ""
      },
      {
        "name": "TestBitSet",
        "desc": ""
      },
      {
        "name": "TestBits",
        "desc": ""
      },
      {
        "name": "TestBitwise",
        "desc": ""
      },
      {
        "name": "TestBytes",
        "desc": ""
      },
      {
        "name": "TestCalibrate",
        "desc": ""
      },
      {
        "name": "TestCmp",
        "desc": ""
      },
      {
        "name": "TestCmpAbs",
        "desc": ""
      },
      {
        "name": "TestDecimalInit",
        "desc": ""
      },
      {
        "name": "TestDecimalRounding",
        "desc": ""
      },
      {
        "name": "TestDecimalString",
        "desc": ""
      },
      {
        "name": "TestDenomRace",
        "desc": ""
      },
      {
        "name": "TestDivWW",
        "desc": ""
      },
      {
        "name": "TestDivisionSigns",
        "desc": ""
      },
      {
        "name": "TestEscape",
        "desc": ""
      },
      {
        "name": "TestExp",
        "desc": ""
      },
      {
        "name": "TestExpNN",
        "desc": ""
      },
      {
        "name": "TestFibo",
        "desc": ""
      },
      {
        "name": "TestFillBytes",
        "desc": ""
      },
      {
        "name": "TestFloat32Distribution",
        "desc": ""
      },
      {
        "name": "TestFloat32SpecialCases",
        "desc": ""
      },
      {
        "name": "TestFloat64",
        "desc": ""
      },
      {
        "name": "TestFloat64Distribution",
        "desc": ""
      },
      {
        "name": "TestFloat64SpecialCases",
        "desc": ""
      },
      {
        "name": "TestFloat64Text",
        "desc": ""
      },
      {
        "name": "TestFloatAbs",
        "desc": ""
      },
      {
        "name": "TestFloatAdd",
        "desc": "TestFloatAdd tests Float.Add/Sub by comparing the result of a \"manual\" addition/subtraction of arguments represented by Bits values with the respective Float addition/subtraction for a variety of precisions and rounding modes."
      },
      {
        "name": "TestFloatAdd32",
        "desc": "TestFloatAdd32 tests that Float.Add/Sub of numbers with 24bit mantissa behaves like float32 addition/subtraction (excluding denormal numbers)."
      },
      {
        "name": "TestFloatAdd64",
        "desc": "TestFloatAdd64 tests that Float.Add/Sub of numbers with 53bit mantissa behaves like float64 addition/subtraction."
      },
      {
        "name": "TestFloatAddRoundZero",
        "desc": "TestFloatAddRoundZero tests Float.Add/Sub rounding when the result is exactly zero. x + (-x) or x - x for non-zero x should be +0 in all cases except when the rounding mode is ToNegativeInf in which case it should be -0."
      },
      {
        "name": "TestFloatAppendText",
        "desc": ""
      },
      {
        "name": "TestFloatAppendTextNil",
        "desc": ""
      },
      {
        "name": "TestFloatArithmeticOverflow",
        "desc": ""
      },
      {
        "name": "TestFloatArithmeticRounding",
        "desc": "For rounding modes ToNegativeInf and ToPositiveInf, rounding is affected by the sign of the value to be rounded. Test that rounding happens after the sign of a result has been set. This test uses specific values that are known to fail if rounding is \"factored\" out before setting the result sign."
      },
      {
        "name": "TestFloatArithmeticSpecialValues",
        "desc": "TestFloatArithmeticSpecialValues tests that Float operations produce the correct results for combinations of zero (±0), finite (±1 and ±2.71828), and infinite (±Inf) operands."
      },
      {
        "name": "TestFloatCmpSpecialValues",
        "desc": "TestFloatCmpSpecialValues tests that Cmp produces the correct results for combinations of zero (±0), finite (±1 and ±2.71828), and infinite (±Inf) operands."
      },
      {
        "name": "TestFloatCorruptGob",
        "desc": ""
      },
      {
        "name": "TestFloatFloat32",
        "desc": ""
      },
      {
        "name": "TestFloatFloat64",
        "desc": ""
      },
      {
        "name": "TestFloatFormat",
        "desc": ""
      },
      {
        "name": "TestFloatGobDecodeInvalid",
        "desc": ""
      },
      {
        "name": "TestFloatGobDecodeShortBuffer",
        "desc": ""
      },
      {
        "name": "TestFloatGobEncoding",
        "desc": ""
      },
      {
        "name": "TestFloatInc",
        "desc": ""
      },
      {
        "name": "TestFloatInt",
        "desc": ""
      },
      {
        "name": "TestFloatInt64",
        "desc": ""
      },
      {
        "name": "TestFloatIsInt",
        "desc": ""
      },
      {
        "name": "TestFloatJSONEncoding",
        "desc": ""
      },
      {
        "name": "TestFloatMantExp",
        "desc": ""
      },
      {
        "name": "TestFloatMantExpAliasing",
        "desc": ""
      },
      {
        "name": "TestFloatMinPrec",
        "desc": ""
      },
      {
        "name": "TestFloatMul",
        "desc": "TestFloatMul tests Float.Mul/Quo by comparing the result of a \"manual\" multiplication/division of arguments represented by Bits values with the respective Float multiplication/division for a variety of precisions and rounding modes."
      },
      {
        "name": "TestFloatMul64",
        "desc": "TestFloatMul64 tests that Float.Mul/Quo of numbers with 53bit mantissa behaves like float64 multiplication/division."
      },
      {
        "name": "TestFloatNeg",
        "desc": ""
      },
      {
        "name": "TestFloatPrec",
        "desc": ""
      },
      {
        "name": "TestFloatPredicates",
        "desc": ""
      },
      {
        "name": "TestFloatQuo",
        "desc": ""
      },
      {
        "name": "TestFloatQuoSmoke",
        "desc": "TestFloatQuoSmoke tests all divisions x/y for values x, y in the range [-n, +n]; it serves as a smoke test for basic correctness of division."
      },
      {
        "name": "TestFloatRat",
        "desc": ""
      },
      {
        "name": "TestFloatRound",
        "desc": "TestFloatRound tests basic rounding."
      },
      {
        "name": "TestFloatRound24",
        "desc": "TestFloatRound24 tests that rounding a float64 to 24 bits matches IEEE 754 rounding to nearest when converting a float64 to a float32 (excluding denormal numbers)."
      },
      {
        "name": "TestFloatScan",
        "desc": ""
      },
      {
        "name": "TestFloatSetFloat64",
        "desc": ""
      },
      {
        "name": "TestFloatSetFloat64String",
        "desc": ""
      },
      {
        "name": "TestFloatSetInf",
        "desc": ""
      },
      {
        "name": "TestFloatSetInt",
        "desc": ""
      },
      {
        "name": "TestFloatSetInt64",
        "desc": ""
      },
      {
        "name": "TestFloatSetMantExp",
        "desc": ""
      },
      {
        "name": "TestFloatSetPrec",
        "desc": ""
      },
      {
        "name": "TestFloatSetRat",
        "desc": ""
      },
      {
        "name": "TestFloatSetUint64",
        "desc": ""
      },
      {
        "name": "TestFloatSign",
        "desc": ""
      },
      {
        "name": "TestFloatSqrt",
        "desc": ""
      },
      {
        "name": "TestFloatSqrt64",
        "desc": "TestFloatSqrt64 tests that Float.Sqrt of numbers with 53bit mantissa behaves like float math.Sqrt."
      },
      {
        "name": "TestFloatSqrtSpecial",
        "desc": ""
      },
      {
        "name": "TestFloatString",
        "desc": ""
      },
      {
        "name": "TestFloatText",
        "desc": ""
      },
      {
        "name": "TestFloatUint64",
        "desc": ""
      },
      {
        "name": "TestFloatZeroValue",
        "desc": ""
      },
      {
        "name": "TestFormat",
        "desc": ""
      },
      {
        "name": "TestFromBits",
        "desc": ""
      },
      {
        "name": "TestFunVWW",
        "desc": ""
      },
      {
        "name": "TestGcd",
        "desc": ""
      },
      {
        "name": "TestGetString",
        "desc": ""
      },
      {
        "name": "TestGobEncodingNilIntInSlice",
        "desc": "Sending a nil Int pointer (inside a slice) on a round trip through gob should yield a zero. TODO: top-level nils."
      },
      {
        "name": "TestGobEncodingNilRatInSlice",
        "desc": "Sending a nil Rat pointer (inside a slice) on a round trip through gob should yield a zero. TODO: top-level nils."
      },
      {
        "name": "TestHilbert",
        "desc": ""
      },
      {
        "name": "TestInt64",
        "desc": ""
      },
      {
        "name": "TestIntAppendText",
        "desc": ""
      },
      {
        "name": "TestIntAppendTextNil",
        "desc": ""
      },
      {
        "name": "TestIntCmpSelf",
        "desc": ""
      },
      {
        "name": "TestIntGobEncoding",
        "desc": ""
      },
      {
        "name": "TestIntJSONEncoding",
        "desc": ""
      },
      {
        "name": "TestIntJSONEncodingNil",
        "desc": ""
      },
      {
        "name": "TestIntText",
        "desc": ""
      },
      {
        "name": "TestIntXMLEncoding",
        "desc": ""
      },
      {
        "name": "TestIsFinite",
        "desc": ""
      },
      {
        "name": "TestIsInt",
        "desc": ""
      },
      {
        "name": "TestIssue20490",
        "desc": ""
      },
      {
        "name": "TestIssue22830",
        "desc": "We can't test this together with the other Exp tests above because it requires a different receiver setup."
      },
      {
        "name": "TestIssue2379",
        "desc": ""
      },
      {
        "name": "TestIssue2607",
        "desc": ""
      },
      {
        "name": "TestIssue31084",
        "desc": ""
      },
      {
        "name": "TestIssue31184",
        "desc": ""
      },
      {
        "name": "TestIssue34919",
        "desc": "TestIssue34919 verifies that a Rat's denominator is not modified when simply accessing the Rat value."
      },
      {
        "name": "TestIssue3521",
        "desc": ""
      },
      {
        "name": "TestIssue37499",
        "desc": "TestIssue37499 triggers the edge case of divBasic where the inaccurate estimate of the first word's quotient happens at the very beginning of the loop."
      },
      {
        "name": "TestIssue42552",
        "desc": "TestIssue42552 triggers an edge case of recursive division where the first division loop is never entered, and correcting the remainder takes exactly two iterations in the final loop."
      },
      {
        "name": "TestIssue42838",
        "desc": ""
      },
      {
        "name": "TestIssue45910",
        "desc": ""
      },
      {
        "name": "TestIssue6866",
        "desc": ""
      },
      {
        "name": "TestIssue820",
        "desc": ""
      },
      {
        "name": "TestJacobi",
        "desc": ""
      },
      {
        "name": "TestJacobiPanic",
        "desc": ""
      },
      {
        "name": "TestLinkerGC",
        "desc": "Tests that the linker is able to remove references to Float, Rat, and Int if unused (notably, not used by init)."
      },
      {
        "name": "TestLsh",
        "desc": ""
      },
      {
        "name": "TestLshRsh",
        "desc": ""
      },
      {
        "name": "TestLshSelf",
        "desc": ""
      },
      {
        "name": "TestLshVU",
        "desc": ""
      },
      {
        "name": "TestLucasPseudoprimes",
        "desc": ""
      },
      {
        "name": "TestMaxBase",
        "desc": ""
      },
      {
        "name": "TestMillerRabinPseudoprimes",
        "desc": ""
      },
      {
        "name": "TestModInverse",
        "desc": ""
      },
      {
        "name": "TestModSqrt",
        "desc": ""
      },
      {
        "name": "TestModW",
        "desc": ""
      },
      {
        "name": "TestMontgomery",
        "desc": ""
      },
      {
        "name": "TestMul",
        "desc": ""
      },
      {
        "name": "TestMulAddVWW",
        "desc": ""
      },
      {
        "name": "TestMulAddWWW",
        "desc": ""
      },
      {
        "name": "TestMulAlloc",
        "desc": ""
      },
      {
        "name": "TestMulBits",
        "desc": ""
      },
      {
        "name": "TestMulRangeN",
        "desc": ""
      },
      {
        "name": "TestMulRangeZ",
        "desc": ""
      },
      {
        "name": "TestMulUnbalanced",
        "desc": "TestMulUnbalanced tests that multiplying numbers of different lengths does not cause deep recursion and in turn allocate too much memory. Test case for issue 3807."
      },
      {
        "name": "TestMulWW",
        "desc": ""
      },
      {
        "name": "TestNLZ",
        "desc": ""
      },
      {
        "name": "TestNatDiv",
        "desc": ""
      },
      {
        "name": "TestNatMul",
        "desc": ""
      },
      {
        "name": "TestNatSqr",
        "desc": ""
      },
      {
        "name": "TestNatSubMod2N",
        "desc": ""
      },
      {
        "name": "TestNewIntAllocs",
        "desc": ""
      },
      {
        "name": "TestNewIntMinInt64",
        "desc": ""
      },
      {
        "name": "TestNormBits",
        "desc": ""
      },
      {
        "name": "TestNot",
        "desc": ""
      },
      {
        "name": "TestProbablyPrime",
        "desc": ""
      },
      {
        "name": "TestProdZZ",
        "desc": ""
      },
      {
        "name": "TestQuo",
        "desc": ""
      },
      {
        "name": "TestQuoStepD6",
        "desc": ""
      },
      {
        "name": "TestRatAbs",
        "desc": ""
      },
      {
        "name": "TestRatAppendText",
        "desc": ""
      },
      {
        "name": "TestRatBin",
        "desc": ""
      },
      {
        "name": "TestRatCmp",
        "desc": ""
      },
      {
        "name": "TestRatGobDecodeShortBuffer",
        "desc": ""
      },
      {
        "name": "TestRatGobEncoding",
        "desc": ""
      },
      {
        "name": "TestRatInv",
        "desc": ""
      },
      {
        "name": "TestRatJSONEncoding",
        "desc": ""
      },
      {
        "name": "TestRatNeg",
        "desc": ""
      },
      {
        "name": "TestRatScan",
        "desc": ""
      },
      {
        "name": "TestRatSetFrac64Rat",
        "desc": ""
      },
      {
        "name": "TestRatSetInt64",
        "desc": ""
      },
      {
        "name": "TestRatSetString",
        "desc": ""
      },
      {
        "name": "TestRatSetStringZero",
        "desc": ""
      },
      {
        "name": "TestRatSetUint64",
        "desc": ""
      },
      {
        "name": "TestRatSign",
        "desc": ""
      },
      {
        "name": "TestRatXMLEncoding",
        "desc": ""
      },
      {
        "name": "TestRsh",
        "desc": ""
      },
      {
        "name": "TestRshSelf",
        "desc": ""
      },
      {
        "name": "TestRshVU",
        "desc": ""
      },
      {
        "name": "TestScan",
        "desc": ""
      },
      {
        "name": "TestScanBase",
        "desc": ""
      },
      {
        "name": "TestScanExponent",
        "desc": ""
      },
      {
        "name": "TestScanPi",
        "desc": "Test case for BenchmarkScanPi."
      },
      {
        "name": "TestScanPiParallel",
        "desc": ""
      },
      {
        "name": "TestSet",
        "desc": ""
      },
      {
        "name": "TestSetBytes",
        "desc": ""
      },
      {
        "name": "TestSetFloat64NonFinite",
        "desc": "TestSetFloat64NonFinite checks that SetFloat64 of a non-finite value returns nil."
      },
      {
        "name": "TestSetString",
        "desc": ""
      },
      {
        "name": "TestSetZ",
        "desc": ""
      },
      {
        "name": "TestShiftLeft",
        "desc": ""
      },
      {
        "name": "TestShiftOverlap",
        "desc": ""
      },
      {
        "name": "TestShiftRight",
        "desc": ""
      },
      {
        "name": "TestSignZ",
        "desc": ""
      },
      {
        "name": "TestSqrAlloc",
        "desc": ""
      },
      {
        "name": "TestSqrt",
        "desc": ""
      },
      {
        "name": "TestSticky",
        "desc": ""
      },
      {
        "name": "TestString",
        "desc": ""
      },
      {
        "name": "TestStringPowers",
        "desc": ""
      },
      {
        "name": "TestSub",
        "desc": ""
      },
      {
        "name": "TestSubVV",
        "desc": ""
      },
      {
        "name": "TestSubVVNoVec",
        "desc": ""
      },
      {
        "name": "TestSubVW",
        "desc": ""
      },
      {
        "name": "TestSumZZ",
        "desc": ""
      },
      {
        "name": "TestTrailingZeroBits",
        "desc": ""
      },
      {
        "name": "TestUint64",
        "desc": ""
      },
      {
        "name": "TestZeroRat",
        "desc": ""
      },
      {
        "name": "_",
        "desc": ""
      },
      {
        "name": "actualPrec",
        "desc": "actualPrec returns the number of actually used mantissa bits."
      },
      {
        "name": "addTo",
        "desc": "addTo implements z += x; z must be long enough. (we don't use nat.add because we need z to stay the same slice, and we don't need to normalize z after each addition)"
      },
      {
        "name": "alias",
        "desc": "alias reports whether x and y share the same base array.  Note: alias assumes that the capacity of underlying arrays is never changed for nat values; i.e. that there are no 3-operand slice expressions in this code (or worse, reflect-based operations to the same effect)."
      },
      {
        "name": "alike",
        "desc": "alike(x, y) is like x.Cmp(y) == 0 but also considers the sign of 0 (0 != -0)."
      },
      {
        "name": "alike32",
        "desc": ""
      },
      {
        "name": "alike64",
        "desc": ""
      },
      {
        "name": "allocBytes",
        "desc": "allocBytes returns the number of bytes allocated by invoking f."
      },
      {
        "name": "altBit",
        "desc": ""
      },
      {
        "name": "appendZeros",
        "desc": "appendZeros appends n 0 digits to buf and returns buf."
      },
      {
        "name": "basicMul",
        "desc": "basicMul multiplies x and y and leaves the result in z. The (non-normalized) result is placed in z[0 : len(x) + len(y)]."
      },
      {
        "name": "basicSqr",
        "desc": "basicSqr sets z = x*x and is asymptotically faster than basicMul by about a factor of 2, but slower for small arguments due to overhead. Requirements: len(x) \u003e 0, len(z) == 2*len(x) The (non-normalized) result is placed in z."
      },
      {
        "name": "bench",
        "desc": "bench runs benchmarks of fn for a variety of word sizes. It adds the given suffix (for example \"/impl=go\") to the benchmark names it creates, after a \"/words=N\" parameter. Putting words first makes it easier to run all benchmarks with a specific word size (go test -run=NONE '-bench=V/words=100$') even if different benchmarks have different numbers of other parameters."
      },
      {
        "name": "benchBasicSqr",
        "desc": ""
      },
      {
        "name": "benchDiv",
        "desc": ""
      },
      {
        "name": "benchMul",
        "desc": ""
      },
      {
        "name": "benchSqr",
        "desc": ""
      },
      {
        "name": "benchmarkDiv",
        "desc": ""
      },
      {
        "name": "benchmarkIntSqr",
        "desc": ""
      },
      {
        "name": "benchmarkNatMul",
        "desc": ""
      },
      {
        "name": "benchmarkNatSqr",
        "desc": ""
      },
      {
        "name": "checkBytes",
        "desc": ""
      },
      {
        "name": "checkGcd",
        "desc": ""
      },
      {
        "name": "checkIsBestApprox32",
        "desc": "checkIsBestApprox32 checks that f is the best possible float32 approximation of r. Returns true on success."
      },
      {
        "name": "checkIsBestApprox64",
        "desc": "checkIsBestApprox64 checks that f is the best possible float64 approximation of r. Returns true on success."
      },
      {
        "name": "checkLehmerExtGcd",
        "desc": ""
      },
      {
        "name": "checkLehmerGcd",
        "desc": ""
      },
      {
        "name": "checkMul",
        "desc": ""
      },
      {
        "name": "checkNonLossyRoundtrip32",
        "desc": "checkNonLossyRoundtrip32 checks that a float-\u003eRat-\u003efloat roundtrip is non-lossy for finite f."
      },
      {
        "name": "checkNonLossyRoundtrip64",
        "desc": "checkNonLossyRoundtrip64 checks that a float-\u003eRat-\u003efloat roundtrip is non-lossy for finite f."
      },
      {
        "name": "checkQuo",
        "desc": ""
      },
      {
        "name": "checkSetBytes",
        "desc": ""
      },
      {
        "name": "checkSlice",
        "desc": "checkSlice checks that the magic values left by setSlices are still there. If orig != nil, it also checks that the actual data in x is unmodified since setSlice."
      },
      {
        "name": "computeBasicSqrThreshold",
        "desc": ""
      },
      {
        "name": "computeDivRecursiveThreshold",
        "desc": ""
      },
      {
        "name": "computeKaratsubaSqrThreshold",
        "desc": ""
      },
      {
        "name": "computeKaratsubaThreshold",
        "desc": ""
      },
      {
        "name": "computeThreshold",
        "desc": ""
      },
      {
        "name": "csv",
        "desc": "csv returns a single csv line starting with name and followed by the values. Values that are float64 +infinity, denoting missing data, are replaced by an empty string."
      },
      {
        "name": "cutSpace",
        "desc": ""
      },
      {
        "name": "doHilbert",
        "desc": ""
      },
      {
        "name": "fdiv",
        "desc": ""
      },
      {
        "name": "fmtE",
        "desc": "%e: d.ddddde±dd"
      },
      {
        "name": "fmtF",
        "desc": "%f: ddddddd.ddddd"
      },
      {
        "name": "fnorm",
        "desc": "fnorm normalizes mantissa m by shifting it to the left such that the msb of the most-significant word (msw) is 1. It returns the shift amount. It assumes that len(m) != 0."
      },
      {
        "name": "format",
        "desc": ""
      },
      {
        "name": "fromBinary",
        "desc": ""
      },
      {
        "name": "greaterThan",
        "desc": "greaterThan reports whether the two digit numbers x1 x2 \u003e y1 y2. TODO(rsc): In contradiction to most of this file, x1 is the high digit and x2 is the low digit. This should be fixed."
      },
      {
        "name": "ifmt",
        "desc": "ifmt returns the debug formatting of the Int x: 0xHEX."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "isEven32",
        "desc": ""
      },
      {
        "name": "isEven64",
        "desc": ""
      },
      {
        "name": "isFinite",
        "desc": "isFinite reports whether f represents a finite rational value. It is equivalent to !math.IsNan(f) \u0026\u0026 !math.IsInf(f, 0)."
      },
      {
        "name": "isNormalized",
        "desc": ""
      },
      {
        "name": "itoa",
        "desc": ""
      },
      {
        "name": "karatsuba",
        "desc": "karatsuba multiplies x and y, writing the (non-normalized) result to z. x and y must have the same length n, and z must have length twice that."
      },
      {
        "name": "karatsubaSqr",
        "desc": "karatsubaSqr squares x, writing the (non-normalized) result to z. z must have length 2*len(x). It is analogous to [karatsuba] but can run faster knowing both multiplicands are the same value."
      },
      {
        "name": "lehmerUpdate",
        "desc": "lehmerUpdate updates the inputs A and B such that:  \tA = u0*A + v0*B \tB = u1*A + v1*B  where the signs of u0, u1, v0, v1 are given by even For even == true: u0, v1 \u003e= 0 \u0026\u0026 u1, v0 \u003c= 0 For even == false: u0, v1 \u003c= 0 \u0026\u0026 u1, v0 \u003e= 0 q, r, s, t are temporary variables to avoid allocations in the multiplication."
      },
      {
        "name": "log2",
        "desc": "log2 computes the integer binary logarithm of x. The result is the integer n for which 2^n \u003c= x \u003c 2^(n+1). If x == 0, the result is -1."
      },
      {
        "name": "low32",
        "desc": "low32 returns the least significant 32 bits of x."
      },
      {
        "name": "low64",
        "desc": "low64 returns the least significant 64 bits of x."
      },
      {
        "name": "maxPow",
        "desc": "maxPow returns (b**n, n) such that b**n is the largest power b**n \u003c= _M. For instance maxPow(10) == (1e19, 19) for 19 decimal digits in a 64bit Word. In other words, at most n digits in base b fit into a Word. TODO(gri) replace this with a table, generated at build time."
      },
      {
        "name": "msb32",
        "desc": "msb32 returns the 32 most significant bits of x."
      },
      {
        "name": "msb64",
        "desc": "msb64 returns the 64 most significant bits of x."
      },
      {
        "name": "mulBytes",
        "desc": "mulBytes returns x*y via grade school multiplication. Both inputs and the result are assumed to be in big-endian representation (to match the semantics of Int.Bytes and Int.SetBytes)."
      },
      {
        "name": "mulW",
        "desc": "mulW sets z = x * (-?)w where the minus sign is present when neg is true."
      },
      {
        "name": "nats",
        "desc": "nats returns a sequence of interesting nats of the given size:    - all 0   - all ^0   - all possible combinations of words   - ten random values"
      },
      {
        "name": "nlz",
        "desc": "nlz returns the number of leading zeros in x. Wraps bits.LeadingZeros call for convenience."
      },
      {
        "name": "permute",
        "desc": ""
      },
      {
        "name": "quotToFloat32",
        "desc": "quotToFloat32 returns the non-negative float32 value nearest to the quotient a/b, using round-to-even in halfway cases. It does not mutate its arguments. Preconditions: b is non-zero; a and b have no common factors."
      },
      {
        "name": "quotToFloat64",
        "desc": "quotToFloat64 returns the non-negative float64 value nearest to the quotient a/b, using round-to-even in halfway cases. It does not mutate its arguments. Preconditions: b is non-zero; a and b have no common factors."
      },
      {
        "name": "ratTok",
        "desc": ""
      },
      {
        "name": "resetTable",
        "desc": ""
      },
      {
        "name": "roundShortest",
        "desc": ""
      },
      {
        "name": "rsh",
        "desc": "rsh implements x \u003e\u003e s, for s \u003c= maxShift."
      },
      {
        "name": "runGCD",
        "desc": ""
      },
      {
        "name": "runGCDExt",
        "desc": ""
      },
      {
        "name": "runModWTests",
        "desc": ""
      },
      {
        "name": "same",
        "desc": ""
      },
      {
        "name": "scanExponent",
        "desc": "scanExponent scans the longest possible prefix of r representing a base 10 (“e”, “E”) or a base 2 (“p”, “P”) exponent, if any. It returns the exponent, the exponent base (10 or 2), or a read or syntax error, if any.  If sepOk is set, an underscore character “_” may appear between successive exponent digits; such underscores do not change the value of the exponent. Incorrect placement of underscores is reported as an error if there are no other errors. If sepOk is not set, underscores are not recognized and thus terminate scanning like any other character that is not a valid digit.  \texponent = ( \"e\" | \"E\" | \"p\" | \"P\" ) [ sign ] digits . \tsign     = \"+\" | \"-\" . \tdigits   = digit { [ '_' ] digit } . \tdigit    = \"0\" ... \"9\" .  A base 2 exponent is only permitted if base2ok is set."
      },
      {
        "name": "scanSign",
        "desc": ""
      },
      {
        "name": "setDuringTest",
        "desc": ""
      },
      {
        "name": "setSlice",
        "desc": "setSlice sets x[1:len(x)-1] to orig, leaving magic values in x[0] and x[len(x)-1] so that we can tell if routines accidentally write before or after the data."
      },
      {
        "name": "shouldRoundUp",
        "desc": "shouldRoundUp reports if x should be rounded up if shortened to n digits. n must be a valid index for x.mant."
      },
      {
        "name": "testBitFun",
        "desc": ""
      },
      {
        "name": "testBitFunSelf",
        "desc": ""
      },
      {
        "name": "testBitset",
        "desc": ""
      },
      {
        "name": "testFloatRound",
        "desc": ""
      },
      {
        "name": "testFunNN",
        "desc": ""
      },
      {
        "name": "testFunSNN",
        "desc": ""
      },
      {
        "name": "testFunVWW",
        "desc": ""
      },
      {
        "name": "testFunWVW",
        "desc": ""
      },
      {
        "name": "testFunZZ",
        "desc": ""
      },
      {
        "name": "testGcd",
        "desc": ""
      },
      {
        "name": "testModSqrt",
        "desc": "testModSqrt is a helper for TestModSqrt, which checks that ModSqrt can compute a square-root of elt^2."
      },
      {
        "name": "testPseudoprimes",
        "desc": ""
      },
      {
        "name": "testRatBin",
        "desc": ""
      },
      {
        "name": "testShiftFunc",
        "desc": ""
      },
      {
        "name": "testSqr",
        "desc": ""
      },
      {
        "name": "testVU",
        "desc": ""
      },
      {
        "name": "testVV",
        "desc": ""
      },
      {
        "name": "testVV2",
        "desc": ""
      },
      {
        "name": "testVVU",
        "desc": ""
      },
      {
        "name": "testVVWW",
        "desc": ""
      },
      {
        "name": "testVW",
        "desc": ""
      },
      {
        "name": "testVWW",
        "desc": ""
      },
      {
        "name": "toBinary",
        "desc": ""
      },
      {
        "name": "trace",
        "desc": "trace prints a single debug value."
      },
      {
        "name": "trim",
        "desc": "trim cuts off any trailing zeros from x's mantissa; they are meaningless for the value of x."
      },
      {
        "name": "validateBinaryOperands",
        "desc": ""
      },
      {
        "name": "writeMultiple",
        "desc": "write count copies of text to s."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Float",
        "desc": "Float returns the *Float z of the smallest possible precision such that z = sum(2**bits[i]), with i = range bits. If multiple bits[i] are equal, they are added: Bits{0, 1, 0}.Float() == 2**0 + 2**1 + 2**0 = 4."
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "mul",
        "desc": ""
      },
      {
        "name": "norm",
        "desc": "norm returns the normalized bits for x: It removes multiple equal entries by treating them as an addition (e.g., Bits{5, 5} =\u003e Bits{6}), and it sorts the result list for reproducible results."
      },
      {
        "name": "round",
        "desc": "round returns the Float value corresponding to x after rounding x to prec bits according to mode."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Abs",
        "desc": "Abs sets z to the (possibly rounded) value |x| (the absolute value of x) and returns z."
      },
      {
        "name": "Acc",
        "desc": "Acc returns the accuracy of x produced by the most recent operation, unless explicitly documented otherwise by that operation."
      },
      {
        "name": "Add",
        "desc": "Add sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. Add panics with [ErrNaN] if x and y are infinities with opposite signs. The value of z is undefined in that case."
      },
      {
        "name": "Append",
        "desc": "Append appends to buf the string form of the floating-point number x, as generated by x.Text, and returns the extended buffer."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface. Only the [Float] value is marshaled (in full precision), other attributes such as precision or accuracy are ignored."
      },
      {
        "name": "Cmp",
        "desc": "Cmp compares x and y and returns:   - -1 if x \u003c y;   - 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf);   - +1 if x \u003e y."
      },
      {
        "name": "Copy",
        "desc": "Copy sets z to x, with the same precision, rounding mode, and accuracy as x. Copy returns z. If x and z are identical, Copy is a no-op."
      },
      {
        "name": "Float32",
        "desc": "Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| \u003c [math.SmallestNonzeroFloat32]), the result is (0, [Below]) or (-0, [Above]), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| \u003e [math.MaxFloat32]), the result is (+Inf, [Above]) or (-Inf, [Below]), depending on the sign of x."
      },
      {
        "name": "Float64",
        "desc": "Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| \u003c [math.SmallestNonzeroFloat64]), the result is (0, [Below]) or (-0, [Above]), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| \u003e [math.MaxFloat64]), the result is (+Inf, [Above]) or (-Inf, [Below]), depending on the sign of x."
      },
      {
        "name": "Format",
        "desc": "Format implements [fmt.Formatter]. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details."
      },
      {
        "name": "GobDecode",
        "desc": "GobDecode implements the [encoding/gob.GobDecoder] interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value."
      },
      {
        "name": "GobEncode",
        "desc": "GobEncode implements the [encoding/gob.GobEncoder] interface. The [Float] value and all its attributes (precision, rounding mode, accuracy) are marshaled."
      },
      {
        "name": "Int",
        "desc": "Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is [Exact] if x.IsInt(); otherwise it is [Below] for x \u003e 0, and [Above] for x \u003c 0. If a non-nil *[Int] argument z is provided, [Int] stores the result in z instead of allocating a new [Int]."
      },
      {
        "name": "Int64",
        "desc": "Int64 returns the integer resulting from truncating x towards zero. If [math.MinInt64] \u003c= x \u003c= [math.MaxInt64], the result is [Exact] if x is an integer, and [Above] (x \u003c 0) or [Below] (x \u003e 0) otherwise. The result is ([math.MinInt64], [Above]) for x \u003c [math.MinInt64], and ([math.MaxInt64], [Below]) for x \u003e [math.MaxInt64]."
      },
      {
        "name": "IsInf",
        "desc": "IsInf reports whether x is +Inf or -Inf."
      },
      {
        "name": "IsInt",
        "desc": "IsInt reports whether x is an integer. ±Inf values are not integers."
      },
      {
        "name": "MantExp",
        "desc": "MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant × 2**exp, with 0.5 \u003c= |mant| \u003c 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver.  Special cases are:  \t(  ±0).MantExp(mant) = 0, with mant set to   ±0 \t(±Inf).MantExp(mant) = 0, with mant set to ±Inf  x and mant may be the same in which case x is set to its mantissa value."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface. Only the [Float] value is marshaled (in full precision), other attributes such as precision or accuracy are ignored."
      },
      {
        "name": "MinPrec",
        "desc": "MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf."
      },
      {
        "name": "Mode",
        "desc": "Mode returns the rounding mode of x."
      },
      {
        "name": "Mul",
        "desc": "Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for [Float.Add]. Mul panics with [ErrNaN] if one operand is zero and the other operand an infinity. The value of z is undefined in that case."
      },
      {
        "name": "Neg",
        "desc": "Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z."
      },
      {
        "name": "Parse",
        "desc": "Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value.  For base 0, an underscore character “_” may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit.  It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form:  \tnumber    = [ sign ] ( float | \"inf\" | \"Inf\" ) . \tsign      = \"+\" | \"-\" . \tfloat     = ( mantissa | prefix pmantissa ) [ exponent ] . \tprefix    = \"0\" [ \"b\" | \"B\" | \"o\" | \"O\" | \"x\" | \"X\" ] . \tmantissa  = digits \".\" [ digits ] | digits | \".\" digits . \tpmantissa = [ \"_\" ] digits \".\" [ digits ] | [ \"_\" ] digits | \".\" digits . \texponent  = ( \"e\" | \"E\" | \"p\" | \"P\" ) [ sign ] digits . \tdigits    = digit { [ \"_\" ] digit } . \tdigit     = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" .  The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic.  For base 0, the number prefix determines the actual base: A prefix of “0b” or “0B” selects base 2, “0o” or “0O” selects base 8, and “0x” or “0X” selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix \"0\" is not supported (a leading \"0\" is simply considered a \"0\").  A \"p\" or \"P\" exponent indicates a base 2 (rather than base 10) exponent; for instance, \"0x1.fffffffffffffp1023\" (using base 0) represents the maximum float64 value. For hexadecimal mantissae, the exponent character must be one of 'p' or 'P', if present (an \"e\" or \"E\" exponent indicator cannot be distinguished from a mantissa digit).  The returned *Float f is nil and the value of z is valid but not defined if an error is reported."
      },
      {
        "name": "Prec",
        "desc": "Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf."
      },
      {
        "name": "Quo",
        "desc": "Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for [Float.Add]. Quo panics with [ErrNaN] if both operands are zero or infinities. The value of z is undefined in that case."
      },
      {
        "name": "Rat",
        "desc": "Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is [Exact] if x is not an Inf. If a non-nil *[Rat] argument z is provided, [Rat] stores the result in z instead of allocating a new [Rat]."
      },
      {
        "name": "Scan",
        "desc": "Scan is a support routine for [fmt.Scanner]; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by [fmt.Scan] for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle ±Inf."
      },
      {
        "name": "Set",
        "desc": "Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result."
      },
      {
        "name": "SetFloat64",
        "desc": "SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with [ErrNaN] if x is a NaN."
      },
      {
        "name": "SetInf",
        "desc": "SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always [Exact]."
      },
      {
        "name": "SetInt",
        "desc": "SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect)."
      },
      {
        "name": "SetInt64",
        "desc": "SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect)."
      },
      {
        "name": "SetMantExp",
        "desc": "SetMantExp sets z to mant × 2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of [Float.MantExp] but does not require 0.5 \u003c= |mant| \u003c 1.0. Specifically, for a given x of type *[Float], SetMantExp relates to [Float.MantExp] as follows:  \tmant := new(Float) \tnew(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0  Special cases are:  \tz.SetMantExp(  ±0, exp) =   ±0 \tz.SetMantExp(±Inf, exp) = ±Inf  z and mant may be the same in which case z's exponent is set to exp."
      },
      {
        "name": "SetMode",
        "desc": "SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to [Exact]."
      },
      {
        "name": "SetPrec",
        "desc": "SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to ±0; infinite values remain unchanged. If prec \u003e [MaxPrec], it is set to [MaxPrec]."
      },
      {
        "name": "SetRat",
        "desc": "SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b."
      },
      {
        "name": "SetString",
        "desc": "SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by [Float.Parse], with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil."
      },
      {
        "name": "SetUint64",
        "desc": "SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect)."
      },
      {
        "name": "Sign",
        "desc": "Sign returns:   - -1 if x \u003c 0;   - 0 if x is ±0;   - +1 if x \u003e 0."
      },
      {
        "name": "Signbit",
        "desc": "Signbit reports whether x is negative or negative zero."
      },
      {
        "name": "Sqrt",
        "desc": "Sqrt sets z to the rounded square root of x, and returns it.  If z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode, but z's accuracy is not computed. Specifically, the result of z.Acc() is undefined.  The function panics if z \u003c 0. The value of z is undefined in that case."
      },
      {
        "name": "String",
        "desc": "String formats x like x.Text('g', 10). (String must be called explicitly, [Float.Format] does not support %s verb.)"
      },
      {
        "name": "Sub",
        "desc": "Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for [Float.Add]. Sub panics with [ErrNaN] if x and y are infinities with equal signs. The value of z is undefined in that case."
      },
      {
        "name": "Text",
        "desc": "Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of:  \t'e'\t-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits \t'E'\t-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits \t'f'\t-ddddd.dddd, no exponent \t'g'\tlike 'e' for large exponents, like 'f' otherwise \t'G'\tlike 'E' for large exponents, like 'f' otherwise \t'x'\t-0xd.dddddp±dd, hexadecimal mantissa, decimal power of two exponent \t'p'\t-0x.dddp±dd, hexadecimal mantissa, decimal power of two exponent (non-standard) \t'b'\t-ddddddp±dd, decimal mantissa, decimal power of two exponent (non-standard)  For the power-of-two exponent formats, the mantissa is printed in normalized form:  \t'x'\thexadecimal mantissa in [1, 2), or 0 \t'p'\thexadecimal mantissa in [½, 1), or 0 \t'b'\tdecimal integer mantissa using x.Prec() bits, or 0  Note that the 'x' form is the one used by most other languages and libraries.  If format is a different character, Text returns a \"%\" followed by the unrecognized format character.  The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 \u003c= x \u003c= [math.MaxUint64], the result is [Exact] if x is an integer and [Below] otherwise. The result is (0, [Above]) for x \u003c 0, and ([math.MaxUint64], [Below]) for x \u003e [math.MaxUint64]."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the [encoding.TextUnmarshaler] interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect."
      },
      {
        "name": "fmtB",
        "desc": "fmtB appends the string of x in the format mantissa \"p\" exponent with a decimal mantissa and a binary exponent, or \"0\" if x is zero, and returns the extended buffer. The mantissa is normalized such that is uses x.Prec() bits in binary representation. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtB.)"
      },
      {
        "name": "fmtP",
        "desc": "fmtP appends the string of x in the format \"0x.\" mantissa \"p\" exponent with a hexadecimal mantissa and a binary exponent, or \"0\" if x is zero, and returns the extended buffer. The mantissa is normalized such that 0.5 \u003c= 0.mantissa \u003c 1.0. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtP.)"
      },
      {
        "name": "fmtX",
        "desc": "fmtX appends the string of x in the format \"0x1.\" mantissa \"p\" exponent with a hexadecimal mantissa and a binary exponent, or \"0x0p0\" if x is zero, and returns the extended buffer. A non-zero mantissa is normalized such that 1.0 \u003c= mantissa \u003c 2.0. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtX.)"
      },
      {
        "name": "int64",
        "desc": ""
      },
      {
        "name": "ord",
        "desc": "ord classifies x and returns:  \t-2 if -Inf == x \t-1 if -Inf \u003c x \u003c 0 \t 0 if x == 0 (signed or unsigned) \t+1 if 0 \u003c x \u003c +Inf \t+2 if x == +Inf"
      },
      {
        "name": "pow5",
        "desc": "pow5 sets z to 5**n and returns z. n must not be negative."
      },
      {
        "name": "round",
        "desc": "round rounds z according to z.mode to z.prec bits and sets z.acc accordingly. sbit must be 0 or 1 and summarizes any \"sticky bit\" information one might have before calling round. z's mantissa must be normalized (with the msb set) or empty.  CAUTION: The rounding modes [ToNegativeInf], [ToPositiveInf] are affected by the sign of z. For correct rounding, the sign of z must be set correctly before calling round."
      },
      {
        "name": "scan",
        "desc": "scan is like Parse but reads the longest possible prefix representing a valid floating point number from an io.ByteScanner rather than a string. It serves as the implementation of Parse. It does not recognize ±Inf and does not expect EOF at the end."
      },
      {
        "name": "setBits64",
        "desc": ""
      },
      {
        "name": "setExpAndRound",
        "desc": ""
      },
      {
        "name": "sqrtInverse",
        "desc": "Compute √x (to z.prec precision) by solving  \t1/t² - x = 0  for t (using Newton's method), and then inverting."
      },
      {
        "name": "uadd",
        "desc": "z = x + y, ignoring signs of x and y for the addition but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent."
      },
      {
        "name": "ucmp",
        "desc": "ucmp returns -1, 0, or +1, depending on whether |x| \u003c |y|, |x| == |y|, or |x| \u003e |y|. x and y must have a non-empty mantissa and valid exponent."
      },
      {
        "name": "uint64",
        "desc": ""
      },
      {
        "name": "umul",
        "desc": "z = x * y, ignoring signs of x and y for the multiplication but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent."
      },
      {
        "name": "uquo",
        "desc": "z = x / y, ignoring signs of x and y for the division but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent."
      },
      {
        "name": "usub",
        "desc": "z = x - y for |x| \u003e |y|, ignoring signs of x and y for the subtraction but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent."
      },
      {
        "name": "validate",
        "desc": "debugging support"
      },
      {
        "name": "validate0",
        "desc": ""
      },
      {
        "name": "Abs",
        "desc": "Abs sets z to |x| (the absolute value of x) and returns z."
      },
      {
        "name": "Add",
        "desc": "Add sets z to the sum x+y and returns z."
      },
      {
        "name": "And",
        "desc": "And sets z = x \u0026 y and returns z."
      },
      {
        "name": "AndNot",
        "desc": "AndNot sets z = x \u0026^ y and returns z."
      },
      {
        "name": "Append",
        "desc": "Append appends the string representation of x, as generated by x.Text(base), to buf and returns the extended buffer."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface."
      },
      {
        "name": "Binomial",
        "desc": "Binomial sets z to the binomial coefficient C(n, k) and returns z."
      },
      {
        "name": "Bit",
        "desc": "Bit returns the value of the i'th bit of x. That is, it returns (x\u003e\u003ei)\u00261. The bit index i must be \u003e= 0."
      },
      {
        "name": "BitLen",
        "desc": "BitLen returns the length of the absolute value of x in bits. The bit length of 0 is 0."
      },
      {
        "name": "Bits",
        "desc": "Bits provides raw (unchecked but fast) access to x by returning its absolute value as a little-endian [Word] slice. The result and x share the same underlying array. Bits is intended to support implementation of missing low-level [Int] functionality outside this package; it should be avoided otherwise."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns the absolute value of x as a big-endian byte slice.  To use a fixed length slice, or a preallocated one, use [Int.FillBytes]."
      },
      {
        "name": "Cmp",
        "desc": "Cmp compares x and y and returns:   - -1 if x \u003c y;   - 0 if x == y;   - +1 if x \u003e y."
      },
      {
        "name": "CmpAbs",
        "desc": "CmpAbs compares the absolute values of x and y and returns:   - -1 if |x| \u003c |y|;   - 0 if |x| == |y|;   - +1 if |x| \u003e |y|."
      },
      {
        "name": "Div",
        "desc": "Div sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Div implements Euclidean division (unlike Go); see [Int.DivMod] for more details."
      },
      {
        "name": "DivMod",
        "desc": "DivMod sets z to the quotient x div y and m to the modulus x mod y and returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time panic occurs.  DivMod implements Euclidean division and modulus (unlike Go):  \tq = x div y  such that \tm = x - y*q  with 0 \u003c= m \u003c |y|  (See Raymond T. Boute, “The Euclidean definition of the functions div and mod”. ACM Transactions on Programming Languages and Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992. ACM press.) See [Int.QuoRem] for T-division and modulus (like Go)."
      },
      {
        "name": "Exp",
        "desc": "Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z. If m == nil or m == 0, z = x**y unless y \u003c= 0 then z = 1. If m != 0, y \u003c 0, and x and m are not relatively prime, z is unchanged and nil is returned.  Modular exponentiation of inputs of a particular size is not a cryptographically constant-time operation."
      },
      {
        "name": "FillBytes",
        "desc": "FillBytes sets buf to the absolute value of x, storing it as a zero-extended big-endian byte slice, and returns buf.  If the absolute value of x doesn't fit in buf, FillBytes will panic."
      },
      {
        "name": "Float64",
        "desc": "Float64 returns the float64 value nearest x, and an indication of any rounding that occurred."
      },
      {
        "name": "Format",
        "desc": "Format implements [fmt.Formatter]. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading \"0x\" or \"0X\" for \"%#x\" and \"%#X\" respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification."
      },
      {
        "name": "GCD",
        "desc": "GCD sets z to the greatest common divisor of a and b and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y.  a and b may be positive, zero or negative. (Before Go 1.14 both had to be \u003e 0.) Regardless of the signs of a and b, z is always \u003e= 0.  If a == b == 0, GCD sets z = x = y = 0.  If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.  If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0."
      },
      {
        "name": "GobDecode",
        "desc": "GobDecode implements the [encoding/gob.GobDecoder] interface."
      },
      {
        "name": "GobEncode",
        "desc": "GobEncode implements the [encoding/gob.GobEncoder] interface."
      },
      {
        "name": "Int64",
        "desc": "Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined."
      },
      {
        "name": "IsInt64",
        "desc": "IsInt64 reports whether x can be represented as an int64."
      },
      {
        "name": "IsUint64",
        "desc": "IsUint64 reports whether x can be represented as a uint64."
      },
      {
        "name": "Lsh",
        "desc": "Lsh sets z = x \u003c\u003c n and returns z."
      },
      {
        "name": "MarshalJSON",
        "desc": "MarshalJSON implements the [encoding/json.Marshaler] interface."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface."
      },
      {
        "name": "Mod",
        "desc": "Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see [Int.DivMod] for more details."
      },
      {
        "name": "ModInverse",
        "desc": "ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring ℤ/nℤ.  In this case, z is unchanged and the return value is nil. If n == 0, a division-by-zero run-time panic occurs."
      },
      {
        "name": "ModSqrt",
        "desc": "ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer, its behavior is undefined if p is odd but not prime."
      },
      {
        "name": "Mul",
        "desc": "Mul sets z to the product x*y and returns z."
      },
      {
        "name": "MulRange",
        "desc": "MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a \u003e b (empty range), the result is 1."
      },
      {
        "name": "Neg",
        "desc": "Neg sets z to -x and returns z."
      },
      {
        "name": "Not",
        "desc": "Not sets z = ^x and returns z."
      },
      {
        "name": "Or",
        "desc": "Or sets z = x | y and returns z."
      },
      {
        "name": "ProbablyPrime",
        "desc": "ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.  If x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most ¼ⁿ.  ProbablyPrime is 100% accurate for inputs less than 2⁶⁴. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities.  ProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test.  As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test. Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked."
      },
      {
        "name": "Quo",
        "desc": "Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see [Int.QuoRem] for more details."
      },
      {
        "name": "QuoRem",
        "desc": "QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.  QuoRem implements T-division and modulus (like Go):  \tq = x/y      with the result truncated to zero \tr = x - y*q  (See Daan Leijen, “Division and Modulus for Computer Scientists”.) See [Int.DivMod] for Euclidean division and modulus (unlike Go)."
      },
      {
        "name": "Rand",
        "desc": "Rand sets z to a pseudo-random number in [0, n) and returns z.  As this uses the [math/rand] package, it must not be used for security-sensitive work. Use [crypto/rand.Int] instead."
      },
      {
        "name": "Rem",
        "desc": "Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see [Int.QuoRem] for more details."
      },
      {
        "name": "Rsh",
        "desc": "Rsh sets z = x \u003e\u003e n and returns z."
      },
      {
        "name": "Scan",
        "desc": "Scan is a support routine for [fmt.Scanner]; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal)."
      },
      {
        "name": "Set",
        "desc": "Set sets z to x and returns z."
      },
      {
        "name": "SetBit",
        "desc": "SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is,   - if b is 1, SetBit sets z = x | (1 \u003c\u003c i);   - if b is 0, SetBit sets z = x \u0026^ (1 \u003c\u003c i);   - if b is not 0 or 1, SetBit will panic."
      },
      {
        "name": "SetBits",
        "desc": "SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian [Word] slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level [Int] functionality outside this package; it should be avoided otherwise."
      },
      {
        "name": "SetBytes",
        "desc": "SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z."
      },
      {
        "name": "SetInt64",
        "desc": "SetInt64 sets z to x and returns z."
      },
      {
        "name": "SetString",
        "desc": "SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.  The base argument must be 0 or a value between 2 and [MaxBase]. For base 0, the number prefix determines the actual base: A prefix of “0b” or “0B” selects base 2, “0”, “0o” or “0O” selects base 8, and “0x” or “0X” selects base 16. Otherwise, the selected base is 10 and no prefix is accepted.  For bases \u003c= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases \u003e 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.  For base 0, an underscore character “_” may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and act like any other character that is not a valid digit."
      },
      {
        "name": "SetUint64",
        "desc": "SetUint64 sets z to x and returns z."
      },
      {
        "name": "Sign",
        "desc": "Sign returns:   - -1 if x \u003c 0;   - 0 if x == 0;   - +1 if x \u003e 0."
      },
      {
        "name": "Sqrt",
        "desc": "Sqrt sets z to ⌊√x⌋, the largest integer such that z² ≤ x, and returns z. It panics if x is negative."
      },
      {
        "name": "String",
        "desc": "String returns the decimal representation of x as generated by x.Text(10)."
      },
      {
        "name": "Sub",
        "desc": "Sub sets z to the difference x-y and returns z."
      },
      {
        "name": "Text",
        "desc": "Text returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as \"0x\") is added to the string. If x is a nil pointer it returns \"\u003cnil\u003e\"."
      },
      {
        "name": "TrailingZeroBits",
        "desc": "TrailingZeroBits returns the number of consecutive least significant zero bits of |x|."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined."
      },
      {
        "name": "UnmarshalJSON",
        "desc": "UnmarshalJSON implements the [encoding/json.Unmarshaler] interface."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the [encoding.TextUnmarshaler] interface."
      },
      {
        "name": "Xor",
        "desc": "Xor sets z = x ^ y and returns z."
      },
      {
        "name": "exp",
        "desc": ""
      },
      {
        "name": "expSlow",
        "desc": ""
      },
      {
        "name": "lehmerGCD",
        "desc": "lehmerGCD sets z to the greatest common divisor of a and b, which both must be != 0, and returns z. If x or y are not nil, their values are set such that z = a*x + b*y. See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L. This implementation uses the improved condition by Collins requiring only one quotient and avoiding the possibility of single Word overflow. See Jebelean, \"Improving the multiprecision Euclidean algorithm\", Design and Implementation of Symbolic Computation Systems, pp 45-58. The cosequences are updated according to Algorithm 10.45 from Cohen et al. \"Handbook of Elliptic and Hyperelliptic Curve Cryptography\" pp 192."
      },
      {
        "name": "modSqrt3Mod4Prime",
        "desc": "modSqrt3Mod4 uses the identity  \t   (a^((p+1)/4))^2  mod p \t== u^(p+1)          mod p \t== u^2              mod p  to calculate the square root of any quadratic residue mod p quickly for 3 mod 4 primes."
      },
      {
        "name": "modSqrt5Mod8Prime",
        "desc": "modSqrt5Mod8Prime uses Atkin's observation that 2 is not a square mod p  \talpha ==  (2*a)^((p-5)/8)    mod p \tbeta  ==  2*a*alpha^2        mod p  is a square root of -1 \tb     ==  a*alpha*(beta-1)   mod p  is a square root of a  to calculate the square root of any quadratic residue mod p quickly for 5 mod 8 primes."
      },
      {
        "name": "modSqrtTonelliShanks",
        "desc": "modSqrtTonelliShanks uses the Tonelli-Shanks algorithm to find the square root of a quadratic residue modulo any prime."
      },
      {
        "name": "mul",
        "desc": "mul is like Mul but takes an explicit stack to use, for internal use. It does not return a *Int because doing so makes the stack-allocated Ints used in natmul.go escape to the heap (even though the result is unused)."
      },
      {
        "name": "scaleDenom",
        "desc": "scaleDenom sets z to the product x*f. If f == 0 (zero value of denominator), z is set to (a copy of) x."
      },
      {
        "name": "scan",
        "desc": "scan sets z to the integer value corresponding to the longest possible prefix read from r representing a signed integer number in a given conversion base. It returns z, the actual conversion base used, and an error, if any. In the error case, the value of z is undefined but the returned value is nil. The syntax follows the syntax of integer literals in Go.  The base argument must be 0 or a value from 2 through MaxBase. If the base is 0, the string prefix determines the actual conversion base. A prefix of “0b” or “0B” selects base 2; a “0”, “0o”, or “0O” prefix selects base 8, and a “0x” or “0X” prefix selects base 16. Otherwise the selected base is 10."
      },
      {
        "name": "setFromScanner",
        "desc": "setFromScanner implements SetString given an io.ByteScanner. For documentation see comments of SetString."
      },
      {
        "name": "Abs",
        "desc": "Abs sets z to |x| (the absolute value of x) and returns z."
      },
      {
        "name": "Add",
        "desc": "Add sets z to the sum x+y and returns z."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface."
      },
      {
        "name": "Cmp",
        "desc": "Cmp compares x and y and returns:   - -1 if x \u003c y;   - 0 if x == y;   - +1 if x \u003e y."
      },
      {
        "name": "Denom",
        "desc": "Denom returns the denominator of x; it is always \u003e 0. The result is a reference to x's denominator, unless x is an uninitialized (zero value) [Rat], in which case the result is a new [Int] of value 1. (To initialize x, any operation that sets x will do, including x.Set(x).) If the result is a reference to x's denominator it may change if a new value is assigned to x, and vice versa."
      },
      {
        "name": "Float32",
        "desc": "Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0."
      },
      {
        "name": "Float64",
        "desc": "Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0."
      },
      {
        "name": "FloatPrec",
        "desc": "FloatPrec returns the number n of non-repeating digits immediately following the decimal point of the decimal representation of x. The boolean result indicates whether a decimal representation of x with that many fractional digits is exact or rounded.  Examples:  \tx      n    exact    decimal representation n fractional digits \t0      0    true     0 \t1      0    true     1 \t1/2    1    true     0.5 \t1/3    0    false    0       (0.333... rounded) \t1/4    2    true     0.25 \t1/6    1    false    0.2     (0.166... rounded)"
      },
      {
        "name": "FloatString",
        "desc": "FloatString returns a string representation of x in decimal form with prec digits of precision after the radix point. The last digit is rounded to nearest, with halves rounded away from zero."
      },
      {
        "name": "GobDecode",
        "desc": "GobDecode implements the [encoding/gob.GobDecoder] interface."
      },
      {
        "name": "GobEncode",
        "desc": "GobEncode implements the [encoding/gob.GobEncoder] interface."
      },
      {
        "name": "Inv",
        "desc": "Inv sets z to 1/x and returns z. If x == 0, Inv panics."
      },
      {
        "name": "IsInt",
        "desc": "IsInt reports whether the denominator of x is 1."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface."
      },
      {
        "name": "Mul",
        "desc": "Mul sets z to the product x*y and returns z."
      },
      {
        "name": "Neg",
        "desc": "Neg sets z to -x and returns z."
      },
      {
        "name": "Num",
        "desc": "Num returns the numerator of x; it may be \u003c= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x."
      },
      {
        "name": "Quo",
        "desc": "Quo sets z to the quotient x/y and returns z. If y == 0, Quo panics."
      },
      {
        "name": "RatString",
        "desc": "RatString returns a string representation of x in the form \"a/b\" if b != 1, and in the form \"a\" if b == 1."
      },
      {
        "name": "Scan",
        "desc": "Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent."
      },
      {
        "name": "Set",
        "desc": "Set sets z to x (by making a copy of x) and returns z."
      },
      {
        "name": "SetFloat64",
        "desc": "SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil."
      },
      {
        "name": "SetFrac",
        "desc": "SetFrac sets z to a/b and returns z. If b == 0, SetFrac panics."
      },
      {
        "name": "SetFrac64",
        "desc": "SetFrac64 sets z to a/b and returns z. If b == 0, SetFrac64 panics."
      },
      {
        "name": "SetInt",
        "desc": "SetInt sets z to x (by making a copy of x) and returns z."
      },
      {
        "name": "SetInt64",
        "desc": "SetInt64 sets z to x and returns z."
      },
      {
        "name": "SetString",
        "desc": "SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction \"a/b\", or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of “0b”, “0” or “0o”, or “0x” (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for “0” to denote a non-decimal mantissa. A leading “0” is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 “e” or base-2 “p” (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) “p” exponent (because an “e” or “E” cannot be distinguished from a mantissa digit). If the exponent's absolute value is too large, the operation may fail. The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil."
      },
      {
        "name": "SetUint64",
        "desc": "SetUint64 sets z to x and returns z."
      },
      {
        "name": "Sign",
        "desc": "Sign returns:   - -1 if x \u003c 0;   - 0 if x == 0;   - +1 if x \u003e 0."
      },
      {
        "name": "String",
        "desc": "String returns a string representation of x in the form \"a/b\" (even if b == 1)."
      },
      {
        "name": "Sub",
        "desc": "Sub sets z to the difference x-y and returns z."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the [encoding.TextUnmarshaler] interface."
      },
      {
        "name": "marshal",
        "desc": "marshal implements [Rat.String] returning a slice of bytes. It appends the string representation of x in the form \"a/b\" (even if b == 1) to buf, and returns the extended buffer."
      },
      {
        "name": "norm",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "ReadByte",
        "desc": ""
      },
      {
        "name": "UnreadByte",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "at",
        "desc": "at returns the i'th mantissa digit, starting with the most significant digit at 0."
      },
      {
        "name": "init",
        "desc": "Init initializes x to the decimal representation of m \u003c\u003c shift (for shift \u003e= 0), or m \u003e\u003e -shift (for shift \u003c 0)."
      },
      {
        "name": "round",
        "desc": "round sets x to (at most) n mantissa digits by rounding it to the nearest even value with n (or fever) mantissa digits. If n \u003c 0, x remains unchanged."
      },
      {
        "name": "roundDown",
        "desc": ""
      },
      {
        "name": "roundUp",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "at",
        "desc": ""
      },
      {
        "name": "eql",
        "desc": ""
      },
      {
        "name": "mul",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "and",
        "desc": ""
      },
      {
        "name": "andNot",
        "desc": ""
      },
      {
        "name": "bit",
        "desc": "bit returns the value of the i'th bit, with lsb == bit 0."
      },
      {
        "name": "bitLen",
        "desc": "bitLen returns the length of x in bits. Unlike most methods, it works even if x is not normalized."
      },
      {
        "name": "bytes",
        "desc": "bytes writes the value of z into buf using big-endian encoding. The value of z is encoded in the slice buf[i:]. If the value of z cannot be represented in buf, bytes panics. The number i of unused bytes at the beginning of buf is returned as result."
      },
      {
        "name": "cmp",
        "desc": ""
      },
      {
        "name": "convertWords",
        "desc": "Convert words of q to base b digits in s. If q is large, it is recursively \"split in half\" by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using repeated nat/Word division.  The iterative method processes n Words by n divW() calls, each of which visits every Word in the incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. Recursive conversion divides q by its approximate square root, yielding two parts, each half the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and is made better by splitting the subblocks recursively. Best is to split blocks until one more split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for specific hardware."
      },
      {
        "name": "div",
        "desc": "div returns q, r such that q = ⌊u/v⌋ and r = u%v = u - q·v. It uses z and z2 as the storage for q and r. The caller may pass stk == nil to request that div obtain and release one itself."
      },
      {
        "name": "divBasic",
        "desc": "divBasic implements long division as described above. It overwrites q with ⌊u/v⌋ and overwrites u with the remainder r. q must be large enough to hold ⌊u/v⌋."
      },
      {
        "name": "divLarge",
        "desc": "div returns q, r such that q = ⌊uIn/vIn⌋ and r = uIn%vIn = uIn - q·vIn. It uses z and u as the storage for q and r. The caller must ensure that len(vIn) ≥ 2 (use divW otherwise) and that len(uIn) ≥ len(vIn) (the answer is 0, uIn otherwise)."
      },
      {
        "name": "divRecursive",
        "desc": "divRecursive implements recursive division as described above. It overwrites z with ⌊u/v⌋ and overwrites u with the remainder r. z must be large enough to hold ⌊u/v⌋. This function is just for allocating and freeing temporaries around divRecursiveStep, the real implementation."
      },
      {
        "name": "divRecursiveStep",
        "desc": "divRecursiveStep is the actual implementation of recursive division. It adds ⌊u/v⌋ to z and overwrites u with the remainder r. z must be large enough to hold ⌊u/v⌋. It uses temps[depth] (allocating if needed) as a temporary live across the recursive call. It also uses tmp, but not live across the recursion."
      },
      {
        "name": "divW",
        "desc": "divW returns q, r such that q = ⌊x/y⌋ and r = x%y = x - q·y. It uses z as the storage for q. Note that y is a single digit (Word), not a big number."
      },
      {
        "name": "expNN",
        "desc": "If m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m; otherwise it sets z to x**y. The result is the value of z. The caller may pass stk == nil to request that expNN obtain and release one itself."
      },
      {
        "name": "expNNMontgomery",
        "desc": "expNNMontgomery calculates x**y mod m using a fixed, 4-bit window. Uses Montgomery representation."
      },
      {
        "name": "expNNMontgomeryEven",
        "desc": "expNNMontgomeryEven calculates x**y mod m where m = m1 × m2 for m1 = 2ⁿ and m2 odd. It uses two recursive calls to expNN for x**y mod m1 and x**y mod m2 and then uses the Chinese Remainder Theorem to combine the results. The recursive call using m1 will use expNNWindowed, while the recursive call using m2 will use expNNMontgomery. For more details, see Ç. K. Koç, “Montgomery Reduction with Even Modulus”, IEE Proceedings: Computers and Digital Techniques, 141(5) 314-316, September 1994. http://www.people.vcu.edu/~jwang3/CMSC691/j34monex.pdf"
      },
      {
        "name": "expNNWindowed",
        "desc": "expNNWindowed calculates x**y mod m using a fixed, 4-bit window, where m = 2**logM."
      },
      {
        "name": "expWW",
        "desc": "expWW computes x**y"
      },
      {
        "name": "isPow2",
        "desc": "isPow2 returns i, true when x == 2**i and 0, false otherwise."
      },
      {
        "name": "itoa",
        "desc": "itoa is like utoa but it prepends a '-' if neg \u0026\u0026 x != 0."
      },
      {
        "name": "lsh",
        "desc": "z = x \u003c\u003c s"
      },
      {
        "name": "make",
        "desc": ""
      },
      {
        "name": "modInverse",
        "desc": ""
      },
      {
        "name": "modW",
        "desc": "modW returns x % d."
      },
      {
        "name": "montgomery",
        "desc": "montgomery computes z mod m = x*y*2**(-n*_W) mod m, assuming k = -1/m mod 2**_W. z is used for storing the result which is returned; z must not alias x, y or m. See Gueron, \"Efficient Software Implementations of Modular Exponentiation\". https://eprint.iacr.org/2011/239.pdf In the terminology of that paper, this is an \"Almost Montgomery Multiplication\": x and y are required to satisfy 0 \u003c= z \u003c 2**(n*_W) and then the result z is guaranteed to satisfy 0 \u003c= z \u003c 2**(n*_W), but it may not be \u003c m."
      },
      {
        "name": "mul",
        "desc": "mul sets z = x*y, using stk for temporary storage. The caller may pass stk == nil to request that mul obtain and release one itself."
      },
      {
        "name": "mulAddWW",
        "desc": "mulAddWW returns z = x*y + r."
      },
      {
        "name": "mulRange",
        "desc": "mulRange computes the product of all the unsigned integers in the range [a, b] inclusively. If a \u003e b (empty range), the result is 1. The caller may pass stk == nil to request that mulRange obtain and release one itself."
      },
      {
        "name": "norm",
        "desc": ""
      },
      {
        "name": "or",
        "desc": ""
      },
      {
        "name": "probablyPrimeLucas",
        "desc": "probablyPrimeLucas reports whether n passes the \"almost extra strong\" Lucas probable prime test, using Baillie-OEIS parameter selection. This corresponds to \"AESLPSP\" on Jacobsen's tables (link below). The combination of this test and a Miller-Rabin/Fermat test with base 2 gives a Baillie-PSW test.  References:  Baillie and Wagstaff, \"Lucas Pseudoprimes\", Mathematics of Computation 35(152), October 1980, pp. 1391-1417, especially page 1401. https://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf  Grantham, \"Frobenius Pseudoprimes\", Mathematics of Computation 70(234), March 2000, pp. 873-891. https://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf  Baillie, \"Extra strong Lucas pseudoprimes\", OEIS A217719, https://oeis.org/A217719.  Jacobsen, \"Pseudoprime Statistics, Tables, and Data\", http://ntheory.org/pseudoprimes.html.  Nicely, \"The Baillie-PSW Primality Test\", https://web.archive.org/web/20191121062007/http://www.trnicely.net/misc/bpsw.html. (Note that Nicely's definition of the \"extra strong\" test gives the wrong Jacobi condition, as pointed out by Jacobsen.)  Crandall and Pomerance, Prime Numbers: A Computational Perspective, 2nd ed. Springer, 2005."
      },
      {
        "name": "probablyPrimeMillerRabin",
        "desc": "probablyPrimeMillerRabin reports whether n passes reps rounds of the Miller-Rabin primality test, using pseudo-randomly chosen bases. If force2 is true, one of the rounds is forced to use base 2. See Handbook of Applied Cryptography, p. 139, Algorithm 4.24. The number n is known to be non-zero."
      },
      {
        "name": "random",
        "desc": "random creates a random integer in [0..limit), using the space in z if possible. n is the bit length of limit."
      },
      {
        "name": "rem",
        "desc": "rem returns r such that r = u%v. It uses z as the storage for r."
      },
      {
        "name": "rsh",
        "desc": "z = x \u003e\u003e s"
      },
      {
        "name": "scan",
        "desc": "scan scans the number corresponding to the longest possible prefix from r representing an unsigned number in a given conversion base. scan returns the corresponding natural number res, the actual base b, a digit count, and a read or syntax error err, if any.  For base 0, an underscore character “_” may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit.  \tnumber    = mantissa | prefix pmantissa . \tprefix    = \"0\" [ \"b\" | \"B\" | \"o\" | \"O\" | \"x\" | \"X\" ] . \tmantissa  = digits \".\" [ digits ] | digits | \".\" digits . \tpmantissa = [ \"_\" ] digits \".\" [ digits ] | [ \"_\" ] digits | \".\" digits . \tdigits    = digit { [ \"_\" ] digit } . \tdigit     = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" .  Unless fracOk is set, the base argument must be 0 or a value between 2 and MaxBase. If fracOk is set, the base argument must be one of 0, 2, 8, 10, or 16. Providing an invalid base argument leads to a run- time panic.  For base 0, the number prefix determines the actual base: A prefix of “0b” or “0B” selects base 2, “0o” or “0O” selects base 8, and “0x” or “0X” selects base 16. If fracOk is false, a “0” prefix (immediately followed by digits) selects base 8 as well. Otherwise, the selected base is 10 and no prefix is accepted.  If fracOk is set, a period followed by a fractional part is permitted. The result value is computed as if there were no period present; and the count value is used to determine the fractional part.  For bases \u003c= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases \u003e 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.  A result digit count \u003e 0 corresponds to the number of (non-prefix) digits parsed. A digit count \u003c= 0 indicates the presence of a period (if fracOk is set, only), and -count is the number of fractional digits found. In this case, the actual value of the scanned number is res * b**count."
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "setBit",
        "desc": ""
      },
      {
        "name": "setBytes",
        "desc": "setBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z."
      },
      {
        "name": "setUint64",
        "desc": ""
      },
      {
        "name": "setWord",
        "desc": ""
      },
      {
        "name": "sqr",
        "desc": "sqr sets z = x*x, using stk for temporary storage. The caller may pass stk == nil to request that sqr obtain and release one itself."
      },
      {
        "name": "sqrt",
        "desc": "sqrt sets z = ⌊√x⌋ The caller may pass stk == nil to request that sqrt obtain and release one itself."
      },
      {
        "name": "sticky",
        "desc": "sticky returns 1 if there's a 1 bit within the i least significant bits, otherwise it returns 0."
      },
      {
        "name": "sub",
        "desc": ""
      },
      {
        "name": "subMod2N",
        "desc": "subMod2N returns z = (x - y) mod 2ⁿ."
      },
      {
        "name": "trailingZeroBits",
        "desc": "trailingZeroBits returns the number of consecutive least significant zero bits of x."
      },
      {
        "name": "trunc",
        "desc": "trunc returns z = x mod 2ⁿ."
      },
      {
        "name": "utoa",
        "desc": "utoa converts x to an ASCII representation in the given base; base must be between 2 and MaxBase, inclusive."
      },
      {
        "name": "xor",
        "desc": ""
      },
      {
        "name": "free",
        "desc": "free returns the stack for use by another calculation."
      },
      {
        "name": "nat",
        "desc": "nat returns a nat of n words, allocated on the stack."
      },
      {
        "name": "restore",
        "desc": "restore restores the stack pointer to n. It is almost always invoked as  \tdefer stk.restore(stk.save())  which makes sure to pop any temporaries allocated in the current function from the stack before returning."
      },
      {
        "name": "save",
        "desc": "save returns the current stack pointer. A future call to restore with the same value frees any temporaries allocated on the stack after the call to save."
      }
    ],
    "types": [
      {
        "name": "Accuracy",
        "desc": "Accuracy describes the rounding error produced by the most recent operation that generated a [Float] value, relative to the exact value."
      },
      {
        "name": "Bits",
        "desc": "A Bits value b represents a finite floating-point number x of the form  \tx = 2**b[0] + 2**b[1] + ... 2**b[len(b)-1]  The order of slice elements is not significant. Negative elements may be used to form fractions. A Bits value is normalized if each b[i] occurs at most once. For instance Bits{0, 0, 1} is not normalized but represents the same floating-point number as Bits{2}, which is normalized. The zero (nil) value of Bits is a ready to use Bits value and represents the value 0."
      },
      {
        "name": "ErrNaN",
        "desc": "An ErrNaN panic is raised by a [Float] operation that would lead to a NaN under IEEE 754 rules. An ErrNaN implements the error interface."
      },
      {
        "name": "Float",
        "desc": "A nonzero finite Float represents a multi-precision floating point number  \tsign × mantissa × 2**exponent  with 0.5 \u003c= mantissa \u003c 1.0, and MinExp \u003c= exponent \u003c= MaxExp. A Float may also be zero (+0, -0) or infinite (+Inf, -Inf). All Floats are ordered, and the ordering of two Floats x and y is defined by x.Cmp(y).  Each Float value also has a precision, rounding mode, and accuracy. The precision is the maximum number of mantissa bits available to represent the value. The rounding mode specifies how a result should be rounded to fit into the mantissa bits, and accuracy describes the rounding error with respect to the exact result.  Unless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of [Float.MantExp]), round the numeric result according to the precision and rounding mode of the result variable.  If the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven).  By setting the desired precision to 24 or 53 and using matching rounding mode (typically [ToNearestEven]), Float operations produce the same results as the corresponding float32 or float64 IEEE 754 arithmetic for operands that correspond to normal (i.e., not denormal) float32 or float64 numbers. Exponent underflow and overflow lead to a 0 or an Infinity for different values than IEEE 754 because Float exponents have a much larger range.  The zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode [ToNearestEven].  Operations always take pointer arguments (*Float) rather than Float values, and each unique Float value requires its own unique *Float pointer. To \"copy\" a Float value, an existing (or newly allocated) Float must be set to a new value using the [Float.Set] method; shallow copies of Floats are not supported and may lead to errors."
      },
      {
        "name": "Int",
        "desc": "An Int represents a signed multi-precision integer. The zero value for an Int represents the value 0.  Operations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To \"copy\" an Int value, an existing (or newly allocated) Int must be set to a new value using the [Int.Set] method; shallow copies of Ints are not supported and may lead to errors.  Note that methods may leak the Int's value through timing side-channels. Because of this and because of the scope and complexity of the implementation, Int is not well-suited to implement cryptographic operations. The standard library avoids exposing non-trivial Int methods to attacker-controlled inputs and the determination of whether a bug in math/big is considered a security vulnerability might depend on the impact on the standard library."
      },
      {
        "name": "Rat",
        "desc": "A Rat represents a quotient a/b of arbitrary precision. The zero value for a Rat represents the value 0.  Operations always take pointer arguments (*Rat) rather than Rat values, and each unique Rat value requires its own unique *Rat pointer. To \"copy\" a Rat value, an existing (or newly allocated) Rat must be set to a new value using the [Rat.Set] method; shallow copies of Rats are not supported and may lead to errors."
      },
      {
        "name": "RoundingMode",
        "desc": "RoundingMode determines how a [Float] value is rounded to the desired precision. Rounding may change the [Float] value; the rounding error is described by the [Float]'s [Accuracy]."
      },
      {
        "name": "StringTest",
        "desc": ""
      },
      {
        "name": "Word",
        "desc": "A Word represents a single digit of a multi-precision unsigned integer."
      },
      {
        "name": "argNN",
        "desc": ""
      },
      {
        "name": "argVU",
        "desc": ""
      },
      {
        "name": "argVWW",
        "desc": ""
      },
      {
        "name": "argWVW",
        "desc": ""
      },
      {
        "name": "argZZ",
        "desc": ""
      },
      {
        "name": "benchFunc",
        "desc": "A benchFunc is a function to be benchmarked. It takes one output buffer and two input buffers, but it does not have to use any of them."
      },
      {
        "name": "bitFun",
        "desc": ""
      },
      {
        "name": "byteReader",
        "desc": "byteReader is a local wrapper around fmt.ScanState; it implements the ByteReader interface."
      },
      {
        "name": "decimal",
        "desc": "A decimal represents an unsigned floating-point number in decimal representation. The value of a non-zero decimal d is d.mant * 10**d.exp with 0.1 \u003c= d.mant \u003c 1, with the most-significant mantissa digit at index 0. For the zero decimal, the mantissa length and exponent are 0. The zero value for decimal represents a ready-to-use 0.0."
      },
      {
        "name": "divisor",
        "desc": ""
      },
      {
        "name": "form",
        "desc": "A form value describes the internal representation."
      },
      {
        "name": "funNN",
        "desc": ""
      },
      {
        "name": "funSNN",
        "desc": ""
      },
      {
        "name": "funVWW",
        "desc": ""
      },
      {
        "name": "funWVW",
        "desc": ""
      },
      {
        "name": "funZZ",
        "desc": ""
      },
      {
        "name": "intShiftTest",
        "desc": ""
      },
      {
        "name": "matrix",
        "desc": ""
      },
      {
        "name": "modWTest",
        "desc": ""
      },
      {
        "name": "nat",
        "desc": "An unsigned integer x of the form  \tx = x[n-1]*_B^(n-1) + x[n-2]*_B^(n-2) + ... + x[1]*_B + x[0]  with 0 \u003c= x[i] \u003c _B and 0 \u003c= i \u003c n is stored in a slice of length n, with the digits x[i] as the slice elements.  A number is normalized if the slice contains no leading 0 digits. During arithmetic operations, denormalized values may occur but are always normalized before returning the final result. The normalized representation of 0 is the empty or nil slice (length = 0)."
      },
      {
        "name": "ratBinArg",
        "desc": ""
      },
      {
        "name": "ratBinFun",
        "desc": ""
      },
      {
        "name": "scanTest",
        "desc": ""
      },
      {
        "name": "shiftTest",
        "desc": ""
      },
      {
        "name": "stack",
        "desc": "A stack provides temporary storage for complex calculations such as multiplication and division. The stack is a simple slice of words, extended as needed to hold all the temporary storage for a calculation. In general, if a function takes a *stack, it expects a non-nil *stack. However, certain functions may allow passing a nil *stack instead, so that they can handle trivial stack-free cases without forcing the caller to obtain and free a stack that will be unused. These functions document that they accept a nil *stack in their doc comments."
      }
    ]
  },
  {
    "name": "math/bits",
    "desc": "Package bits implements bit counting and manipulation functions for the predeclared unsigned integer types.  Functions in this package may be implemented directly by the compiler, for better performance. For those functions the code in this package will not be used. Which functions are implemented by the compiler depends on the architecture and the Go release.",
    "functions": [
      {
        "name": "Add",
        "desc": "Add returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Add32",
        "desc": "Add32 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Add64",
        "desc": "Add64 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Div",
        "desc": "Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div panics for y == 0 (division by zero) or y \u003c= hi (quotient overflow)."
      },
      {
        "name": "Div32",
        "desc": "Div32 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div32 panics for y == 0 (division by zero) or y \u003c= hi (quotient overflow)."
      },
      {
        "name": "Div64",
        "desc": "Div64 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div64 panics for y == 0 (division by zero) or y \u003c= hi (quotient overflow)."
      },
      {
        "name": "LeadingZeros",
        "desc": "LeadingZeros returns the number of leading zero bits in x; the result is [UintSize] for x == 0."
      },
      {
        "name": "LeadingZeros16",
        "desc": "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0."
      },
      {
        "name": "LeadingZeros32",
        "desc": "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0."
      },
      {
        "name": "LeadingZeros64",
        "desc": "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0."
      },
      {
        "name": "LeadingZeros8",
        "desc": "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0."
      },
      {
        "name": "Len",
        "desc": "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0."
      },
      {
        "name": "Len16",
        "desc": "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
      },
      {
        "name": "Len32",
        "desc": "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
      },
      {
        "name": "Len64",
        "desc": "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
      },
      {
        "name": "Len8",
        "desc": "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0."
      },
      {
        "name": "Mul",
        "desc": "Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Mul32",
        "desc": "Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Mul64",
        "desc": "Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "OnesCount",
        "desc": "OnesCount returns the number of one bits (\"population count\") in x."
      },
      {
        "name": "OnesCount16",
        "desc": "OnesCount16 returns the number of one bits (\"population count\") in x."
      },
      {
        "name": "OnesCount32",
        "desc": "OnesCount32 returns the number of one bits (\"population count\") in x."
      },
      {
        "name": "OnesCount64",
        "desc": "OnesCount64 returns the number of one bits (\"population count\") in x."
      },
      {
        "name": "OnesCount8",
        "desc": "OnesCount8 returns the number of one bits (\"population count\") in x."
      },
      {
        "name": "Rem",
        "desc": "Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0 (division by zero) but, unlike Div, it doesn't panic on a quotient overflow."
      },
      {
        "name": "Rem32",
        "desc": "Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y == 0 (division by zero) but, unlike [Div32], it doesn't panic on a quotient overflow."
      },
      {
        "name": "Rem64",
        "desc": "Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics for y == 0 (division by zero) but, unlike [Div64], it doesn't panic on a quotient overflow."
      },
      {
        "name": "Reverse",
        "desc": "Reverse returns the value of x with its bits in reversed order."
      },
      {
        "name": "Reverse16",
        "desc": "Reverse16 returns the value of x with its bits in reversed order."
      },
      {
        "name": "Reverse32",
        "desc": "Reverse32 returns the value of x with its bits in reversed order."
      },
      {
        "name": "Reverse64",
        "desc": "Reverse64 returns the value of x with its bits in reversed order."
      },
      {
        "name": "Reverse8",
        "desc": "Reverse8 returns the value of x with its bits in reversed order."
      },
      {
        "name": "ReverseBytes",
        "desc": "ReverseBytes returns the value of x with its bytes in reversed order.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "ReverseBytes16",
        "desc": "ReverseBytes16 returns the value of x with its bytes in reversed order.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "ReverseBytes32",
        "desc": "ReverseBytes32 returns the value of x with its bytes in reversed order.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "ReverseBytes64",
        "desc": "ReverseBytes64 returns the value of x with its bytes in reversed order.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "RotateLeft",
        "desc": "RotateLeft returns the value of x rotated left by (k mod [UintSize]) bits. To rotate x right by k bits, call RotateLeft(x, -k).  This function's execution time does not depend on the inputs."
      },
      {
        "name": "RotateLeft16",
        "desc": "RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).  This function's execution time does not depend on the inputs."
      },
      {
        "name": "RotateLeft32",
        "desc": "RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).  This function's execution time does not depend on the inputs."
      },
      {
        "name": "RotateLeft64",
        "desc": "RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).  This function's execution time does not depend on the inputs."
      },
      {
        "name": "RotateLeft8",
        "desc": "RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Sub",
        "desc": "Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Sub32",
        "desc": "Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "Sub64",
        "desc": "Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1; otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.  This function's execution time does not depend on the inputs."
      },
      {
        "name": "TrailingZeros",
        "desc": "TrailingZeros returns the number of trailing zero bits in x; the result is [UintSize] for x == 0."
      },
      {
        "name": "TrailingZeros16",
        "desc": "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0."
      },
      {
        "name": "TrailingZeros32",
        "desc": "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0."
      },
      {
        "name": "TrailingZeros64",
        "desc": "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0."
      },
      {
        "name": "TrailingZeros8",
        "desc": "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "errorString",
        "desc": ""
      }
    ]
  },
  {
    "name": "math/cmplx",
    "desc": "Package cmplx provides basic constants and mathematical functions for complex numbers. Special case handling conforms to the C99 standard Annex G IEC 60559-compatible complex arithmetic.",
    "functions": [
      {
        "name": "Abs",
        "desc": "Abs returns the absolute value (also called the modulus) of x."
      },
      {
        "name": "Acos",
        "desc": "Acos returns the inverse cosine of x."
      },
      {
        "name": "Acosh",
        "desc": "Acosh returns the inverse hyperbolic cosine of x."
      },
      {
        "name": "Asin",
        "desc": "Asin returns the inverse sine of x."
      },
      {
        "name": "Asinh",
        "desc": "Asinh returns the inverse hyperbolic sine of x."
      },
      {
        "name": "Atan",
        "desc": "Atan returns the inverse tangent of x."
      },
      {
        "name": "Atanh",
        "desc": "Atanh returns the inverse hyperbolic tangent of x."
      },
      {
        "name": "BenchmarkAbs",
        "desc": ""
      },
      {
        "name": "BenchmarkAcos",
        "desc": ""
      },
      {
        "name": "BenchmarkAcosh",
        "desc": ""
      },
      {
        "name": "BenchmarkAsin",
        "desc": ""
      },
      {
        "name": "BenchmarkAsinh",
        "desc": ""
      },
      {
        "name": "BenchmarkAtan",
        "desc": ""
      },
      {
        "name": "BenchmarkAtanh",
        "desc": ""
      },
      {
        "name": "BenchmarkConj",
        "desc": ""
      },
      {
        "name": "BenchmarkCos",
        "desc": ""
      },
      {
        "name": "BenchmarkCosh",
        "desc": ""
      },
      {
        "name": "BenchmarkExp",
        "desc": ""
      },
      {
        "name": "BenchmarkLog",
        "desc": ""
      },
      {
        "name": "BenchmarkLog10",
        "desc": ""
      },
      {
        "name": "BenchmarkPhase",
        "desc": ""
      },
      {
        "name": "BenchmarkPolar",
        "desc": ""
      },
      {
        "name": "BenchmarkPow",
        "desc": ""
      },
      {
        "name": "BenchmarkRect",
        "desc": ""
      },
      {
        "name": "BenchmarkSin",
        "desc": ""
      },
      {
        "name": "BenchmarkSinh",
        "desc": ""
      },
      {
        "name": "BenchmarkSqrt",
        "desc": ""
      },
      {
        "name": "BenchmarkTan",
        "desc": ""
      },
      {
        "name": "BenchmarkTanh",
        "desc": ""
      },
      {
        "name": "Conj",
        "desc": "Conj returns the complex conjugate of x."
      },
      {
        "name": "Cos",
        "desc": "Cos returns the cosine of x."
      },
      {
        "name": "Cosh",
        "desc": "Cosh returns the hyperbolic cosine of x."
      },
      {
        "name": "Cot",
        "desc": "Cot returns the cotangent of x."
      },
      {
        "name": "Exp",
        "desc": "Exp returns e**x, the base-e exponential of x."
      },
      {
        "name": "Inf",
        "desc": "Inf returns a complex infinity, complex(+Inf, +Inf)."
      },
      {
        "name": "IsInf",
        "desc": "IsInf reports whether either real(x) or imag(x) is an infinity."
      },
      {
        "name": "IsNaN",
        "desc": "IsNaN reports whether either real(x) or imag(x) is NaN and neither is an infinity."
      },
      {
        "name": "Log",
        "desc": "Log returns the natural logarithm of x."
      },
      {
        "name": "Log10",
        "desc": "Log10 returns the decimal logarithm of x."
      },
      {
        "name": "NaN",
        "desc": "NaN returns a complex “not-a-number” value."
      },
      {
        "name": "Phase",
        "desc": "Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi]."
      },
      {
        "name": "Polar",
        "desc": "Polar returns the absolute value r and phase θ of x, such that x = r * e**θi. The phase is in the range [-Pi, Pi]."
      },
      {
        "name": "Pow",
        "desc": "Pow returns x**y, the base-x exponential of y. For generalized compatibility with [math.Pow]:  \tPow(0, ±0) returns 1+0i \tPow(0, c) for real(c)\u003c0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i."
      },
      {
        "name": "Rect",
        "desc": "Rect returns the complex number x with polar coordinates r, θ."
      },
      {
        "name": "Sin",
        "desc": "Sin returns the sine of x."
      },
      {
        "name": "Sinh",
        "desc": "Sinh returns the hyperbolic sine of x."
      },
      {
        "name": "Sqrt",
        "desc": "Sqrt returns the square root of x. The result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x)."
      },
      {
        "name": "Tan",
        "desc": "Tan returns the tangent of x."
      },
      {
        "name": "Tanh",
        "desc": "Tanh returns the hyperbolic tangent of x."
      },
      {
        "name": "TestAbs",
        "desc": ""
      },
      {
        "name": "TestAcos",
        "desc": ""
      },
      {
        "name": "TestAcosh",
        "desc": ""
      },
      {
        "name": "TestAsin",
        "desc": ""
      },
      {
        "name": "TestAsinh",
        "desc": ""
      },
      {
        "name": "TestAtan",
        "desc": ""
      },
      {
        "name": "TestAtanh",
        "desc": ""
      },
      {
        "name": "TestConj",
        "desc": ""
      },
      {
        "name": "TestCos",
        "desc": ""
      },
      {
        "name": "TestCosh",
        "desc": ""
      },
      {
        "name": "TestExp",
        "desc": ""
      },
      {
        "name": "TestInfiniteLoopIntanSeries",
        "desc": "See issue 17577"
      },
      {
        "name": "TestIsNaN",
        "desc": ""
      },
      {
        "name": "TestLog",
        "desc": ""
      },
      {
        "name": "TestLog10",
        "desc": ""
      },
      {
        "name": "TestPolar",
        "desc": ""
      },
      {
        "name": "TestPow",
        "desc": ""
      },
      {
        "name": "TestRect",
        "desc": ""
      },
      {
        "name": "TestSin",
        "desc": ""
      },
      {
        "name": "TestSinh",
        "desc": ""
      },
      {
        "name": "TestSqrt",
        "desc": ""
      },
      {
        "name": "TestTan",
        "desc": ""
      },
      {
        "name": "TestTanHuge",
        "desc": ""
      },
      {
        "name": "TestTanh",
        "desc": ""
      },
      {
        "name": "alike",
        "desc": ""
      },
      {
        "name": "cAlike",
        "desc": ""
      },
      {
        "name": "cSoclose",
        "desc": ""
      },
      {
        "name": "cTolerance",
        "desc": ""
      },
      {
        "name": "cVeryclose",
        "desc": ""
      },
      {
        "name": "isExact",
        "desc": ""
      },
      {
        "name": "reducePi",
        "desc": "reducePi reduces the input argument x to the range (-Pi/2, Pi/2]. x must be greater than or equal to 0. For small arguments it uses Cody-Waite reduction in 3 float64 parts based on: \"Elementary Function Evaluation:  Algorithms and Implementation\" Jean-Michel Muller, 1997. For very large arguments it uses Payne-Hanek range reduction based on: \"ARGUMENT REDUCTION FOR HUGE ARGUMENTS: Good to the Last Bit\" K. C. Ng et al, March 24, 1992."
      },
      {
        "name": "sinhcosh",
        "desc": "calculate sinh and cosh."
      },
      {
        "name": "tanSeries",
        "desc": "Taylor series expansion for cosh(2y) - cos(2x)"
      },
      {
        "name": "tolerance",
        "desc": "functions borrowed from pkg/math/all_test.go"
      },
      {
        "name": "veryclose",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ff",
        "desc": ""
      }
    ]
  },
  {
    "name": "math/rand",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkConcurrent",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat32",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat64",
        "desc": ""
      },
      {
        "name": "BenchmarkInt31n1000",
        "desc": ""
      },
      {
        "name": "BenchmarkInt63Threadsafe",
        "desc": ""
      },
      {
        "name": "BenchmarkInt63ThreadsafeParallel",
        "desc": ""
      },
      {
        "name": "BenchmarkInt63Unthreadsafe",
        "desc": ""
      },
      {
        "name": "BenchmarkInt63n1000",
        "desc": ""
      },
      {
        "name": "BenchmarkIntn1000",
        "desc": ""
      },
      {
        "name": "BenchmarkPerm3",
        "desc": ""
      },
      {
        "name": "BenchmarkPerm30",
        "desc": ""
      },
      {
        "name": "BenchmarkPerm30ViaShuffle",
        "desc": ""
      },
      {
        "name": "BenchmarkRead1000",
        "desc": ""
      },
      {
        "name": "BenchmarkRead3",
        "desc": ""
      },
      {
        "name": "BenchmarkRead64",
        "desc": ""
      },
      {
        "name": "BenchmarkShuffleOverhead",
        "desc": "BenchmarkShuffleOverhead uses a minimal swap function to measure just the shuffling overhead."
      },
      {
        "name": "Example",
        "desc": ""
      },
      {
        "name": "ExampleIntn",
        "desc": ""
      },
      {
        "name": "ExamplePerm",
        "desc": ""
      },
      {
        "name": "ExampleShuffle",
        "desc": ""
      },
      {
        "name": "ExampleShuffle_slicesInUnison",
        "desc": ""
      },
      {
        "name": "Example_rand",
        "desc": "This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver."
      },
      {
        "name": "TestAuto",
        "desc": ""
      },
      {
        "name": "TestConcurrent",
        "desc": "TestConcurrent exercises the rand API concurrently, triggering situations where the race detector is likely to detect issues."
      },
      {
        "name": "TestDefaultRace",
        "desc": "Test that racy access to the default functions behaves reasonably."
      },
      {
        "name": "TestExpTables",
        "desc": ""
      },
      {
        "name": "TestFloat32",
        "desc": ""
      },
      {
        "name": "TestNonStandardExponentialValues",
        "desc": ""
      },
      {
        "name": "TestNonStandardNormalValues",
        "desc": ""
      },
      {
        "name": "TestNormTables",
        "desc": ""
      },
      {
        "name": "TestReadByOneByte",
        "desc": ""
      },
      {
        "name": "TestReadEmpty",
        "desc": ""
      },
      {
        "name": "TestReadSeedReset",
        "desc": ""
      },
      {
        "name": "TestReadUniformity",
        "desc": ""
      },
      {
        "name": "TestRegress",
        "desc": ""
      },
      {
        "name": "TestSeedNop",
        "desc": ""
      },
      {
        "name": "TestShuffleSmall",
        "desc": ""
      },
      {
        "name": "TestStandardExponentialValues",
        "desc": ""
      },
      {
        "name": "TestStandardNormalValues",
        "desc": ""
      },
      {
        "name": "TestUniformFactorial",
        "desc": "TestUniformFactorial tests several ways of generating a uniform value in [0, n!)."
      },
      {
        "name": "checkSampleDistribution",
        "desc": ""
      },
      {
        "name": "checkSampleSliceDistributions",
        "desc": ""
      },
      {
        "name": "compareFloat32Slices",
        "desc": "compareFloat32Slices returns the first index where the two slices disagree, or \u003c0 if the lengths are the same and all elements are identical."
      },
      {
        "name": "compareUint32Slices",
        "desc": "compareUint32Slices returns the first index where the two slices disagree, or \u003c0 if the lengths are the same and all elements are identical."
      },
      {
        "name": "doDefaultTest",
        "desc": "doDefaultTest should be run before there have been any calls to the top-level math/rand functions. Make sure that we can make concurrent calls to top-level functions and to Seed without any duplicate values. This will also give the race detector a change to report any problems."
      },
      {
        "name": "encodePerm",
        "desc": "encodePerm converts from a permuted slice of length n, such as Perm generates, to an int in [0, n!). See https://en.wikipedia.org/wiki/Lehmer_code. encodePerm modifies the input slice."
      },
      {
        "name": "generateExponentialSamples",
        "desc": ""
      },
      {
        "name": "generateNormalSamples",
        "desc": ""
      },
      {
        "name": "hasSlowFloatingPoint",
        "desc": ""
      },
      {
        "name": "initExp",
        "desc": ""
      },
      {
        "name": "initNorm",
        "desc": ""
      },
      {
        "name": "nearEqual",
        "desc": ""
      },
      {
        "name": "testExponentialDistribution",
        "desc": ""
      },
      {
        "name": "testNormalDistribution",
        "desc": ""
      },
      {
        "name": "testReadUniformity",
        "desc": ""
      },
      {
        "name": "checkSimilarDistribution",
        "desc": "checkSimilarDistribution returns success if the mean and stddev of the two statsResults are similar."
      }
    ],
    "types": [
      {
        "name": "statsResults",
        "desc": ""
      }
    ]
  },
  {
    "name": "math/rand/v2",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkChaCha8",
        "desc": ""
      },
      {
        "name": "BenchmarkChaCha8MarshalBinary",
        "desc": ""
      },
      {
        "name": "BenchmarkChaCha8MarshalBinaryRead",
        "desc": ""
      },
      {
        "name": "BenchmarkChaCha8Read",
        "desc": ""
      },
      {
        "name": "BenchmarkConcurrent",
        "desc": ""
      },
      {
        "name": "BenchmarkExpFloat64",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat32",
        "desc": ""
      },
      {
        "name": "BenchmarkFloat64",
        "desc": ""
      },
      {
        "name": "BenchmarkGlobalInt64",
        "desc": ""
      },
      {
        "name": "BenchmarkGlobalInt64Parallel",
        "desc": ""
      },
      {
        "name": "BenchmarkGlobalIntN1000",
        "desc": ""
      },
      {
        "name": "BenchmarkGlobalUint64",
        "desc": ""
      },
      {
        "name": "BenchmarkGlobalUint64Parallel",
        "desc": ""
      },
      {
        "name": "BenchmarkInt32N1000",
        "desc": ""
      },
      {
        "name": "BenchmarkInt32N1e8",
        "desc": ""
      },
      {
        "name": "BenchmarkInt32N1e9",
        "desc": ""
      },
      {
        "name": "BenchmarkInt32N2e9",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N1000",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N1e18",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N1e8",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N1e9",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N2e18",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N2e9",
        "desc": ""
      },
      {
        "name": "BenchmarkInt64N4e18",
        "desc": ""
      },
      {
        "name": "BenchmarkIntN1000",
        "desc": ""
      },
      {
        "name": "BenchmarkNormFloat64",
        "desc": ""
      },
      {
        "name": "BenchmarkPCG_DXSM",
        "desc": ""
      },
      {
        "name": "BenchmarkPerm3",
        "desc": ""
      },
      {
        "name": "BenchmarkPerm30",
        "desc": ""
      },
      {
        "name": "BenchmarkPerm30ViaShuffle",
        "desc": ""
      },
      {
        "name": "BenchmarkShuffleOverhead",
        "desc": "BenchmarkShuffleOverhead uses a minimal swap function to measure just the shuffling overhead."
      },
      {
        "name": "BenchmarkSourceUint64",
        "desc": ""
      },
      {
        "name": "BenchmarkUint64",
        "desc": ""
      },
      {
        "name": "Example",
        "desc": ""
      },
      {
        "name": "ExampleIntN",
        "desc": ""
      },
      {
        "name": "ExampleN",
        "desc": ""
      },
      {
        "name": "ExamplePerm",
        "desc": ""
      },
      {
        "name": "ExampleShuffle",
        "desc": ""
      },
      {
        "name": "ExampleShuffle_slicesInUnison",
        "desc": ""
      },
      {
        "name": "Example_rand",
        "desc": "This example shows the use of each of the methods on a *Rand. The use of the global functions is the same, without the receiver."
      },
      {
        "name": "TestAuto",
        "desc": ""
      },
      {
        "name": "TestChaCha8",
        "desc": ""
      },
      {
        "name": "TestChaCha8Marshal",
        "desc": ""
      },
      {
        "name": "TestChaCha8MarshalRead",
        "desc": ""
      },
      {
        "name": "TestChaCha8Read",
        "desc": ""
      },
      {
        "name": "TestConcurrent",
        "desc": "TestConcurrent exercises the rand API concurrently, triggering situations where the race detector is likely to detect issues."
      },
      {
        "name": "TestExpTables",
        "desc": ""
      },
      {
        "name": "TestFloat32",
        "desc": ""
      },
      {
        "name": "TestN",
        "desc": ""
      },
      {
        "name": "TestNonStandardExponentialValues",
        "desc": ""
      },
      {
        "name": "TestNonStandardNormalValues",
        "desc": ""
      },
      {
        "name": "TestNormTables",
        "desc": ""
      },
      {
        "name": "TestPCG",
        "desc": ""
      },
      {
        "name": "TestPCGMarshal",
        "desc": ""
      },
      {
        "name": "TestRegress",
        "desc": ""
      },
      {
        "name": "TestShuffleSmall",
        "desc": ""
      },
      {
        "name": "TestStandardExponentialValues",
        "desc": ""
      },
      {
        "name": "TestStandardNormalValues",
        "desc": ""
      },
      {
        "name": "TestUniformFactorial",
        "desc": "TestUniformFactorial tests several ways of generating a uniform value in [0, n!)."
      },
      {
        "name": "TestUpdateExample",
        "desc": ""
      },
      {
        "name": "checkSampleDistribution",
        "desc": ""
      },
      {
        "name": "checkSampleSliceDistributions",
        "desc": ""
      },
      {
        "name": "compareFloat32Slices",
        "desc": "compareFloat32Slices returns the first index where the two slices disagree, or \u003c0 if the lengths are the same and all elements are identical."
      },
      {
        "name": "compareUint32Slices",
        "desc": "compareUint32Slices returns the first index where the two slices disagree, or \u003c0 if the lengths are the same and all elements are identical."
      },
      {
        "name": "encodePerm",
        "desc": "encodePerm converts from a permuted slice of length n, such as Perm generates, to an int in [0, n!). See https://en.wikipedia.org/wiki/Lehmer_code. encodePerm modifies the input slice."
      },
      {
        "name": "generateExponentialSamples",
        "desc": ""
      },
      {
        "name": "generateNormalSamples",
        "desc": ""
      },
      {
        "name": "hasSlowFloatingPoint",
        "desc": ""
      },
      {
        "name": "initExp",
        "desc": ""
      },
      {
        "name": "initNorm",
        "desc": ""
      },
      {
        "name": "keep",
        "desc": ""
      },
      {
        "name": "nearEqual",
        "desc": ""
      },
      {
        "name": "replace",
        "desc": "replace substitutes the definition text from new into the content of file. The text in new is of the form  \tvar whatever = T{ \t\t... \t}  Replace searches file for an exact match for the text of the first line, finds the closing brace, and then substitutes new for what used to be in the file. This lets us update the regressGolden table during go test -update."
      },
      {
        "name": "testExponentialDistribution",
        "desc": ""
      },
      {
        "name": "testNormalDistribution",
        "desc": ""
      },
      {
        "name": "testRand",
        "desc": ""
      },
      {
        "name": "checkSimilarDistribution",
        "desc": "checkSimilarDistribution returns success if the mean and stddev of the two statsResults are similar."
      }
    ],
    "types": [
      {
        "name": "statsResults",
        "desc": ""
      }
    ]
  },
  {
    "name": "mime",
    "desc": "Package mime implements parts of the MIME spec.",
    "functions": [
      {
        "name": "AddExtensionType",
        "desc": "AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in \".html\"."
      },
      {
        "name": "BenchmarkExtensionsByType",
        "desc": ""
      },
      {
        "name": "BenchmarkParseMediaType",
        "desc": ""
      },
      {
        "name": "BenchmarkParseMediaTypeBogus",
        "desc": ""
      },
      {
        "name": "BenchmarkQDecodeHeader",
        "desc": ""
      },
      {
        "name": "BenchmarkQDecodeWord",
        "desc": ""
      },
      {
        "name": "BenchmarkQEncodeWord",
        "desc": ""
      },
      {
        "name": "BenchmarkTypeByExtension",
        "desc": ""
      },
      {
        "name": "ExtensionsByType",
        "desc": "ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in \".html\". When typ has no associated extensions, ExtensionsByType returns an nil slice."
      },
      {
        "name": "FormatMediaType",
        "desc": "FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string."
      },
      {
        "name": "ParseMediaType",
        "desc": "ParseMediaType parses a media type value and any optional parameters, per RFC 1521.  Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error [ErrInvalidMediaParameter]. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved."
      },
      {
        "name": "TestCharsetDecoder",
        "desc": ""
      },
      {
        "name": "TestCharsetDecoderError",
        "desc": ""
      },
      {
        "name": "TestConsumeMediaParam",
        "desc": ""
      },
      {
        "name": "TestConsumeToken",
        "desc": ""
      },
      {
        "name": "TestConsumeValue",
        "desc": ""
      },
      {
        "name": "TestDecodeHeader",
        "desc": ""
      },
      {
        "name": "TestDecodeWord",
        "desc": ""
      },
      {
        "name": "TestEncodeWord",
        "desc": ""
      },
      {
        "name": "TestEncodedWordLength",
        "desc": ""
      },
      {
        "name": "TestExtensionsByType",
        "desc": ""
      },
      {
        "name": "TestExtensionsByType2",
        "desc": ""
      },
      {
        "name": "TestFormatMediaType",
        "desc": ""
      },
      {
        "name": "TestLookupMallocs",
        "desc": ""
      },
      {
        "name": "TestParseMediaType",
        "desc": ""
      },
      {
        "name": "TestParseMediaTypeBogus",
        "desc": ""
      },
      {
        "name": "TestTypeByExtension",
        "desc": ""
      },
      {
        "name": "TestTypeByExtensionCase",
        "desc": ""
      },
      {
        "name": "TestTypeByExtensionUNIX",
        "desc": ""
      },
      {
        "name": "TestTypeByExtension_LocalData",
        "desc": ""
      },
      {
        "name": "TypeByExtension",
        "desc": "TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in \".html\". When ext has no associated type, TypeByExtension returns \"\".  Extensions are looked up first case-sensitively, then case-insensitively.  The built-in table is small but on unix it is augmented by the local system's MIME-info database or mime.types file(s) if available under one or more of these names:  \t/usr/local/share/mime/globs2 \t/usr/share/mime/globs2 \t/etc/mime.types \t/etc/apache2/mime.types \t/etc/apache/mime.types  On Windows, MIME types are extracted from the registry.  Text types have the charset parameter set to \"utf-8\" by default."
      },
      {
        "name": "checkMediaTypeDisposition",
        "desc": ""
      },
      {
        "name": "clearMimeTypes",
        "desc": ""
      },
      {
        "name": "closeWord",
        "desc": "closeWord writes the end of an encoded-word into buf."
      },
      {
        "name": "consumeMediaParam",
        "desc": ""
      },
      {
        "name": "consumeToken",
        "desc": "consumeToken consumes a token from the beginning of provided string, per RFC 2045 section 5.1 (referenced from 2183), and return the token consumed and the rest of the string. Returns (\"\", v) on failure to consume at least one character."
      },
      {
        "name": "consumeValue",
        "desc": "consumeValue consumes a \"value\" per RFC 2045, where a value is either a 'token' or a 'quoted-string'.  On success, consumeValue returns the value consumed (and de-quoted/escaped, if a quoted-string) and the rest of the string. On failure, returns (\"\", v)."
      },
      {
        "name": "decode",
        "desc": ""
      },
      {
        "name": "decode2231Enc",
        "desc": ""
      },
      {
        "name": "fromHex",
        "desc": ""
      },
      {
        "name": "hasNonWhitespace",
        "desc": "hasNonWhitespace reports whether s (assumed to be ASCII) contains at least one byte of non-whitespace."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initMime",
        "desc": ""
      },
      {
        "name": "initMimeForTests",
        "desc": ""
      },
      {
        "name": "initMimePlan9",
        "desc": ""
      },
      {
        "name": "initMimeUnix",
        "desc": ""
      },
      {
        "name": "initMimeUnixTest",
        "desc": ""
      },
      {
        "name": "initMimeWindows",
        "desc": ""
      },
      {
        "name": "isTSpecial",
        "desc": "isTSpecial reports whether c is in 'tspecials' as defined by RFC 1521 and RFC 2045."
      },
      {
        "name": "isToken",
        "desc": "isToken reports whether s is a 'token' as defined by RFC 1521 and RFC 2045."
      },
      {
        "name": "isTokenChar",
        "desc": "isTokenChar reports whether c is in 'token' as defined by RFC 1521 and RFC 2045."
      },
      {
        "name": "isUTF8",
        "desc": ""
      },
      {
        "name": "ishex",
        "desc": ""
      },
      {
        "name": "loadMimeFile",
        "desc": ""
      },
      {
        "name": "loadMimeGlobsFile",
        "desc": ""
      },
      {
        "name": "needsEncoding",
        "desc": ""
      },
      {
        "name": "percentHexUnescape",
        "desc": ""
      },
      {
        "name": "qDecode",
        "desc": "qDecode decodes a Q encoded string."
      },
      {
        "name": "readHexByte",
        "desc": "readHexByte returns the byte from its quoted-printable representation."
      },
      {
        "name": "setExtensionType",
        "desc": ""
      },
      {
        "name": "setMimeInit",
        "desc": ""
      },
      {
        "name": "setMimeTypes",
        "desc": "setMimeTypes is used by initMime's non-test path, and by tests."
      },
      {
        "name": "setType",
        "desc": ""
      },
      {
        "name": "unhex",
        "desc": ""
      },
      {
        "name": "writeQString",
        "desc": "writeQString encodes s using Q encoding and writes it to buf."
      },
      {
        "name": "Decode",
        "desc": "Decode decodes an RFC 2047 encoded-word."
      },
      {
        "name": "DecodeHeader",
        "desc": "DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if [WordDecoder.CharsetReader] of d returns an error."
      },
      {
        "name": "convert",
        "desc": ""
      },
      {
        "name": "Encode",
        "desc": "Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive."
      },
      {
        "name": "bEncode",
        "desc": "bEncode encodes s using base64 encoding and writes it to buf."
      },
      {
        "name": "encodeWord",
        "desc": "encodeWord encodes a string into an encoded-word."
      },
      {
        "name": "openWord",
        "desc": "openWord writes the beginning of an encoded-word into buf."
      },
      {
        "name": "qEncode",
        "desc": "qEncode encodes s using Q encoding and writes it to buf. It splits the encoded-words when necessary."
      },
      {
        "name": "splitWord",
        "desc": "splitWord closes the current encoded-word and opens a new one."
      }
    ],
    "types": [
      {
        "name": "WordDecoder",
        "desc": "A WordDecoder decodes MIME headers containing RFC 2047 encoded-words."
      },
      {
        "name": "WordEncoder",
        "desc": "A WordEncoder is an RFC 2047 encoded-word encoder."
      },
      {
        "name": "badMediaTypeTest",
        "desc": ""
      },
      {
        "name": "formatTest",
        "desc": ""
      },
      {
        "name": "mediaTypeTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "mime/multipart",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNewReader",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "mime/quotedprintable",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNewReader",
        "desc": ""
      },
      {
        "name": "ExampleNewWriter",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "net",
    "desc": "Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets.  Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the [Dial], [Listen], and Accept functions and the associated [Conn] and [Listener] interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions.  The Dial function connects to a server:  \tconn, err := net.Dial(\"tcp\", \"golang.org:80\") \tif err != nil { \t\t// handle error \t} \tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\") \tstatus, err := bufio.NewReader(conn).ReadString('\\n') \t// ...  The Listen function creates servers:  \tln, err := net.Listen(\"tcp\", \":8080\") \tif err != nil { \t\t// handle error \t} \tfor { \t\tconn, err := ln.Accept() \t\tif err != nil { \t\t\t// handle error \t\t} \t\tgo handleConnection(conn) \t}  # Name Resolution  The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like [LookupHost] and [LookupAddr], varies by operating system.  On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.  On Unix the pure Go resolver is preferred over the cgo resolver, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement.  On all systems (except Plan 9), when the cgo resolver is being used this package applies a concurrent cgo lookup limit to prevent the system from running out of system threads. Currently, it is limited to 500 concurrent lookups.  The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in:  \texport GODEBUG=netdns=go    # force pure Go resolver \texport GODEBUG=netdns=cgo   # force native resolver (cgo, win32)  The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag. The netgo build tag disables entirely the use of the native (CGO) resolver, meaning the Go resolver is the only one that can be used. With the netcgo build tag the native and the pure Go resolver are compiled into the binary, but the native (CGO) resolver is preferred over the Go resolver. With netcgo, the Go resolver can still be forced at runtime with GODEBUG=netdns=go.  A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1.  The Go resolver will send an EDNS0 additional header with a DNS request, to signal a willingness to accept a larger DNS packet size. This can reportedly cause sporadic failures with the DNS server run by some modems and routers. Setting GODEBUG=netedns0=0 will disable sending the additional header.  On macOS, if Go code that uses the net package is built with -buildmode=c-archive, linking the resulting archive into a C program requires passing -lresolv when linking the C code.  On Plan 9, the resolver always accesses /net/cs and /net/dns.  On Windows, in Go 1.18.x and earlier, the resolver always used C library functions, such as GetAddrInfo and DnsQuery.",
    "functions": [
      {
        "name": "BenchmarkDNSName",
        "desc": ""
      },
      {
        "name": "BenchmarkGoLookupIP",
        "desc": ""
      },
      {
        "name": "BenchmarkGoLookupIPNoSuchHost",
        "desc": ""
      },
      {
        "name": "BenchmarkGoLookupIPWithBrokenNameServer",
        "desc": ""
      },
      {
        "name": "BenchmarkIPEqual",
        "desc": ""
      },
      {
        "name": "BenchmarkIPMarshalText",
        "desc": ""
      },
      {
        "name": "BenchmarkIPMaskString",
        "desc": ""
      },
      {
        "name": "BenchmarkIPString",
        "desc": ""
      },
      {
        "name": "BenchmarkInterfaceAddrs",
        "desc": ""
      },
      {
        "name": "BenchmarkInterfaceByIndex",
        "desc": ""
      },
      {
        "name": "BenchmarkInterfaceByName",
        "desc": ""
      },
      {
        "name": "BenchmarkInterfaces",
        "desc": ""
      },
      {
        "name": "BenchmarkInterfacesAndAddrs",
        "desc": ""
      },
      {
        "name": "BenchmarkInterfacesAndMulticastAddrs",
        "desc": ""
      },
      {
        "name": "BenchmarkParseIP",
        "desc": ""
      },
      {
        "name": "BenchmarkParseIPValidIPv4",
        "desc": ""
      },
      {
        "name": "BenchmarkParseIPValidIPv6",
        "desc": ""
      },
      {
        "name": "BenchmarkReadWriteMsgUDPAddrPort",
        "desc": ""
      },
      {
        "name": "BenchmarkSendFile",
        "desc": ""
      },
      {
        "name": "BenchmarkSendfileZeroBytes",
        "desc": ""
      },
      {
        "name": "BenchmarkSetReadDeadline",
        "desc": ""
      },
      {
        "name": "BenchmarkSplice",
        "desc": ""
      },
      {
        "name": "BenchmarkSpliceFile",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP4ConcurrentReadWrite",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP4OneShot",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP4OneShotTimeout",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP4Persistent",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP4PersistentTimeout",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP6ConcurrentReadWrite",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP6OneShot",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP6OneShotTimeout",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP6Persistent",
        "desc": ""
      },
      {
        "name": "BenchmarkTCP6PersistentTimeout",
        "desc": ""
      },
      {
        "name": "BenchmarkUDP6LinkLocalUnicast",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteToReadFromUDP",
        "desc": ""
      },
      {
        "name": "BenchmarkWriteToReadFromUDPAddrPort",
        "desc": ""
      },
      {
        "name": "Dial",
        "desc": "Dial connects to the address on the named network.  Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\".  For TCP and UDP networks, the address has the form \"host:port\". The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\". The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions [JoinHostPort] and [SplitHostPort] manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds.  Examples:  \tDial(\"tcp\", \"golang.org:http\") \tDial(\"tcp\", \"192.0.2.1:http\") \tDial(\"tcp\", \"198.51.100.1:80\") \tDial(\"udp\", \"[2001:db8::1]:domain\") \tDial(\"udp\", \"[fe80::1%lo0]:53\") \tDial(\"tcp\", \":80\")  For IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a colon and a literal protocol number or a protocol name, and the address has the form \"host\". The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as \"0\" or \"255\".  Examples:  \tDial(\"ip4:1\", \"192.0.2.1\") \tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\") \tDial(\"ip6:58\", \"fe80::1%lo0\")  For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for TCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is assumed.  For Unix networks, the address must be a file system path."
      },
      {
        "name": "DialIP",
        "desc": "DialIP acts like [Dial] for IP networks.  The network must be an IP network name; see func Dial for details.  If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed."
      },
      {
        "name": "DialTCP",
        "desc": "DialTCP acts like [Dial] for TCP networks.  The network must be a TCP network name; see func Dial for details.  If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed."
      },
      {
        "name": "DialTimeout",
        "desc": "DialTimeout acts like [Dial] but takes a timeout.  The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect.  See func Dial for a description of the network and address parameters."
      },
      {
        "name": "DialUDP",
        "desc": "DialUDP acts like [Dial] for UDP networks.  The network must be a UDP network name; see func [Dial] for details.  If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed."
      },
      {
        "name": "DialUnix",
        "desc": "DialUnix acts like [Dial] for Unix networks.  The network must be a Unix network name; see func [Dial] for details.  If laddr is non-nil, it is used as the local address for the connection."
      },
      {
        "name": "FileConn",
        "desc": "FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c."
      },
      {
        "name": "FileListener",
        "desc": "FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln."
      },
      {
        "name": "FilePacketConn",
        "desc": "FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c."
      },
      {
        "name": "InterfaceAddrs",
        "desc": "InterfaceAddrs returns a list of the system's unicast interface addresses.  The returned list does not identify the associated interface; use Interfaces and [Interface.Addrs] for more detail."
      },
      {
        "name": "InterfaceByIndex",
        "desc": "InterfaceByIndex returns the interface specified by index.  On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use [InterfaceByName]."
      },
      {
        "name": "InterfaceByName",
        "desc": "InterfaceByName returns the interface specified by name."
      },
      {
        "name": "Interfaces",
        "desc": "Interfaces returns a list of the system's network interfaces."
      },
      {
        "name": "JoinHostPort",
        "desc": "JoinHostPort combines host and port into a network address of the form \"host:port\". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns \"[host]:port\".  See func Dial for a description of the host and port parameters."
      },
      {
        "name": "Listen",
        "desc": "Listen announces on the local network address.  The network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".  For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network \"tcp4\". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen. The [Addr] method of [Listener] can be used to discover the chosen port.  See func [Dial] for a description of the network and address parameters.  Listen uses context.Background internally; to specify the context, use [ListenConfig.Listen]."
      },
      {
        "name": "ListenIP",
        "desc": "ListenIP acts like [ListenPacket] for IP networks.  The network must be an IP network name; see func Dial for details.  If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses."
      },
      {
        "name": "ListenMulticastUDP",
        "desc": "ListenMulticastUDP acts like [ListenPacket] for UDP networks but takes a group address on a specific network interface.  The network must be a UDP network name; see func [Dial] for details.  ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.  ListenMulticastUDP is just for convenience of simple, small applications. There are [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] packages for general purpose uses.  Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to 0 under IPPROTO_IP, to disable loopback of multicast packets."
      },
      {
        "name": "ListenPacket",
        "desc": "ListenPacket announces on the local network address.  The network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP transport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by a colon and a literal protocol number or a protocol name, as in \"ip:1\" or \"ip:icmp\".  For UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network \"udp4\" or \"ip4:proto\". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen. The LocalAddr method of [PacketConn] can be used to discover the chosen port.  See func [Dial] for a description of the network and address parameters.  ListenPacket uses context.Background internally; to specify the context, use [ListenConfig.ListenPacket]."
      },
      {
        "name": "ListenTCP",
        "desc": "ListenTCP acts like [Listen] for TCP networks.  The network must be a TCP network name; see func Dial for details.  If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen."
      },
      {
        "name": "ListenUDP",
        "desc": "ListenUDP acts like [ListenPacket] for UDP networks.  The network must be a UDP network name; see func [Dial] for details.  If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen."
      },
      {
        "name": "ListenUnix",
        "desc": "ListenUnix acts like [Listen] for Unix networks.  The network must be \"unix\" or \"unixpacket\"."
      },
      {
        "name": "ListenUnixgram",
        "desc": "ListenUnixgram acts like [ListenPacket] for Unix networks.  The network must be \"unixgram\"."
      },
      {
        "name": "LookupAddr",
        "desc": "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.  The returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.  When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom [Resolver].  LookupAddr uses [context.Background] internally; to specify the context, use [Resolver.LookupAddr]."
      },
      {
        "name": "LookupCNAME",
        "desc": "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call [LookupHost] or [LookupIP] directly; both take care of resolving the canonical name as part of the lookup.  A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records.  The returned canonical name is validated to be a properly formatted presentation-format domain name.  LookupCNAME uses [context.Background] internally; to specify the context, use [Resolver.LookupCNAME]."
      },
      {
        "name": "LookupHost",
        "desc": "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.  LookupHost uses [context.Background] internally; to specify the context, use [Resolver.LookupHost]."
      },
      {
        "name": "LookupIP",
        "desc": "LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses."
      },
      {
        "name": "LookupMX",
        "desc": "LookupMX returns the DNS MX records for the given domain name sorted by preference.  The returned mail server names are validated to be properly formatted presentation-format domain names, or numeric IP addresses. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.  LookupMX uses [context.Background] internally; to specify the context, use [Resolver.LookupMX]."
      },
      {
        "name": "LookupNS",
        "desc": "LookupNS returns the DNS NS records for the given domain name.  The returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any.  LookupNS uses [context.Background] internally; to specify the context, use [Resolver.LookupNS]."
      },
      {
        "name": "LookupPort",
        "desc": "LookupPort looks up the port for the given network and service.  LookupPort uses [context.Background] internally; to specify the context, use [Resolver.LookupPort]."
      },
      {
        "name": "LookupSRV",
        "desc": "LookupSRV tries to resolve an [SRV] query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.  LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.  The returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any."
      },
      {
        "name": "LookupTXT",
        "desc": "LookupTXT returns the DNS TXT records for the given domain name.  If a DNS TXT record holds multiple strings, they are concatenated as a single string.  LookupTXT uses [context.Background] internally; to specify the context, use [Resolver.LookupTXT]."
      },
      {
        "name": "ParseCIDR",
        "desc": "ParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291.  It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(\"192.0.2.1/24\") returns the IP address 192.0.2.1 and the network 192.0.2.0/24."
      },
      {
        "name": "ParseMAC",
        "desc": "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:  \t00:00:5e:00:53:01 \t02:00:5e:10:00:00:00:01 \t00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01 \t00-00-5e-00-53-01 \t02-00-5e-10-00-00-00-01 \t00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01 \t0000.5e00.5301 \t0200.5e10.0000.0001 \t0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001"
      },
      {
        "name": "Pipe",
        "desc": "Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the [Conn] interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering."
      },
      {
        "name": "ResolveIPAddr",
        "desc": "ResolveIPAddr returns an address of IP end point.  The network must be an IP network name.  If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.  See func [Dial] for a description of the network and address parameters."
      },
      {
        "name": "ResolveTCPAddr",
        "desc": "ResolveTCPAddr returns an address of TCP end point.  The network must be a TCP network name.  If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.  See func [Dial] for a description of the network and address parameters."
      },
      {
        "name": "ResolveUDPAddr",
        "desc": "ResolveUDPAddr returns an address of UDP end point.  The network must be a UDP network name.  If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses.  See func [Dial] for a description of the network and address parameters."
      },
      {
        "name": "ResolveUnixAddr",
        "desc": "ResolveUnixAddr returns an address of Unix domain socket end point.  The network must be a Unix network name.  See func [Dial] for a description of the network and address parameters."
      },
      {
        "name": "SplitHostPort",
        "desc": "SplitHostPort splits a network address of the form \"host:port\", \"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or host%zone and port.  A literal IPv6 address in hostport must be enclosed in square brackets, as in \"[::1]:80\", \"[::1%lo0]:80\".  See func Dial for a description of the hostport parameter, and host and port results."
      },
      {
        "name": "TestAcceptError",
        "desc": ""
      },
      {
        "name": "TestAcceptIgnoreAbortedConnRequest",
        "desc": "See golang.org/issue/6163, golang.org/issue/6987."
      },
      {
        "name": "TestAcceptIgnoreSomeErrors",
        "desc": "TestAcceptIgnoreSomeErrors tests that windows TCPListener.AcceptTCP handles broken connections. It verifies that broken connections do not affect future connections."
      },
      {
        "name": "TestAcceptTimeout",
        "desc": ""
      },
      {
        "name": "TestAcceptTimeoutMustNotReturn",
        "desc": ""
      },
      {
        "name": "TestAcceptTimeoutMustReturn",
        "desc": ""
      },
      {
        "name": "TestAddrList",
        "desc": ""
      },
      {
        "name": "TestAddrListPartition",
        "desc": ""
      },
      {
        "name": "TestAddrLookupOrder",
        "desc": ""
      },
      {
        "name": "TestAllocs",
        "desc": ""
      },
      {
        "name": "TestAvoidDNSName",
        "desc": "Issue 13705: don't try to resolve onion addresses, etc"
      },
      {
        "name": "TestBuffers_WriteTo",
        "desc": ""
      },
      {
        "name": "TestBuffers_consume",
        "desc": ""
      },
      {
        "name": "TestBuffers_read",
        "desc": ""
      },
      {
        "name": "TestCIDRMask",
        "desc": ""
      },
      {
        "name": "TestCVE202133195",
        "desc": ""
      },
      {
        "name": "TestCancelAfterDial",
        "desc": ""
      },
      {
        "name": "TestCgoLookupIP",
        "desc": ""
      },
      {
        "name": "TestCgoLookupIPWithCancel",
        "desc": ""
      },
      {
        "name": "TestCgoLookupPTR",
        "desc": ""
      },
      {
        "name": "TestCgoLookupPTRWithCancel",
        "desc": ""
      },
      {
        "name": "TestCgoLookupPort",
        "desc": ""
      },
      {
        "name": "TestCgoLookupPortWithCancel",
        "desc": ""
      },
      {
        "name": "TestCloseError",
        "desc": ""
      },
      {
        "name": "TestCloseRead",
        "desc": ""
      },
      {
        "name": "TestCloseUnblocksRead",
        "desc": "Issue 17695: verify that a blocked Read is woken up by a Close."
      },
      {
        "name": "TestCloseUnblocksReadUDP",
        "desc": "Issue 72770: verify that a blocked UDP read is woken up by a Close."
      },
      {
        "name": "TestCloseWrite",
        "desc": ""
      },
      {
        "name": "TestClosingListener",
        "desc": "Issue 21856."
      },
      {
        "name": "TestConcurrentPreferGoResolversDial",
        "desc": "TestConcurrentPreferGoResolversDial tests that multiple resolvers with the PreferGo option used concurrently are all dialed properly."
      },
      {
        "name": "TestConcurrentSetDeadline",
        "desc": "Issue 35367."
      },
      {
        "name": "TestConfHostLookupOrder",
        "desc": ""
      },
      {
        "name": "TestConnAndListener",
        "desc": ""
      },
      {
        "name": "TestConnAndPacketConn",
        "desc": ""
      },
      {
        "name": "TestConnClose",
        "desc": ""
      },
      {
        "name": "TestContextError",
        "desc": ""
      },
      {
        "name": "TestCopyFromTTY",
        "desc": "Issue 70763: test that we don't fail on sendfile from a tty."
      },
      {
        "name": "TestCopyPipeIntoTCP",
        "desc": ""
      },
      {
        "name": "TestDNSConfigNoReload",
        "desc": ""
      },
      {
        "name": "TestDNSDefaultSearch",
        "desc": ""
      },
      {
        "name": "TestDNSDialTCP",
        "desc": "Issue 26573: verify that Conns that don't implement PacketConn are treated as streams even when udp was requested."
      },
      {
        "name": "TestDNSErrorUnwrap",
        "desc": ""
      },
      {
        "name": "TestDNSFlood",
        "desc": ""
      },
      {
        "name": "TestDNSGoroutineRace",
        "desc": "Test for a race between uninstalling the test hooks and closing a socket connection. This used to fail when testing with -race."
      },
      {
        "name": "TestDNSName",
        "desc": ""
      },
      {
        "name": "TestDNSNameLength",
        "desc": ""
      },
      {
        "name": "TestDNSPacketSize",
        "desc": "Test that we advertise support for a larger DNS packet size. This isn't a great test as it just tests the dnsmessage package against itself."
      },
      {
        "name": "TestDNSReadConfig",
        "desc": ""
      },
      {
        "name": "TestDNSReadMissingFile",
        "desc": ""
      },
      {
        "name": "TestDNSSRVUniformity",
        "desc": ""
      },
      {
        "name": "TestDNSTimeout",
        "desc": "A context timeout should still return a DNSError."
      },
      {
        "name": "TestDNSTransportFallback",
        "desc": ""
      },
      {
        "name": "TestDNSTransportNoFallbackOnTCP",
        "desc": ""
      },
      {
        "name": "TestDNSTrustAD",
        "desc": ""
      },
      {
        "name": "TestDNSUseTCP",
        "desc": "Issue 29358. Add configuration knob to force TCP-only DNS requests in the pure Go resolver."
      },
      {
        "name": "TestDNSUseTCPTruncated",
        "desc": ""
      },
      {
        "name": "TestDialAddrError",
        "desc": ""
      },
      {
        "name": "TestDialCancel",
        "desc": ""
      },
      {
        "name": "TestDialClosedPortFailFast",
        "desc": ""
      },
      {
        "name": "TestDialContextCancelRace",
        "desc": "Issue 16523"
      },
      {
        "name": "TestDialError",
        "desc": ""
      },
      {
        "name": "TestDialGoogle",
        "desc": ""
      },
      {
        "name": "TestDialListenIPArgs",
        "desc": ""
      },
      {
        "name": "TestDialListenerAddr",
        "desc": "Issue 18806: it should always be possible to net.Dial a net.Listener().Addr().String when the listen address was \":n\", even if the machine has halfway configured IPv6 such that it can bind on \"::\" not connect back to that same address."
      },
      {
        "name": "TestDialLocal",
        "desc": ""
      },
      {
        "name": "TestDialParallel",
        "desc": ""
      },
      {
        "name": "TestDialParallelSpuriousConnection",
        "desc": ""
      },
      {
        "name": "TestDialTCPDefaultKeepAlive",
        "desc": ""
      },
      {
        "name": "TestDialTimeout",
        "desc": ""
      },
      {
        "name": "TestDialTimeoutMaxDuration",
        "desc": ""
      },
      {
        "name": "TestDialWithNonZeroDeadline",
        "desc": ""
      },
      {
        "name": "TestDialerControl",
        "desc": ""
      },
      {
        "name": "TestDialerControlContext",
        "desc": ""
      },
      {
        "name": "TestDialerDualStack",
        "desc": ""
      },
      {
        "name": "TestDialerDualStackFDLeak",
        "desc": ""
      },
      {
        "name": "TestDialerFallbackDelay",
        "desc": ""
      },
      {
        "name": "TestDialerKeepAlive",
        "desc": ""
      },
      {
        "name": "TestDialerLocalAddr",
        "desc": ""
      },
      {
        "name": "TestDialerPartialDeadline",
        "desc": ""
      },
      {
        "name": "TestDtoi",
        "desc": ""
      },
      {
        "name": "TestDualStackTCPListener",
        "desc": "TestDualStackTCPListener tests both single and double listen to a test listener with various address families, different listening address and same port.  On DragonFly BSD, we expect the kernel version of node under test to be greater than or equal to 4.4."
      },
      {
        "name": "TestDualStackUDPListener",
        "desc": "TestDualStackUDPListener tests both single and double listen to a test listener with various address families, different listening address and same port.  On DragonFly BSD, we expect the kernel version of node under test to be greater than or equal to 4.4."
      },
      {
        "name": "TestEndlessWrite",
        "desc": "Test that a client can't trigger an endless loop of write system calls on the server by shutting down the write side on the client. Possibility raised in the discussion of https://golang.org/cl/71973."
      },
      {
        "name": "TestErrorForOriginalNameWhenSearching",
        "desc": "Issue 12712. When using search domains, return the error encountered querying the original name instead of an error encountered querying a generated name."
      },
      {
        "name": "TestErrors",
        "desc": "The various errors should implement the Error interface."
      },
      {
        "name": "TestExtendedRCode",
        "desc": ""
      },
      {
        "name": "TestFakePortExhaustion",
        "desc": ""
      },
      {
        "name": "TestFileCloseRace",
        "desc": "Issue 24483."
      },
      {
        "name": "TestFileConn",
        "desc": ""
      },
      {
        "name": "TestFileError",
        "desc": ""
      },
      {
        "name": "TestFileFdBlocks",
        "desc": "For backward compatibility, opening a net.Conn, turning it into an os.File, and calling the Fd method should return a blocking descriptor."
      },
      {
        "name": "TestFileListener",
        "desc": ""
      },
      {
        "name": "TestFilePacketConn",
        "desc": ""
      },
      {
        "name": "TestForceCgoDNS",
        "desc": ""
      },
      {
        "name": "TestForceGoDNS",
        "desc": ""
      },
      {
        "name": "TestGoLookupIPCNAMEOrderHostsAliasesDNSFilesMode",
        "desc": ""
      },
      {
        "name": "TestGoLookupIPCNAMEOrderHostsAliasesFilesDNSMode",
        "desc": ""
      },
      {
        "name": "TestGoLookupIPCNAMEOrderHostsAliasesFilesOnlyMode",
        "desc": ""
      },
      {
        "name": "TestGoLookupIPOrderFallbackToFile",
        "desc": "Test that goLookupIPOrder falls back to the host file when no DNS servers are available."
      },
      {
        "name": "TestGoLookupIPWithResolverConfig",
        "desc": ""
      },
      {
        "name": "TestHostCacheModification",
        "desc": ""
      },
      {
        "name": "TestIPAddrFamily",
        "desc": ""
      },
      {
        "name": "TestIPAddrScope",
        "desc": ""
      },
      {
        "name": "TestIPAppendTextNoAllocs",
        "desc": ""
      },
      {
        "name": "TestIPConnLocalName",
        "desc": ""
      },
      {
        "name": "TestIPConnRemoteName",
        "desc": ""
      },
      {
        "name": "TestIPConnSpecificMethods",
        "desc": ""
      },
      {
        "name": "TestIPMask",
        "desc": ""
      },
      {
        "name": "TestIPMaskString",
        "desc": ""
      },
      {
        "name": "TestIPNetContains",
        "desc": ""
      },
      {
        "name": "TestIPNetString",
        "desc": ""
      },
      {
        "name": "TestIPString",
        "desc": ""
      },
      {
        "name": "TestIPVersion",
        "desc": ""
      },
      {
        "name": "TestIPv4MulticastListener",
        "desc": "TestIPv4MulticastListener tests both single and double listen to a test listener with same address family, same group address and same port."
      },
      {
        "name": "TestIPv4WriteMsgUDPAddrPortTargetAddrIPVersion",
        "desc": "TestIPv4WriteMsgUDPAddrPortTargetAddrIPVersion verifies that WriteMsgUDPAddrPort accepts IPv4 and IPv4-mapped IPv6 destination addresses, and rejects IPv6 destination addresses on a \"udp4\" connection."
      },
      {
        "name": "TestIPv6LinkLocalUnicastTCP",
        "desc": ""
      },
      {
        "name": "TestIPv6LinkLocalUnicastUDP",
        "desc": ""
      },
      {
        "name": "TestIPv6MulticastListener",
        "desc": "TestIPv6MulticastListener tests both single and double listen to a test listener with same address family, same group address and same port."
      },
      {
        "name": "TestIPv6WriteMsgUDPAddrPortTargetAddrIPVersion",
        "desc": "TestIPv6WriteMsgUDPAddrPortTargetAddrIPVersion verifies that WriteMsgUDPAddrPort accepts IPv4, IPv4-mapped IPv6, and IPv6 target addresses on a UDPConn listening on \"::\"."
      },
      {
        "name": "TestIgnoreDNSForgeries",
        "desc": "UDP round-tripper algorithm should ignore invalid DNS responses (issue 13281)."
      },
      {
        "name": "TestIgnoreLameReferrals",
        "desc": "Issue 15434. If a name server gives a lame referral, continue to the next."
      },
      {
        "name": "TestInterfaceAddrs",
        "desc": ""
      },
      {
        "name": "TestInterfaceAddrsWithNetsh",
        "desc": ""
      },
      {
        "name": "TestInterfaceArrivalAndDeparture",
        "desc": ""
      },
      {
        "name": "TestInterfaceArrivalAndDepartureZoneCache",
        "desc": ""
      },
      {
        "name": "TestInterfaceHardwareAddrWithGetmac",
        "desc": ""
      },
      {
        "name": "TestInterfaceMulticastAddrs",
        "desc": ""
      },
      {
        "name": "TestInterfaceUnicastAddrs",
        "desc": ""
      },
      {
        "name": "TestInterfaces",
        "desc": ""
      },
      {
        "name": "TestInterfacesWithNetsh",
        "desc": ""
      },
      {
        "name": "TestIssue8434",
        "desc": "Issue 8434: verify that Temporary returns true on an error when rcode is SERVFAIL"
      },
      {
        "name": "TestIssueNoSuchHostExists",
        "desc": ""
      },
      {
        "name": "TestJoinHostPort",
        "desc": ""
      },
      {
        "name": "TestListenConfigControl",
        "desc": ""
      },
      {
        "name": "TestListenError",
        "desc": ""
      },
      {
        "name": "TestListenMulticastUDP",
        "desc": ""
      },
      {
        "name": "TestListenPacketError",
        "desc": ""
      },
      {
        "name": "TestListenerClose",
        "desc": ""
      },
      {
        "name": "TestLongDNSNames",
        "desc": ""
      },
      {
        "name": "TestLookupCNAME",
        "desc": ""
      },
      {
        "name": "TestLookupContextCancel",
        "desc": ""
      },
      {
        "name": "TestLookupDotsWithLocalSource",
        "desc": ""
      },
      {
        "name": "TestLookupDotsWithRemoteSource",
        "desc": ""
      },
      {
        "name": "TestLookupGmailMX",
        "desc": ""
      },
      {
        "name": "TestLookupGmailNS",
        "desc": ""
      },
      {
        "name": "TestLookupGmailTXT",
        "desc": ""
      },
      {
        "name": "TestLookupGoogleHost",
        "desc": ""
      },
      {
        "name": "TestLookupGoogleIP",
        "desc": ""
      },
      {
        "name": "TestLookupGooglePublicDNSAddr",
        "desc": ""
      },
      {
        "name": "TestLookupGoogleSRV",
        "desc": ""
      },
      {
        "name": "TestLookupHostCancel",
        "desc": "TestLookupHostCancel verifies that lookup works even after many canceled lookups (see golang.org/issue/24178 for details)."
      },
      {
        "name": "TestLookupIPAddrConcurrentCallsForNetworks",
        "desc": "Issue 30521: The lookup group should call the resolver for each network."
      },
      {
        "name": "TestLookupIPAddrPreservesContextValues",
        "desc": "Issue 28600: The context that is used to lookup ips should always preserve the values from the context that was passed into LookupIPAddr."
      },
      {
        "name": "TestLookupIPv6LinkLocalAddr",
        "desc": ""
      },
      {
        "name": "TestLookupIPv6LinkLocalAddrWithZone",
        "desc": ""
      },
      {
        "name": "TestLookupLocalPTR",
        "desc": ""
      },
      {
        "name": "TestLookupLongTXT",
        "desc": ""
      },
      {
        "name": "TestLookupNoData",
        "desc": ""
      },
      {
        "name": "TestLookupNoSuchHost",
        "desc": ""
      },
      {
        "name": "TestLookupNonLDH",
        "desc": ""
      },
      {
        "name": "TestLookupNullByte",
        "desc": "Issue 31597: don't panic on null byte in name"
      },
      {
        "name": "TestLookupOrderFilesNoSuchHost",
        "desc": ""
      },
      {
        "name": "TestLookupPTR",
        "desc": ""
      },
      {
        "name": "TestLookupPort",
        "desc": ""
      },
      {
        "name": "TestLookupPortDifferentNetwork",
        "desc": ""
      },
      {
        "name": "TestLookupPortEmptyNetworkString",
        "desc": ""
      },
      {
        "name": "TestLookupPortIPNetworkString",
        "desc": ""
      },
      {
        "name": "TestLookupPortNotFound",
        "desc": ""
      },
      {
        "name": "TestLookupPort_Minimal",
        "desc": "Like TestLookupPort but with minimal tests that should always pass because the answers are baked-in to the net package."
      },
      {
        "name": "TestLookupProtocol_Minimal",
        "desc": ""
      },
      {
        "name": "TestLookupStaticAddr",
        "desc": ""
      },
      {
        "name": "TestLookupStaticHost",
        "desc": ""
      },
      {
        "name": "TestLookupStaticHostAliases",
        "desc": ""
      },
      {
        "name": "TestLookupTorOnion",
        "desc": "Issue 13705: don't try to resolve onion addresses, etc"
      },
      {
        "name": "TestLookupWithIP",
        "desc": ""
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "TestMarshalEmptyIP",
        "desc": "Issue 6339"
      },
      {
        "name": "TestMaxAckBacklog",
        "desc": ""
      },
      {
        "name": "TestModeSocket",
        "desc": ""
      },
      {
        "name": "TestMultiPathTCP",
        "desc": ""
      },
      {
        "name": "TestNSLookupCNAME",
        "desc": ""
      },
      {
        "name": "TestNSLookupMX",
        "desc": ""
      },
      {
        "name": "TestNSLookupNS",
        "desc": ""
      },
      {
        "name": "TestNSLookupTXT",
        "desc": ""
      },
      {
        "name": "TestNameListAvoidDNS",
        "desc": ""
      },
      {
        "name": "TestNetworkNumberAndMask",
        "desc": ""
      },
      {
        "name": "TestNilResolverLookup",
        "desc": "Issue 24330: treat the nil *Resolver like a zero value. Verify nothing crashes if nil is used."
      },
      {
        "name": "TestNoSuchHost",
        "desc": "TestNoSuchHost verifies that tryOneName works correctly when the domain does not exist.  Issue 12778: verify that NXDOMAIN without RA bit errors as \"no such host\" and not \"server misbehaving\"  Issue 25336: verify that NXDOMAIN errors fail fast.  Issue 27525: verify that empty answers fail fast."
      },
      {
        "name": "TestNotTemporaryRead",
        "desc": "Issue 24808: verify that ECONNRESET is not temporary for read."
      },
      {
        "name": "TestNullMX",
        "desc": ""
      },
      {
        "name": "TestPTRandNonPTR",
        "desc": "Issue 34660: PTR response with non-PTR answers should ignore non-PTR"
      },
      {
        "name": "TestPacketConn",
        "desc": ""
      },
      {
        "name": "TestPacketConnClose",
        "desc": ""
      },
      {
        "name": "TestParseCIDR",
        "desc": ""
      },
      {
        "name": "TestParseIP",
        "desc": ""
      },
      {
        "name": "TestParseMAC",
        "desc": ""
      },
      {
        "name": "TestParseNSSConf",
        "desc": ""
      },
      {
        "name": "TestParsePort",
        "desc": ""
      },
      {
        "name": "TestParseProcNet",
        "desc": ""
      },
      {
        "name": "TestPointToPointInterface",
        "desc": ""
      },
      {
        "name": "TestProhibitionaryDialArg",
        "desc": ""
      },
      {
        "name": "TestProtocolDialError",
        "desc": ""
      },
      {
        "name": "TestProtocolListenError",
        "desc": ""
      },
      {
        "name": "TestRFC6724ClassifyScope",
        "desc": ""
      },
      {
        "name": "TestRFC6724CommonPrefixLength",
        "desc": ""
      },
      {
        "name": "TestRFC6724PolicyTableClassify",
        "desc": ""
      },
      {
        "name": "TestRFC6724PolicyTableContent",
        "desc": ""
      },
      {
        "name": "TestRFC6724PolicyTableOrder",
        "desc": ""
      },
      {
        "name": "TestRawConnControl",
        "desc": ""
      },
      {
        "name": "TestRawConnReadWrite",
        "desc": ""
      },
      {
        "name": "TestReadFromTimeout",
        "desc": ""
      },
      {
        "name": "TestReadFromTimeoutFluctuation",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestReadLine",
        "desc": ""
      },
      {
        "name": "TestReadTimeout",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestReadTimeoutFluctuation",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestReadTimeoutMustNotReturn",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestReadTimeoutUnblocksRead",
        "desc": "Tests that a blocked Read is interrupted by a concurrent SetReadDeadline modifying that Conn's read deadline to the past. See golang.org/cl/30164 which documented this. The net/http package depends on this."
      },
      {
        "name": "TestReadUnixgramWithUnnamedSocket",
        "desc": ""
      },
      {
        "name": "TestReadWriteDeadlineRace",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestReadWriteProlongedTimeout",
        "desc": "TestReadWriteProlongedTimeout tests concurrent deadline modification. Known to cause data races in the past."
      },
      {
        "name": "TestResolveGoogle",
        "desc": ""
      },
      {
        "name": "TestResolveIPAddr",
        "desc": ""
      },
      {
        "name": "TestResolveTCPAddr",
        "desc": ""
      },
      {
        "name": "TestResolveUDPAddr",
        "desc": ""
      },
      {
        "name": "TestResolverDialFunc",
        "desc": ""
      },
      {
        "name": "TestResolverLookupIP",
        "desc": ""
      },
      {
        "name": "TestResolverLookupIPWithEmptyHost",
        "desc": "Issue 53995: Resolver.LookupIP should return error for empty host name."
      },
      {
        "name": "TestRetryTimeout",
        "desc": "Issue 16865. If a name server times out, continue to the next."
      },
      {
        "name": "TestReverseAddress",
        "desc": ""
      },
      {
        "name": "TestRootNS",
        "desc": ""
      },
      {
        "name": "TestRotate",
        "desc": ""
      },
      {
        "name": "TestSendfile",
        "desc": ""
      },
      {
        "name": "TestSendfileOnWriteTimeoutExceeded",
        "desc": "Issue 43822: tests that returns EOF when conn write timeout."
      },
      {
        "name": "TestSendfileParts",
        "desc": ""
      },
      {
        "name": "TestSendfilePipe",
        "desc": "Test that sendfile doesn't put a pipe into blocking mode."
      },
      {
        "name": "TestSendfileSeeked",
        "desc": ""
      },
      {
        "name": "TestSendfileWithExactLimit",
        "desc": ""
      },
      {
        "name": "TestSendfileWithLargeFile",
        "desc": ""
      },
      {
        "name": "TestSendfileWithLimitLargerThanFile",
        "desc": ""
      },
      {
        "name": "TestSingleRequestLookup",
        "desc": "Issue 29644: support single-request resolv.conf option in pure Go resolver. The A and AAAA queries will be sent sequentially, not in parallel."
      },
      {
        "name": "TestSortByRFC6724",
        "desc": ""
      },
      {
        "name": "TestSpecialDomainName",
        "desc": ""
      },
      {
        "name": "TestSplice",
        "desc": ""
      },
      {
        "name": "TestSplitHostPort",
        "desc": ""
      },
      {
        "name": "TestSpuriousENOTAVAIL",
        "desc": ""
      },
      {
        "name": "TestStrictErrorsLookupIP",
        "desc": "Issue 17448. With StrictErrors enabled, temporary errors should make LookupIP fail rather than return a partial result."
      },
      {
        "name": "TestStrictErrorsLookupTXT",
        "desc": "Issue 17448. With StrictErrors enabled, temporary errors should make LookupTXT stop walking the search list."
      },
      {
        "name": "TestSystemConf",
        "desc": ""
      },
      {
        "name": "TestTCP4ListenZero",
        "desc": ""
      },
      {
        "name": "TestTCPBig",
        "desc": "Test that \u003e32-bit reads work on 64-bit systems. On 32-bit systems this tests that maxint reads work."
      },
      {
        "name": "TestTCPConcurrentAccept",
        "desc": ""
      },
      {
        "name": "TestTCPConnKeepAliveConfig",
        "desc": ""
      },
      {
        "name": "TestTCPConnKeepAliveConfigDialer",
        "desc": ""
      },
      {
        "name": "TestTCPConnKeepAliveConfigListener",
        "desc": ""
      },
      {
        "name": "TestTCPConnSpecificMethods",
        "desc": ""
      },
      {
        "name": "TestTCPListenAfterClose",
        "desc": ""
      },
      {
        "name": "TestTCPListener",
        "desc": "TestTCPListener tests both single and double listen to a test listener with same address family, same listening address and same port."
      },
      {
        "name": "TestTCPListenerName",
        "desc": ""
      },
      {
        "name": "TestTCPListenerSpecificMethods",
        "desc": ""
      },
      {
        "name": "TestTCPReadWriteAllocs",
        "desc": ""
      },
      {
        "name": "TestTCPServer",
        "desc": "TestTCPServer tests concurrent accept-read-write servers."
      },
      {
        "name": "TestTCPSpuriousConnSetupCompletion",
        "desc": "See golang.org/issue/14548."
      },
      {
        "name": "TestTCPSpuriousConnSetupCompletionWithCancel",
        "desc": "Issue 19289. Test that a canceled Dial does not cause a subsequent Dial to succeed."
      },
      {
        "name": "TestTCPStress",
        "desc": ""
      },
      {
        "name": "TestTXTRecordTwoStrings",
        "desc": "Issue 27763: verify that two strings in one TXT record are concatenated."
      },
      {
        "name": "TestUDP4ListenZero",
        "desc": ""
      },
      {
        "name": "TestUDPConnLocalAndRemoteNames",
        "desc": ""
      },
      {
        "name": "TestUDPConnLocalName",
        "desc": ""
      },
      {
        "name": "TestUDPConnSpecificMethods",
        "desc": ""
      },
      {
        "name": "TestUDPIPVersionReadMsg",
        "desc": ""
      },
      {
        "name": "TestUDPListener",
        "desc": "TestUDPListener tests both single and double listen to a test listener with same address family, same listening address and same port."
      },
      {
        "name": "TestUDPReadSizeError",
        "desc": ""
      },
      {
        "name": "TestUDPReadTimeout",
        "desc": "TestUDPReadTimeout verifies that ReadFromUDP with timeout returns an error without data or an address."
      },
      {
        "name": "TestUDPServer",
        "desc": ""
      },
      {
        "name": "TestUDPZeroByteBuffer",
        "desc": ""
      },
      {
        "name": "TestUDPZeroBytePayload",
        "desc": ""
      },
      {
        "name": "TestUnixAbstractLongNameNulStart",
        "desc": ""
      },
      {
        "name": "TestUnixAndUnixpacketServer",
        "desc": "TestUnixAndUnixpacketServer tests concurrent accept-read-write servers"
      },
      {
        "name": "TestUnixAutobindClose",
        "desc": ""
      },
      {
        "name": "TestUnixConnLocalAndRemoteNames",
        "desc": ""
      },
      {
        "name": "TestUnixConnLocalWindows",
        "desc": ""
      },
      {
        "name": "TestUnixConnReadMsgUnixSCMRightsCloseOnExec",
        "desc": ""
      },
      {
        "name": "TestUnixConnSpecificMethods",
        "desc": ""
      },
      {
        "name": "TestUnixListenerSpecificMethods",
        "desc": ""
      },
      {
        "name": "TestUnixUnlink",
        "desc": ""
      },
      {
        "name": "TestUnixgramAutobind",
        "desc": ""
      },
      {
        "name": "TestUnixgramConnLocalAndRemoteNames",
        "desc": ""
      },
      {
        "name": "TestUnixgramLinuxAbstractLongName",
        "desc": ""
      },
      {
        "name": "TestUnixgramServer",
        "desc": ""
      },
      {
        "name": "TestUnixgramWrite",
        "desc": ""
      },
      {
        "name": "TestUnixgramZeroByteBuffer",
        "desc": ""
      },
      {
        "name": "TestUnixgramZeroBytePayload",
        "desc": ""
      },
      {
        "name": "TestUpdateResolvConf",
        "desc": ""
      },
      {
        "name": "TestVariousDeadlines",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestVariousDeadlines1Proc",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestVariousDeadlines4Proc",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestWasip1FileConnNet",
        "desc": ""
      },
      {
        "name": "TestWasip1FileListenNet",
        "desc": ""
      },
      {
        "name": "TestWasip1NewFileConn",
        "desc": ""
      },
      {
        "name": "TestWasip1NewFileListener",
        "desc": ""
      },
      {
        "name": "TestWeighting",
        "desc": ""
      },
      {
        "name": "TestWildWildcardListener",
        "desc": ""
      },
      {
        "name": "TestWithUnexpiredValuesPreserved",
        "desc": ""
      },
      {
        "name": "TestWriteTimeout",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestWriteTimeoutFluctuation",
        "desc": ""
      },
      {
        "name": "TestWriteTimeoutMustNotReturn",
        "desc": "There is a very similar copy of this in os/timeout_test.go."
      },
      {
        "name": "TestWriteToTimeout",
        "desc": ""
      },
      {
        "name": "TestWriteToUDP",
        "desc": ""
      },
      {
        "name": "TestWritevError",
        "desc": ""
      },
      {
        "name": "TestZeroByteRead",
        "desc": ""
      },
      {
        "name": "_C_free",
        "desc": ""
      },
      {
        "name": "_C_freeaddrinfo",
        "desc": ""
      },
      {
        "name": "_C_gai_strerror",
        "desc": ""
      },
      {
        "name": "_C_getaddrinfo",
        "desc": ""
      },
      {
        "name": "_C_malloc",
        "desc": ""
      },
      {
        "name": "_C_res_nclose",
        "desc": ""
      },
      {
        "name": "_C_res_ninit",
        "desc": ""
      },
      {
        "name": "_C_res_nsearch",
        "desc": ""
      },
      {
        "name": "absDomainName",
        "desc": "absDomainName returns an absolute domain name which ends with a trailing dot to match pure Go reverse resolver and all other lookup routines. See golang.org/issue/12189. But we don't want to add dots for local names from /etc/hosts. It's hard to tell so we settle on the heuristic that names without dots (like \"localhost\" or \"myhost\") do not get trailing dots, but any other names do."
      },
      {
        "name": "acquireThread",
        "desc": ""
      },
      {
        "name": "adapterAddresses",
        "desc": "adapterAddresses returns a list of IP adapter and address structures. The structure contains an IP adapter and flattened multiple IP addresses including unicast, anycast and multicast addresses."
      },
      {
        "name": "addCmdInheritedHandle",
        "desc": ""
      },
      {
        "name": "addrPortToSockaddrInet4",
        "desc": ""
      },
      {
        "name": "addrPortToSockaddrInet6",
        "desc": ""
      },
      {
        "name": "addrTable",
        "desc": ""
      },
      {
        "name": "allFF",
        "desc": ""
      },
      {
        "name": "allResolvers",
        "desc": ""
      },
      {
        "name": "avoidDNS",
        "desc": "avoidDNS reports whether this is a hostname for which we should not use DNS. Currently this includes only .onion, per RFC 7686. See golang.org/issue/13705. Does not cover .local names (RFC 6762), see golang.org/issue/16739."
      },
      {
        "name": "benchSplice",
        "desc": ""
      },
      {
        "name": "benchmarkIPEqual",
        "desc": ""
      },
      {
        "name": "benchmarkIPString",
        "desc": ""
      },
      {
        "name": "benchmarkSendFile",
        "desc": ""
      },
      {
        "name": "benchmarkSpliceFile",
        "desc": ""
      },
      {
        "name": "benchmarkTCP",
        "desc": ""
      },
      {
        "name": "benchmarkTCPConcurrentReadWrite",
        "desc": ""
      },
      {
        "name": "boolint",
        "desc": "Boolean to int."
      },
      {
        "name": "canCreateMPTCPSocket",
        "desc": ""
      },
      {
        "name": "canUseConnectEx",
        "desc": "canUseConnectEx reports whether we can use the ConnectEx Windows API call for the given network type."
      },
      {
        "name": "cgoLookupAddrPTR",
        "desc": ""
      },
      {
        "name": "cgoLookupCNAME",
        "desc": ""
      },
      {
        "name": "cgoLookupHost",
        "desc": ""
      },
      {
        "name": "cgoLookupHostIP",
        "desc": ""
      },
      {
        "name": "cgoLookupIP",
        "desc": ""
      },
      {
        "name": "cgoLookupPTR",
        "desc": ""
      },
      {
        "name": "cgoLookupPort",
        "desc": ""
      },
      {
        "name": "cgoLookupServicePort",
        "desc": ""
      },
      {
        "name": "cgoNameinfoPTR",
        "desc": ""
      },
      {
        "name": "cgoResSearch",
        "desc": ""
      },
      {
        "name": "cgoSockaddr",
        "desc": ""
      },
      {
        "name": "cgoSockaddrInet4",
        "desc": ""
      },
      {
        "name": "cgoSockaddrInet6",
        "desc": ""
      },
      {
        "name": "checkDistribution",
        "desc": ""
      },
      {
        "name": "checkDualStackAddrFamily",
        "desc": ""
      },
      {
        "name": "checkDualStackSecondListener",
        "desc": ""
      },
      {
        "name": "checkFirstListener",
        "desc": ""
      },
      {
        "name": "checkGetmac",
        "desc": "check that getmac exists as a powershell command, and that it speaks English."
      },
      {
        "name": "checkHeader",
        "desc": "checkHeader performs basic sanity checks on the header."
      },
      {
        "name": "checkMulticastListener",
        "desc": ""
      },
      {
        "name": "checkMulticastStats",
        "desc": ""
      },
      {
        "name": "checkNetsh",
        "desc": ""
      },
      {
        "name": "checkResponse",
        "desc": ""
      },
      {
        "name": "checkSecondListener",
        "desc": ""
      },
      {
        "name": "checkUnicastStats",
        "desc": ""
      },
      {
        "name": "commonPrefixLen",
        "desc": "commonPrefixLen reports the length of the longest prefix (looking at the most significant, or leftmost, bits) that the two addresses have in common, up to the length of a's prefix (i.e., the portion of the address not including the interface ID).  If a or b is an IPv4 address as an IPv6 address, the IPv4 addresses are compared (with max common prefix length of 32). If a and b are different IP versions, 0 is returned.  See https://tools.ietf.org/html/rfc6724#section-2.2"
      },
      {
        "name": "compareByRFC6724",
        "desc": "compareByRFC6724 compares two byRFC6724Info records and returns an integer indicating the order. It follows the algorithm and variable names from RFC 6724 section 6. Returns -1 if a is preferred, 1 if b is preferred, and 0 if they are equal."
      },
      {
        "name": "concurrentThreadsLimit",
        "desc": "concurrentThreadsLimit returns the number of threads we permit to run concurrently doing DNS lookups."
      },
      {
        "name": "condFatalf",
        "desc": ""
      },
      {
        "name": "controlOnConnSetup",
        "desc": ""
      },
      {
        "name": "controlRawConn",
        "desc": ""
      },
      {
        "name": "countAnyByte",
        "desc": "Count occurrences in s of any bytes in t."
      },
      {
        "name": "createTempFile",
        "desc": ""
      },
      {
        "name": "dialClosedPort",
        "desc": ""
      },
      {
        "name": "dialPlan9",
        "desc": ""
      },
      {
        "name": "dialPlan9Blocking",
        "desc": ""
      },
      {
        "name": "dialerMPTCP",
        "desc": ""
      },
      {
        "name": "differentWildcardAddr",
        "desc": ""
      },
      {
        "name": "disableSocketConnect",
        "desc": ""
      },
      {
        "name": "dnsDefaultSearch",
        "desc": ""
      },
      {
        "name": "dnsPacketRoundTrip",
        "desc": ""
      },
      {
        "name": "dnsStreamRoundTrip",
        "desc": ""
      },
      {
        "name": "doBlockingWithCtx",
        "desc": "doBlockingWithCtx executes a blocking function in a separate goroutine when the provided context is cancellable. It is intended for use with calls that don't support context cancellation (cgo, syscalls). blocking func may still be running after this function finishes. For the duration of the execution of the blocking function, the thread is 'acquired' using [acquireThread], blocking might not be executed when the context gets canceled early."
      },
      {
        "name": "dtoi",
        "desc": "Decimal to integer. Returns number, characters consumed, success."
      },
      {
        "name": "dupFileSocket",
        "desc": ""
      },
      {
        "name": "dupSocket",
        "desc": ""
      },
      {
        "name": "emitDNSNameTest",
        "desc": ""
      },
      {
        "name": "enableSocketConnect",
        "desc": ""
      },
      {
        "name": "ensureRooted",
        "desc": ""
      },
      {
        "name": "equalASCIIName",
        "desc": ""
      },
      {
        "name": "expectSendfile",
        "desc": "expectSendfile runs f, and verifies that internal/poll.SendFile successfully handles a write to wantConn during f's execution.  On platforms where supportsSendfile() is false, expectSendfile runs f but does not expect a call to SendFile."
      },
      {
        "name": "extractExtendedRCode",
        "desc": "extractExtendedRCode extracts the extended RCode from the OPT resource (EDNS(0)) If an OPT record is not found, the RCode from the hdr is returned. Another return value indicates whether an additional resource was found."
      },
      {
        "name": "fakeConnect",
        "desc": ""
      },
      {
        "name": "fakeListen",
        "desc": ""
      },
      {
        "name": "favoriteAddrFamily",
        "desc": "favoriteAddrFamily returns the appropriate address family for the given network, laddr, raddr and mode.  If mode indicates \"listen\" and laddr is a wildcard, we assume that the user wants to make a passive-open connection with a wildcard address family, both AF_INET and AF_INET6, and a wildcard address like the following:    - A listen for a wildcard communication domain, \"tcp\" or     \"udp\", with a wildcard address: If the platform supports     both IPv6 and IPv4-mapped IPv6 communication capabilities,     or does not support IPv4, we use a dual stack, AF_INET6 and     IPV6_V6ONLY=0, wildcard address listen. The dual stack     wildcard address listen may fall back to an IPv6-only,     AF_INET6 and IPV6_V6ONLY=1, wildcard address listen.     Otherwise we prefer an IPv4-only, AF_INET, wildcard address     listen.    - A listen for a wildcard communication domain, \"tcp\" or     \"udp\", with an IPv4 wildcard address: same as above.    - A listen for a wildcard communication domain, \"tcp\" or     \"udp\", with an IPv6 wildcard address: same as above.    - A listen for an IPv4 communication domain, \"tcp4\" or \"udp4\",     with an IPv4 wildcard address: We use an IPv4-only, AF_INET,     wildcard address listen.    - A listen for an IPv6 communication domain, \"tcp6\" or \"udp6\",     with an IPv6 wildcard address: We use an IPv6-only, AF_INET6     and IPV6_V6ONLY=1, wildcard address listen.  Otherwise guess: If the addresses are IPv4 then returns AF_INET, or else returns AF_INET6. It also returns a boolean value what designates IPV6_V6ONLY option.  Note that the latest DragonFly BSD and OpenBSD kernels allow neither \"net.inet6.ip6.v6only=1\" change nor IPPROTO_IPV6 level IPV6_V6ONLY socket option setting.  favoriteAddrFamily should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/database64128/tfo-go/v2   - github.com/metacubex/tfo-go   - github.com/sagernet/tfo-go  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "fd_fdstat_get_type",
        "desc": "This helper is implemented in the syscall package. It means we don't have to redefine the fd_fdstat_get host import or the fdstat struct it populates."
      },
      {
        "name": "fetchGoogle",
        "desc": ""
      },
      {
        "name": "fileConn",
        "desc": ""
      },
      {
        "name": "fileConnNet",
        "desc": ""
      },
      {
        "name": "fileListenNet",
        "desc": ""
      },
      {
        "name": "fileListener",
        "desc": ""
      },
      {
        "name": "filePacketConn",
        "desc": ""
      },
      {
        "name": "filterAddrList",
        "desc": "filterAddrList applies a filter to a list of IP addresses, yielding a list of Addr objects. Known filters are nil, ipv4only, and ipv6only. It returns every address when the filter is nil. The result contains at least one address when error is nil."
      },
      {
        "name": "fixErr",
        "desc": ""
      },
      {
        "name": "forceCgoDNS",
        "desc": "forceCgoDNS forces the resolver configuration to use the cgo resolver and returns a fixup function to restore the old settings."
      },
      {
        "name": "forceCloseSockets",
        "desc": "forceCloseSockets must be called only from TestMain."
      },
      {
        "name": "forceGoDNS",
        "desc": "forceGoDNS forces the resolver configuration to use the pure Go resolver and returns a fixup function to restore the old settings."
      },
      {
        "name": "foreachField",
        "desc": "foreachField runs fn on each non-empty run of non-space bytes in x. It returns the first non-nil error returned by fn."
      },
      {
        "name": "genericReadFrom",
        "desc": "Fallback implementation of io.ReaderFrom's ReadFrom, when sendfile isn't applicable."
      },
      {
        "name": "genericWriteTo",
        "desc": "Fallback implementation of io.WriterTo's WriteTo, when zero-copy isn't applicable."
      },
      {
        "name": "getCurrentKeepAliveSettings",
        "desc": ""
      },
      {
        "name": "getFields",
        "desc": ""
      },
      {
        "name": "getIfList",
        "desc": ""
      },
      {
        "name": "getprotobyname",
        "desc": ""
      },
      {
        "name": "goDebugNetDNS",
        "desc": "goDebugNetDNS parses the value of the GODEBUG \"netdns\" value. The netdns value can be of the form:  \t1       // debug level 1 \t2       // debug level 2 \tcgo     // use cgo for DNS lookups \tgo      // use go for DNS lookups \tcgo+1   // use cgo for DNS lookups + debug level 1 \t1+cgo   // same \tcgo+2   // same, but debug level 2  etc."
      },
      {
        "name": "goLookupIPFiles",
        "desc": "lookup entries from /etc/hosts"
      },
      {
        "name": "goLookupPort",
        "desc": "goLookupPort is the native Go implementation of LookupPort."
      },
      {
        "name": "googleLiteralAddrs",
        "desc": ""
      },
      {
        "name": "goosPrefersCgo",
        "desc": "goosPrefersCgo reports whether the GOOS value passed in prefers the cgo resolver."
      },
      {
        "name": "handlePlan9DNSError",
        "desc": ""
      },
      {
        "name": "hangupCtlWrite",
        "desc": ""
      },
      {
        "name": "hasFallenBack",
        "desc": "hasFallenBack reports whether the MPTCP connection has fallen back to \"plain\" TCP.  A connection can fallback to TCP for different reasons, e.g. the other peer doesn't support it, a middle box \"accidentally\" drops the option, etc.  If the MPTCP protocol has not been requested when creating the socket, this method will return true: MPTCP is not being used.  Kernel \u003e= 5.16 returns EOPNOTSUPP/ENOPROTOOPT in case of fallback. Older kernels will always return them even if MPTCP is used: not usable."
      },
      {
        "name": "hasSuffixFold",
        "desc": ""
      },
      {
        "name": "hasUpperCase",
        "desc": "hasUpperCase tells whether the given string contains at least one upper-case."
      },
      {
        "name": "hexString",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initConfVal",
        "desc": "initConfVal initializes confVal based on the environment that will not change during program execution."
      },
      {
        "name": "initMPTCPavailable",
        "desc": "Check that MPTCP is supported by attempting to create an MPTCP socket and by looking at the returned error if any."
      },
      {
        "name": "installAccept4TestHook",
        "desc": ""
      },
      {
        "name": "installTestHooks",
        "desc": ""
      },
      {
        "name": "interfaceAddrTable",
        "desc": "If the ifi is nil, interfaceAddrTable returns addresses for all network interfaces. Otherwise it returns addresses for a specific interface."
      },
      {
        "name": "interfaceByIndex",
        "desc": ""
      },
      {
        "name": "interfaceCount",
        "desc": ""
      },
      {
        "name": "interfaceMessages",
        "desc": ""
      },
      {
        "name": "interfaceMulticastAddrTable",
        "desc": "interfaceMulticastAddrTable returns addresses for a specific interface."
      },
      {
        "name": "interfaceTable",
        "desc": "If the ifindex is zero, interfaceTable returns mappings of all network interfaces. Otherwise it returns a mapping of a specific interface."
      },
      {
        "name": "interfaceToIPv4Addr",
        "desc": ""
      },
      {
        "name": "internetSocket",
        "desc": ""
      },
      {
        "name": "ipAddrsEface",
        "desc": "ipAddrsEface returns an empty interface slice of addrs."
      },
      {
        "name": "ipEmptyString",
        "desc": "ipEmptyString is like ip.String except that it returns an empty string when ip is unset."
      },
      {
        "name": "ipToSockaddr",
        "desc": "ipToSockaddr should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/database64128/tfo-go/v2   - github.com/metacubex/tfo-go   - github.com/sagernet/tfo-go  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "ipToSockaddrInet4",
        "desc": ""
      },
      {
        "name": "ipToSockaddrInet6",
        "desc": ""
      },
      {
        "name": "ipVersion",
        "desc": "ipVersion returns the provided network's IP version: '4', '6' or 0 if network does not end in a '4' or '6' byte."
      },
      {
        "name": "ipv4only",
        "desc": "ipv4only reports whether addr is an IPv4 address."
      },
      {
        "name": "ipv6LinkLocalUnicastAddr",
        "desc": "ipv6LinkLocalUnicastAddr returns an IPv6 link-local unicast address on the given network interface for tests. It returns \"\" if no suitable address is found."
      },
      {
        "name": "ipv6only",
        "desc": "ipv6only reports whether addr is an IPv6 address except IPv4-mapped IPv6 address."
      },
      {
        "name": "isClosedChan",
        "desc": ""
      },
      {
        "name": "isConnError",
        "desc": ""
      },
      {
        "name": "isDeadlineExceeded",
        "desc": "isDeadlineExceeded reports whether err is or wraps os.ErrDeadlineExceeded. We also check that the error implements net.Error, and that the Timeout method returns true."
      },
      {
        "name": "isDomainName",
        "desc": "isDomainName checks if a string is a presentation-format domain name (currently restricted to hostname-compatible \"preferred name\" LDH labels and SRV-like \"underscore labels\"; see golang.org/issue/12421).  isDomainName should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/sagernet/sing  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "isENOBUFS",
        "desc": ""
      },
      {
        "name": "isGateway",
        "desc": "isGateway reports whether h should be considered a \"gateway\" name for the myhostname NSS module."
      },
      {
        "name": "isIPv4",
        "desc": "isIPv4 reports whether addr contains an IPv4 address."
      },
      {
        "name": "isLocalhost",
        "desc": "isLocalhost reports whether h should be considered a \"localhost\" name for the myhostname NSS module."
      },
      {
        "name": "isNotIPv4",
        "desc": "isNotIPv4 reports whether addr does not contain an IPv4 address."
      },
      {
        "name": "isOutbound",
        "desc": "isOutbound reports whether h should be considered an \"outbound\" name for the myhostname NSS module."
      },
      {
        "name": "isPlatformError",
        "desc": ""
      },
      {
        "name": "isSpace",
        "desc": "isSpace reports whether b is an ASCII space character."
      },
      {
        "name": "isUsingMPTCPProto",
        "desc": "isUsingMPTCPProto reports whether the socket protocol is MPTCP.  Compared to hasFallenBack method, here only the socket protocol being used is checked: it can be MPTCP but it doesn't mean MPTCP is used on the wire, maybe a fallback to TCP has been done."
      },
      {
        "name": "isUsingMultipathTCP",
        "desc": "isUsingMultipathTCP reports whether MPTCP is still being used.  Please look at the description of hasFallenBack (kernel \u003e=5.16) and isUsingMPTCPProto methods for more details about what is being checked here."
      },
      {
        "name": "isWildcard",
        "desc": ""
      },
      {
        "name": "isZeros",
        "desc": "Is p all zeros?"
      },
      {
        "name": "joinIPv4Group",
        "desc": ""
      },
      {
        "name": "joinIPv6Group",
        "desc": ""
      },
      {
        "name": "listenIPv4MulticastUDP",
        "desc": ""
      },
      {
        "name": "listenIPv6MulticastUDP",
        "desc": ""
      },
      {
        "name": "listenPlan9",
        "desc": ""
      },
      {
        "name": "listenerBacklog",
        "desc": "listenerBacklog is a caching wrapper around maxListenerBacklog.  listenerBacklog should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/database64128/tfo-go/v2   - github.com/metacubex/tfo-go   - github.com/sagernet/tfo-go  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "localIP",
        "desc": ""
      },
      {
        "name": "lookupIPReturn",
        "desc": "lookupIPReturn turns the return values from singleflight.Do into the return values from LookupIP."
      },
      {
        "name": "lookupLocalhost",
        "desc": ""
      },
      {
        "name": "lookupPTR",
        "desc": ""
      },
      {
        "name": "lookupPortMap",
        "desc": ""
      },
      {
        "name": "lookupPortMapWithNetwork",
        "desc": ""
      },
      {
        "name": "lookupProtocol",
        "desc": "lookupProtocol looks up IP protocol name and returns correspondent protocol number."
      },
      {
        "name": "lookupProtocolMap",
        "desc": ""
      },
      {
        "name": "lookupSlowFast",
        "desc": ""
      },
      {
        "name": "lookupStaticAddr",
        "desc": "lookupStaticAddr looks up the hosts for the given address from /etc/hosts."
      },
      {
        "name": "lookupStaticHost",
        "desc": "lookupStaticHost looks up the addresses and the canonical name for the given host from /etc/hosts."
      },
      {
        "name": "lookupWithFake",
        "desc": ""
      },
      {
        "name": "lowerASCII",
        "desc": "lowerASCII returns the ASCII lowercase version of b."
      },
      {
        "name": "lowerASCIIBytes",
        "desc": "lowerASCIIBytes makes x ASCII lowercase in-place."
      },
      {
        "name": "mapErr",
        "desc": "mapErr maps from the context errors to the historical internal net error values."
      },
      {
        "name": "mapRCode",
        "desc": ""
      },
      {
        "name": "maxAckBacklog",
        "desc": "Linux stores the backlog as:    - uint16 in kernel version \u003c 4.1,   - uint32 in kernel version \u003e= 4.1  Truncate number to avoid wrapping.  See issue 5030 and 41470."
      },
      {
        "name": "maxListenerBacklog",
        "desc": ""
      },
      {
        "name": "maybeSkipKeepAliveTest",
        "desc": ""
      },
      {
        "name": "minNonzeroTime",
        "desc": ""
      },
      {
        "name": "mockTXTResponse",
        "desc": ""
      },
      {
        "name": "multicastRIBContains",
        "desc": ""
      },
      {
        "name": "mustHaveExternalNetwork",
        "desc": "mustHaveExternalNetwork is like testenv.MustHaveExternalNetwork except on non-Linux, non-mobile builders it permits the test to run in -short mode."
      },
      {
        "name": "mustNewName",
        "desc": ""
      },
      {
        "name": "mustQuestion",
        "desc": ""
      },
      {
        "name": "mustSetDeadline",
        "desc": "mustSetDeadline calls the bound method m to set a deadline on a Conn. If the call fails, mustSetDeadline skips t if the current GOOS is believed not to support deadlines, or fails the test otherwise."
      },
      {
        "name": "mxString",
        "desc": ""
      },
      {
        "name": "name",
        "desc": ""
      },
      {
        "name": "netshInterfaceIPShowInterface",
        "desc": ""
      },
      {
        "name": "netshInterfaceIPv4ShowAddress",
        "desc": ""
      },
      {
        "name": "netshInterfaceIPv6ShowAddress",
        "desc": ""
      },
      {
        "name": "networkNumberAndMask",
        "desc": ""
      },
      {
        "name": "newDualStackListener",
        "desc": ""
      },
      {
        "name": "newDualStackPacketListener",
        "desc": ""
      },
      {
        "name": "newDualStackServer",
        "desc": ""
      },
      {
        "name": "newFD",
        "desc": ""
      },
      {
        "name": "newFileFD",
        "desc": ""
      },
      {
        "name": "newRandReader",
        "desc": ""
      },
      {
        "name": "newRequest",
        "desc": ""
      },
      {
        "name": "newResolvConfTest",
        "desc": ""
      },
      {
        "name": "newResolverDialFunc",
        "desc": ""
      },
      {
        "name": "newUnixFile",
        "desc": "Defined in os package."
      },
      {
        "name": "newWindowsFile",
        "desc": "Defined in os package."
      },
      {
        "name": "nextTimeout",
        "desc": "nextTimeout returns the next timeout to try after an operation took the given actual duration with a timeout shorter than that duration."
      },
      {
        "name": "nsString",
        "desc": ""
      },
      {
        "name": "nslookup",
        "desc": ""
      },
      {
        "name": "nslookupCNAME",
        "desc": ""
      },
      {
        "name": "nslookupMX",
        "desc": ""
      },
      {
        "name": "nslookupNS",
        "desc": ""
      },
      {
        "name": "nslookupTXT",
        "desc": ""
      },
      {
        "name": "open",
        "desc": ""
      },
      {
        "name": "packetConnTestData",
        "desc": ""
      },
      {
        "name": "packetTransceiver",
        "desc": ""
      },
      {
        "name": "packetTransponder",
        "desc": ""
      },
      {
        "name": "parseAcceptError",
        "desc": "parseAcceptError parses nestedErr and reports whether it is a valid error value from Accept functions. It returns nil when nestedErr is valid."
      },
      {
        "name": "parseCNAMEFromResources",
        "desc": ""
      },
      {
        "name": "parseCloseError",
        "desc": "parseCloseError parses nestedErr and reports whether it is a valid error value from Close functions. It returns nil when nestedErr is valid."
      },
      {
        "name": "parseCommonError",
        "desc": "parseCommonError parses nestedErr and reports whether it is a valid error value from miscellaneous functions. It returns nil when nestedErr is valid."
      },
      {
        "name": "parseCriteria",
        "desc": "parses \"foo=bar !foo=bar\""
      },
      {
        "name": "parseDialError",
        "desc": "parseDialError parses nestedErr and reports whether it is a valid error value from Dial, Listen functions. It returns nil when nestedErr is valid."
      },
      {
        "name": "parseIP",
        "desc": ""
      },
      {
        "name": "parseLiteralIP",
        "desc": ""
      },
      {
        "name": "parseLookupPortError",
        "desc": ""
      },
      {
        "name": "parseNetwork",
        "desc": ""
      },
      {
        "name": "parsePlan9Addr",
        "desc": "parsePlan9Addr parses address of the form [ip!]port (e.g. 127.0.0.1!80)."
      },
      {
        "name": "parsePort",
        "desc": "parsePort parses service as a decimal integer and returns the corresponding value as port. It is the caller's responsibility to parse service as a non-decimal integer when needsLookup is true.  Some system resolvers will return a valid port number when given a number over 65536 (see https://golang.org/issues/11715). Alas, the parser can't bail early on numbers \u003e 65536. Therefore reasonably large/small numbers are parsed in full and rejected if invalid."
      },
      {
        "name": "parseReadError",
        "desc": "parseReadError parses nestedErr and reports whether it is a valid error value from Read functions. It returns nil when nestedErr is valid."
      },
      {
        "name": "parseWriteError",
        "desc": "parseWriteError parses nestedErr and reports whether it is a valid error value from Write functions. It returns nil when nestedErr is valid."
      },
      {
        "name": "partialDeadline",
        "desc": "partialDeadline returns the deadline to use for a single address, when multiple addresses are pending."
      },
      {
        "name": "ping",
        "desc": ""
      },
      {
        "name": "plan9LocalAddr",
        "desc": "plan9LocalAddr returns a Plan 9 local address string. See setladdrport at https://9p.io/sources/plan9/sys/src/9/ip/devip.c."
      },
      {
        "name": "postAcceptMPTCP",
        "desc": ""
      },
      {
        "name": "printInflightSockets",
        "desc": ""
      },
      {
        "name": "printRunningGoroutines",
        "desc": ""
      },
      {
        "name": "printSocketStats",
        "desc": ""
      },
      {
        "name": "probe",
        "desc": ""
      },
      {
        "name": "query",
        "desc": ""
      },
      {
        "name": "queryCS",
        "desc": ""
      },
      {
        "name": "queryCS1",
        "desc": ""
      },
      {
        "name": "queryDNS",
        "desc": ""
      },
      {
        "name": "randInt",
        "desc": ""
      },
      {
        "name": "randIntn",
        "desc": ""
      },
      {
        "name": "readHosts",
        "desc": ""
      },
      {
        "name": "readInterface",
        "desc": ""
      },
      {
        "name": "readPlan9Addr",
        "desc": ""
      },
      {
        "name": "readRawConn",
        "desc": ""
      },
      {
        "name": "readServices",
        "desc": ""
      },
      {
        "name": "releaseThread",
        "desc": ""
      },
      {
        "name": "removeComment",
        "desc": "removeComment returns line, removing any '#' byte and any following bytes."
      },
      {
        "name": "resSearch",
        "desc": "resSearch will make a call to the 'res_nsearch' routine in the C library and parse the output as a slice of DNS resources."
      },
      {
        "name": "resolveCNAME",
        "desc": "returns the last CNAME in chain."
      },
      {
        "name": "reverseaddr",
        "desc": "reverseaddr returns the in-addr.arpa. or ip6.arpa. hostname of the IP address addr suitable for rDNS (PTR) record lookup or an error if it fails to parse the IP address."
      },
      {
        "name": "roundDurationUp",
        "desc": "roundDurationUp rounds d to the next multiple of to."
      },
      {
        "name": "runCmd",
        "desc": ""
      },
      {
        "name": "runningGoroutines",
        "desc": "runningGoroutines returns a list of remaining goroutines."
      },
      {
        "name": "runtime_rand",
        "desc": "provided by runtime"
      },
      {
        "name": "samePlatformError",
        "desc": ""
      },
      {
        "name": "selfConnect",
        "desc": ""
      },
      {
        "name": "sendFile",
        "desc": "sendFile copies the contents of r to c using the sendfile system call to minimize copies.  if handled == true, sendFile returns the number (potentially zero) of bytes copied and any non-EOF error.  if handled == false, sendFile performed no work."
      },
      {
        "name": "setDefaultListenerSockopts",
        "desc": ""
      },
      {
        "name": "setDefaultMulticastSockopts",
        "desc": ""
      },
      {
        "name": "setDefaultSockopts",
        "desc": ""
      },
      {
        "name": "setIPv4MreqToInterface",
        "desc": ""
      },
      {
        "name": "setIPv4MulticastInterface",
        "desc": ""
      },
      {
        "name": "setIPv4MulticastLoopback",
        "desc": ""
      },
      {
        "name": "setIPv6MulticastInterface",
        "desc": ""
      },
      {
        "name": "setIPv6MulticastLoopback",
        "desc": ""
      },
      {
        "name": "setKeepAlive",
        "desc": ""
      },
      {
        "name": "setKeepAliveCount",
        "desc": ""
      },
      {
        "name": "setKeepAliveIdle",
        "desc": "Set keep alive period."
      },
      {
        "name": "setKeepAliveIdleAndInterval",
        "desc": "setKeepAliveIdleAndInterval serves for kernels prior to Windows 10, version 1709."
      },
      {
        "name": "setKeepAliveIdleAndIntervalAndCount",
        "desc": "setKeepAliveIdleAndIntervalAndCount serves for Solaris prior to 11.4 by simulating the TCP_KEEPIDLE, TCP_KEEPINTVL, and TCP_KEEPCNT with `TCP_KEEPALIVE_THRESHOLD` + `TCP_KEEPALIVE_ABORT_THRESHOLD`."
      },
      {
        "name": "setKeepAliveInterval",
        "desc": ""
      },
      {
        "name": "setLinger",
        "desc": ""
      },
      {
        "name": "setNoDelay",
        "desc": ""
      },
      {
        "name": "setReadBuffer",
        "desc": ""
      },
      {
        "name": "setReadMsgCloseOnExec",
        "desc": ""
      },
      {
        "name": "setSystemNSS",
        "desc": ""
      },
      {
        "name": "setWriteBuffer",
        "desc": ""
      },
      {
        "name": "setupTestData",
        "desc": ""
      },
      {
        "name": "simpleMaskLength",
        "desc": "If mask is a sequence of 1 bits followed by 0 bits, return the number of 1 bits."
      },
      {
        "name": "skipToAnswer",
        "desc": ""
      },
      {
        "name": "slowDialTCP",
        "desc": "In some environments, the slow IPs may be explicitly unreachable, and fail more quickly than expected. This test hook prevents dialTCP from returning before the deadline."
      },
      {
        "name": "socket",
        "desc": "socket returns a network file descriptor that is ready for I/O using the fake network."
      },
      {
        "name": "sortByRFC6724",
        "desc": ""
      },
      {
        "name": "sortByRFC6724withSrcs",
        "desc": ""
      },
      {
        "name": "sortedIPStrings",
        "desc": ""
      },
      {
        "name": "sotypeToNet",
        "desc": ""
      },
      {
        "name": "spliceFrom",
        "desc": "spliceFrom transfers data from r to c using the splice system call to minimize copies from and to userspace. c must be a TCP connection. Currently, spliceFrom is only enabled if r is a TCP or a stream-oriented Unix connection.  If spliceFrom returns handled == false, it has performed no work."
      },
      {
        "name": "spliceTo",
        "desc": "spliceTo transfers data from c to w using the splice system call to minimize copies from and to userspace. c must be a TCP connection. Currently, spliceTo is only enabled if w is a stream-oriented Unix connection.  If spliceTo returns handled == false, it has performed no work."
      },
      {
        "name": "splitAtBytes",
        "desc": "Split s at any bytes in t."
      },
      {
        "name": "splitHostZone",
        "desc": ""
      },
      {
        "name": "spuriousENOTAVAIL",
        "desc": ""
      },
      {
        "name": "srcAddrs",
        "desc": "srcAddrs tries to UDP-connect to each address to see if it has a route. (This doesn't send any packets). The destination port number is irrelevant."
      },
      {
        "name": "srvString",
        "desc": ""
      },
      {
        "name": "startPlan9",
        "desc": ""
      },
      {
        "name": "startTestSocketPeer",
        "desc": ""
      },
      {
        "name": "stat",
        "desc": ""
      },
      {
        "name": "stringsEqualFold",
        "desc": "stringsEqualFold is strings.EqualFold, ASCII only. It reports whether s and t are equal, ASCII-case-insensitively."
      },
      {
        "name": "stringsHasSuffixFold",
        "desc": "stringsHasSuffixFold reports whether s ends in suffix, ASCII-case-insensitively."
      },
      {
        "name": "stripIPv4Header",
        "desc": ""
      },
      {
        "name": "supportsIPv4",
        "desc": "supportsIPv4 reports whether the platform supports IPv4 networking functionality."
      },
      {
        "name": "supportsIPv4map",
        "desc": "supportsIPv4map reports whether the platform supports mapping an IPv4 address inside an IPv6 address at transport layer protocols. See RFC 4291, RFC 4038 and RFC 3493."
      },
      {
        "name": "supportsIPv6",
        "desc": "supportsIPv6 reports whether the platform supports IPv6 networking functionality."
      },
      {
        "name": "supportsMultipathTCP",
        "desc": ""
      },
      {
        "name": "supportsSendfile",
        "desc": "Always true except for workstation and client versions of Windows"
      },
      {
        "name": "supportsUnixSocket",
        "desc": ""
      },
      {
        "name": "sysSocket",
        "desc": "Wrapper around the socket system call that marks the returned file descriptor as nonblocking and close-on-exec."
      },
      {
        "name": "testBuffer_writeTo",
        "desc": ""
      },
      {
        "name": "testDNSPacketSize",
        "desc": ""
      },
      {
        "name": "testDots",
        "desc": ""
      },
      {
        "name": "testGoLookupIPCNAMEOrderHostsAliases",
        "desc": ""
      },
      {
        "name": "testIsTCPAddr",
        "desc": ""
      },
      {
        "name": "testIsUDPAddr",
        "desc": ""
      },
      {
        "name": "testLookup",
        "desc": ""
      },
      {
        "name": "testLookupNoData",
        "desc": ""
      },
      {
        "name": "testLookupStaticHostAliases",
        "desc": ""
      },
      {
        "name": "testMultiPathTCP",
        "desc": ""
      },
      {
        "name": "testRotate",
        "desc": ""
      },
      {
        "name": "testSendfile",
        "desc": ""
      },
      {
        "name": "testSplice",
        "desc": ""
      },
      {
        "name": "testSpliceIssue25985",
        "desc": ""
      },
      {
        "name": "testSpliceNoUnixgram",
        "desc": ""
      },
      {
        "name": "testSpliceNoUnixpacket",
        "desc": ""
      },
      {
        "name": "testSpliceReaderAtEOF",
        "desc": ""
      },
      {
        "name": "testSpliceToFile",
        "desc": ""
      },
      {
        "name": "testStaticAddr",
        "desc": ""
      },
      {
        "name": "testStaticHost",
        "desc": ""
      },
      {
        "name": "testUniformity",
        "desc": ""
      },
      {
        "name": "testUnixAddr",
        "desc": "testUnixAddr uses os.MkdirTemp to get a name that is unique."
      },
      {
        "name": "testUnixgramWriteConn",
        "desc": ""
      },
      {
        "name": "testUnixgramWritePacketConn",
        "desc": ""
      },
      {
        "name": "testVariousDeadlines",
        "desc": ""
      },
      {
        "name": "testWeighting",
        "desc": ""
      },
      {
        "name": "testWriteToConn",
        "desc": ""
      },
      {
        "name": "testWriteToPacketConn",
        "desc": ""
      },
      {
        "name": "testableAddress",
        "desc": "testableAddress reports whether address of network is testable on the current platform configuration."
      },
      {
        "name": "testableListenArgs",
        "desc": "testableListenArgs reports whether arguments are testable on the current platform configuration."
      },
      {
        "name": "testableNetwork",
        "desc": "testableNetwork reports whether network is testable on the current platform configuration."
      },
      {
        "name": "timeoutUpperBound",
        "desc": "timeoutUpperBound returns the maximum time that we expect a timeout of duration d to take to return the caller."
      },
      {
        "name": "toErrno",
        "desc": ""
      },
      {
        "name": "toJson",
        "desc": ""
      },
      {
        "name": "toLower",
        "desc": "toLower returns a lower-case version of in. Restricting us to ASCII is sufficient to handle the IP protocol names and allow us to not depend on the strings and unicode packages."
      },
      {
        "name": "transceiver",
        "desc": ""
      },
      {
        "name": "trimSpace",
        "desc": "trimSpace returns x without any leading or trailing ASCII whitespace."
      },
      {
        "name": "uninstallAccept4TestHook",
        "desc": ""
      },
      {
        "name": "uninstallTestHooks",
        "desc": ""
      },
      {
        "name": "unixSocket",
        "desc": ""
      },
      {
        "name": "validRecs",
        "desc": "returns only results applicable to name and resolves CNAME entries."
      },
      {
        "name": "validateInterfaceMulticastAddrs",
        "desc": ""
      },
      {
        "name": "validateInterfaceUnicastAddrs",
        "desc": ""
      },
      {
        "name": "validateResolvedAddr",
        "desc": ""
      },
      {
        "name": "verifyKeepAliveSettings",
        "desc": ""
      },
      {
        "name": "verifySpliceFds",
        "desc": ""
      },
      {
        "name": "winError",
        "desc": ""
      },
      {
        "name": "withTCPConnPair",
        "desc": "withTCPConnPair sets up a TCP connection between two peers, then runs peer1 and peer2 concurrently. withTCPConnPair returns when both have completed."
      },
      {
        "name": "withUnexpiredValuesPreserved",
        "desc": "withUnexpiredValuesPreserved returns a context.Context that only uses lookupCtx for its values, otherwise it is never canceled and has no deadline. If the lookup context expires, any looked up values will return nil. See Issue 28600."
      },
      {
        "name": "wrapSyscallError",
        "desc": "wrapSyscallError takes an error and a syscall name. If the error is a syscall.Errno, it wraps it in an os.SyscallError using the syscall name."
      },
      {
        "name": "writeRawConn",
        "desc": ""
      },
      {
        "name": "xtoi",
        "desc": "Hexadecimal to integer. Returns number, characters consumed, success."
      },
      {
        "name": "xtoi2",
        "desc": "xtoi2 converts the next two hex digits of s into a byte. If s is longer than 2 bytes then the third byte must be e. If the first two bytes of s are not hex digits or the third byte does not match e, false is returned."
      },
      {
        "name": "AddIP",
        "desc": ""
      },
      {
        "name": "AddIP",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": "Read from the buffers.  Read implements [io.Reader] for [Buffers].  Read modifies the slice v as well as v[i] for 0 \u003c= i \u003c len(v), but does not modify v[i][j] for any i, j."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo writes contents of the buffers to w.  WriteTo implements [io.WriterTo] for [Buffers].  WriteTo modifies the slice v as well as v[i] for 0 \u003c= i \u003c len(v), but does not modify v[i][j] for any i, j."
      },
      {
        "name": "consume",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": "Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a [DNSError] for which Temporary returns false."
      },
      {
        "name": "Timeout",
        "desc": "Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a [DNSError] for which Timeout returns false."
      },
      {
        "name": "Unwrap",
        "desc": "Unwrap returns e.UnwrapErr."
      },
      {
        "name": "Dial",
        "desc": "Dial connects to the address on the named network.  See func Dial for a description of the network and address parameters.  Dial uses [context.Background] internally; to specify the context, use [Dialer.DialContext]."
      },
      {
        "name": "DialContext",
        "desc": "DialContext connects to the address on the named network using the provided context.  The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection.  When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one.  See func [Dial] for a description of the network and address parameters."
      },
      {
        "name": "MultipathTCP",
        "desc": "MultipathTCP reports whether MPTCP will be used.  This method doesn't check if MPTCP is supported by the operating system or not."
      },
      {
        "name": "SetMultipathTCP",
        "desc": "SetMultipathTCP directs the [Dial] methods to use, or not use, MPTCP, if supported by the operating system. This method overrides the system default and the GODEBUG=multipathtcp=... setting if any.  If MPTCP is not available on the host or not supported by the server, the Dial methods will fall back to TCP."
      },
      {
        "name": "deadline",
        "desc": "deadline returns the earliest of:   - now+Timeout   - d.Deadline   - the context's deadline  Or zero, if none of Timeout, Deadline, or context's deadline is set."
      },
      {
        "name": "dualStack",
        "desc": ""
      },
      {
        "name": "fallbackDelay",
        "desc": ""
      },
      {
        "name": "resolver",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface. The encoding is the same as returned by [IP.String], with one exception: When len(ip) is zero, it appends nothing."
      },
      {
        "name": "DefaultMask",
        "desc": "DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal."
      },
      {
        "name": "IsGlobalUnicast",
        "desc": "IsGlobalUnicast reports whether ip is a global unicast address.  The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space."
      },
      {
        "name": "IsInterfaceLocalMulticast",
        "desc": "IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address."
      },
      {
        "name": "IsLinkLocalMulticast",
        "desc": "IsLinkLocalMulticast reports whether ip is a link-local multicast address."
      },
      {
        "name": "IsLinkLocalUnicast",
        "desc": "IsLinkLocalUnicast reports whether ip is a link-local unicast address."
      },
      {
        "name": "IsLoopback",
        "desc": "IsLoopback reports whether ip is a loopback address."
      },
      {
        "name": "IsMulticast",
        "desc": "IsMulticast reports whether ip is a multicast address."
      },
      {
        "name": "IsPrivate",
        "desc": "IsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses)."
      },
      {
        "name": "IsUnspecified",
        "desc": "IsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\"."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface. The encoding is the same as returned by [IP.String], with one exception: When len(ip) is zero, it returns an empty slice."
      },
      {
        "name": "Mask",
        "desc": "Mask returns the result of masking the IP address ip with mask."
      },
      {
        "name": "String",
        "desc": "String returns the string form of the IP address ip. It returns one of 4 forms:   - \"\u003cnil\u003e\", if ip has length 0   - dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address   - IPv6 conforming to RFC 5952 (\"2001:db8::1\"), if ip is a valid IPv6 address   - the hexadecimal form of ip, without punctuation, if no other cases apply"
      },
      {
        "name": "To16",
        "desc": "To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil."
      },
      {
        "name": "To4",
        "desc": "To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the [encoding.TextUnmarshaler] interface. The IP address is expected in a form accepted by [ParseIP]."
      },
      {
        "name": "appendTo",
        "desc": "appendTo appends the string representation of ip to b and returns the expanded b If len(ip) != IPv4len or IPv6len, it appends nothing."
      },
      {
        "name": "matchAddrFamily",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": "Network returns the address's network name, \"ip\"."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "family",
        "desc": ""
      },
      {
        "name": "isWildcard",
        "desc": ""
      },
      {
        "name": "opAddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "toLocal",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "ReadFrom",
        "desc": "ReadFrom implements the [PacketConn] ReadFrom method."
      },
      {
        "name": "ReadFromIP",
        "desc": "ReadFromIP acts like ReadFrom but returns an IPAddr."
      },
      {
        "name": "ReadMsgIP",
        "desc": "ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.  The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "SyscallConn",
        "desc": "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "WriteMsgIP",
        "desc": "WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.  The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo implements the [PacketConn] WriteTo method."
      },
      {
        "name": "WriteToIP",
        "desc": "WriteToIP acts like [IPConn.WriteTo] but takes an [IPAddr]."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "readFrom",
        "desc": ""
      },
      {
        "name": "readMsg",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "writeMsg",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": "Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0."
      },
      {
        "name": "String",
        "desc": "String returns the hexadecimal form of m, with no punctuation."
      },
      {
        "name": "Contains",
        "desc": "Contains reports whether the network includes ip."
      },
      {
        "name": "Network",
        "desc": "Network returns the address's network name, \"ip+net\"."
      },
      {
        "name": "String",
        "desc": "String returns the CIDR notation of n like \"192.0.2.0/24\" or \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like \"198.51.100.0/c000ff00\"."
      },
      {
        "name": "Addrs",
        "desc": "Addrs returns a list of unicast interface addresses for a specific interface."
      },
      {
        "name": "MulticastAddrs",
        "desc": "MulticastAddrs returns a list of multicast, joined group addresses for a specific interface."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Listen",
        "desc": "Listen announces on the local network address.  See func Listen for a description of the network and address parameters.  The ctx argument is used while resolving the address on which to listen; it does not affect the returned Listener."
      },
      {
        "name": "ListenPacket",
        "desc": "ListenPacket announces on the local network address.  See func ListenPacket for a description of the network and address parameters.  The ctx argument is used while resolving the address on which to listen; it does not affect the returned PacketConn."
      },
      {
        "name": "MultipathTCP",
        "desc": "MultipathTCP reports whether MPTCP will be used.  This method doesn't check if MPTCP is supported by the operating system or not."
      },
      {
        "name": "SetMultipathTCP",
        "desc": "SetMultipathTCP directs the [Listen] method to use, or not use, MPTCP, if supported by the operating system. This method overrides the system default and the GODEBUG=multipathtcp=... setting if any.  If MPTCP is not available on the host or not supported by the client, the Listen method will fall back to TCP."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "isValid",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "LookupAddr",
        "desc": "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.  The returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any."
      },
      {
        "name": "LookupCNAME",
        "desc": "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call [LookupHost] or [LookupIP] directly; both take care of resolving the canonical name as part of the lookup.  A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS \"CNAME\" records, as long as host resolves to address records.  The returned canonical name is validated to be a properly formatted presentation-format domain name."
      },
      {
        "name": "LookupHost",
        "desc": "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses."
      },
      {
        "name": "LookupIP",
        "desc": "LookupIP looks up host for the given network using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. network must be one of \"ip\", \"ip4\" or \"ip6\"."
      },
      {
        "name": "LookupIPAddr",
        "desc": "LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses."
      },
      {
        "name": "LookupMX",
        "desc": "LookupMX returns the DNS MX records for the given domain name sorted by preference.  The returned mail server names are validated to be properly formatted presentation-format domain names, or numeric IP addresses. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any."
      },
      {
        "name": "LookupNS",
        "desc": "LookupNS returns the DNS NS records for the given domain name.  The returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any."
      },
      {
        "name": "LookupNetIP",
        "desc": "LookupNetIP looks up host using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. The network must be one of \"ip\", \"ip4\" or \"ip6\"."
      },
      {
        "name": "LookupPort",
        "desc": "LookupPort looks up the port for the given network and service.  The network must be one of \"tcp\", \"tcp4\", \"tcp6\", \"udp\", \"udp4\", \"udp6\" or \"ip\"."
      },
      {
        "name": "LookupSRV",
        "desc": "LookupSRV tries to resolve an [SRV] query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.  LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.  The returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any."
      },
      {
        "name": "LookupTXT",
        "desc": "LookupTXT returns the DNS TXT records for the given domain name.  If a DNS TXT record holds multiple strings, they are concatenated as a single string."
      },
      {
        "name": "dial",
        "desc": "dial makes a new connection to the provided server (which must be an IP address) with the provided network type, using either r.Dial (if both r and r.Dial are non-nil) or else Dialer.DialContext."
      },
      {
        "name": "exchange",
        "desc": "exchange sends a query on the connection and hopes for a response."
      },
      {
        "name": "getLookupGroup",
        "desc": ""
      },
      {
        "name": "goLookupCNAME",
        "desc": "goLookupCNAME is the native Go (non-cgo) implementation of LookupCNAME."
      },
      {
        "name": "goLookupHostOrder",
        "desc": ""
      },
      {
        "name": "goLookupIP",
        "desc": "goLookupIP is the native Go implementation of LookupIP. The libc versions are in cgo_*.go."
      },
      {
        "name": "goLookupIPCNAMEOrder",
        "desc": ""
      },
      {
        "name": "goLookupMX",
        "desc": "goLookupMX returns the MX records for name."
      },
      {
        "name": "goLookupNS",
        "desc": "goLookupNS returns the NS records for name."
      },
      {
        "name": "goLookupPTR",
        "desc": "goLookupPTR is the native Go implementation of LookupAddr."
      },
      {
        "name": "goLookupSRV",
        "desc": "goLookupSRV returns the SRV records for a target name, built either from its component service (\"sip\"), protocol (\"tcp\"), and name (\"example.com.\"), or from name directly (if service and proto are both empty).  In either case, the returned target name (\"_sip._tcp.example.com.\") is also returned on success.  The records are sorted by weight."
      },
      {
        "name": "goLookupTXT",
        "desc": "goLookupTXT returns the TXT records from name."
      },
      {
        "name": "internetAddrList",
        "desc": "internetAddrList resolves addr, which may be a literal IP address or a DNS name, and returns a list of internet protocol family addresses. The result contains at least one address when error is nil."
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "lookupAddr",
        "desc": ""
      },
      {
        "name": "lookupCNAME",
        "desc": ""
      },
      {
        "name": "lookupHost",
        "desc": ""
      },
      {
        "name": "lookupIP",
        "desc": ""
      },
      {
        "name": "lookupIPAddr",
        "desc": "lookupIPAddr looks up host using the local resolver and particular network. It returns a slice of that host's IPv4 and IPv6 addresses."
      },
      {
        "name": "lookupMX",
        "desc": ""
      },
      {
        "name": "lookupNS",
        "desc": ""
      },
      {
        "name": "lookupPort",
        "desc": ""
      },
      {
        "name": "lookupPortWithNetwork",
        "desc": ""
      },
      {
        "name": "lookupSRV",
        "desc": ""
      },
      {
        "name": "lookupTXT",
        "desc": ""
      },
      {
        "name": "preferGo",
        "desc": ""
      },
      {
        "name": "resolveAddrList",
        "desc": "resolveAddrList resolves addr using hint and returns a list of addresses. The result contains at least one address when error is nil."
      },
      {
        "name": "strictErrors",
        "desc": ""
      },
      {
        "name": "tryOneName",
        "desc": "Do a lookup for a single name, which must be rooted (otherwise answer will not find the answers)."
      },
      {
        "name": "SetTTL",
        "desc": "SetTTL sets the TTL for subsequent written resources. Once a resource has been written, SetTTL calls are no-ops. That is, it can only be called at most once, before anything else is written."
      },
      {
        "name": "header",
        "desc": ""
      },
      {
        "name": "AddSRV",
        "desc": "AddSRV adds a SRV record. The target name must end in a period and be 63 bytes or fewer."
      },
      {
        "name": "AddrPort",
        "desc": "AddrPort returns the [TCPAddr] a as a [netip.AddrPort].  If a.Port does not fit in a uint16, it's silently truncated.  If a is nil, a zero value is returned."
      },
      {
        "name": "Network",
        "desc": "Network returns the address's network name, \"tcp\"."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "family",
        "desc": ""
      },
      {
        "name": "isWildcard",
        "desc": ""
      },
      {
        "name": "opAddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "toLocal",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "CloseRead",
        "desc": "CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close."
      },
      {
        "name": "CloseWrite",
        "desc": "CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "MultipathTCP",
        "desc": "MultipathTCP reports whether the ongoing connection is using MPTCP.  If Multipath TCP is not supported by the host, by the other peer or intentionally / accidentally filtered out by a device in between, a fallback to TCP will be done. This method does its best to check if MPTCP is still being used or not.  On Linux, more conditions are verified on kernels \u003e= v5.16, improving the results."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "ReadFrom",
        "desc": "ReadFrom implements the [io.ReaderFrom] ReadFrom method."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetKeepAlive",
        "desc": "SetKeepAlive sets whether the operating system should send keep-alive messages on the connection."
      },
      {
        "name": "SetKeepAliveConfig",
        "desc": "SetKeepAliveConfig configures keep-alive messages sent by the operating system."
      },
      {
        "name": "SetKeepAlivePeriod",
        "desc": "SetKeepAlivePeriod sets the duration the connection needs to remain idle before TCP starts sending keepalive probes.  Note that calling this method on Windows prior to Windows 10 version 1709 will reset the KeepAliveInterval to the default system value, which is normally 1 second."
      },
      {
        "name": "SetLinger",
        "desc": "SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.  If sec \u003c 0 (the default), the operating system finishes sending the data in the background.  If sec == 0, the operating system discards any unsent or unacknowledged data.  If sec \u003e 0, the data is sent in the background as with sec \u003c 0. On some operating systems including Linux, this may cause Close to block until all data has been sent or discarded. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded."
      },
      {
        "name": "SetNoDelay",
        "desc": "SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm).  The default is true (no delay), meaning that data is sent as soon as possible after a Write."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "SyscallConn",
        "desc": "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo implements the io.WriterTo WriteTo method."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "readFrom",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": "Accept implements the Accept method in the [Listener] interface; it waits for the next call and returns a generic [Conn]."
      },
      {
        "name": "AcceptTCP",
        "desc": "AcceptTCP accepts the next incoming call and returns the new connection."
      },
      {
        "name": "Addr",
        "desc": "Addr returns the listener's network address, a [*TCPAddr]. The Addr returned is shared by all invocations of Addr, so do not modify it."
      },
      {
        "name": "Close",
        "desc": "Close stops listening on the TCP address. Already Accepted connections are not closed."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline."
      },
      {
        "name": "SyscallConn",
        "desc": "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface.  The returned RawConn only supports calling Control. Read and Write return an error."
      },
      {
        "name": "accept",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "dup",
        "desc": ""
      },
      {
        "name": "file",
        "desc": ""
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "port",
        "desc": ""
      },
      {
        "name": "AddrPort",
        "desc": "AddrPort returns the [UDPAddr] a as a [netip.AddrPort].  If a.Port does not fit in a uint16, it's silently truncated.  If a is nil, a zero value is returned."
      },
      {
        "name": "Network",
        "desc": "Network returns the address's network name, \"udp\"."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "family",
        "desc": ""
      },
      {
        "name": "isWildcard",
        "desc": ""
      },
      {
        "name": "opAddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "toLocal",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "ReadFrom",
        "desc": "ReadFrom implements the [PacketConn] ReadFrom method."
      },
      {
        "name": "ReadFromUDP",
        "desc": "ReadFromUDP acts like [UDPConn.ReadFrom] but returns a UDPAddr."
      },
      {
        "name": "ReadFromUDPAddrPort",
        "desc": "ReadFromUDPAddrPort acts like ReadFrom but returns a [netip.AddrPort].  If c is bound to an unspecified address, the returned netip.AddrPort's address might be an IPv4-mapped IPv6 address. Use [netip.Addr.Unmap] to get the address without the IPv6 prefix."
      },
      {
        "name": "ReadMsgUDP",
        "desc": "ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.  The packages [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] can be used to manipulate IP-level socket options in oob."
      },
      {
        "name": "ReadMsgUDPAddrPort",
        "desc": "ReadMsgUDPAddrPort is like [UDPConn.ReadMsgUDP] but returns an [netip.AddrPort] instead of a [UDPAddr]."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "SyscallConn",
        "desc": "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "WriteMsgUDP",
        "desc": "WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written.  The packages [golang.org/x/net/ipv4] and [golang.org/x/net/ipv6] can be used to manipulate IP-level socket options in oob."
      },
      {
        "name": "WriteMsgUDPAddrPort",
        "desc": "WriteMsgUDPAddrPort is like [UDPConn.WriteMsgUDP] but takes a [netip.AddrPort] instead of a [UDPAddr]."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo implements the [PacketConn] WriteTo method."
      },
      {
        "name": "WriteToUDP",
        "desc": "WriteToUDP acts like [UDPConn.WriteTo] but takes a [UDPAddr]."
      },
      {
        "name": "WriteToUDPAddrPort",
        "desc": "WriteToUDPAddrPort acts like [UDPConn.WriteTo] but takes a [netip.AddrPort]."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "port",
        "desc": ""
      },
      {
        "name": "readFrom",
        "desc": ""
      },
      {
        "name": "readFromAddrPort",
        "desc": ""
      },
      {
        "name": "readFromUDP",
        "desc": "readFromUDP implements ReadFromUDP."
      },
      {
        "name": "readMsg",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "writeMsg",
        "desc": ""
      },
      {
        "name": "writeMsgAddrPort",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "writeToAddrPort",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": "Network returns the address's network name, \"unix\", \"unixgram\" or \"unixpacket\"."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "family",
        "desc": ""
      },
      {
        "name": "isWildcard",
        "desc": ""
      },
      {
        "name": "opAddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "toLocal",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "CloseRead",
        "desc": "CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use [UnixConn.Close]."
      },
      {
        "name": "CloseWrite",
        "desc": "CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use [UnixConn.Close]."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "ReadFrom",
        "desc": "ReadFrom implements the [PacketConn].ReadFrom method."
      },
      {
        "name": "ReadFromUnix",
        "desc": "ReadFromUnix acts like [UnixConn.ReadFrom] but returns a [UnixAddr]."
      },
      {
        "name": "ReadMsgUnix",
        "desc": "ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.  Note that if len(b) == 0 and len(oob) \u003e 0, this function will still read (and discard) 1 byte from the connection."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "SyscallConn",
        "desc": "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "WriteMsgUnix",
        "desc": "WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.  Note that if len(b) == 0 and len(oob) \u003e 0, this function will still write 1 byte to the connection."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo implements the [PacketConn].WriteTo method."
      },
      {
        "name": "WriteToUnix",
        "desc": "WriteToUnix acts like [UnixConn.WriteTo] but takes a [UnixAddr]."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "readFrom",
        "desc": ""
      },
      {
        "name": "readMsg",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "writeMsg",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": "Accept implements the Accept method in the [Listener] interface. Returned connections will be of type [*UnixConn]."
      },
      {
        "name": "AcceptUnix",
        "desc": "AcceptUnix accepts the next incoming call and returns the new connection."
      },
      {
        "name": "Addr",
        "desc": "Addr returns the listener's network address. The [Addr] returned is shared by all invocations of Addr, so do not modify it."
      },
      {
        "name": "Close",
        "desc": "Close stops listening on the Unix address. Already accepted connections are not closed."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.  The returned [os.File]'s file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline."
      },
      {
        "name": "SetUnlinkOnClose",
        "desc": "SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.  The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file."
      },
      {
        "name": "SyscallConn",
        "desc": "SyscallConn returns a raw network connection. This implements the [syscall.Conn] interface.  The returned [syscall.RawConn] only supports calling Control. Read and Write return an error."
      },
      {
        "name": "accept",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "file",
        "desc": ""
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "first",
        "desc": "first returns the first address which satisfies strategy, or if none do, then the first address of any kind."
      },
      {
        "name": "forResolve",
        "desc": "forResolve returns the most appropriate address in address for a call to ResolveTCPAddr, ResolveUDPAddr, or ResolveIPAddr. IPv4 is preferred, unless addr contains an IPv6 literal."
      },
      {
        "name": "partition",
        "desc": "partition divides an address list into two categories, using a strategy function to assign a boolean label to each address. The first address, and any with a matching label, are returned as primaries, while addresses with the opposite label are returned as fallbacks. For non-empty inputs, primaries is guaranteed to be non-empty."
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "isAddrinfoErrno",
        "desc": "isAddrinfoErrno is just for testing purposes."
      },
      {
        "name": "sort",
        "desc": "sort reorders MX records as specified in RFC 5321."
      },
      {
        "name": "shuffleByWeight",
        "desc": "shuffleByWeight shuffles SRV records by weight using the algorithm described in RFC 2782."
      },
      {
        "name": "sort",
        "desc": "sort reorders SRV records as specified in RFC 2782."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Is",
        "desc": ""
      },
      {
        "name": "addrLookupOrder",
        "desc": "addrLookupOrder determines which strategy to use to resolve addresses. The provided Resolver is optional. nil means to not consider its options. It also returns dnsConfig when it was used to determine the lookup order."
      },
      {
        "name": "hostLookupOrder",
        "desc": "hostLookupOrder determines which strategy to use to resolve hostname. The provided Resolver is optional. nil means to not consider its options. It also returns dnsConfig when it was used to determine the lookup order."
      },
      {
        "name": "lookupOrder",
        "desc": ""
      },
      {
        "name": "mustUseGoResolver",
        "desc": "mustUseGoResolver reports whether a DNS lookup of any sort is required to use the go resolver. The provided Resolver is optional. This will report true if the cgo resolver is not available."
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "Deadline",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": "Reset attempts to reset the timer. If the timer has already expired, Reset returns false."
      },
      {
        "name": "nameList",
        "desc": "nameList returns a list of names for sequential DNS queries."
      },
      {
        "name": "serverOffset",
        "desc": "serverOffset returns an offset that can be used to determine indices of servers in c.servers when making queries. When the rotate option is enabled, this offset increases. Otherwise it is always 0."
      },
      {
        "name": "buildup",
        "desc": ""
      },
      {
        "name": "teardown",
        "desc": ""
      },
      {
        "name": "teardownNetwork",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "DialContext",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "accept",
        "desc": ""
      },
      {
        "name": "assignFakeAddr",
        "desc": ""
      },
      {
        "name": "closeRead",
        "desc": ""
      },
      {
        "name": "closeWrite",
        "desc": ""
      },
      {
        "name": "dup",
        "desc": ""
      },
      {
        "name": "readFrom",
        "desc": ""
      },
      {
        "name": "readFromInet4",
        "desc": ""
      },
      {
        "name": "readFromInet6",
        "desc": ""
      },
      {
        "name": "readMsg",
        "desc": ""
      },
      {
        "name": "readMsgInet4",
        "desc": ""
      },
      {
        "name": "readMsgInet6",
        "desc": ""
      },
      {
        "name": "setLinger",
        "desc": ""
      },
      {
        "name": "setReadBuffer",
        "desc": ""
      },
      {
        "name": "setWriteBuffer",
        "desc": ""
      },
      {
        "name": "writeMsg",
        "desc": ""
      },
      {
        "name": "writeMsgInet4",
        "desc": ""
      },
      {
        "name": "writeMsgInet6",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "writeToInet4",
        "desc": ""
      },
      {
        "name": "writeToInet6",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "getLineFromData",
        "desc": ""
      },
      {
        "name": "readLine",
        "desc": ""
      },
      {
        "name": "stat",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "probe",
        "desc": "probe probes IPv4, IPv6 and IPv4-mapped IPv6 communication capabilities.  Plan 9 uses IPv6 natively, see ip(3)."
      },
      {
        "name": "index",
        "desc": ""
      },
      {
        "name": "name",
        "desc": ""
      },
      {
        "name": "update",
        "desc": "update refreshes the network interface information if the cache was last updated more than 1 minute ago, or if force is set. It reports whether the cache was updated."
      },
      {
        "name": "buildup",
        "desc": ""
      },
      {
        "name": "teardown",
        "desc": ""
      },
      {
        "name": "buildup",
        "desc": ""
      },
      {
        "name": "teardown",
        "desc": ""
      },
      {
        "name": "transponder",
        "desc": ""
      },
      {
        "name": "dial",
        "desc": ""
      },
      {
        "name": "get",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "get",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "accept",
        "desc": ""
      },
      {
        "name": "acceptPlan9",
        "desc": ""
      },
      {
        "name": "addrFunc",
        "desc": ""
      },
      {
        "name": "assignFakeAddr",
        "desc": ""
      },
      {
        "name": "closeRead",
        "desc": ""
      },
      {
        "name": "closeWrite",
        "desc": ""
      },
      {
        "name": "connect",
        "desc": "Always returns nil for connected peer address result."
      },
      {
        "name": "ctrlNetwork",
        "desc": ""
      },
      {
        "name": "destroy",
        "desc": ""
      },
      {
        "name": "dial",
        "desc": ""
      },
      {
        "name": "dup",
        "desc": "This method is only called via Conn."
      },
      {
        "name": "file",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "listenDatagram",
        "desc": ""
      },
      {
        "name": "listenStream",
        "desc": ""
      },
      {
        "name": "name",
        "desc": ""
      },
      {
        "name": "netFD",
        "desc": ""
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "readFrom",
        "desc": ""
      },
      {
        "name": "readFromInet4",
        "desc": ""
      },
      {
        "name": "readFromInet6",
        "desc": ""
      },
      {
        "name": "readMsg",
        "desc": ""
      },
      {
        "name": "readMsgInet4",
        "desc": ""
      },
      {
        "name": "readMsgInet6",
        "desc": ""
      },
      {
        "name": "setAddr",
        "desc": ""
      },
      {
        "name": "setLinger",
        "desc": ""
      },
      {
        "name": "setReadBuffer",
        "desc": ""
      },
      {
        "name": "setWriteBuffer",
        "desc": ""
      },
      {
        "name": "shutdown",
        "desc": ""
      },
      {
        "name": "status",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "writeMsg",
        "desc": ""
      },
      {
        "name": "writeMsgInet4",
        "desc": ""
      },
      {
        "name": "writeMsgInet6",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "writeToInet4",
        "desc": ""
      },
      {
        "name": "writeToInet6",
        "desc": ""
      },
      {
        "name": "ReadFrom",
        "desc": "ReadFrom hides another ReadFrom method. It should never be called."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo hides another WriteTo method. It should never be called."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "standardStatusAction",
        "desc": "standardStatusAction reports whether c is equivalent to not specifying the criterion at all. last is whether this criteria is the last in the list."
      },
      {
        "name": "standardCriteria",
        "desc": "standardCriteria reports all specified criteria have the default status actions."
      },
      {
        "name": "acquireSema",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "init initializes conf and is only called via conf.initOnce."
      },
      {
        "name": "releaseSema",
        "desc": ""
      },
      {
        "name": "tryAcquireSema",
        "desc": ""
      },
      {
        "name": "tryUpdate",
        "desc": "tryUpdate tries to update conf."
      },
      {
        "name": "Value",
        "desc": "Value performs a lookup if the original context hasn't expired."
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "newLocalServer",
        "desc": ""
      },
      {
        "name": "closeRead",
        "desc": ""
      },
      {
        "name": "closeWrite",
        "desc": ""
      },
      {
        "name": "get",
        "desc": ""
      },
      {
        "name": "put",
        "desc": ""
      },
      {
        "name": "recvfrom",
        "desc": ""
      },
      {
        "name": "send",
        "desc": ""
      },
      {
        "name": "setLinger",
        "desc": ""
      },
      {
        "name": "setReadBuffer",
        "desc": "setReadBuffer sets a soft limit on the number of bytes available to read from the pipe."
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "set",
        "desc": "set sets the point in time when the deadline will time out. A timeout event is signaled by closing the channel returned by waiter. Once a timeout has occurred, the deadline can be refreshed by specifying a t value in the future.  A zero value for t prevents timeout."
      },
      {
        "name": "wait",
        "desc": "wait returns a channel that is closed when the deadline is exceeded."
      },
      {
        "name": "Classify",
        "desc": "Classify returns the policyTableEntry of the entry with the longest matching prefix that contains ip. The table t must be sorted from largest mask size to smallest."
      },
      {
        "name": "Control",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": "Network returns the network type of the underlying connection.  Other packages in std that import internal/poll and are unable to import net (such as os) can use a type assertion to access this extension method so that they can distinguish different socket types.  Network is not intended for use outside the standard library."
      },
      {
        "name": "PollFD",
        "desc": "PollFD returns the poll.FD of the underlying connection.  Other packages in std that also import [internal/poll] (such as os) can use a type assertion to access this extension method so that they can pass the *poll.FD to functions like poll.Splice.  PollFD is not intended for use outside the standard library."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "Control",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": "Network returns the network type of the underlying connection.  Other packages in std that import internal/poll and are unable to import net (such as os) can use a type assertion to access this extension method so that they can distinguish different socket types.  Network is not intended for use outside the standard library."
      },
      {
        "name": "PollFD",
        "desc": "PollFD returns the poll.FD of the underlying connection.  Other packages in std that also import [internal/poll] (such as os) can use a type assertion to access this extension method so that they can pass the *poll.FD to functions like poll.Splice.  PollFD is not intended for use outside the standard library."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "forceUpdate",
        "desc": ""
      },
      {
        "name": "forceUpdateConf",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "init initializes conf and is only called via conf.initOnce."
      },
      {
        "name": "releaseSema",
        "desc": ""
      },
      {
        "name": "servers",
        "desc": ""
      },
      {
        "name": "teardown",
        "desc": ""
      },
      {
        "name": "tryAcquireSema",
        "desc": ""
      },
      {
        "name": "tryUpdate",
        "desc": "tryUpdate tries to update conf with the named resolv.conf file. The name variable only exists for testing. It is otherwise always \"/etc/resolv.conf\"."
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writeAndUpdate",
        "desc": ""
      },
      {
        "name": "writeAndUpdateWithLastCheckedTime",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "init initializes conf and is only called via conf.initOnce."
      },
      {
        "name": "releaseSema",
        "desc": ""
      },
      {
        "name": "tryAcquireSema",
        "desc": ""
      },
      {
        "name": "tryUpdate",
        "desc": "tryUpdate tries to update conf with the named resolv.conf file. The name variable only exists for testing. It is otherwise always \"/etc/resolv.conf\"."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "benchSendFile",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "benchSpliceFile",
        "desc": ""
      },
      {
        "name": "install",
        "desc": ""
      },
      {
        "name": "uninstall",
        "desc": ""
      },
      {
        "name": "bench",
        "desc": ""
      },
      {
        "name": "test",
        "desc": ""
      },
      {
        "name": "testFile",
        "desc": ""
      },
      {
        "name": "newLocalServer",
        "desc": ""
      },
      {
        "name": "dialIP",
        "desc": ""
      },
      {
        "name": "dialMPTCP",
        "desc": ""
      },
      {
        "name": "dialParallel",
        "desc": "dialParallel races two copies of dialSerial, giving the first a head start. It returns the first established connection and closes the others. Otherwise it returns an error from the first primary address."
      },
      {
        "name": "dialSerial",
        "desc": "dialSerial connects to a list of addresses in sequence, returning either the first successful connection, or the first error."
      },
      {
        "name": "dialSingle",
        "desc": "dialSingle attempts to establish and returns a single connection to the destination address."
      },
      {
        "name": "dialTCP",
        "desc": ""
      },
      {
        "name": "dialUDP",
        "desc": ""
      },
      {
        "name": "dialUnix",
        "desc": ""
      },
      {
        "name": "doDialTCP",
        "desc": ""
      },
      {
        "name": "doDialTCPProto",
        "desc": ""
      },
      {
        "name": "listenIP",
        "desc": ""
      },
      {
        "name": "listenMPTCP",
        "desc": ""
      },
      {
        "name": "listenMulticastUDP",
        "desc": ""
      },
      {
        "name": "listenTCP",
        "desc": ""
      },
      {
        "name": "listenTCPProto",
        "desc": ""
      },
      {
        "name": "listenUDP",
        "desc": ""
      },
      {
        "name": "listenUnix",
        "desc": ""
      },
      {
        "name": "listenUnixgram",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "File",
        "desc": "File returns a copy of the underlying [os.File]. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.  The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect.  On Windows, the returned os.File's file descriptor is not usable on other processes."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it."
      },
      {
        "name": "Read",
        "desc": "Read implements the Conn Read method."
      },
      {
        "name": "RemoteAddr",
        "desc": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline implements the Conn SetDeadline method."
      },
      {
        "name": "SetReadBuffer",
        "desc": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline implements the Conn SetReadDeadline method."
      },
      {
        "name": "SetWriteBuffer",
        "desc": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline implements the Conn SetWriteDeadline method."
      },
      {
        "name": "Write",
        "desc": "Write implements the Conn Write method."
      },
      {
        "name": "ok",
        "desc": ""
      },
      {
        "name": "writeBuffers",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "setBroadcast",
        "desc": ""
      },
      {
        "name": "setLinkLocal",
        "desc": ""
      },
      {
        "name": "setPointToPoint",
        "desc": ""
      },
      {
        "name": "setup",
        "desc": ""
      },
      {
        "name": "teardown",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Is",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Bytes",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "AAAAWriter",
        "desc": ""
      },
      {
        "name": "AWriter",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": "Addr represents a network end point address.  The two methods [Addr.Network] and [Addr.String] conventionally return strings that can be passed as the arguments to [Dial], but the exact form and meaning of the strings is up to the implementation."
      },
      {
        "name": "AddrError",
        "desc": ""
      },
      {
        "name": "Buffers",
        "desc": "Buffers contains zero or more runs of bytes to write.  On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as \"writev\")."
      },
      {
        "name": "Conn",
        "desc": "Conn is a generic stream-oriented network connection.  Multiple goroutines may invoke methods on a Conn simultaneously."
      },
      {
        "name": "DNSConfigError",
        "desc": "DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.)"
      },
      {
        "name": "DNSError",
        "desc": "DNSError represents a DNS lookup error."
      },
      {
        "name": "Dialer",
        "desc": "A Dialer contains options for connecting to an address.  The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the [Dial] function.  It is safe to call Dialer's methods concurrently."
      },
      {
        "name": "Error",
        "desc": "An Error represents a network error."
      },
      {
        "name": "Flags",
        "desc": ""
      },
      {
        "name": "HardwareAddr",
        "desc": "A HardwareAddr represents a physical hardware address."
      },
      {
        "name": "IP",
        "desc": "An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.  Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address."
      },
      {
        "name": "IPAddr",
        "desc": "IPAddr represents the address of an IP end point."
      },
      {
        "name": "IPConn",
        "desc": "IPConn is the implementation of the [Conn] and [PacketConn] interfaces for IP network connections."
      },
      {
        "name": "IPMask",
        "desc": "An IPMask is a bitmask that can be used to manipulate IP addresses for IP addressing and routing.  See type [IPNet] and func [ParseCIDR] for details."
      },
      {
        "name": "IPNet",
        "desc": "An IPNet represents an IP network."
      },
      {
        "name": "Interface",
        "desc": "Interface represents a mapping between network interface name and index. It also represents network interface facility information."
      },
      {
        "name": "InvalidAddrError",
        "desc": ""
      },
      {
        "name": "KeepAliveConfig",
        "desc": "KeepAliveConfig contains TCP keep-alive options.  If the Idle, Interval, or Count fields are zero, a default value is chosen. If a field is negative, the corresponding socket-level option will be left unchanged.  Note that prior to Windows 10 version 1709, neither setting Idle and Interval separately nor changing Count (which is usually 10) is supported. Therefore, it's recommended to set both Idle and Interval to non-negative values in conjunction with a -1 for Count on those old Windows if you intend to customize the TCP keep-alive settings. By contrast, if only one of Idle and Interval is set to a non-negative value, the other will be set to the system default value, and ultimately, set both Idle and Interval to negative values if you want to leave them unchanged.  Note that Solaris and its derivatives do not support setting Interval to a non-negative value and Count to a negative value, or vice-versa."
      },
      {
        "name": "ListenConfig",
        "desc": "ListenConfig contains options for listening to an address."
      },
      {
        "name": "Listener",
        "desc": "A Listener is a generic network listener for stream-oriented protocols.  Multiple goroutines may invoke methods on a Listener simultaneously."
      },
      {
        "name": "MX",
        "desc": "An MX represents a single DNS MX record."
      },
      {
        "name": "NS",
        "desc": "An NS represents a single DNS NS record."
      },
      {
        "name": "OpError",
        "desc": "OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error."
      },
      {
        "name": "PacketConn",
        "desc": "PacketConn is a generic packet-oriented network connection.  Multiple goroutines may invoke methods on a PacketConn simultaneously."
      },
      {
        "name": "ParseError",
        "desc": "A ParseError is the error type of literal network address parsers."
      },
      {
        "name": "Resolver",
        "desc": "A Resolver looks up names and numbers.  A nil *Resolver is equivalent to a zero Resolver."
      },
      {
        "name": "ResponseWriter",
        "desc": ""
      },
      {
        "name": "SRV",
        "desc": "An SRV represents a single DNS SRV record."
      },
      {
        "name": "SRVWriter",
        "desc": ""
      },
      {
        "name": "TCPAddr",
        "desc": "TCPAddr represents the address of a TCP end point."
      },
      {
        "name": "TCPConn",
        "desc": "TCPConn is an implementation of the [Conn] interface for TCP network connections."
      },
      {
        "name": "TCPListener",
        "desc": "TCPListener is a TCP network listener. Clients should typically use variables of type [Listener] instead of assuming TCP."
      },
      {
        "name": "UDPAddr",
        "desc": "UDPAddr represents the address of a UDP end point."
      },
      {
        "name": "UDPConn",
        "desc": "UDPConn is the implementation of the [Conn] and [PacketConn] interfaces for UDP network connections."
      },
      {
        "name": "UnixAddr",
        "desc": "UnixAddr represents the address of a Unix domain socket end point."
      },
      {
        "name": "UnixConn",
        "desc": "UnixConn is an implementation of the [Conn] interface for connections to Unix domain sockets."
      },
      {
        "name": "UnixListener",
        "desc": "UnixListener is a Unix domain socket listener. Clients should typically use variables of type [Listener] instead of assuming Unix domain sockets."
      },
      {
        "name": "UnknownNetworkError",
        "desc": ""
      },
      {
        "name": "_C_char",
        "desc": ""
      },
      {
        "name": "_C_int",
        "desc": ""
      },
      {
        "name": "_C_socklen_t",
        "desc": ""
      },
      {
        "name": "_C_struct___res_state",
        "desc": ""
      },
      {
        "name": "_C_struct_addrinfo",
        "desc": ""
      },
      {
        "name": "_C_struct_sockaddr",
        "desc": ""
      },
      {
        "name": "_C_uchar",
        "desc": ""
      },
      {
        "name": "_C_uint",
        "desc": ""
      },
      {
        "name": "addrList",
        "desc": "An addrList represents a list of network endpoint addresses."
      },
      {
        "name": "addrPortUDPAddr",
        "desc": "An addrPortUDPAddr is a netip.AddrPort-based UDP address that satisfies the Addr interface."
      },
      {
        "name": "addrinfoErrno",
        "desc": "An addrinfoErrno represents a getaddrinfo, getnameinfo-specific error number. It's a signed number and a zero value is a non-error by convention."
      },
      {
        "name": "buffersWriter",
        "desc": "buffersWriter is the interface implemented by Conns that support a \"writev\"-like batch write optimization. writeBuffers should fully consume and write all chunks from the provided Buffers, else it should report a non-nil error."
      },
      {
        "name": "byName",
        "desc": ""
      },
      {
        "name": "byPref",
        "desc": "byPref sorts MX records by preference"
      },
      {
        "name": "byPriorityWeight",
        "desc": "byPriorityWeight sorts SRV records by ascending priority and weight."
      },
      {
        "name": "byRFC6724Info",
        "desc": ""
      },
      {
        "name": "canceledError",
        "desc": "canceledError lets us return the same error string we have always returned, while still being Is context.Canceled."
      },
      {
        "name": "conf",
        "desc": "conf is used to determine name resolution configuration."
      },
      {
        "name": "conn",
        "desc": ""
      },
      {
        "name": "contextWithNonZeroDeadline",
        "desc": ""
      },
      {
        "name": "deadlineTimer",
        "desc": ""
      },
      {
        "name": "dnsConfig",
        "desc": ""
      },
      {
        "name": "dnsNameTest",
        "desc": ""
      },
      {
        "name": "dualStackServer",
        "desc": ""
      },
      {
        "name": "fakeDNSConn",
        "desc": ""
      },
      {
        "name": "fakeDNSPacketConn",
        "desc": ""
      },
      {
        "name": "fakeDNSServer",
        "desc": ""
      },
      {
        "name": "fakeNetFD",
        "desc": ""
      },
      {
        "name": "fakeSockAddr",
        "desc": ""
      },
      {
        "name": "fdType",
        "desc": ""
      },
      {
        "name": "file",
        "desc": ""
      },
      {
        "name": "fileAddr",
        "desc": ""
      },
      {
        "name": "hostLookupOrder",
        "desc": "hostLookupOrder specifies the order of LookupHost lookup strategies. It is basically a simplified representation of nsswitch.conf. \"files\" means /etc/hosts."
      },
      {
        "name": "ifStats",
        "desc": ""
      },
      {
        "name": "ifreq",
        "desc": ""
      },
      {
        "name": "ipAttr",
        "desc": ""
      },
      {
        "name": "ipStackCapabilities",
        "desc": ""
      },
      {
        "name": "ipv6LinkLocalUnicastTest",
        "desc": ""
      },
      {
        "name": "ipv6ZoneCache",
        "desc": "An ipv6ZoneCache represents a cache holding partial network interface information. It is used for reducing the cost of IPv6 addressing scope zone resolution.  Multiple names sharing the index are managed by first-come first-served basis for consistency."
      },
      {
        "name": "localPacketServer",
        "desc": ""
      },
      {
        "name": "localServer",
        "desc": ""
      },
      {
        "name": "lookupCustomResolver",
        "desc": ""
      },
      {
        "name": "mdnsTest",
        "desc": "mdnsTest is for testing only."
      },
      {
        "name": "mptcpStatusDial",
        "desc": "mptcpStatusDial is a tristate for Multipath TCP on clients, see go.dev/issue/56539"
      },
      {
        "name": "mptcpStatusListen",
        "desc": "mptcpStatusListen is a tristate for Multipath TCP on servers, see go.dev/issue/56539"
      },
      {
        "name": "netFD",
        "desc": "Network file descriptor."
      },
      {
        "name": "noReadFrom",
        "desc": "noReadFrom can be embedded alongside another type to hide the ReadFrom method of that other type."
      },
      {
        "name": "noWriteTo",
        "desc": "noWriteTo can be embedded alongside another type to hide the WriteTo method of that other type."
      },
      {
        "name": "notFoundError",
        "desc": "notFoundError is a special error understood by the newDNSError function, which causes a creation of a DNSError with IsNotFound field set to true."
      },
      {
        "name": "nssConf",
        "desc": "nssConf represents the state of the machine's /etc/nsswitch.conf file."
      },
      {
        "name": "nssCriterion",
        "desc": "nssCriterion is the parsed structure of one of the criteria in brackets after an NSS source name."
      },
      {
        "name": "nssHostTest",
        "desc": ""
      },
      {
        "name": "nssSource",
        "desc": ""
      },
      {
        "name": "nsswitchConfig",
        "desc": ""
      },
      {
        "name": "onlyValuesCtx",
        "desc": "onlyValuesCtx is a context that uses an underlying context for value lookup if the underlying context hasn't yet expired."
      },
      {
        "name": "packet",
        "desc": ""
      },
      {
        "name": "packetListener",
        "desc": ""
      },
      {
        "name": "packetQueue",
        "desc": "A packetQueue is a set of 1-buffered channels implementing a FIFO queue of packets."
      },
      {
        "name": "packetQueueState",
        "desc": ""
      },
      {
        "name": "pipe",
        "desc": ""
      },
      {
        "name": "pipeAddr",
        "desc": ""
      },
      {
        "name": "pipeDeadline",
        "desc": "pipeDeadline is an abstraction for handling timeouts."
      },
      {
        "name": "policyTable",
        "desc": ""
      },
      {
        "name": "policyTableEntry",
        "desc": ""
      },
      {
        "name": "rawConn",
        "desc": ""
      },
      {
        "name": "rawListener",
        "desc": ""
      },
      {
        "name": "rawSockaddrDatalink",
        "desc": ""
      },
      {
        "name": "resolvConfTest",
        "desc": ""
      },
      {
        "name": "resolveIPAddrTest",
        "desc": ""
      },
      {
        "name": "resolveTCPAddrTest",
        "desc": ""
      },
      {
        "name": "resolveUDPAddrTest",
        "desc": ""
      },
      {
        "name": "resolverConfig",
        "desc": "A resolverConfig represents a DNS stub resolver configuration."
      },
      {
        "name": "resolverDialHandler",
        "desc": ""
      },
      {
        "name": "resolverFuncConn",
        "desc": ""
      },
      {
        "name": "routeStats",
        "desc": ""
      },
      {
        "name": "scope",
        "desc": "RFC 6724 section 3.1."
      },
      {
        "name": "sendFileBench",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": "A sockaddr represents a TCP, UDP, IP or Unix network endpoint address that can be converted into a syscall.Sockaddr."
      },
      {
        "name": "someaddr",
        "desc": ""
      },
      {
        "name": "spliceFileBench",
        "desc": ""
      },
      {
        "name": "spliceHook",
        "desc": ""
      },
      {
        "name": "spliceTestCase",
        "desc": ""
      },
      {
        "name": "staticHostEntry",
        "desc": ""
      },
      {
        "name": "streamListener",
        "desc": ""
      },
      {
        "name": "sysDialer",
        "desc": "sysDialer contains a Dial's parameters and configuration."
      },
      {
        "name": "sysListener",
        "desc": "sysListener contains a Listen's parameters and configuration."
      },
      {
        "name": "tcpConnWithoutReadFrom",
        "desc": "tcpConnWithoutReadFrom implements all the methods of *TCPConn other than ReadFrom. This is used to permit ReadFrom to call io.Copy without leading to a recursive call to ReadFrom."
      },
      {
        "name": "tcpConnWithoutWriteTo",
        "desc": "tcpConnWithoutWriteTo implements all the methods of *TCPConn other than WriteTo. This is used to permit WriteTo to call io.Copy without leading to a recursive call to WriteTo."
      },
      {
        "name": "temporary",
        "desc": ""
      },
      {
        "name": "temporaryError",
        "desc": "temporaryError is an error type that implements the [Error] interface. It returns true from the Temporary method."
      },
      {
        "name": "testInterface",
        "desc": ""
      },
      {
        "name": "timeout",
        "desc": ""
      },
      {
        "name": "timeoutError",
        "desc": ""
      },
      {
        "name": "udpHeader",
        "desc": ""
      },
      {
        "name": "unknownAddr",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/http",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkClient",
        "desc": "A benchmark for profiling the client without the HTTP server code. The server code runs in a subprocess."
      },
      {
        "name": "BenchmarkClientServer",
        "desc": ""
      },
      {
        "name": "BenchmarkClientServerParallel",
        "desc": ""
      },
      {
        "name": "BenchmarkCloseNotifier",
        "desc": ""
      },
      {
        "name": "BenchmarkFileAndServer_16MB",
        "desc": ""
      },
      {
        "name": "BenchmarkFileAndServer_1KB",
        "desc": ""
      },
      {
        "name": "BenchmarkFileAndServer_64MB",
        "desc": ""
      },
      {
        "name": "BenchmarkReadRequestApachebench",
        "desc": ""
      },
      {
        "name": "BenchmarkReadRequestChrome",
        "desc": ""
      },
      {
        "name": "BenchmarkReadRequestCurl",
        "desc": ""
      },
      {
        "name": "BenchmarkReadRequestSiege",
        "desc": ""
      },
      {
        "name": "BenchmarkReadRequestWrk",
        "desc": ""
      },
      {
        "name": "BenchmarkResponseStatusLine",
        "desc": ""
      },
      {
        "name": "BenchmarkServeMux",
        "desc": ""
      },
      {
        "name": "BenchmarkServeMux_SkipServe",
        "desc": ""
      },
      {
        "name": "BenchmarkServer",
        "desc": "A benchmark for profiling the server without the HTTP client code. The client code runs in a subprocess.  For use like:  \t$ go test -c \t$ ./http.test -test.run='^$' -test.bench='^BenchmarkServer$' -test.benchtime=15s -test.cpuprofile=http.prof \t$ go tool pprof http.test http.prof \t(pprof) web"
      },
      {
        "name": "BenchmarkServerFakeConnNoKeepAlive",
        "desc": ""
      },
      {
        "name": "BenchmarkServerFakeConnWithKeepAlive",
        "desc": ""
      },
      {
        "name": "BenchmarkServerFakeConnWithKeepAliveLite",
        "desc": "same as above, but representing the most simple possible request and handler. Notably: the handler does not call rw.Header()."
      },
      {
        "name": "BenchmarkServerHandlerNoHeader",
        "desc": "Neither a Content-Type or Content-Length, so sniffed and counted."
      },
      {
        "name": "BenchmarkServerHandlerNoLen",
        "desc": "A Content-Type is set, but no length. No sniffing, but will count the Content-Length."
      },
      {
        "name": "BenchmarkServerHandlerNoType",
        "desc": "A Content-Length is set, but the Content-Type will be sniffed."
      },
      {
        "name": "BenchmarkServerHandlerTypeLen",
        "desc": "Both Content-Type and Content-Length set. Should be no buffering."
      },
      {
        "name": "BenchmarkServerHijack",
        "desc": ""
      },
      {
        "name": "ExampleFileServer",
        "desc": ""
      },
      {
        "name": "ExampleFileServer_dotFileHiding",
        "desc": ""
      },
      {
        "name": "ExampleFileServer_stripPrefix",
        "desc": ""
      },
      {
        "name": "ExampleGet",
        "desc": ""
      },
      {
        "name": "ExampleHandle",
        "desc": ""
      },
      {
        "name": "ExampleHandleFunc",
        "desc": ""
      },
      {
        "name": "ExampleHijacker",
        "desc": ""
      },
      {
        "name": "ExampleListenAndServe",
        "desc": ""
      },
      {
        "name": "ExampleListenAndServeTLS",
        "desc": ""
      },
      {
        "name": "ExampleNotFoundHandler",
        "desc": ""
      },
      {
        "name": "ExampleProtocols_http1",
        "desc": ""
      },
      {
        "name": "ExampleProtocols_http1or2",
        "desc": ""
      },
      {
        "name": "ExampleResponseWriter_trailers",
        "desc": "HTTP Trailers are a set of key/value pairs like headers that come after the HTTP response, instead of before."
      },
      {
        "name": "ExampleServeMux_Handle",
        "desc": ""
      },
      {
        "name": "ExampleServer_Shutdown",
        "desc": ""
      },
      {
        "name": "ExampleStripPrefix",
        "desc": ""
      },
      {
        "name": "Test304Responses",
        "desc": "Test304Responses verifies that 304s don't declare that they're chunking in their response headers and aren't allowed to produce output."
      },
      {
        "name": "TestAcceptMaxFds",
        "desc": ""
      },
      {
        "name": "TestAltProtoCancellation",
        "desc": "Issue 36820 Test that we use the older backward compatible cancellation protocol when a RoundTripper is registered via RegisterProtocol."
      },
      {
        "name": "TestAutomaticHTTP2_ListenAndServe",
        "desc": ""
      },
      {
        "name": "TestAutomaticHTTP2_ListenAndServe_GetCertificate",
        "desc": ""
      },
      {
        "name": "TestAutomaticHTTP2_ListenAndServe_GetConfigForClient",
        "desc": ""
      },
      {
        "name": "TestAutomaticHTTP2_Serve_H2TLSConfig",
        "desc": ""
      },
      {
        "name": "TestAutomaticHTTP2_Serve_NoTLSConfig",
        "desc": "Issue 15908"
      },
      {
        "name": "TestAutomaticHTTP2_Serve_NonH2TLSConfig",
        "desc": ""
      },
      {
        "name": "TestAutomaticHTTP2_Serve_WithTLSConfig",
        "desc": ""
      },
      {
        "name": "TestBadResponseAfterReadingBody",
        "desc": ""
      },
      {
        "name": "TestBasicAuth",
        "desc": ""
      },
      {
        "name": "TestBasicAuthHeadersPreserved",
        "desc": ""
      },
      {
        "name": "TestBidiStreamReverseProxy",
        "desc": ""
      },
      {
        "name": "TestCancelRequestMidBody",
        "desc": "Tests that closing the Request.Cancel channel also while still reading the response body. Issue 13159."
      },
      {
        "name": "TestCancelRequestWhenSharingConnection",
        "desc": "Issue 41600 Test that a new request which uses the connection of an active request cannot cause it to be canceled as well."
      },
      {
        "name": "TestCaseSensitiveMethod",
        "desc": ""
      },
      {
        "name": "TestChunkedNoContent",
        "desc": "From https://golang.org/issue/4454 , \"client fails to handle requests with no body and chunked encoding\""
      },
      {
        "name": "TestChunkedResponseHeaders",
        "desc": ""
      },
      {
        "name": "TestClient",
        "desc": ""
      },
      {
        "name": "TestClientAltersCookiesOnRedirect",
        "desc": "Issue 17494: cookies should be altered when Client follows redirects."
      },
      {
        "name": "TestClientCallsCloseOnlyOnce",
        "desc": "Issue 40382: Client calls Close multiple times on Request.Body."
      },
      {
        "name": "TestClientCanClose",
        "desc": "TestClientCanClose verifies that clients can also force a connection to close."
      },
      {
        "name": "TestClientCloseIdleConnections",
        "desc": ""
      },
      {
        "name": "TestClientCopyHeadersOnRedirect",
        "desc": "Issue 4800: copy (some) headers when Client follows a redirect. Issue 35104: Since both URLs have the same host (localhost) but different ports, sensitive headers like Cookie and Authorization are preserved."
      },
      {
        "name": "TestClientCopyHostOnRedirect",
        "desc": "Issue 22233: copy host when Client follows a relative redirect."
      },
      {
        "name": "TestClientDoCanceledVsTimeout",
        "desc": "Issue 33545: lock-in the behavior promised by Client.Do's docs about request cancellation vs timing out."
      },
      {
        "name": "TestClientErrorWithRequestURI",
        "desc": ""
      },
      {
        "name": "TestClientHead",
        "desc": ""
      },
      {
        "name": "TestClientHeadContentLength",
        "desc": "Verify Response.ContentLength is populated. https://golang.org/issue/4126"
      },
      {
        "name": "TestClientInsecureTransport",
        "desc": ""
      },
      {
        "name": "TestClientPopulatesNilResponseBody",
        "desc": ""
      },
      {
        "name": "TestClientPropagatesTimeoutToContext",
        "desc": ""
      },
      {
        "name": "TestClientRedirect308NoGetBody",
        "desc": "Don't follow a 307/308 if we can't resent the request body."
      },
      {
        "name": "TestClientRedirectEatsBody_h1",
        "desc": ""
      },
      {
        "name": "TestClientRedirectNoLocation",
        "desc": "Issues 17773 and 49281: don't follow a 3xx if the response doesn't have a Location header."
      },
      {
        "name": "TestClientRedirectResponseWithoutRequest",
        "desc": "Issue 15577: don't assume the roundtripper's response populates its Request field."
      },
      {
        "name": "TestClientRedirectTypes",
        "desc": ""
      },
      {
        "name": "TestClientRedirectUseResponse",
        "desc": ""
      },
      {
        "name": "TestClientRedirects",
        "desc": ""
      },
      {
        "name": "TestClientRedirectsContext",
        "desc": "Tests that Client redirects' contexts are derived from the original request's context."
      },
      {
        "name": "TestClientSendsCookieFromJar",
        "desc": ""
      },
      {
        "name": "TestClientStripHeadersOnRepeatedRedirect",
        "desc": "Issue #70530: Once we strip a header on a redirect to a different host, the header should stay stripped across any further redirects."
      },
      {
        "name": "TestClientTimeout",
        "desc": ""
      },
      {
        "name": "TestClientTimeoutCancel",
        "desc": "Issue 16094: if Client.Timeout is set but not hit, a Timeout error shouldn't be returned."
      },
      {
        "name": "TestClientTimeoutDoesNotExpire",
        "desc": "Issue 49366: if Client.Timeout is set but not hit, no error should be returned."
      },
      {
        "name": "TestClientTimeoutKillsConn_AfterHeaders",
        "desc": "Issue 23399: verify that if a client request times out, the Transport's conn is closed so that it's not reused.  This is the test variant that has the server send response headers first, and time out during the write of the response body."
      },
      {
        "name": "TestClientTimeoutKillsConn_BeforeHeaders",
        "desc": "Issue 23399: verify that if a client request times out, the Transport's conn is closed so that it's not reused.  This is the test variant that times out before the server replies with any response headers."
      },
      {
        "name": "TestClientTimeout_Headers",
        "desc": "Client.Timeout firing before getting to the body"
      },
      {
        "name": "TestClientWithCorrectTLSServerName",
        "desc": ""
      },
      {
        "name": "TestClientWithIncorrectTLSServerName",
        "desc": ""
      },
      {
        "name": "TestClientWriteShutdown",
        "desc": "TestClientWriteShutdown tests that if the client shuts down the write side of their TCP connection, the server doesn't send a 400 Bad Request."
      },
      {
        "name": "TestClientWrites",
        "desc": "TestClientWrites verifies that client requests are buffered and we don't send a TCP packet per line of the http request + body."
      },
      {
        "name": "TestCloseIdleConnections",
        "desc": "Issue 14607"
      },
      {
        "name": "TestCloseNotifier",
        "desc": ""
      },
      {
        "name": "TestCloseNotifierChanLeak",
        "desc": ""
      },
      {
        "name": "TestCloseNotifierPipelined",
        "desc": "Tests that a pipelined request does not cause the first request's Handler's CloseNotify channel to fire.  Issue 13165 (where it used to deadlock), but behavior changed in Issue 23921."
      },
      {
        "name": "TestCloseWrite",
        "desc": ""
      },
      {
        "name": "TestCodesPreventingContentTypeAndBody",
        "desc": "Issue 6157, Issue 6685"
      },
      {
        "name": "TestConcurrentReadWriteReqBody",
        "desc": ""
      },
      {
        "name": "TestConcurrentServerServe",
        "desc": "Verify this doesn't race (Issue 16505)"
      },
      {
        "name": "TestConnClosedBeforeRequestIsWritten",
        "desc": "https://go.dev/issue/49621"
      },
      {
        "name": "TestConnContextNotModifyingAllContexts",
        "desc": "Issue 35750: check ConnContext not modifying context for other connections"
      },
      {
        "name": "TestConnectRequest",
        "desc": ""
      },
      {
        "name": "TestConsumingBodyOnNextConn",
        "desc": ""
      },
      {
        "name": "TestContentEncodingNoSniffing",
        "desc": "Issue 31753: don't sniff when Content-Encoding is set"
      },
      {
        "name": "TestContentLengthZero",
        "desc": "TestContentLengthZero tests that for both an HTTP/1.0 and HTTP/1.1 request (both keep-alive), when a Handler never writes any response, the net/http package adds a \"Content-Length: 0\" response header."
      },
      {
        "name": "TestContentTypeOkayOn204",
        "desc": ""
      },
      {
        "name": "TestContentTypeWithVariousSources",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionAddTrustedOriginErrors",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionAddingBypassesConcurrently",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionPatternBypass",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionSecFetchSite",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionServer",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionSetDenyHandler",
        "desc": ""
      },
      {
        "name": "TestCrossOriginProtectionTrustedOriginBypass",
        "desc": ""
      },
      {
        "name": "TestDeleteRedirects",
        "desc": ""
      },
      {
        "name": "TestDetectContentType",
        "desc": ""
      },
      {
        "name": "TestDirJoin",
        "desc": ""
      },
      {
        "name": "TestDirectoryIfNotModified",
        "desc": ""
      },
      {
        "name": "TestDisableContentLength",
        "desc": "TestDisableContentLength verifies that the Content-Length is set by default or disabled when the header is set to nil."
      },
      {
        "name": "TestDisableKeepAliveUpgrade",
        "desc": ""
      },
      {
        "name": "TestDontCacheBrokenHTTP2Conn",
        "desc": "Issue 34978: don't cache a broken HTTP/2 connection"
      },
      {
        "name": "TestDoubleHijack",
        "desc": ""
      },
      {
        "name": "TestEarlyHints",
        "desc": ""
      },
      {
        "name": "TestEarlyHintsRequest",
        "desc": ""
      },
      {
        "name": "TestEmptyDirOpenCWD",
        "desc": ""
      },
      {
        "name": "TestEmptyPasswordAuth",
        "desc": ""
      },
      {
        "name": "TestErrNotSupported",
        "desc": ""
      },
      {
        "name": "TestError",
        "desc": ""
      },
      {
        "name": "TestErrorContentLength",
        "desc": ""
      },
      {
        "name": "TestErrorWriteLoopRace",
        "desc": "Issue 37669 Test that a cancellation doesn't result in a data race due to the writeLoop goroutine being left running, if the caller mutates the processed Request upon completion."
      },
      {
        "name": "TestFSRedirect",
        "desc": ""
      },
      {
        "name": "TestFileServerCleanPath",
        "desc": ""
      },
      {
        "name": "TestFileServerCleans",
        "desc": ""
      },
      {
        "name": "TestFileServerDirWithRootFile",
        "desc": "Issue 63769"
      },
      {
        "name": "TestFileServerErrorMessages",
        "desc": ""
      },
      {
        "name": "TestFileServerEscapesNames",
        "desc": ""
      },
      {
        "name": "TestFileServerFS",
        "desc": ""
      },
      {
        "name": "TestFileServerImplicitLeadingSlash",
        "desc": ""
      },
      {
        "name": "TestFileServerMethods",
        "desc": ""
      },
      {
        "name": "TestFileServerNamesEscape",
        "desc": ""
      },
      {
        "name": "TestFileServerNotDirError",
        "desc": "Issues 18984, 49552: tests that requests for paths beyond files return not-found errors"
      },
      {
        "name": "TestFileServerNullByte",
        "desc": ""
      },
      {
        "name": "TestFileServerSortsNames",
        "desc": ""
      },
      {
        "name": "TestFileServerZeroByte",
        "desc": ""
      },
      {
        "name": "TestFormFileCallsParseMultipartForm",
        "desc": "Test that FormFile invokes ParseMultipartForm."
      },
      {
        "name": "TestFormFileOrder",
        "desc": "Test that FormFile errors if called after MultipartReader on the same request."
      },
      {
        "name": "TestFormValueCallsParseMultipartForm",
        "desc": "Test that FormValue invokes ParseMultipartForm."
      },
      {
        "name": "TestGetBasicAuth",
        "desc": ""
      },
      {
        "name": "TestGetBody",
        "desc": ""
      },
      {
        "name": "TestGetRequestFormat",
        "desc": ""
      },
      {
        "name": "TestH12_200NoBody",
        "desc": ""
      },
      {
        "name": "TestH12_AutoGzip",
        "desc": "Verify that both our HTTP/1 and HTTP/2 request and auto-decompress gzip. Some hosts send gzip even if you don't ask for it; see golang.org/issue/13298"
      },
      {
        "name": "TestH12_AutoGzipWithDumpResponse",
        "desc": "Issue 15366"
      },
      {
        "name": "TestH12_AutoGzip_Disabled",
        "desc": ""
      },
      {
        "name": "TestH12_ExplicitContentLength",
        "desc": ""
      },
      {
        "name": "TestH12_FlushBeforeBody",
        "desc": ""
      },
      {
        "name": "TestH12_FlushMidBody",
        "desc": ""
      },
      {
        "name": "TestH12_HandlerWritesTooLittle",
        "desc": ""
      },
      {
        "name": "TestH12_HeadContentLengthLargeBody",
        "desc": ""
      },
      {
        "name": "TestH12_HeadContentLengthNoBody",
        "desc": "Issue 13532"
      },
      {
        "name": "TestH12_HeadContentLengthSmallBody",
        "desc": ""
      },
      {
        "name": "TestH12_Head_ExplicitLen",
        "desc": ""
      },
      {
        "name": "TestH12_Head_ImplicitLen",
        "desc": ""
      },
      {
        "name": "TestH12_RequestContentLength_Known_NonZero",
        "desc": ""
      },
      {
        "name": "TestH12_RequestContentLength_Known_Zero",
        "desc": ""
      },
      {
        "name": "TestH12_RequestContentLength_Unknown",
        "desc": ""
      },
      {
        "name": "TestH12_ServerEmptyContentLength",
        "desc": ""
      },
      {
        "name": "TestH12_SmallBody",
        "desc": ""
      },
      {
        "name": "TestH12_WebSocketUpgrade",
        "desc": "Always use HTTP/1.1 for WebSocket upgrades."
      },
      {
        "name": "TestH2_204NoBody",
        "desc": ""
      },
      {
        "name": "TestH2_304NoBody",
        "desc": ""
      },
      {
        "name": "TestH2_404NoBody",
        "desc": ""
      },
      {
        "name": "TestHTTP10ConnectionHeader",
        "desc": "https://golang.org/issue/5955 Note that this does not test the \"request too large\" exit path from the http server. This is intentional; not sending Connection: close is just a minor wire optimization and is pointless if dealing with a badly behaved client."
      },
      {
        "name": "TestHTTP10KeepAlive204Response",
        "desc": "Issue 15647: 204 responses can't have bodies, so HTTP/1.0 keep-alive conns should stay open."
      },
      {
        "name": "TestHTTP10KeepAlive304Response",
        "desc": ""
      },
      {
        "name": "TestHTTP11KeepAlive204Response",
        "desc": ""
      },
      {
        "name": "TestHTTP2UpgradeClosesConnection",
        "desc": ""
      },
      {
        "name": "TestHTTPSClientDetectsHTTPServer",
        "desc": "Check that an HTTPS client can interpret a particular TLS error to determine that the server is speaking HTTP. See golang.org/issue/11111."
      },
      {
        "name": "TestHandlerAbortRacesBodyRead",
        "desc": ""
      },
      {
        "name": "TestHandlerBodyClose",
        "desc": ""
      },
      {
        "name": "TestHandlerFinishSkipBigContentLengthRead",
        "desc": "If a Handler finishes and there's an unread request body, verify the server implicitly tries to do a read on it before replying."
      },
      {
        "name": "TestHandlerPanic",
        "desc": ""
      },
      {
        "name": "TestHandlerPanicNil",
        "desc": ""
      },
      {
        "name": "TestHandlerPanicWithHijack",
        "desc": ""
      },
      {
        "name": "TestHandlerSetTransferEncodingChunked",
        "desc": "https://golang.org/issue/15960"
      },
      {
        "name": "TestHandlerSetTransferEncodingGzip",
        "desc": "https://golang.org/issue/16063"
      },
      {
        "name": "TestHandlerSetsBodyNil",
        "desc": ""
      },
      {
        "name": "TestHandlerWritesTooMuch",
        "desc": "Tests that the HTTP/1 and HTTP/2 servers prevent handlers from writing more than they declared. This test does not test whether the transport deals with too much data, though, since the server doesn't make it possible to send bogus data. For those tests, see transport_test.go (for HTTP/1) or x/net/http2/transport_test.go (for HTTP/2)."
      },
      {
        "name": "TestHandlersCanSetConnectionClose10",
        "desc": ""
      },
      {
        "name": "TestHandlersCanSetConnectionClose11",
        "desc": "TestHandlersCanSetConnectionClose verifies that handlers can force a connection to close, even for HTTP/1.1 requests."
      },
      {
        "name": "TestHeadBody",
        "desc": ""
      },
      {
        "name": "TestHeadReaderFrom",
        "desc": "Ensure ResponseWriter.ReadFrom doesn't write a body in response to a HEAD request. https://go.dev/issue/68609"
      },
      {
        "name": "TestHeadResponses",
        "desc": "TestHeadResponses verifies that all MIME type sniffing and Content-Length counting of GET requests also happens on HEAD requests."
      },
      {
        "name": "TestHeaderToWire",
        "desc": "Tests regarding the ordering of Write, WriteHeader, Header, and Flush calls. In Go 1.0, rw.WriteHeader immediately flushed the (*response).header to the wire. In Go 1.1, the actual wire flush is delayed, so we could maybe tack on a Content-Length and better Content-Type after we see more (or all) of the output. To preserve compatibility with Go 1, we need to be careful to track which headers were live at the time of WriteHeader, so we write the same ones, even if the handler modifies them (~erroneously) after the first Write."
      },
      {
        "name": "TestHijackAfterCloseNotifier",
        "desc": "Tests that we can use CloseNotifier in one request, and later call Hijack on a second request on the same connection.  It also tests that the connReader stitches together its background 1-byte read for CloseNotifier when CloseNotifier doesn't fire with the rest of the second HTTP later.  Issue 9763. HTTP/1-only test. (http2 doesn't have Hijack)"
      },
      {
        "name": "TestHijackBeforeRequestBodyRead",
        "desc": ""
      },
      {
        "name": "TestHostHandlers",
        "desc": ""
      },
      {
        "name": "TestIdentityResponse",
        "desc": "TestIdentityResponse verifies that a handler can unset"
      },
      {
        "name": "TestIdentityTransferEncoding",
        "desc": ""
      },
      {
        "name": "TestIdleConnChannelLeak",
        "desc": ""
      },
      {
        "name": "TestIdleConnH2Crash",
        "desc": "Issue 16208: Go 1.7 crashed after Transport.IdleConnTimeout if an HTTP/2 connection was established but its caller no longer wanted it. (Assuming the connection cache was enabled, which it is by default)  This test reproduced the crash by setting the IdleConnTimeout low (to make the test reasonable) and then making a request which is canceled by the DialTLS hook, which then also waits to return the real connection until after the RoundTrip saw the error.  Then we know the successful tls.Dial from DialTLS will need to go into the idle pool. Then we give it a of time to explode."
      },
      {
        "name": "TestInterruptWithPanic",
        "desc": ""
      },
      {
        "name": "TestInvalidChunkedBodies",
        "desc": ""
      },
      {
        "name": "TestInvalidHeaderResponse",
        "desc": ""
      },
      {
        "name": "TestInvalidTrailerClosesConnection",
        "desc": ""
      },
      {
        "name": "TestIs408",
        "desc": ""
      },
      {
        "name": "TestIssue10884_MaxBytesEOF",
        "desc": ""
      },
      {
        "name": "TestIssue11549_Expect100",
        "desc": ""
      },
      {
        "name": "TestIssue13893_Expect100",
        "desc": ""
      },
      {
        "name": "TestIssue32441",
        "desc": "Issue 32441: body is not reset after ErrSkipAltProtocol"
      },
      {
        "name": "TestIssue3595",
        "desc": "Test that a client receives a server's reply, even if the server doesn't read the entire request body."
      },
      {
        "name": "TestIssue3644",
        "desc": "Test that the transport doesn't close the TCP connection early, before the response body has been read. This was a regression which sadly lacked a triggering test. The large response body made the old race easier to trigger."
      },
      {
        "name": "TestIssue4191_InfiniteGetTimeout",
        "desc": ""
      },
      {
        "name": "TestIssue4191_InfiniteGetToPutTimeout",
        "desc": ""
      },
      {
        "name": "TestIssue58237",
        "desc": ""
      },
      {
        "name": "TestIssue61474",
        "desc": ""
      },
      {
        "name": "TestJarCalls",
        "desc": ""
      },
      {
        "name": "TestKeepAliveFinalChunkWithEOF",
        "desc": "Issue 15703"
      },
      {
        "name": "TestLinuxSendfile",
        "desc": "verifies that sendfile is being used on Linux"
      },
      {
        "name": "TestLinuxSendfileChild",
        "desc": "TestLinuxSendfileChild isn't a real test. It's used as a helper process for TestLinuxSendfile."
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "TestMaxBytesHandler",
        "desc": ""
      },
      {
        "name": "TestMaxBytesReaderDifferentLimits",
        "desc": "Issue 45101: maxBytesReader's Read panicked when n \u003c -1. This test also ensures that Read treats negative limits as equivalent to 0."
      },
      {
        "name": "TestMaxBytesReaderStickyError",
        "desc": "Issue 14981: MaxBytesReader's return error wasn't sticky. It doesn't technically need to be, but people expected it to be."
      },
      {
        "name": "TestMaxInt64ForMultipartFormMaxMemoryOverflow",
        "desc": "Issue #40430: Test that if maxMemory for ParseMultipartForm when combined with the payload size and the internal leeway buffer size of 10MiB overflows, that we correctly return an error."
      },
      {
        "name": "TestMissingFileMultipartRequest",
        "desc": ""
      },
      {
        "name": "TestMissingStatusNoPanic",
        "desc": "Ensure that a missing status doesn't make the server panic See Issue https://golang.org/issues/21701"
      },
      {
        "name": "TestMultipartReader",
        "desc": ""
      },
      {
        "name": "TestMultipartReaderOrder",
        "desc": "Test that MultipartReader errors if called after ParseMultipartForm on the same request."
      },
      {
        "name": "TestMultipartRequest",
        "desc": ""
      },
      {
        "name": "TestMultipartRequestAuto",
        "desc": ""
      },
      {
        "name": "TestMuxNoSlash405WithTrailingSlash",
        "desc": "Test that we don't attempt trailing-slash response 405 on a path that already has a trailing slash. See issue #67657."
      },
      {
        "name": "TestMuxNoSlashRedirectWithTrailingSlash",
        "desc": "Test that we don't attempt trailing-slash redirect on a path that already has a trailing slash. See issue #65624."
      },
      {
        "name": "TestMuxRedirectLeadingSlashes",
        "desc": "Tests for https://golang.org/issue/900"
      },
      {
        "name": "TestMuxRedirectRelative",
        "desc": ""
      },
      {
        "name": "TestNewClientServerTest",
        "desc": "Testing the newClientServerTest helper itself."
      },
      {
        "name": "TestNewRequestContentLength",
        "desc": ""
      },
      {
        "name": "TestNewRequestGetBody",
        "desc": "verify that NewRequest sets Request.GetBody and that it works"
      },
      {
        "name": "TestNewRequestHost",
        "desc": ""
      },
      {
        "name": "TestNextProtoUpgrade",
        "desc": ""
      },
      {
        "name": "TestNoBodyOnChunked304Response",
        "desc": "Issue 22330: do not allow the response body to be read when the status code forbids a response body."
      },
      {
        "name": "TestNoContentLengthIfTransferEncoding",
        "desc": "Issue 9987: shouldn't add automatic Content-Length (or Content-Type) if a Transfer-Encoding was set by the handler."
      },
      {
        "name": "TestNoCrashReturningTransportAltConn",
        "desc": "Issue 13839"
      },
      {
        "name": "TestNoPanicOnRoundTripWithBasicAuth",
        "desc": "Issue 34878: verify we don't panic when including basic auth (Go 1.13 regression)"
      },
      {
        "name": "TestNoSniffExpectRequestBody",
        "desc": ""
      },
      {
        "name": "TestNoWriteDeadline",
        "desc": "Test that the HTTP/2 server does not send RST when WriteDeadline not set."
      },
      {
        "name": "TestOnProxyConnectResponse",
        "desc": ""
      },
      {
        "name": "TestOnlyWriteTimeout",
        "desc": "golang.org/issue/4741 -- setting only a write timeout that triggers shouldn't cause a handler to block forever on reads (next HTTP request) that will never happen."
      },
      {
        "name": "TestOptions",
        "desc": ""
      },
      {
        "name": "TestOptionsHandler",
        "desc": ""
      },
      {
        "name": "TestParseBasicAuth",
        "desc": ""
      },
      {
        "name": "TestParseFormCleanup",
        "desc": ""
      },
      {
        "name": "TestParseFormInitializeOnError",
        "desc": ""
      },
      {
        "name": "TestParseFormQuery",
        "desc": ""
      },
      {
        "name": "TestParseFormQueryMethods",
        "desc": "Tests that we only parse the form automatically for certain methods."
      },
      {
        "name": "TestParseFormSemicolonSeparator",
        "desc": "Issue #25192: Test that ParseForm fails but still parses the form when a URL containing a semicolon is provided."
      },
      {
        "name": "TestParseFormUnknownContentType",
        "desc": ""
      },
      {
        "name": "TestParseHTTPVersion",
        "desc": ""
      },
      {
        "name": "TestParseMultipartForm",
        "desc": ""
      },
      {
        "name": "TestParseMultipartFormFilename",
        "desc": "Issue 45789: multipart form should not include directory path in filename"
      },
      {
        "name": "TestParseMultipartFormOrder",
        "desc": "Test that ParseMultipartForm errors if called after MultipartReader on the same request."
      },
      {
        "name": "TestParseMultipartFormPopulatesPostForm",
        "desc": "Issue 9305: ParseMultipartForm should populate PostForm too"
      },
      {
        "name": "TestParseMultipartFormSemicolonSeparator",
        "desc": "Issue #25192: Test that ParseMultipartForm fails but still parses the multi-part form when a URL containing a semicolon is provided."
      },
      {
        "name": "TestPathValueAndPattern",
        "desc": ""
      },
      {
        "name": "TestPathValueNoMatch",
        "desc": ""
      },
      {
        "name": "TestPostFormRequestFormat",
        "desc": ""
      },
      {
        "name": "TestPostRedirects",
        "desc": ""
      },
      {
        "name": "TestPostRequestFormat",
        "desc": ""
      },
      {
        "name": "TestProbeZeroLengthBody",
        "desc": ""
      },
      {
        "name": "TestProcessing",
        "desc": ""
      },
      {
        "name": "TestProxyAuthHeader",
        "desc": ""
      },
      {
        "name": "TestProxyFromEnvironment",
        "desc": ""
      },
      {
        "name": "TestProxyFromEnvironmentLowerCase",
        "desc": ""
      },
      {
        "name": "TestQuery",
        "desc": ""
      },
      {
        "name": "TestQuerySemicolon",
        "desc": "TestQuerySemicolon tests the behavior of semicolons in queries. See Issue 25192."
      },
      {
        "name": "TestReadRequestErrors",
        "desc": ""
      },
      {
        "name": "TestRedirect",
        "desc": "Test different URL formats and schemes"
      },
      {
        "name": "TestRedirectBadPath",
        "desc": ""
      },
      {
        "name": "TestRedirectContentTypeAndBody",
        "desc": "Test that Redirect sets Content-Type header for GET and HEAD requests and writes a short HTML body, unless the request already has a Content-Type header."
      },
      {
        "name": "TestRedirectCookiesJar",
        "desc": ""
      },
      {
        "name": "TestRedirectGetBody",
        "desc": "Make sure the retries copies the GetBody in the request."
      },
      {
        "name": "TestReferer",
        "desc": ""
      },
      {
        "name": "TestRequestBadHostHeader",
        "desc": ""
      },
      {
        "name": "TestRequestBadUserAgent",
        "desc": ""
      },
      {
        "name": "TestRequestBodyCloseDoesntBlock",
        "desc": "Test that a hanging Request.Body.Read from another goroutine can't cause the Handler goroutine's Request.Body.Close to block. See issue 7121."
      },
      {
        "name": "TestRequestBodyLimit",
        "desc": ""
      },
      {
        "name": "TestRequestBodyReadErrorClosesConnection",
        "desc": ""
      },
      {
        "name": "TestRequestBodyTimeoutClosesConnection",
        "desc": ""
      },
      {
        "name": "TestRequestClonePathValue",
        "desc": "Ensure that Request.Clone works correctly with PathValue. See issue 64911."
      },
      {
        "name": "TestRequestCloneTransferEncoding",
        "desc": "Ensure that Request.Clone creates a deep copy of TransferEncoding. See issue 41907."
      },
      {
        "name": "TestRequestCookie",
        "desc": "Issue 53181: verify Request.Cookie return the correct Cookie. Return ErrNoCookie instead of the first cookie when name is \"\"."
      },
      {
        "name": "TestRequestCookiesByName",
        "desc": ""
      },
      {
        "name": "TestRequestInvalidMethod",
        "desc": ""
      },
      {
        "name": "TestRequestLimit",
        "desc": ""
      },
      {
        "name": "TestRequestRedirect",
        "desc": ""
      },
      {
        "name": "TestRequestSanitization",
        "desc": ""
      },
      {
        "name": "TestRequestWriteBufferedWriter",
        "desc": ""
      },
      {
        "name": "TestResponseBodyReadAfterClose",
        "desc": "Don't allow a Body.Read after Body.Close. Issue 13648."
      },
      {
        "name": "TestResponseControllerEnableFullDuplex",
        "desc": ""
      },
      {
        "name": "TestResponseControllerFlush",
        "desc": ""
      },
      {
        "name": "TestResponseControllerHijack",
        "desc": ""
      },
      {
        "name": "TestResponseControllerSetFutureReadDeadline",
        "desc": ""
      },
      {
        "name": "TestResponseControllerSetFutureWriteDeadline",
        "desc": ""
      },
      {
        "name": "TestResponseControllerSetPastReadDeadline",
        "desc": ""
      },
      {
        "name": "TestResponseControllerSetPastWriteDeadline",
        "desc": ""
      },
      {
        "name": "TestResponseSetsTLSConnectionState",
        "desc": ""
      },
      {
        "name": "TestResponseWriterWriteString",
        "desc": "test that ResponseWriter implements io.StringWriter."
      },
      {
        "name": "TestRetryRequestsOnError",
        "desc": "Issues 4677, 18241, and 17844. If we try to reuse a connection that the server is in the process of closing, we may end up successfully writing out our request (or a portion of our request) only to find a connection error when we try to read from (or finish writing to) the socket.  NOTE: we resend a request only if:   - we reused a keep-alive connection   - we haven't yet received any header data   - either we wrote no bytes to the server, or the request is idempotent  This automatically prevents an infinite resend loop because we'll run out of the cached keep-alive connections eventually."
      },
      {
        "name": "TestReuseRequest",
        "desc": ""
      },
      {
        "name": "TestRoundTripGzip",
        "desc": "Test that the modification made to the Request by the RoundTripper is cleaned up"
      },
      {
        "name": "TestRoundTripReturnsProxyError",
        "desc": "Test for issue 8755 Ensure that if a proxy returns an error, it is exposed by RoundTrip"
      },
      {
        "name": "TestSOCKS5Proxy",
        "desc": ""
      },
      {
        "name": "TestScanETag",
        "desc": ""
      },
      {
        "name": "TestServeContent",
        "desc": ""
      },
      {
        "name": "TestServeContentHeadersWithError",
        "desc": ""
      },
      {
        "name": "TestServeContentWithEmptyContentIgnoreRanges",
        "desc": "Tests that ranges are ignored with serving empty content. (Issue 54794)"
      },
      {
        "name": "TestServeDirWithoutTrailingSlash",
        "desc": "Issue 13996"
      },
      {
        "name": "TestServeFile",
        "desc": ""
      },
      {
        "name": "TestServeFileContentType",
        "desc": ""
      },
      {
        "name": "TestServeFileDirPanicEmptyPath",
        "desc": "Tests that this doesn't panic. (Issue 30165)"
      },
      {
        "name": "TestServeFileFS",
        "desc": ""
      },
      {
        "name": "TestServeFileFromCWD",
        "desc": ""
      },
      {
        "name": "TestServeFileMimeType",
        "desc": ""
      },
      {
        "name": "TestServeFileNotModified",
        "desc": "Tests that ServeFile does not generate representation metadata when file has not been modified, as per RFC 7232 section 4.1."
      },
      {
        "name": "TestServeFileRejectsInvalidSuffixLengths",
        "desc": "Issue 40940: Ensure that we only accept non-negative suffix-lengths in \"Range\": \"bytes=-N\", and should reject \"bytes=--2\"."
      },
      {
        "name": "TestServeFileWithContentEncoding",
        "desc": "Tests that ServeFile doesn't add a Content-Length if a Content-Encoding is specified."
      },
      {
        "name": "TestServeFileZippingResponseWriter",
        "desc": ""
      },
      {
        "name": "TestServeFile_DotDot",
        "desc": ""
      },
      {
        "name": "TestServeHTTP10Close",
        "desc": "TestServeHTTP10Close verifies that HTTP/1.0 requests won't be kept alive."
      },
      {
        "name": "TestServeIndexHtml",
        "desc": ""
      },
      {
        "name": "TestServeIndexHtmlFS",
        "desc": ""
      },
      {
        "name": "TestServeMuxHandleFuncWithNilHandler",
        "desc": "Issue 24297"
      },
      {
        "name": "TestServeMuxHandler",
        "desc": ""
      },
      {
        "name": "TestServeMuxHandlerRedirects",
        "desc": "TestServeMuxHandlerRedirects tests that automatic redirects generated by mux.Handler() shouldn't clear the request's query string."
      },
      {
        "name": "TestServeMuxHandlerTrailingSlash",
        "desc": "Issue 73688"
      },
      {
        "name": "TestServeTLS",
        "desc": ""
      },
      {
        "name": "TestServeWithSlashRedirectForHostPatterns",
        "desc": ""
      },
      {
        "name": "TestServeWithSlashRedirectKeepsQueryString",
        "desc": "Test that the special cased \"/route\" redirect implicitly created by a registered \"/route/\" properly sets the query string in the redirect URL. See Issue 17841."
      },
      {
        "name": "TestServerAllowsBlockingRemoteAddr",
        "desc": "Issue 12943"
      },
      {
        "name": "TestServerBufferedChunking",
        "desc": "Tests that chunked server responses that write 1 byte at a time are buffered before chunk headers are added, not after chunk headers."
      },
      {
        "name": "TestServerCancelsReadHeaderTimeoutWhenIdle",
        "desc": "Issue 54784: test that the Server's ReadHeaderTimeout only starts once the beginning of a request has been received, rather than including time the connection spent idle."
      },
      {
        "name": "TestServerCancelsReadTimeoutWhenIdle",
        "desc": "Issue 18447: test that the Server's ReadTimeout is stopped while the server's doing its 1-byte background read between requests, waiting for the connection to maybe close."
      },
      {
        "name": "TestServerCloseDeadlock",
        "desc": "Issue 17878: tests that we can call Close twice."
      },
      {
        "name": "TestServerCloseListenerOnce",
        "desc": "Issue 24803: don't call Listener.Close on Server.Shutdown."
      },
      {
        "name": "TestServerConnState",
        "desc": ""
      },
      {
        "name": "TestServerConnStateNew",
        "desc": ""
      },
      {
        "name": "TestServerContentType",
        "desc": ""
      },
      {
        "name": "TestServerContentTypeSniff",
        "desc": ""
      },
      {
        "name": "TestServerContext_LocalAddrContextKey",
        "desc": ""
      },
      {
        "name": "TestServerContext_ServerContextKey",
        "desc": ""
      },
      {
        "name": "TestServerContexts",
        "desc": ""
      },
      {
        "name": "TestServerDuplicateBackgroundRead",
        "desc": "Issue 18535: test that the Server doesn't try to do a background read if it's already done one."
      },
      {
        "name": "TestServerEmptyBodyRace",
        "desc": "golang.org/issue/7856"
      },
      {
        "name": "TestServerExpect",
        "desc": "Tests that the server responds to the \"Expect\" request header correctly."
      },
      {
        "name": "TestServerFileStatError",
        "desc": "Issue 12991"
      },
      {
        "name": "TestServerFlushAndHijack",
        "desc": "This verifies that a handler can Flush and then Hijack.  A similar test crashed once during development, but it was only testing this tangentially and temporarily until another TODO was fixed.  So add an explicit test for this."
      },
      {
        "name": "TestServerGracefulClose",
        "desc": "Tests that the server flushes its response headers out when it's ignoring the response body and waits a bit before forcefully closing the TCP connection, causing the client to get a RST. See https://golang.org/issue/3595"
      },
      {
        "name": "TestServerHandlersCanHandleH2PRI",
        "desc": ""
      },
      {
        "name": "TestServerHijackGetsBackgroundByte",
        "desc": "Test that the bufio.Reader returned by Hijack includes any buffered byte (from the Server's backgroundRead) in its buffer. We want the Handler code to be able to tell that a byte is available via bufio.Reader.Buffered(), without resorting to Reading it (potentially blocking) to get at it."
      },
      {
        "name": "TestServerHijackGetsBackgroundByte_big",
        "desc": "Like TestServerHijackGetsBackgroundByte above but sending a immediate 1MB of data to the server to fill up the server's 4KB buffer."
      },
      {
        "name": "TestServerHijackGetsFullBody",
        "desc": "Test that the bufio.Reader returned by Hijack yields the entire body."
      },
      {
        "name": "TestServerIdleTimeout",
        "desc": ""
      },
      {
        "name": "TestServerIssue5953",
        "desc": "Issue 5953: shouldn't sniff if the handler set a Content-Type header, even if it's the empty string."
      },
      {
        "name": "TestServerKeepAliveAfterWriteError",
        "desc": "golang.org/issue/8534 -- the Server shouldn't reuse a connection for keep-alive after it's seen any Write error (e.g. a timeout) on that net.Conn.  To test, verify we don't timeout or see fewer unique client addresses (== unique connections) than requests."
      },
      {
        "name": "TestServerKeepAlivesEnabled",
        "desc": "Issue 17717: tests that Server.SetKeepAlivesEnabled is respected by both HTTP/1 and HTTP/2."
      },
      {
        "name": "TestServerKeepAlivesEnabledResultClose",
        "desc": ""
      },
      {
        "name": "TestServerListenNotComparableListener",
        "desc": "Issue 24812: don't crash on non-comparable Listener"
      },
      {
        "name": "TestServerNoDate",
        "desc": ""
      },
      {
        "name": "TestServerNoReadTimeout",
        "desc": ""
      },
      {
        "name": "TestServerNoWriteTimeout",
        "desc": ""
      },
      {
        "name": "TestServerReadAfterHandlerAbort100Continue",
        "desc": ""
      },
      {
        "name": "TestServerReadAfterHandlerDone100Continue",
        "desc": ""
      },
      {
        "name": "TestServerReadAfterWriteHeader100Continue",
        "desc": ""
      },
      {
        "name": "TestServerReadTimeout",
        "desc": ""
      },
      {
        "name": "TestServerReaderFromOrder",
        "desc": "See golang.org/issue/5660"
      },
      {
        "name": "TestServerRequestContextCancel_ConnClose",
        "desc": "Tests that the Request.Context available to the Handler is canceled if the peer closes their TCP connection. This requires that the server is always blocked in a Read call so it notices the EOF from the client. See issues 15927 and 15224."
      },
      {
        "name": "TestServerRequestContextCancel_ServeHTTPDone",
        "desc": ""
      },
      {
        "name": "TestServerSetKeepAlivesEnabledClosesConns",
        "desc": "Tests that calls to Server.SetKeepAlivesEnabled(false) closes any currently-open connections."
      },
      {
        "name": "TestServerShutdown",
        "desc": ""
      },
      {
        "name": "TestServerShutdownStateNew",
        "desc": ""
      },
      {
        "name": "TestServerShutdownThenServe",
        "desc": "Issue 20239: don't block in Serve if Shutdown is called first."
      },
      {
        "name": "TestServerTLSNextProtos",
        "desc": "Issue #72100: Verify that we don't modify the caller's TLS.Config.NextProtos slice."
      },
      {
        "name": "TestServerTimeouts",
        "desc": ""
      },
      {
        "name": "TestServerUndeclaredTrailers",
        "desc": ""
      },
      {
        "name": "TestServerUnreadRequestBodyLarge",
        "desc": "Over a ~256KB (maxPostHandlerReadBytes) threshold, the server should ignore client request bodies that a handler didn't read and close the connection."
      },
      {
        "name": "TestServerUnreadRequestBodyLittle",
        "desc": "Under a ~256KB (maxPostHandlerReadBytes) threshold, the server should consume client request bodies that a handler didn't read."
      },
      {
        "name": "TestServerValidatesHeaders",
        "desc": "Test that we validate the valid bytes in HTTP/1 headers. Issue 11207."
      },
      {
        "name": "TestServerValidatesHostHeader",
        "desc": "Test that we validate the Host header. Issue 11206 (invalid bytes in Host) and 13624 (Host present in HTTP/1.1)"
      },
      {
        "name": "TestServerValidatesMethod",
        "desc": "Issue 18319: test that the Server validates the request method."
      },
      {
        "name": "TestServerWriteHijackZeroBytes",
        "desc": "Issue 16456: allow writing 0 bytes on hijacked conn to test hijack without any log spam."
      },
      {
        "name": "TestServerWriteTimeout",
        "desc": ""
      },
      {
        "name": "TestSetBasicAuth",
        "desc": ""
      },
      {
        "name": "TestSetPathValue",
        "desc": ""
      },
      {
        "name": "TestSetsRemoteAddr",
        "desc": ""
      },
      {
        "name": "TestShouldCopyHeaderOnRedirect",
        "desc": "Part of Issue 4800"
      },
      {
        "name": "TestShouldRedirectConcurrency",
        "desc": ""
      },
      {
        "name": "TestSniffWriteSize",
        "desc": ""
      },
      {
        "name": "TestStarRequest",
        "desc": ""
      },
      {
        "name": "TestStarRequestMethod",
        "desc": ""
      },
      {
        "name": "TestStatus",
        "desc": ""
      },
      {
        "name": "TestStreamingGet",
        "desc": ""
      },
      {
        "name": "TestStressSurpriseServerCloses",
        "desc": "Test for https://golang.org/issue/2616 (appropriate issue number) This fails pretty reliably with GOMAXPROCS=100 or something high."
      },
      {
        "name": "TestStripPasswordFromError",
        "desc": ""
      },
      {
        "name": "TestStripPortFromHost",
        "desc": "Issue 23351: document and test behavior of ServeMux with ports"
      },
      {
        "name": "TestStripPrefix",
        "desc": ""
      },
      {
        "name": "TestStripPrefixNotModifyRequest",
        "desc": "https://golang.org/issue/18952."
      },
      {
        "name": "TestTLSHandshakeTimeout",
        "desc": ""
      },
      {
        "name": "TestTLSHandshakeTrace",
        "desc": "Test the httptrace.TLSHandshake{Start,Done} hooks with an https http1 connections. The http2 test is done in TestTransportEventTrace_h2"
      },
      {
        "name": "TestTLSServer",
        "desc": ""
      },
      {
        "name": "TestTLSServerClosesConnection",
        "desc": "Trying to repro golang.org/issue/3514"
      },
      {
        "name": "TestTLSServerRejectHTTPRequests",
        "desc": "Test that the HTTPS server nicely rejects plaintext HTTP/1.x requests."
      },
      {
        "name": "TestTLSServerWithoutTLSConn",
        "desc": ""
      },
      {
        "name": "TestTimeoutHandler",
        "desc": ""
      },
      {
        "name": "TestTimeoutHandlerContextCanceled",
        "desc": ""
      },
      {
        "name": "TestTimeoutHandlerEmptyResponse",
        "desc": "https://golang.org/issue/15948"
      },
      {
        "name": "TestTimeoutHandlerPanicRecovery",
        "desc": "https://golang.org/issues/22084"
      },
      {
        "name": "TestTimeoutHandlerRace",
        "desc": "See issues 8209 and 8414."
      },
      {
        "name": "TestTimeoutHandlerRaceHeader",
        "desc": "See issues 8209 and 8414. Both issues involved panics in the implementation of TimeoutHandler."
      },
      {
        "name": "TestTimeoutHandlerRaceHeaderTimeout",
        "desc": "Issue 9162"
      },
      {
        "name": "TestTimeoutHandlerStartTimerWhenServing",
        "desc": "Issue 14568."
      },
      {
        "name": "TestTimeoutHandlerSuperfluousLogs",
        "desc": "Issue 30803: ensure that TimeoutHandler logs spurious WriteHeader calls, for consistency with other Handlers."
      },
      {
        "name": "TestTolerateCRLFBeforeRequestLine",
        "desc": "tolerate extra CRLF(s) before Request-Line on subsequent requests on a conn Issue 10876."
      },
      {
        "name": "TestTrailersClientToServer",
        "desc": "Tests that clients can send trailers to a server and that the server can read them."
      },
      {
        "name": "TestTrailersServerToClient",
        "desc": "Tests that servers send trailers to a client and that the client can read them."
      },
      {
        "name": "TestTrailersServerToClientFlush",
        "desc": ""
      },
      {
        "name": "TestTransportAltProto",
        "desc": ""
      },
      {
        "name": "TestTransportAndServerSharedBodyRace",
        "desc": "Issue 6995 A server Handler can receive a Request, and then turn around and give a copy of that Request.Body out to the Transport (e.g. any proxy).  So then two people own that Request.Body (both the server and the http client), and both think they can close it on failure. Therefore, all incoming server requests Bodies need to be thread-safe."
      },
      {
        "name": "TestTransportAutomaticHTTP2",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_DefaultTransport",
        "desc": "golang.org/issue/14391: also check DefaultTransport"
      },
      {
        "name": "TestTransportAutomaticHTTP2_Dial",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_DialContext",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_DialTLS",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_DialerAndTLSConfigSupportsHTTP2AndTLSConfig",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_ExpectContinueTimeout",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_TLSConfig",
        "desc": ""
      },
      {
        "name": "TestTransportAutomaticHTTP2_TLSNextProto",
        "desc": ""
      },
      {
        "name": "TestTransportBodyReadError",
        "desc": "Issue 18239: make sure the Transport doesn't retry requests with bodies if Request.GetBody is not defined."
      },
      {
        "name": "TestTransportCONNECTBidi",
        "desc": ""
      },
      {
        "name": "TestTransportCancelRequest",
        "desc": ""
      },
      {
        "name": "TestTransportCancelRequestBeforeDo",
        "desc": ""
      },
      {
        "name": "TestTransportCancelRequestBeforeResponseHeaders",
        "desc": "Issue 11020. The returned error message should be errRequestCanceled"
      },
      {
        "name": "TestTransportCancelRequestInDial",
        "desc": ""
      },
      {
        "name": "TestTransportCancelRequestInDo",
        "desc": ""
      },
      {
        "name": "TestTransportCancelRequestWithBody",
        "desc": "Issue 51354"
      },
      {
        "name": "TestTransportCancelRequestWithBodyInDo",
        "desc": ""
      },
      {
        "name": "TestTransportCheckContextDoneEarly",
        "desc": "Issue 25852: Transport should check whether Context is done early."
      },
      {
        "name": "TestTransportClone",
        "desc": ""
      },
      {
        "name": "TestTransportCloseIdleConnsThenReturn",
        "desc": "tests that putting an idle conn after a call to CloseIdleConns does return it"
      },
      {
        "name": "TestTransportCloseResponseBody",
        "desc": "golang.org/issue/3672 -- Client can't close HTTP stream Calling Close on a Response.Body used to just read until EOF. Now it actually closes the TCP connection."
      },
      {
        "name": "TestTransportClosesBodyOnError",
        "desc": "Issue 6981"
      },
      {
        "name": "TestTransportClosesBodyOnInvalidRequests",
        "desc": "Issue 35015: ensure that Transport closes the body on any error with an invalid request, as promised by Client.Do docs."
      },
      {
        "name": "TestTransportClosesRequestBody",
        "desc": "Verify the status quo: that the Client.Post function coerces its body into a ReadCloser if it's a Closer, and that the Transport then closes it."
      },
      {
        "name": "TestTransportConcurrency",
        "desc": ""
      },
      {
        "name": "TestTransportConnectionCloseOnRequest",
        "desc": "TestTransportConnectionCloseOnRequest tests that the Transport's doesn't reuse an underlying TCP connection after making an http.Request with Request.Close set.  It tests the behavior by making an HTTP request to a server which describes the source connection it got (remote port number + address of its net.Conn)."
      },
      {
        "name": "TestTransportConnectionCloseOnRequestDisableKeepAlive",
        "desc": "if the Transport's DisableKeepAlives is set, all requests should send Connection: close. HTTP/1-only (Connection: close doesn't exist in h2)"
      },
      {
        "name": "TestTransportConnectionCloseOnResponse",
        "desc": ""
      },
      {
        "name": "TestTransportContentEncodingCaseInsensitive",
        "desc": "Test for issue 19248: Content-Encoding's value is case insensitive."
      },
      {
        "name": "TestTransportDecrementConnWhenIdleConnRemoved",
        "desc": "Issue 34941 When the client has too many concurrent requests on a single connection, http.http2noCachedConnError is reported on multiple requests. There should only be one decrement regardless of the number of failures."
      },
      {
        "name": "TestTransportDialContext",
        "desc": ""
      },
      {
        "name": "TestTransportDialPreservesNetOpProxyError",
        "desc": "Issue 16997: test transport dial preserves typed errors"
      },
      {
        "name": "TestTransportDialTLS",
        "desc": ""
      },
      {
        "name": "TestTransportDialTLSContext",
        "desc": ""
      },
      {
        "name": "TestTransportDiscardsUnneededConns",
        "desc": "Issue 13957"
      },
      {
        "name": "TestTransportDoesNotLimitDelivered1xxResponses",
        "desc": ""
      },
      {
        "name": "TestTransportEmptyMethod",
        "desc": "Issue 13311"
      },
      {
        "name": "TestTransportEventTrace",
        "desc": ""
      },
      {
        "name": "TestTransportEventTraceRealDNS",
        "desc": ""
      },
      {
        "name": "TestTransportEventTraceTLSVerify",
        "desc": ""
      },
      {
        "name": "TestTransportEventTrace_NoHooks",
        "desc": "test a non-nil httptrace.ClientTrace but with all hooks set to zero."
      },
      {
        "name": "TestTransportExpect100Continue200ResponseNoConnClose",
        "desc": ""
      },
      {
        "name": "TestTransportExpect100Continue200ResponseWithConnClose",
        "desc": ""
      },
      {
        "name": "TestTransportExpect100Continue500ResponseNoConnClose",
        "desc": ""
      },
      {
        "name": "TestTransportExpect100Continue500ResponseTimeout",
        "desc": ""
      },
      {
        "name": "TestTransportExpect100ContinueSent",
        "desc": ""
      },
      {
        "name": "TestTransportFlushesBodyChunks",
        "desc": "Issue 6574"
      },
      {
        "name": "TestTransportFlushesRequestHeader",
        "desc": "Issue 22088: flush Transport request headers if we're not sure the body won't block on read."
      },
      {
        "name": "TestTransportGCRequest",
        "desc": "tests that Transport doesn't retain a pointer to the provided request."
      },
      {
        "name": "TestTransportGzip",
        "desc": ""
      },
      {
        "name": "TestTransportGzipRecursive",
        "desc": "TestTransportGzipRecursive sends a gzip quine and checks that the client gets the same value back. This is more cute than anything, but checks that we don't recurse forever, and checks that Content-Encoding is removed."
      },
      {
        "name": "TestTransportGzipShort",
        "desc": "golang.org/issue/7750: request fails when server replies with a short gzip body"
      },
      {
        "name": "TestTransportHeadChunkedResponse",
        "desc": "TestTransportHeadChunkedResponse verifies that we ignore chunked transfer-encoding on responses to HEAD requests."
      },
      {
        "name": "TestTransportHeadResponses",
        "desc": "TestTransportHeadResponses verifies that we deal with Content-Lengths with no bodies properly"
      },
      {
        "name": "TestTransportIDNA",
        "desc": "Issue 13835: international domain names should work"
      },
      {
        "name": "TestTransportIdleCacheKeys",
        "desc": ""
      },
      {
        "name": "TestTransportIdleConnCrash",
        "desc": "This used to crash; https://golang.org/issue/3266"
      },
      {
        "name": "TestTransportIdleConnRacesRequest",
        "desc": "https://go.dev/issue/70515  When the first request on a new connection fails, we do not retry the request. If the first request on a connection races with IdleConnTimeout, we should not fail the request."
      },
      {
        "name": "TestTransportIdleConnTimeout",
        "desc": ""
      },
      {
        "name": "TestTransportIgnore1xxResponses",
        "desc": "Issue 17739: the HTTP client must ignore any unknown 1xx informational responses before the actual response."
      },
      {
        "name": "TestTransportIgnores408",
        "desc": ""
      },
      {
        "name": "TestTransportIssue10457",
        "desc": "Tests that we don't leak Transport persistConn.readLoop goroutines when a server hangs up immediately after saying it would keep-alive."
      },
      {
        "name": "TestTransportKeepAlives",
        "desc": "Two subsequent requests and verify their response is the same. The response from the server is our own IP:port"
      },
      {
        "name": "TestTransportLimits1xxResponses",
        "desc": ""
      },
      {
        "name": "TestTransportMaxConnsPerHost",
        "desc": ""
      },
      {
        "name": "TestTransportMaxConnsPerHostDialCancellation",
        "desc": ""
      },
      {
        "name": "TestTransportMaxConnsPerHostIncludeDialInProgress",
        "desc": ""
      },
      {
        "name": "TestTransportMaxIdleConns",
        "desc": ""
      },
      {
        "name": "TestTransportMaxPerHostIdleConns",
        "desc": ""
      },
      {
        "name": "TestTransportNoHost",
        "desc": ""
      },
      {
        "name": "TestTransportNoReuseAfterEarlyResponse",
        "desc": "Verifies that the Transport doesn't reuse a connection in the case where the server replies before the request has been fully written. We still honor that reply (see TestIssue3595), but don't send future requests on the connection because it's then in a questionable state. golang.org/issue/7569"
      },
      {
        "name": "TestTransportPersistConnContextLeakMaxConnsPerHost",
        "desc": ""
      },
      {
        "name": "TestTransportPersistConnLeak",
        "desc": "tests that persistent goroutine connections shut down when no longer desired."
      },
      {
        "name": "TestTransportPersistConnLeakNeverIdle",
        "desc": ""
      },
      {
        "name": "TestTransportPersistConnLeakShortBody",
        "desc": "golang.org/issue/4531: Transport leaks goroutines when request.ContentLength is explicitly short"
      },
      {
        "name": "TestTransportPoolConnCannotReuseConnectionInUse",
        "desc": ""
      },
      {
        "name": "TestTransportPoolConnConnectionBecomesAvailableDuringDial",
        "desc": ""
      },
      {
        "name": "TestTransportPoolConnReusePriorConnection",
        "desc": ""
      },
      {
        "name": "TestTransportPrefersResponseOverWriteError",
        "desc": "Issue 11745."
      },
      {
        "name": "TestTransportProxy",
        "desc": ""
      },
      {
        "name": "TestTransportProxyConnectHeader",
        "desc": "Issue 13290: send User-Agent in proxy CONNECT"
      },
      {
        "name": "TestTransportProxyDialDoesNotMutateProxyConnectHeader",
        "desc": "Issue 36431: calls to RoundTrip should not mutate t.ProxyConnectHeader.  (A bug caused dialConn to instead write the per-request Proxy-Authorization header through to the shared Header instance, introducing a data race.)"
      },
      {
        "name": "TestTransportProxyGetConnectHeader",
        "desc": ""
      },
      {
        "name": "TestTransportProxyHTTPSConnectLeak",
        "desc": "Issue 28012: verify that the Transport closes its TCP connection to http proxies when they're slow to reply to HTTPS CONNECT responses."
      },
      {
        "name": "TestTransportRangeAndGzip",
        "desc": "This tests that a client requesting a content range won't also implicitly ask for gzip support. If they want that, they need to do it on their own. golang.org/issue/8923"
      },
      {
        "name": "TestTransportReadToEndReusesConn",
        "desc": "Tests that the HTTP transport re-uses connections when a client reads to the end of a response Body without closing it."
      },
      {
        "name": "TestTransportReading100Continue",
        "desc": "Issue 2184"
      },
      {
        "name": "TestTransportRejectsAlphaPort",
        "desc": "Issue 14353: port can only contain digits."
      },
      {
        "name": "TestTransportRejectsInvalidHeaders",
        "desc": ""
      },
      {
        "name": "TestTransportRejectsSignInContentLength",
        "desc": "Issue 39017. Ensure that HTTP/1 transports reject Content-Length headers that contain a sign (eg. \"+3\"), per RFC 2616, Section 14.13."
      },
      {
        "name": "TestTransportRemovesConnsAfterBroken",
        "desc": ""
      },
      {
        "name": "TestTransportRemovesConnsAfterIdle",
        "desc": ""
      },
      {
        "name": "TestTransportRemovesDeadIdleConnections",
        "desc": ""
      },
      {
        "name": "TestTransportReqCancelerCleanupOnRequestBodyWriteError",
        "desc": "Issue 61708"
      },
      {
        "name": "TestTransportRequestReplayable",
        "desc": ""
      },
      {
        "name": "TestTransportRequestWriteRoundTrip",
        "desc": ""
      },
      {
        "name": "TestTransportRespectRequestWantsClose",
        "desc": "Test that Transport only sends one \"Connection: close\", regardless of how \"close\" was indicated."
      },
      {
        "name": "TestTransportResponseBodyWritableOnProtocolSwitch",
        "desc": ""
      },
      {
        "name": "TestTransportResponseCancelRace",
        "desc": "Test for issue 10474"
      },
      {
        "name": "TestTransportResponseHeaderLength",
        "desc": ""
      },
      {
        "name": "TestTransportResponseHeaderTimeout",
        "desc": ""
      },
      {
        "name": "TestTransportReturnsPeekError",
        "desc": "Issue 16465: Transport.RoundTrip should return the raw net.Conn.Read error from Peek back to the caller."
      },
      {
        "name": "TestTransportReuseConnEmptyResponseBody",
        "desc": "Issue 13633: there was a race where we returned bodyless responses to callers before recycling the persistent connection, which meant a client doing two subsequent requests could end up on different connections. It's somewhat harmless but enough tests assume it's not true in order to test other things that it's worth fixing. Plus it's nice to be consistent and not have timing-dependent behavior."
      },
      {
        "name": "TestTransportReuseConnection_Gzip_Chunked",
        "desc": ""
      },
      {
        "name": "TestTransportReuseConnection_Gzip_ContentLength",
        "desc": ""
      },
      {
        "name": "TestTransportServerClosingUnexpectedly",
        "desc": "Test that the Transport notices when a server hangs up on its unexpectedly (a keep-alive connection is closed)."
      },
      {
        "name": "TestTransportServerProtocols",
        "desc": ""
      },
      {
        "name": "TestTransportSocketLateBinding",
        "desc": ""
      },
      {
        "name": "TestTransportTLSHandshakeTimeout",
        "desc": ""
      },
      {
        "name": "TestTransportTraceGotConnH2IdleConns",
        "desc": "Test for issue 34282 Ensure that getConn doesn't call the GotConn trace hook on an HTTP/2 idle conn"
      },
      {
        "name": "TestTransportTreat101Terminal",
        "desc": "Issue 26161: the HTTP client must treat 101 responses as the final response."
      },
      {
        "name": "TestTransportUserAgent",
        "desc": ""
      },
      {
        "name": "TestTransportUsesTLSConfigServerName",
        "desc": "Test for golang.org/issue/5829; the Transport should respect TLSClientConfig.ServerName when not empty.  tls.Config.ServerName (non-empty, set to \"example.com\") takes precedence over \"some-other-host.tld\" which previously incorrectly took precedence. We don't actually connect to (or even resolve) \"some-other-host.tld\", though, because of the Transport.Dial hook.  The httptest.Server has a cert with \"example.com\" as its name."
      },
      {
        "name": "TestUnsupportedTransferEncodingsReturn501",
        "desc": "Issue 30710: ensure that as per the spec, a server responds with 501 Not Implemented for unsupported transfer-encodings."
      },
      {
        "name": "TestValidateClientRequestTrailers",
        "desc": ""
      },
      {
        "name": "TestWithContextNilURL",
        "desc": ""
      },
      {
        "name": "TestWrappedResponseController",
        "desc": ""
      },
      {
        "name": "TestWriteAfterHijack",
        "desc": ""
      },
      {
        "name": "TestWriteDeadlineEnforcedPerStream",
        "desc": "Test that the HTTP/2 server RSTs stream on slow write."
      },
      {
        "name": "TestWriteDeadlineExtendedOnNewRequest",
        "desc": "Test that the HTTP/2 server handles Server.WriteTimeout (Issue 18437)"
      },
      {
        "name": "TestWriteHeader0",
        "desc": ""
      },
      {
        "name": "TestWriteHeaderNoCodeCheck",
        "desc": "Issue 23010: don't be super strict checking WriteHeader's code if it's not even valid to call WriteHeader then anyway."
      },
      {
        "name": "TestWriteHeaderNoCodeCheck_h1hijack",
        "desc": ""
      },
      {
        "name": "TestWriteHeaderSwitchingProtocols",
        "desc": ""
      },
      {
        "name": "TestZeroLengthPostAndResponse",
        "desc": "TestZeroLengthPostAndResponse exercises an optimization done by the Transport: when there is no body (either because the method doesn't permit a body, or an explicit Content-Length of zero is present), then the transport can re-use the connection immediately. But when it re-uses the connection, it typically closes the previous request's body, which is not optimal for zero-lengthed bodies, as the client would then see http.ErrBodyReadAfterClose and not 0, io.EOF."
      },
      {
        "name": "afterTest",
        "desc": ""
      },
      {
        "name": "benchmarkClientServer",
        "desc": ""
      },
      {
        "name": "benchmarkClientServerParallel",
        "desc": ""
      },
      {
        "name": "benchmarkCloseNotifier",
        "desc": ""
      },
      {
        "name": "benchmarkFileAndServer",
        "desc": ""
      },
      {
        "name": "benchmarkHandler",
        "desc": ""
      },
      {
        "name": "benchmarkReadRequest",
        "desc": ""
      },
      {
        "name": "benchmarkServeMux",
        "desc": ""
      },
      {
        "name": "checkQueryStringHandler",
        "desc": "checkQueryStringHandler checks if r.URL.RawQuery has the same value as the URL excluding the scheme and the query string and sends 200 response code if it is, 500 otherwise."
      },
      {
        "name": "containsDotFile",
        "desc": "containsDotFile reports whether name contains a path element starting with a period. The name is assumed to be a delimited by forward slashes, as guaranteed by the http.FileSystem interface."
      },
      {
        "name": "doFetchCheckPanic",
        "desc": ""
      },
      {
        "name": "fetchWireResponse",
        "desc": "fetchWireResponse is a helper for dialing to host, sending http1ReqBody as the payload and retrieving the response as it was sent on the wire."
      },
      {
        "name": "get",
        "desc": ""
      },
      {
        "name": "getBody",
        "desc": ""
      },
      {
        "name": "getNoBody",
        "desc": "getNoBody wraps Get but closes any Response.Body before returning the response."
      },
      {
        "name": "goroutineLeaked",
        "desc": "Verify the other tests didn't leave any goroutines running."
      },
      {
        "name": "h12requestContentLength",
        "desc": ""
      },
      {
        "name": "handleTLSProtocol09",
        "desc": "handleTLSProtocol09 implements the HTTP/0.9 protocol over TLS, for the TestNextProtoUpgrade test."
      },
      {
        "name": "httptestNewRequest",
        "desc": "httptestNewRequest works around https://go.dev/issue/73151."
      },
      {
        "name": "interestingGoroutines",
        "desc": ""
      },
      {
        "name": "matchReturnedCookies",
        "desc": ""
      },
      {
        "name": "mostlyCopy",
        "desc": ""
      },
      {
        "name": "mustRemoveAll",
        "desc": ""
      },
      {
        "name": "mustStat",
        "desc": ""
      },
      {
        "name": "newLocalListener",
        "desc": ""
      },
      {
        "name": "newPeopleHandler",
        "desc": ""
      },
      {
        "name": "newTestMultipartRequest",
        "desc": ""
      },
      {
        "name": "optWithServerLog",
        "desc": ""
      },
      {
        "name": "pedanticReadAll",
        "desc": "pedanticReadAll works like io.ReadAll but additionally verifies that r obeys the documented io.Reader contract."
      },
      {
        "name": "removeCommonLines",
        "desc": ""
      },
      {
        "name": "reqBytes",
        "desc": "reqBytes treats req as a request (with \\n delimiters) and returns it with \\r\\n delimiters, ending in \\r\\n\\r\\n"
      },
      {
        "name": "run",
        "desc": "run runs a client/server test in a variety of test configurations.  Tests execute in HTTP/1.1 and HTTP/2 modes by default. To run in a different set of configurations, pass a []testMode option.  Tests call t.Parallel() by default. To disable parallel execution, pass the testNotParallel option."
      },
      {
        "name": "runCancelTest",
        "desc": ""
      },
      {
        "name": "runCancelTestChannel",
        "desc": "runCancelTestChannel uses Request.Cancel."
      },
      {
        "name": "runCancelTestContext",
        "desc": "runCancelTestContext uses a request context."
      },
      {
        "name": "runCancelTestTransport",
        "desc": "runCancelTestTransport uses Transport.CancelRequest."
      },
      {
        "name": "runFileAndServerBenchmarks",
        "desc": ""
      },
      {
        "name": "runSynctest",
        "desc": "runSynctest is run combined with synctest.Run.  The TB passed to f arranges for cleanup functions to be run in the synctest bubble."
      },
      {
        "name": "runTimeSensitiveTest",
        "desc": "runTimeSensitiveTest runs test with the provided durations until one passes. If they all fail, t.Fatal is called with the last one's duration and error value."
      },
      {
        "name": "runningBenchmarks",
        "desc": ""
      },
      {
        "name": "send204",
        "desc": ""
      },
      {
        "name": "send304",
        "desc": ""
      },
      {
        "name": "serve",
        "desc": "serve returns a handler that sends a response with the given code."
      },
      {
        "name": "setParallel",
        "desc": "setParallel marks t as a parallel test if we're in short mode (all.bash), but as a serial test otherwise. Using t.Parallel isn't compatible with the afterTest func in non-short mode."
      },
      {
        "name": "skipIfDNSHijacked",
        "desc": ""
      },
      {
        "name": "test304Responses",
        "desc": ""
      },
      {
        "name": "testAutomaticHTTP2_ListenAndServe",
        "desc": ""
      },
      {
        "name": "testAutomaticHTTP2_Serve",
        "desc": ""
      },
      {
        "name": "testBadResponseAfterReadingBody",
        "desc": ""
      },
      {
        "name": "testBidiStreamReverseProxy",
        "desc": ""
      },
      {
        "name": "testCancelRequestMidBody",
        "desc": ""
      },
      {
        "name": "testCancelRequestWhenSharingConnection",
        "desc": ""
      },
      {
        "name": "testCaseSensitiveMethod",
        "desc": ""
      },
      {
        "name": "testChunkedNoContent",
        "desc": ""
      },
      {
        "name": "testChunkedResponseHeaders",
        "desc": ""
      },
      {
        "name": "testClient",
        "desc": ""
      },
      {
        "name": "testClientAltersCookiesOnRedirect",
        "desc": ""
      },
      {
        "name": "testClientCallsCloseOnlyOnce",
        "desc": ""
      },
      {
        "name": "testClientCopyHeadersOnRedirect",
        "desc": ""
      },
      {
        "name": "testClientCopyHostOnRedirect",
        "desc": ""
      },
      {
        "name": "testClientDoCanceledVsTimeout",
        "desc": ""
      },
      {
        "name": "testClientHead",
        "desc": ""
      },
      {
        "name": "testClientHeadContentLength",
        "desc": ""
      },
      {
        "name": "testClientInsecureTransport",
        "desc": ""
      },
      {
        "name": "testClientRedirect308NoGetBody",
        "desc": ""
      },
      {
        "name": "testClientRedirectEatsBody",
        "desc": ""
      },
      {
        "name": "testClientRedirectNoLocation",
        "desc": ""
      },
      {
        "name": "testClientRedirectTypes",
        "desc": ""
      },
      {
        "name": "testClientRedirectUseResponse",
        "desc": ""
      },
      {
        "name": "testClientRedirects",
        "desc": ""
      },
      {
        "name": "testClientRedirectsContext",
        "desc": ""
      },
      {
        "name": "testClientStripHeadersOnRepeatedRedirect",
        "desc": ""
      },
      {
        "name": "testClientTimeout",
        "desc": ""
      },
      {
        "name": "testClientTimeoutCancel",
        "desc": ""
      },
      {
        "name": "testClientTimeoutDoesNotExpire",
        "desc": ""
      },
      {
        "name": "testClientTimeoutKillsConn_AfterHeaders",
        "desc": ""
      },
      {
        "name": "testClientTimeoutKillsConn_BeforeHeaders",
        "desc": ""
      },
      {
        "name": "testClientTimeout_Headers",
        "desc": ""
      },
      {
        "name": "testClientWithCorrectTLSServerName",
        "desc": ""
      },
      {
        "name": "testClientWithIncorrectTLSServerName",
        "desc": ""
      },
      {
        "name": "testClientWriteShutdown",
        "desc": ""
      },
      {
        "name": "testClientWrites",
        "desc": ""
      },
      {
        "name": "testCloseIdleConnections",
        "desc": ""
      },
      {
        "name": "testCloseNotifier",
        "desc": ""
      },
      {
        "name": "testCloseNotifierPipelined",
        "desc": ""
      },
      {
        "name": "testConcurrentReadWriteReqBody",
        "desc": ""
      },
      {
        "name": "testConnClosedBeforeRequestIsWritten",
        "desc": ""
      },
      {
        "name": "testConnContextNotModifyingAllContexts",
        "desc": ""
      },
      {
        "name": "testConnectRequest",
        "desc": ""
      },
      {
        "name": "testContentEncodingNoSniffing",
        "desc": ""
      },
      {
        "name": "testContentLengthZero",
        "desc": ""
      },
      {
        "name": "testContentTypeWithVariousSources",
        "desc": ""
      },
      {
        "name": "testDirectoryIfNotModified",
        "desc": ""
      },
      {
        "name": "testDisableContentLength",
        "desc": ""
      },
      {
        "name": "testDisableKeepAliveUpgrade",
        "desc": ""
      },
      {
        "name": "testDontCacheBrokenHTTP2Conn",
        "desc": ""
      },
      {
        "name": "testEarlyHintsRequest",
        "desc": ""
      },
      {
        "name": "testEmptyPasswordAuth",
        "desc": ""
      },
      {
        "name": "testErrorContentLength",
        "desc": ""
      },
      {
        "name": "testFSRedirect",
        "desc": ""
      },
      {
        "name": "testFileServerDirWithRootFile",
        "desc": ""
      },
      {
        "name": "testFileServerErrorMessages",
        "desc": ""
      },
      {
        "name": "testFileServerEscapesNames",
        "desc": ""
      },
      {
        "name": "testFileServerImplicitLeadingSlash",
        "desc": ""
      },
      {
        "name": "testFileServerMethods",
        "desc": ""
      },
      {
        "name": "testFileServerNamesEscape",
        "desc": ""
      },
      {
        "name": "testFileServerNotDirError",
        "desc": ""
      },
      {
        "name": "testFileServerNullByte",
        "desc": ""
      },
      {
        "name": "testFileServerSortsNames",
        "desc": ""
      },
      {
        "name": "testFileServerZeroByte",
        "desc": ""
      },
      {
        "name": "testH12_noBody",
        "desc": ""
      },
      {
        "name": "testHTTP10ConnectionHeader",
        "desc": ""
      },
      {
        "name": "testHTTPSClientDetectsHTTPServer",
        "desc": ""
      },
      {
        "name": "testHandlerAbortRacesBodyRead",
        "desc": ""
      },
      {
        "name": "testHandlerBodyClose",
        "desc": ""
      },
      {
        "name": "testHandlerPanic",
        "desc": ""
      },
      {
        "name": "testHandlerSetsBodyNil",
        "desc": ""
      },
      {
        "name": "testHandlerWritesTooMuch",
        "desc": ""
      },
      {
        "name": "testHeadBody",
        "desc": ""
      },
      {
        "name": "testHeadReaderFrom",
        "desc": ""
      },
      {
        "name": "testHeadResponses",
        "desc": ""
      },
      {
        "name": "testHijackAfterCloseNotifier",
        "desc": ""
      },
      {
        "name": "testHijackBeforeRequestBodyRead",
        "desc": ""
      },
      {
        "name": "testHostHandlers",
        "desc": ""
      },
      {
        "name": "testIdentityResponse",
        "desc": ""
      },
      {
        "name": "testIdentityTransferEncoding",
        "desc": ""
      },
      {
        "name": "testIdleConnChannelLeak",
        "desc": ""
      },
      {
        "name": "testIdleConnH2Crash",
        "desc": ""
      },
      {
        "name": "testInterruptWithPanic",
        "desc": ""
      },
      {
        "name": "testInvalidHeaderResponse",
        "desc": ""
      },
      {
        "name": "testIssue32441",
        "desc": ""
      },
      {
        "name": "testIssue3595",
        "desc": ""
      },
      {
        "name": "testIssue3644",
        "desc": ""
      },
      {
        "name": "testIssue4191_InfiniteGetTimeout",
        "desc": ""
      },
      {
        "name": "testIssue4191_InfiniteGetToPutTimeout",
        "desc": ""
      },
      {
        "name": "testIssue61474",
        "desc": ""
      },
      {
        "name": "testJarCalls",
        "desc": ""
      },
      {
        "name": "testKeepAliveFinalChunkWithEOF",
        "desc": ""
      },
      {
        "name": "testMaxBytesHandler",
        "desc": ""
      },
      {
        "name": "testMaxInt64ForMultipartFormMaxMemoryOverflow",
        "desc": ""
      },
      {
        "name": "testMissingFile",
        "desc": ""
      },
      {
        "name": "testMultipartFile",
        "desc": ""
      },
      {
        "name": "testNewClientServerTest",
        "desc": ""
      },
      {
        "name": "testNoBodyOnChunked304Response",
        "desc": ""
      },
      {
        "name": "testNoContentLengthIfTransferEncoding",
        "desc": ""
      },
      {
        "name": "testNoPanicWithBasicAuth",
        "desc": ""
      },
      {
        "name": "testNoSniffExpectRequestBody",
        "desc": ""
      },
      {
        "name": "testNoWriteDeadline",
        "desc": ""
      },
      {
        "name": "testOnlyWriteTimeout",
        "desc": ""
      },
      {
        "name": "testOptions",
        "desc": ""
      },
      {
        "name": "testOptionsHandler",
        "desc": ""
      },
      {
        "name": "testParseFormCleanup",
        "desc": ""
      },
      {
        "name": "testProbeZeroLengthBody",
        "desc": ""
      },
      {
        "name": "testProxyAuthHeader",
        "desc": ""
      },
      {
        "name": "testProxyForRequest",
        "desc": ""
      },
      {
        "name": "testQuerySemicolon",
        "desc": ""
      },
      {
        "name": "testRedirectCookiesJar",
        "desc": ""
      },
      {
        "name": "testRedirectGetBody",
        "desc": ""
      },
      {
        "name": "testRedirectsByMethod",
        "desc": ""
      },
      {
        "name": "testRequestBodyCloseDoesntBlock",
        "desc": ""
      },
      {
        "name": "testRequestBodyLimit",
        "desc": ""
      },
      {
        "name": "testRequestLimit",
        "desc": ""
      },
      {
        "name": "testRequestRedirect",
        "desc": ""
      },
      {
        "name": "testRequestSanitization",
        "desc": ""
      },
      {
        "name": "testResponseBodyReadAfterClose",
        "desc": ""
      },
      {
        "name": "testResponseControllerEnableFullDuplex",
        "desc": ""
      },
      {
        "name": "testResponseControllerFlush",
        "desc": ""
      },
      {
        "name": "testResponseControllerHijack",
        "desc": ""
      },
      {
        "name": "testResponseControllerSetFutureReadDeadline",
        "desc": ""
      },
      {
        "name": "testResponseControllerSetFutureWriteDeadline",
        "desc": ""
      },
      {
        "name": "testResponseControllerSetPastReadDeadline",
        "desc": ""
      },
      {
        "name": "testResponseControllerSetPastWriteDeadline",
        "desc": ""
      },
      {
        "name": "testResponseSetsTLSConnectionState",
        "desc": ""
      },
      {
        "name": "testRetryRequestsOnError",
        "desc": ""
      },
      {
        "name": "testReuseRequest",
        "desc": ""
      },
      {
        "name": "testRoundTripGzip",
        "desc": ""
      },
      {
        "name": "testSOCKS5Proxy",
        "desc": ""
      },
      {
        "name": "testServeContent",
        "desc": ""
      },
      {
        "name": "testServeContentHeadersWithError",
        "desc": ""
      },
      {
        "name": "testServeDirWithoutTrailingSlash",
        "desc": ""
      },
      {
        "name": "testServeFile",
        "desc": ""
      },
      {
        "name": "testServeFileContentType",
        "desc": ""
      },
      {
        "name": "testServeFileFromCWD",
        "desc": ""
      },
      {
        "name": "testServeFileMimeType",
        "desc": ""
      },
      {
        "name": "testServeFileNotModified",
        "desc": ""
      },
      {
        "name": "testServeFileRejectsInvalidSuffixLengths",
        "desc": ""
      },
      {
        "name": "testServeFileWithContentEncoding",
        "desc": ""
      },
      {
        "name": "testServeIndexHtml",
        "desc": ""
      },
      {
        "name": "testServeIndexHtmlFS",
        "desc": ""
      },
      {
        "name": "testServeWithSlashRedirectKeepsQueryString",
        "desc": ""
      },
      {
        "name": "testServerAllowsBlockingRemoteAddr",
        "desc": ""
      },
      {
        "name": "testServerCancelsReadHeaderTimeoutWhenIdle",
        "desc": ""
      },
      {
        "name": "testServerCancelsReadTimeoutWhenIdle",
        "desc": ""
      },
      {
        "name": "testServerConnState",
        "desc": ""
      },
      {
        "name": "testServerContentTypeSniff",
        "desc": ""
      },
      {
        "name": "testServerContext_LocalAddrContextKey",
        "desc": ""
      },
      {
        "name": "testServerContext_ServerContextKey",
        "desc": ""
      },
      {
        "name": "testServerContexts",
        "desc": ""
      },
      {
        "name": "testServerDuplicateBackgroundRead",
        "desc": ""
      },
      {
        "name": "testServerEmptyBodyRace",
        "desc": ""
      },
      {
        "name": "testServerExpect",
        "desc": ""
      },
      {
        "name": "testServerFlushAndHijack",
        "desc": ""
      },
      {
        "name": "testServerGracefulClose",
        "desc": ""
      },
      {
        "name": "testServerHandlersCanHandleH2PRI",
        "desc": ""
      },
      {
        "name": "testServerHijackGetsBackgroundByte",
        "desc": ""
      },
      {
        "name": "testServerHijackGetsBackgroundByte_big",
        "desc": ""
      },
      {
        "name": "testServerHijackGetsFullBody",
        "desc": ""
      },
      {
        "name": "testServerIdleTimeout",
        "desc": ""
      },
      {
        "name": "testServerIssue5953",
        "desc": ""
      },
      {
        "name": "testServerKeepAliveAfterWriteError",
        "desc": ""
      },
      {
        "name": "testServerKeepAlivesEnabled",
        "desc": ""
      },
      {
        "name": "testServerKeepAlivesEnabledResultClose",
        "desc": ""
      },
      {
        "name": "testServerNoHeader",
        "desc": ""
      },
      {
        "name": "testServerNoReadTimeout",
        "desc": ""
      },
      {
        "name": "testServerNoWriteTimeout",
        "desc": ""
      },
      {
        "name": "testServerReadAfterHandlerAbort100Continue",
        "desc": ""
      },
      {
        "name": "testServerReadAfterHandlerDone100Continue",
        "desc": ""
      },
      {
        "name": "testServerReadAfterWriteHeader100Continue",
        "desc": ""
      },
      {
        "name": "testServerReadTimeout",
        "desc": ""
      },
      {
        "name": "testServerReaderFromOrder",
        "desc": ""
      },
      {
        "name": "testServerRequestContextCancel_ConnClose",
        "desc": ""
      },
      {
        "name": "testServerRequestContextCancel_ServeHTTPDone",
        "desc": ""
      },
      {
        "name": "testServerSetKeepAlivesEnabledClosesConns",
        "desc": ""
      },
      {
        "name": "testServerShutdown",
        "desc": ""
      },
      {
        "name": "testServerShutdownStateNew",
        "desc": ""
      },
      {
        "name": "testServerTLSNextProtos",
        "desc": ""
      },
      {
        "name": "testServerTimeouts",
        "desc": ""
      },
      {
        "name": "testServerTimeoutsWithTimeout",
        "desc": ""
      },
      {
        "name": "testServerUndeclaredTrailers",
        "desc": ""
      },
      {
        "name": "testServerWriteHijackZeroBytes",
        "desc": ""
      },
      {
        "name": "testServerWriteTimeout",
        "desc": ""
      },
      {
        "name": "testSetsRemoteAddr",
        "desc": ""
      },
      {
        "name": "testShouldRedirectConcurrency",
        "desc": ""
      },
      {
        "name": "testSniffWriteSize",
        "desc": ""
      },
      {
        "name": "testStarRequest",
        "desc": ""
      },
      {
        "name": "testStreamingGet",
        "desc": ""
      },
      {
        "name": "testStressSurpriseServerCloses",
        "desc": ""
      },
      {
        "name": "testStripPrefix",
        "desc": ""
      },
      {
        "name": "testTCPConnectionCloses",
        "desc": ""
      },
      {
        "name": "testTCPConnectionStaysOpen",
        "desc": ""
      },
      {
        "name": "testTLSHandshakeTimeout",
        "desc": ""
      },
      {
        "name": "testTLSHandshakeTrace",
        "desc": ""
      },
      {
        "name": "testTLSServer",
        "desc": ""
      },
      {
        "name": "testTLSServerClosesConnection",
        "desc": ""
      },
      {
        "name": "testTLSServerRejectHTTPRequests",
        "desc": ""
      },
      {
        "name": "testTimeoutHandler",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerContextCanceled",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerEmptyResponse",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerRace",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerRaceHeader",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerRaceHeaderTimeout",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerStartTimerWhenServing",
        "desc": ""
      },
      {
        "name": "testTimeoutHandlerSuperfluousLogs",
        "desc": ""
      },
      {
        "name": "testTrailersClientToServer",
        "desc": ""
      },
      {
        "name": "testTrailersServerToClient",
        "desc": ""
      },
      {
        "name": "testTransportAndServerSharedBodyRace",
        "desc": ""
      },
      {
        "name": "testTransportAutoHTTP",
        "desc": ""
      },
      {
        "name": "testTransportBodyReadError",
        "desc": ""
      },
      {
        "name": "testTransportCONNECTBidi",
        "desc": ""
      },
      {
        "name": "testTransportCancelRequest",
        "desc": ""
      },
      {
        "name": "testTransportCancelRequestBeforeDo",
        "desc": ""
      },
      {
        "name": "testTransportCancelRequestBeforeResponseHeaders",
        "desc": ""
      },
      {
        "name": "testTransportCancelRequestInDial",
        "desc": ""
      },
      {
        "name": "testTransportCancelRequestInDo",
        "desc": ""
      },
      {
        "name": "testTransportCancelRequestWithBody",
        "desc": ""
      },
      {
        "name": "testTransportCloseResponseBody",
        "desc": ""
      },
      {
        "name": "testTransportClosesBodyOnError",
        "desc": ""
      },
      {
        "name": "testTransportClosesBodyOnInvalidRequests",
        "desc": ""
      },
      {
        "name": "testTransportClosesRequestBody",
        "desc": ""
      },
      {
        "name": "testTransportConcurrency",
        "desc": ""
      },
      {
        "name": "testTransportConnectionCloseOnRequest",
        "desc": ""
      },
      {
        "name": "testTransportConnectionCloseOnRequestDisableKeepAlive",
        "desc": ""
      },
      {
        "name": "testTransportConnectionCloseOnResponse",
        "desc": ""
      },
      {
        "name": "testTransportContentEncodingCaseInsensitive",
        "desc": ""
      },
      {
        "name": "testTransportDecrementConnWhenIdleConnRemoved",
        "desc": ""
      },
      {
        "name": "testTransportDialContext",
        "desc": ""
      },
      {
        "name": "testTransportDialTLS",
        "desc": ""
      },
      {
        "name": "testTransportDialTLSContext",
        "desc": ""
      },
      {
        "name": "testTransportDiscardsUnneededConns",
        "desc": ""
      },
      {
        "name": "testTransportDoesNotLimitDelivered1xxResponses",
        "desc": ""
      },
      {
        "name": "testTransportEventTrace",
        "desc": ""
      },
      {
        "name": "testTransportEventTraceTLSVerify",
        "desc": ""
      },
      {
        "name": "testTransportFlushesRequestHeader",
        "desc": ""
      },
      {
        "name": "testTransportGCRequest",
        "desc": ""
      },
      {
        "name": "testTransportGzip",
        "desc": ""
      },
      {
        "name": "testTransportGzipRecursive",
        "desc": ""
      },
      {
        "name": "testTransportGzipShort",
        "desc": ""
      },
      {
        "name": "testTransportHeadChunkedResponse",
        "desc": ""
      },
      {
        "name": "testTransportHeadResponses",
        "desc": ""
      },
      {
        "name": "testTransportIDNA",
        "desc": ""
      },
      {
        "name": "testTransportIdleCacheKeys",
        "desc": ""
      },
      {
        "name": "testTransportIdleConnCrash",
        "desc": ""
      },
      {
        "name": "testTransportIdleConnRacesRequest",
        "desc": ""
      },
      {
        "name": "testTransportIdleConnTimeout",
        "desc": ""
      },
      {
        "name": "testTransportIgnore1xxResponses",
        "desc": ""
      },
      {
        "name": "testTransportIgnores408",
        "desc": ""
      },
      {
        "name": "testTransportIssue10457",
        "desc": ""
      },
      {
        "name": "testTransportKeepAlives",
        "desc": ""
      },
      {
        "name": "testTransportLimits1xxResponses",
        "desc": ""
      },
      {
        "name": "testTransportMaxConnsPerHost",
        "desc": ""
      },
      {
        "name": "testTransportMaxConnsPerHostDialCancellation",
        "desc": ""
      },
      {
        "name": "testTransportMaxConnsPerHostIncludeDialInProgress",
        "desc": ""
      },
      {
        "name": "testTransportMaxIdleConns",
        "desc": ""
      },
      {
        "name": "testTransportMaxPerHostIdleConns",
        "desc": ""
      },
      {
        "name": "testTransportNoReuseAfterEarlyResponse",
        "desc": ""
      },
      {
        "name": "testTransportPersistConnContextLeakMaxConnsPerHost",
        "desc": ""
      },
      {
        "name": "testTransportPersistConnLeak",
        "desc": ""
      },
      {
        "name": "testTransportPersistConnLeakNeverIdle",
        "desc": ""
      },
      {
        "name": "testTransportPersistConnLeakShortBody",
        "desc": ""
      },
      {
        "name": "testTransportPrefersResponseOverWriteError",
        "desc": ""
      },
      {
        "name": "testTransportProxyConnectHeader",
        "desc": ""
      },
      {
        "name": "testTransportProxyDialDoesNotMutateProxyConnectHeader",
        "desc": ""
      },
      {
        "name": "testTransportProxyGetConnectHeader",
        "desc": ""
      },
      {
        "name": "testTransportRace",
        "desc": ""
      },
      {
        "name": "testTransportRangeAndGzip",
        "desc": ""
      },
      {
        "name": "testTransportReadToEndReusesConn",
        "desc": ""
      },
      {
        "name": "testTransportRejectsInvalidHeaders",
        "desc": ""
      },
      {
        "name": "testTransportRejectsSignInContentLength",
        "desc": ""
      },
      {
        "name": "testTransportRemovesConnsAfterBroken",
        "desc": ""
      },
      {
        "name": "testTransportRemovesConnsAfterIdle",
        "desc": ""
      },
      {
        "name": "testTransportRemovesDeadIdleConnections",
        "desc": ""
      },
      {
        "name": "testTransportRequestWriteRoundTrip",
        "desc": ""
      },
      {
        "name": "testTransportRespectRequestWantsClose",
        "desc": ""
      },
      {
        "name": "testTransportResponseBodyWritableOnProtocolSwitch",
        "desc": ""
      },
      {
        "name": "testTransportResponseCancelRace",
        "desc": ""
      },
      {
        "name": "testTransportResponseHeaderLength",
        "desc": ""
      },
      {
        "name": "testTransportResponseHeaderTimeout",
        "desc": ""
      },
      {
        "name": "testTransportReuseConnEmptyResponseBody",
        "desc": ""
      },
      {
        "name": "testTransportReuseConnection_Gzip",
        "desc": "Make sure we re-use underlying TCP connection for gzipped responses too."
      },
      {
        "name": "testTransportServerClosingUnexpectedly",
        "desc": ""
      },
      {
        "name": "testTransportSocketLateBinding",
        "desc": ""
      },
      {
        "name": "testTransportTreat101Terminal",
        "desc": ""
      },
      {
        "name": "testTransportUserAgent",
        "desc": ""
      },
      {
        "name": "testTransportUsesTLSConfigServerName",
        "desc": ""
      },
      {
        "name": "testUnsupportedTransferEncodingsReturn501",
        "desc": ""
      },
      {
        "name": "testValidateClientRequestTrailers",
        "desc": ""
      },
      {
        "name": "testWrappedResponseController",
        "desc": ""
      },
      {
        "name": "testWriteDeadlineEnforcedPerStream",
        "desc": ""
      },
      {
        "name": "testWriteDeadlineExtendedOnNewRequest",
        "desc": ""
      },
      {
        "name": "testWriteHeader0",
        "desc": ""
      },
      {
        "name": "testWriteHeaderAfterWrite",
        "desc": ""
      },
      {
        "name": "testWriteHeaderSwitchingProtocols",
        "desc": ""
      },
      {
        "name": "testZeroLengthPostAndResponse",
        "desc": ""
      },
      {
        "name": "tryTimeouts",
        "desc": "tryTimeouts runs testFunc with increasing timeouts. Test passes on first success, and fails if all timeouts fail."
      },
      {
        "name": "validateTestMultipartContents",
        "desc": ""
      },
      {
        "name": "waitCondition",
        "desc": "waitCondition waits for fn to return true, checking immediately and then at exponentially increasing intervals."
      },
      {
        "name": "waitNumGoroutine",
        "desc": "Wait until number of goroutines is no greater than nmax, or time out."
      },
      {
        "name": "wantBody",
        "desc": ""
      },
      {
        "name": "Cookies",
        "desc": ""
      },
      {
        "name": "SetCookies",
        "desc": ""
      },
      {
        "name": "logf",
        "desc": ""
      },
      {
        "name": "Cookies",
        "desc": ""
      },
      {
        "name": "SetCookies",
        "desc": ""
      },
      {
        "name": "ServeHTTP",
        "desc": ""
      },
      {
        "name": "done",
        "desc": "done reports whether the function has returned."
      },
      {
        "name": "result",
        "desc": "result returns the result of the function. If the function hasn't completed yet, it returns errStillRunning."
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Err",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      },
      {
        "name": "getURL",
        "desc": ""
      },
      {
        "name": "scheme",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "CloseWrite",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Track",
        "desc": ""
      },
      {
        "name": "decrement",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ServeHTTP",
        "desc": ""
      },
      {
        "name": "DialContext",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "decrement",
        "desc": ""
      },
      {
        "name": "context",
        "desc": "context returns a Context which expires when the deadline does."
      },
      {
        "name": "setDeadline",
        "desc": "setDeadline sets the current deadline."
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Done",
        "desc": ""
      },
      {
        "name": "Err",
        "desc": ""
      },
      {
        "name": "Readdir",
        "desc": "Readdir is a wrapper around the Readdir method of the embedded File that filters out all files that start with a period in their name."
      },
      {
        "name": "Open",
        "desc": "Open is a wrapper around the Open method of the embedded FileSystem that serves a 403 permission error when name has a file or directory with whose name starts with a period in its path."
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ConnectionState",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Readdir",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "IsClosedByPeer",
        "desc": "IsClosed reports whether the peer has closed its end of the connection."
      },
      {
        "name": "LocalAddr",
        "desc": "LocalAddr returns the (fake) local network address."
      },
      {
        "name": "Peek",
        "desc": "Peek returns the available unread read buffer, without consuming its contents."
      },
      {
        "name": "Read",
        "desc": "Read reads data from the connection."
      },
      {
        "name": "RemoteAddr",
        "desc": "LocalAddr returns the (fake) remote network address."
      },
      {
        "name": "SetDeadline",
        "desc": "SetDeadline sets the read and write deadlines for the connection."
      },
      {
        "name": "SetReadBufferSize",
        "desc": "SetReadBufferSize sets the read buffer limit for the connection. Writes by the peer will block so long as the buffer is full."
      },
      {
        "name": "SetReadDeadline",
        "desc": "SetReadDeadline sets the read deadline for the connection."
      },
      {
        "name": "SetWriteDeadline",
        "desc": "SetWriteDeadline sets the write deadline for the connection."
      },
      {
        "name": "Write",
        "desc": "Write writes data to the connection."
      },
      {
        "name": "lock",
        "desc": "lock locks h."
      },
      {
        "name": "peek",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "setReadBufferSize",
        "desc": ""
      },
      {
        "name": "unlock",
        "desc": "h unlocks h."
      },
      {
        "name": "waitAndLockForRead",
        "desc": "waitAndLockForRead waits until h is readable and locks it."
      },
      {
        "name": "waitAndLockForWrite",
        "desc": "waitAndLockForWrite waits until h is writable and locks it."
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "writePartial",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "connect",
        "desc": ""
      },
      {
        "name": "lock",
        "desc": ""
      },
      {
        "name": "unlock",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Flush",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "normalizeRes",
        "desc": ""
      },
      {
        "name": "reqFunc",
        "desc": ""
      },
      {
        "name": "run",
        "desc": ""
      },
      {
        "name": "connectionHeader",
        "desc": ""
      },
      {
        "name": "rawResponse",
        "desc": ""
      },
      {
        "name": "Header",
        "desc": ""
      },
      {
        "name": "WriteHeader",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteByte",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Header",
        "desc": ""
      },
      {
        "name": "WriteHeader",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "CloseIdleConnections",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "ServeHTTP",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "check",
        "desc": ""
      },
      {
        "name": "insert",
        "desc": ""
      },
      {
        "name": "remove",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "ReadFrom",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "respond",
        "desc": "respond sends response lines from the server to the transport."
      },
      {
        "name": "wantBodySent",
        "desc": "wantBodySent ensures the transport has sent the request body to the server."
      },
      {
        "name": "wantRequestDone",
        "desc": "wantRequestDone ensures the Transport.RoundTrip has completed with the expected status."
      },
      {
        "name": "roundTrip",
        "desc": "roundTrip starts a RoundTrip. It returns immediately, without waiting for the RoundTrip call to complete."
      },
      {
        "name": "wantDial",
        "desc": "wantDial waits for the Transport to start a Dial."
      },
      {
        "name": "finish",
        "desc": "finish completes a Dial."
      },
      {
        "name": "finish",
        "desc": "finish completes a RoundTrip by sending the request body, consuming the response body, and closing the response body."
      },
      {
        "name": "wantDone",
        "desc": "wantDone indicates that a RoundTrip should have returned."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "RecordingJar",
        "desc": "RecordingJar keeps a log of calls made to it, without tracking any cookies."
      },
      {
        "name": "TBRun",
        "desc": ""
      },
      {
        "name": "TestJar",
        "desc": "Just enough correctness for our redirect tests. Uses the URL.Host as the scope of all cookies."
      },
      {
        "name": "apiHandler",
        "desc": ""
      },
      {
        "name": "asyncResult",
        "desc": ""
      },
      {
        "name": "basicAuthCredentialsTest",
        "desc": ""
      },
      {
        "name": "blockingRemoteAddrConn",
        "desc": ""
      },
      {
        "name": "blockingRemoteAddrListener",
        "desc": ""
      },
      {
        "name": "bodyCloser",
        "desc": ""
      },
      {
        "name": "bodyLimitReader",
        "desc": ""
      },
      {
        "name": "breakableConn",
        "desc": "breakableConn is a net.Conn wrapper with a Write method that will fail when its brokenState is true."
      },
      {
        "name": "brokenState",
        "desc": ""
      },
      {
        "name": "byteAtATimeReader",
        "desc": ""
      },
      {
        "name": "byteFromChanReader",
        "desc": "byteFromChanReader is an io.Reader that reads a single byte at a time from the channel. When the channel is closed, the reader returns io.EOF."
      },
      {
        "name": "cancelProto",
        "desc": ""
      },
      {
        "name": "cancelTest",
        "desc": "A cancelTest is a test of request cancellation."
      },
      {
        "name": "cancelableTimeoutContext",
        "desc": "cancelableTimeoutContext overwrites the error message to DeadlineExceeded"
      },
      {
        "name": "clientServerTest",
        "desc": ""
      },
      {
        "name": "closeWriteTestConn",
        "desc": ""
      },
      {
        "name": "closerFunc",
        "desc": ""
      },
      {
        "name": "contextCounter",
        "desc": ""
      },
      {
        "name": "countCloseListener",
        "desc": "countCloseListener is a Listener wrapper that counts the number of Close calls."
      },
      {
        "name": "countCloseReader",
        "desc": ""
      },
      {
        "name": "countHandler",
        "desc": ""
      },
      {
        "name": "countedConn",
        "desc": "A countedConn is a net.Conn that decrements an atomic counter when finalized."
      },
      {
        "name": "countedContext",
        "desc": ""
      },
      {
        "name": "countingDialer",
        "desc": "A countingDialer dials connections and counts the number that remain reachable."
      },
      {
        "name": "deadlineContext",
        "desc": "deadlineContext converts a changable deadline (as in net.Conn.SetDeadline) into a Context."
      },
      {
        "name": "delayedEOFReader",
        "desc": "delayedEOFReader never returns (n \u003e 0, io.EOF), instead putting off the io.EOF until a subsequent Read call."
      },
      {
        "name": "delegateReader",
        "desc": "delegateReader is a reader that delegates to another reader, once it arrives on a channel."
      },
      {
        "name": "doneContext",
        "desc": ""
      },
      {
        "name": "dotFileHidingFile",
        "desc": "dotFileHidingFile is the http.File use in dotFileHidingFileSystem. It is used to wrap the Readdir method of http.File so that we can remove files and directories that start with a period from its output."
      },
      {
        "name": "dotFileHidingFileSystem",
        "desc": "dotFileHidingFileSystem is an http.FileSystem that hides hidden \"dot files\" from being served."
      },
      {
        "name": "dummyAddr",
        "desc": ""
      },
      {
        "name": "dumpConn",
        "desc": "dumpConn is a net.Conn which writes to Writer and reads from Reader"
      },
      {
        "name": "eofListenerNotComparable",
        "desc": "Listener for TestServerListenNotComparableListener."
      },
      {
        "name": "eofReaderFunc",
        "desc": "eofReaderFunc is an io.Reader that runs itself, and then returns io.EOF."
      },
      {
        "name": "errorListener",
        "desc": ""
      },
      {
        "name": "fakeConnectionStateConn",
        "desc": ""
      },
      {
        "name": "fakeFS",
        "desc": ""
      },
      {
        "name": "fakeFile",
        "desc": ""
      },
      {
        "name": "fakeFileInfo",
        "desc": ""
      },
      {
        "name": "fakeNetConn",
        "desc": "A fakeNetConn is one endpoint of the connection created by fakeNetPipe."
      },
      {
        "name": "fakeNetConnHalf",
        "desc": "fakeNetConnHalf is one data flow in the connection created by fakeNetPipe. Each half contains a buffer. Writes to the half push to the buffer, and reads pull from it."
      },
      {
        "name": "fakeNetListener",
        "desc": ""
      },
      {
        "name": "fileServerCleanPathDir",
        "desc": ""
      },
      {
        "name": "fooProto",
        "desc": ""
      },
      {
        "name": "funcConn",
        "desc": ""
      },
      {
        "name": "funcRoundTripper",
        "desc": ""
      },
      {
        "name": "funcWriter",
        "desc": ""
      },
      {
        "name": "getBasicAuthTest",
        "desc": ""
      },
      {
        "name": "gzipResponseWriter",
        "desc": ""
      },
      {
        "name": "h12Compare",
        "desc": "h12Compare is a test that compares HTTP/1 and HTTP/2 behavior against each other."
      },
      {
        "name": "handlerBodyCloseTest",
        "desc": ""
      },
      {
        "name": "handlerTest",
        "desc": ""
      },
      {
        "name": "http09Writer",
        "desc": ""
      },
      {
        "name": "infiniteReader",
        "desc": "infiniteReader satisfies Read requests as if the contents of buf loop indefinitely."
      },
      {
        "name": "issue12991FS",
        "desc": ""
      },
      {
        "name": "issue12991File",
        "desc": ""
      },
      {
        "name": "issue15577Tripper",
        "desc": "issue15577Tripper returns a Response with a redirect response header and doesn't populate its Response.Request field."
      },
      {
        "name": "issue18239Body",
        "desc": "issue18239Body is an io.ReadCloser for TestTransportBodyReadError. Its Read returns readErr and increments *readCalls atomically. Its Close returns nil and increments *closeCalls atomically."
      },
      {
        "name": "issue40382Body",
        "desc": "issue40382Body is an io.ReadCloser for TestClientCallsCloseOnlyOnce. Its Read reads n bytes before returning io.EOF. Its Close returns nil but fails the test if called more than once."
      },
      {
        "name": "lockedBytesBuffer",
        "desc": ""
      },
      {
        "name": "logWrites",
        "desc": ""
      },
      {
        "name": "logWritesConn",
        "desc": "logWritesConn is a net.Conn that logs each Write call to writes and then proxies to w. It proxies Read calls to a reader it receives from rch."
      },
      {
        "name": "neverEnding",
        "desc": ""
      },
      {
        "name": "nilBodyRoundTripper",
        "desc": ""
      },
      {
        "name": "noopConn",
        "desc": ""
      },
      {
        "name": "noteCloseConn",
        "desc": ""
      },
      {
        "name": "oneConnListener",
        "desc": ""
      },
      {
        "name": "panicOnSeek",
        "desc": ""
      },
      {
        "name": "proxyFromEnvTest",
        "desc": ""
      },
      {
        "name": "recordingTransport",
        "desc": ""
      },
      {
        "name": "redirectTest",
        "desc": ""
      },
      {
        "name": "repeatReader",
        "desc": "repeatReader reads content count times, then EOFs."
      },
      {
        "name": "reqFunc",
        "desc": ""
      },
      {
        "name": "responseWriterJustWriter",
        "desc": ""
      },
      {
        "name": "roundTripFunc",
        "desc": ""
      },
      {
        "name": "roundTripperGetBody",
        "desc": ""
      },
      {
        "name": "roundTripperWithCloseIdle",
        "desc": ""
      },
      {
        "name": "roundTripperWithoutCloseIdle",
        "desc": ""
      },
      {
        "name": "rwTestConn",
        "desc": ""
      },
      {
        "name": "serverExpectTest",
        "desc": ""
      },
      {
        "name": "slowTestConn",
        "desc": "slowTestConn is a net.Conn that provides a means to simulate parts of a request being received piecemeal. Deadlines can be set and enforced in both Read and Write."
      },
      {
        "name": "slurpResult",
        "desc": ""
      },
      {
        "name": "stringHandler",
        "desc": ""
      },
      {
        "name": "terrorWriter",
        "desc": ""
      },
      {
        "name": "testCloseConn",
        "desc": "testCloseConn is a net.Conn tracked by a testConnSet."
      },
      {
        "name": "testConn",
        "desc": ""
      },
      {
        "name": "testConnSet",
        "desc": "testConnSet tracks a set of TCP connections and whether they've been closed."
      },
      {
        "name": "testErrorReader",
        "desc": ""
      },
      {
        "name": "testFileSystem",
        "desc": ""
      },
      {
        "name": "testHandlerBodyConsumer",
        "desc": "testHandlerBodyConsumer represents a function injected into a test handler to vary work done on a request Body."
      },
      {
        "name": "testLogWriter",
        "desc": ""
      },
      {
        "name": "testMockTCPConn",
        "desc": "testMockTCPConn is a mock TCP connection used to test that ReadFrom is called when sending the request body."
      },
      {
        "name": "testMode",
        "desc": ""
      },
      {
        "name": "testNotParallelOpt",
        "desc": ""
      },
      {
        "name": "testRoundTripper",
        "desc": ""
      },
      {
        "name": "tlogWriter",
        "desc": ""
      },
      {
        "name": "trackLastConnListener",
        "desc": "trackLastConnListener tracks the last net.Conn that was accepted."
      },
      {
        "name": "transport100ContinueTest",
        "desc": "A transport100Continue test exercises Transport behaviors when sending a request with an Expect: 100-continue header."
      },
      {
        "name": "transportDialTester",
        "desc": "A transportDialTester manages a test of a connection's Dials."
      },
      {
        "name": "transportDialTesterConn",
        "desc": "A transportDialTesterConn is a client connection created by the Transport as part of a dial test."
      },
      {
        "name": "transportDialTesterRoundTrip",
        "desc": "A transportDialTesterRoundTrip is a RoundTrip made as part of a dial test."
      },
      {
        "name": "wantRange",
        "desc": ""
      },
      {
        "name": "wgReadCloser",
        "desc": ""
      },
      {
        "name": "wrapWriter",
        "desc": ""
      },
      {
        "name": "writeCountingConn",
        "desc": ""
      },
      {
        "name": "writerFuncConn",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/http/cgi",
    "desc": "Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.  Note that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems.",
    "functions": [
      {
        "name": "Request",
        "desc": "Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable."
      },
      {
        "name": "RequestFromMap",
        "desc": "RequestFromMap creates an [http.Request] from CGI variables. The returned Request's Body field is not populated."
      },
      {
        "name": "Serve",
        "desc": "Serve executes the provided [Handler] on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use [http.DefaultServeMux]."
      },
      {
        "name": "Test500WithEmptyHeaders",
        "desc": ""
      },
      {
        "name": "Test500WithNoContentType",
        "desc": ""
      },
      {
        "name": "Test500WithNoHeaders",
        "desc": "golang.org/issue/7198"
      },
      {
        "name": "TestCGIBasicGet",
        "desc": ""
      },
      {
        "name": "TestCGIBasicGetAbsPath",
        "desc": ""
      },
      {
        "name": "TestCGIBasicPost",
        "desc": ""
      },
      {
        "name": "TestCGIEnvIPv6",
        "desc": ""
      },
      {
        "name": "TestCGIPostChunked",
        "desc": "The CGI spec doesn't allow chunked requests."
      },
      {
        "name": "TestChildContentType",
        "desc": ""
      },
      {
        "name": "TestChildOnlyHeaders",
        "desc": "Test that a child handler writing only headers works. golang.org/issue/7196"
      },
      {
        "name": "TestCopyError",
        "desc": "TestCopyError tests that we kill the process if there's an error copying its output. (for example, from the client having gone away)  If we fail to do so, the test will time out (and dump its goroutines) with a call to [Handler.ServeHTTP] blocked on a deferred call to [exec.Cmd.Wait]."
      },
      {
        "name": "TestDir",
        "desc": ""
      },
      {
        "name": "TestDropProxyHeader",
        "desc": "Issue 16405: CGI+http.Transport differing uses of HTTP_PROXY. Verify we don't set the HTTP_PROXY environment variable. Hope nobody was depending on it. It's not a known header, though."
      },
      {
        "name": "TestDupHeaders",
        "desc": ""
      },
      {
        "name": "TestEnvOverride",
        "desc": ""
      },
      {
        "name": "TestHandlerStderr",
        "desc": ""
      },
      {
        "name": "TestHostingOurselves",
        "desc": "This test is a CGI host (testing host.go) that runs its own binary as a child process testing the other half of CGI (child.go)."
      },
      {
        "name": "TestInternalRedirect",
        "desc": ""
      },
      {
        "name": "TestKillChildAfterCopyError",
        "desc": "If there's an error copying the child's output to the parent, test that we kill the child."
      },
      {
        "name": "TestMain",
        "desc": "TestMain executes the test binary as the cgi server if SERVER_SOFTWARE is set, and runs the tests otherwise."
      },
      {
        "name": "TestNilRequestBody",
        "desc": "Test that a child handler does not receive a nil Request Body. golang.org/issue/39190"
      },
      {
        "name": "TestPathInfo",
        "desc": ""
      },
      {
        "name": "TestPathInfoDirRoot",
        "desc": ""
      },
      {
        "name": "TestPathInfoNoRoot",
        "desc": ""
      },
      {
        "name": "TestRedirect",
        "desc": ""
      },
      {
        "name": "TestRemoveLeadingDuplicates",
        "desc": ""
      },
      {
        "name": "TestRequest",
        "desc": ""
      },
      {
        "name": "TestRequestWithTLS",
        "desc": ""
      },
      {
        "name": "TestRequestWithoutHost",
        "desc": ""
      },
      {
        "name": "TestRequestWithoutRemotePort",
        "desc": ""
      },
      {
        "name": "TestRequestWithoutRequestURI",
        "desc": ""
      },
      {
        "name": "TestResponse",
        "desc": ""
      },
      {
        "name": "cgiMain",
        "desc": ""
      },
      {
        "name": "childCGIProcess",
        "desc": "childCGIProcess is used by integration_test to complete unit tests."
      },
      {
        "name": "chunk",
        "desc": ""
      },
      {
        "name": "envMap",
        "desc": ""
      },
      {
        "name": "handlerRunning",
        "desc": "handlerRunning reports whether any goroutine is currently running [Handler.ServeHTTP]."
      },
      {
        "name": "newRequest",
        "desc": ""
      },
      {
        "name": "removeLeadingDuplicates",
        "desc": "removeLeadingDuplicates remove leading duplicate in environments. It's possible to override environment like following.  \tcgi.Handler{ \t  ... \t  Env: []string{\"SCRIPT_FILENAME=foo.php\"}, \t}"
      },
      {
        "name": "runCgiTest",
        "desc": ""
      },
      {
        "name": "runResponseChecks",
        "desc": ""
      },
      {
        "name": "testCGI",
        "desc": "testCGI is a CGI program translated from a Perl program to complete host_test. test cases in host_test should be provided by testCGI."
      },
      {
        "name": "upperCaseAndUnderscore",
        "desc": ""
      },
      {
        "name": "want500Test",
        "desc": ""
      },
      {
        "name": "ServeHTTP",
        "desc": ""
      },
      {
        "name": "handleInternalRedirect",
        "desc": ""
      },
      {
        "name": "printf",
        "desc": ""
      },
      {
        "name": "stderr",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Flush",
        "desc": ""
      },
      {
        "name": "Header",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteHeader",
        "desc": ""
      },
      {
        "name": "writeCGIHeader",
        "desc": "writeCGIHeader finalizes the header sent to the client and writes it to the output. p is not written by writeHeader, but is the first chunk of the body that will be written. It is sniffed for a Content-Type if none is set explicitly."
      }
    ],
    "types": [
      {
        "name": "Handler",
        "desc": "Handler runs an executable in a subprocess with a CGI environment."
      },
      {
        "name": "customWriterRecorder",
        "desc": ""
      },
      {
        "name": "limitWriter",
        "desc": ""
      },
      {
        "name": "neverEnding",
        "desc": ""
      },
      {
        "name": "response",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/http/cookiejar",
    "desc": "Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.",
    "functions": [
      {
        "name": "TestBasics",
        "desc": ""
      },
      {
        "name": "TestCanonicalHost",
        "desc": ""
      },
      {
        "name": "TestChromiumBasics",
        "desc": ""
      },
      {
        "name": "TestChromiumDeletion",
        "desc": ""
      },
      {
        "name": "TestChromiumDomain",
        "desc": ""
      },
      {
        "name": "TestDefaultPath",
        "desc": ""
      },
      {
        "name": "TestDomainAndType",
        "desc": ""
      },
      {
        "name": "TestDomainHandling",
        "desc": ""
      },
      {
        "name": "TestExpiration",
        "desc": ""
      },
      {
        "name": "TestHasDotSuffix",
        "desc": ""
      },
      {
        "name": "TestHasPort",
        "desc": ""
      },
      {
        "name": "TestIsIP",
        "desc": ""
      },
      {
        "name": "TestIssue19384",
        "desc": ""
      },
      {
        "name": "TestJarKey",
        "desc": ""
      },
      {
        "name": "TestJarKeyNilPSL",
        "desc": ""
      },
      {
        "name": "TestPunycode",
        "desc": ""
      },
      {
        "name": "TestUpdateAndDelete",
        "desc": ""
      },
      {
        "name": "adapt",
        "desc": "adapt is the bias adaptation function specified in section 6.1."
      },
      {
        "name": "canonicalHost",
        "desc": "canonicalHost strips port from host if present and returns the canonicalized host name."
      },
      {
        "name": "defaultPath",
        "desc": "defaultPath returns the directory part of a URL's path according to RFC 6265 section 5.1.4."
      },
      {
        "name": "encode",
        "desc": "encode encodes a string as specified in section 6.3 and prepends prefix to the result.  The \"while h \u003c length(input)\" line in the specification becomes \"for remaining != 0\" in the Go code, because len(s) in Go is in bytes, not runes."
      },
      {
        "name": "encodeDigit",
        "desc": ""
      },
      {
        "name": "expiresIn",
        "desc": "expiresIn creates an expires attribute delta seconds from tNow."
      },
      {
        "name": "hasDotSuffix",
        "desc": "hasDotSuffix reports whether s ends in \".\"+suffix."
      },
      {
        "name": "hasPort",
        "desc": "hasPort reports whether host contains a port number. host may be a host name, an IPv4 or an IPv6 address."
      },
      {
        "name": "isIP",
        "desc": "isIP reports whether host is an IP address."
      },
      {
        "name": "jarKey",
        "desc": "jarKey returns the key to use for a jar."
      },
      {
        "name": "mustParseURL",
        "desc": "mustParseURL parses s to a URL and panics on error."
      },
      {
        "name": "toASCII",
        "desc": "toASCII converts a domain or domain label to its ASCII form. For example, toASCII(\"bücher.example.com\") is \"xn--bcher-kva.example.com\", and toASCII(\"golang\") is \"golang\"."
      },
      {
        "name": "Cookies",
        "desc": "Cookies implements the Cookies method of the [http.CookieJar] interface.  It returns an empty slice if the URL's scheme is not HTTP or HTTPS."
      },
      {
        "name": "SetCookies",
        "desc": "SetCookies implements the SetCookies method of the [http.CookieJar] interface.  It does nothing if the URL's scheme is not HTTP or HTTPS."
      },
      {
        "name": "cookies",
        "desc": "cookies is like Cookies but takes the current time as a parameter."
      },
      {
        "name": "domainAndType",
        "desc": "domainAndType determines the cookie's domain and hostOnly attribute."
      },
      {
        "name": "newEntry",
        "desc": "newEntry creates an entry from an http.Cookie c. now is the current time and is compared to c.Expires to determine deletion of c. defPath and host are the default-path and the canonical host name of the URL c was received from.  remove records whether the jar should delete this cookie, as it has already expired with respect to now. In this case, e may be incomplete, but it will be valid to call e.id (which depends on e's Name, Domain and Path).  A malformed c.Domain will result in an error."
      },
      {
        "name": "setCookies",
        "desc": "setCookies is like SetCookies but takes the current time as parameter."
      },
      {
        "name": "domainMatch",
        "desc": "domainMatch checks whether e's Domain allows sending e back to host. It differs from \"domain-match\" of RFC 6265 section 5.1.3 because we treat a cookie with an IP address in the Domain always as a host cookie."
      },
      {
        "name": "id",
        "desc": "id returns the domain;path;name triple of e as an id."
      },
      {
        "name": "pathMatch",
        "desc": "pathMatch implements \"path-match\" according to RFC 6265 section 5.1.4."
      },
      {
        "name": "shouldSend",
        "desc": "shouldSend determines whether e's cookie qualifies to be included in a request to host/path. It is the caller's responsibility to check if the cookie is expired."
      },
      {
        "name": "run",
        "desc": "run runs the jarTest."
      },
      {
        "name": "PublicSuffix",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Jar",
        "desc": "Jar implements the http.CookieJar interface from the net/http package."
      },
      {
        "name": "Options",
        "desc": "Options are the options for creating a new Jar."
      },
      {
        "name": "PublicSuffixList",
        "desc": "PublicSuffixList provides the public suffix of a domain. For example:   - the public suffix of \"example.com\" is \"com\",   - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and   - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".  Implementations of PublicSuffixList must be safe for concurrent use by multiple goroutines.  An implementation that always returns \"\" is valid and may be useful for testing but it is not secure: it means that the HTTP server for foo.com can set a cookie for bar.com.  A public suffix list implementation is in the package golang.org/x/net/publicsuffix."
      },
      {
        "name": "entry",
        "desc": "entry is the internal representation of a cookie.  This struct type is not used outside of this package per se, but the exported fields are those of RFC 6265."
      },
      {
        "name": "jarTest",
        "desc": "jarTest encapsulates the following actions on a jar:  1. Perform SetCookies with fromURL and the cookies from setCookies.     (Done at time tNow + 0 ms.)  2. Check that the entries in the jar matches content.     (Done at time tNow + 1001 ms.)  3. For each query in tests: Check that Cookies with toURL yields the     cookies in want.     (Query n done at tNow + (n+2)*1001 ms.)"
      },
      {
        "name": "query",
        "desc": "query contains one test of the cookies returned from Jar.Cookies."
      },
      {
        "name": "testPSL",
        "desc": "testPSL implements PublicSuffixList with just two rules: \"co.uk\" and the default rule \"*\". The implementation has two intentional bugs:  \tPublicSuffix(\"www.buggy.psl\") == \"xy\" \tPublicSuffix(\"www2.buggy.psl\") == \"com\""
      }
    ]
  },
  {
    "name": "net/http/fcgi",
    "desc": "Package fcgi implements the FastCGI protocol.  See https://fast-cgi.github.io/ for an unofficial mirror of the original documentation.  Currently only the responder role is supported.",
    "functions": [
      {
        "name": "ProcessEnv",
        "desc": "ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context)."
      },
      {
        "name": "Serve",
        "desc": "Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, [http.DefaultServeMux] is used."
      },
      {
        "name": "TestChildServeCleansUp",
        "desc": "Test that child.serve closes the bodies of aborted requests and closes the bodies of all requests before returning. Causes deadlock if either condition isn't met. See issue 6934."
      },
      {
        "name": "TestChildServeReadsEnvVars",
        "desc": "Test that environment variables set for a request can be read by a handler. Ensures that variables not set will not be exposed to a handler."
      },
      {
        "name": "TestGetValues",
        "desc": ""
      },
      {
        "name": "TestMalformedParams",
        "desc": "Verifies it doesn't crash. \tIssue 11824."
      },
      {
        "name": "TestResponseWriterSniffsContentType",
        "desc": ""
      },
      {
        "name": "TestSize",
        "desc": ""
      },
      {
        "name": "TestSlowRequest",
        "desc": "Test whether server properly closes connection when processing slow requests"
      },
      {
        "name": "TestStreams",
        "desc": ""
      },
      {
        "name": "addFastCGIEnvToContext",
        "desc": "addFastCGIEnvToContext reports whether to include the FastCGI environment variable s in the http.Request.Context, accessible via ProcessEnv."
      },
      {
        "name": "encodeSize",
        "desc": ""
      },
      {
        "name": "filterOutUsedEnvVars",
        "desc": "filterOutUsedEnvVars returns a new map of env vars without the variables in the given envVars map that are read for creating each http.Request"
      },
      {
        "name": "makeRecord",
        "desc": ""
      },
      {
        "name": "nameValuePair11",
        "desc": ""
      },
      {
        "name": "readSize",
        "desc": ""
      },
      {
        "name": "readString",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "cleanUp",
        "desc": ""
      },
      {
        "name": "handleRecord",
        "desc": ""
      },
      {
        "name": "serve",
        "desc": ""
      },
      {
        "name": "serveRequest",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close closes the conn if it is not already closed."
      },
      {
        "name": "writeEndRequest",
        "desc": ""
      },
      {
        "name": "writePairs",
        "desc": ""
      },
      {
        "name": "writeRecord",
        "desc": "writeRecord writes and sends a single record."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "content",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "parseParams",
        "desc": "parseParams reads an encoded []byte into Params."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Flush",
        "desc": ""
      },
      {
        "name": "Header",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteHeader",
        "desc": ""
      },
      {
        "name": "writeCGIHeader",
        "desc": "writeCGIHeader finalizes the header sent to the client and writes it to the output. p is not written by writeHeader, but is the first chunk of the body that will be written. It is sniffed for a Content-Type if none is set explicitly."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "beginRequest",
        "desc": ""
      },
      {
        "name": "bufWriter",
        "desc": "bufWriter encapsulates bufio.Writer but also closes the underlying stream when Closed."
      },
      {
        "name": "child",
        "desc": ""
      },
      {
        "name": "conn",
        "desc": "conn sends records over rwc"
      },
      {
        "name": "envVarsContextKey",
        "desc": "envVarsContextKey uniquely identifies a mapping of CGI environment variables to their values in a request context"
      },
      {
        "name": "header",
        "desc": ""
      },
      {
        "name": "nilCloser",
        "desc": ""
      },
      {
        "name": "nopWriteCloser",
        "desc": ""
      },
      {
        "name": "recType",
        "desc": "recType is a record type, as defined by https://web.archive.org/web/20150420080736/http://www.fastcgi.com/drupal/node/6?q=node/22#S8"
      },
      {
        "name": "record",
        "desc": ""
      },
      {
        "name": "request",
        "desc": "request holds the state for an in-progress request. As soon as it's complete, it's converted to an http.Request."
      },
      {
        "name": "response",
        "desc": "response implements http.ResponseWriter."
      },
      {
        "name": "rwNopCloser",
        "desc": ""
      },
      {
        "name": "signalingNopWriteCloser",
        "desc": ""
      },
      {
        "name": "streamWriter",
        "desc": "streamWriter abstracts out the separation of a stream into discrete records. It only writes maxWrite bytes at a time."
      },
      {
        "name": "writeOnlyConn",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/http/httptest",
    "desc": "",
    "functions": [
      {
        "name": "ExampleNewTLSServer",
        "desc": ""
      },
      {
        "name": "ExampleResponseRecorder",
        "desc": ""
      },
      {
        "name": "ExampleServer",
        "desc": ""
      },
      {
        "name": "ExampleServer_hTTP2",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "net/http/httptrace",
    "desc": "Package httptrace provides mechanisms to trace the events within HTTP client requests.",
    "functions": [
      {
        "name": "TestCompose",
        "desc": ""
      },
      {
        "name": "TestWithClientTrace",
        "desc": ""
      },
      {
        "name": "WithClientTrace",
        "desc": "WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first."
      },
      {
        "name": "compose",
        "desc": "compose modifies t such that it respects the previously-registered hooks in old, subject to the composition policy requested in t.Compose."
      },
      {
        "name": "hasNetHooks",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ClientTrace",
        "desc": "ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. Any particular hook may be nil. Functions may be called concurrently from different goroutines and some may be called after the request has completed or failed.  ClientTrace currently traces a single HTTP request \u0026 response during a single round trip and has no hooks that span a series of redirected requests.  See https://blog.golang.org/http-tracing for more."
      },
      {
        "name": "DNSDoneInfo",
        "desc": "DNSDoneInfo contains information about the results of a DNS lookup."
      },
      {
        "name": "DNSStartInfo",
        "desc": "DNSStartInfo contains information about a DNS request."
      },
      {
        "name": "GotConnInfo",
        "desc": "GotConnInfo is the argument to the [ClientTrace.GotConn] function and contains information about the obtained connection."
      },
      {
        "name": "WroteRequestInfo",
        "desc": "WroteRequestInfo contains information provided to the WroteRequest hook."
      },
      {
        "name": "clientEventContextKey",
        "desc": "unique type to prevent assignment."
      }
    ]
  },
  {
    "name": "net/http/httputil",
    "desc": "Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.",
    "functions": [
      {
        "name": "BenchmarkServeHTTP",
        "desc": ""
      },
      {
        "name": "DumpRequest",
        "desc": "DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an [http.Request]. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations.  If body is true, DumpRequest also returns the body. To do so, it consumes req.Body and then replaces it with a new [io.ReadCloser] that yields the same bytes. If DumpRequest returns an error, the state of req is undefined.  The documentation for [http.Request.Write] details which fields of req are included in the dump."
      },
      {
        "name": "DumpRequestOut",
        "desc": "DumpRequestOut is like [DumpRequest] but for outgoing client requests. It includes any headers that the standard [http.Transport] adds, such as User-Agent."
      },
      {
        "name": "DumpResponse",
        "desc": "DumpResponse is like DumpRequest but dumps a response."
      },
      {
        "name": "NewChunkedReader",
        "desc": "NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns [io.EOF] when the final 0-length chunk is read.  NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies."
      },
      {
        "name": "NewChunkedWriter",
        "desc": "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.  NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong."
      },
      {
        "name": "Test1xxHeadersNotModifiedAfterRoundTrip",
        "desc": ""
      },
      {
        "name": "Test1xxResponses",
        "desc": ""
      },
      {
        "name": "TestClonesRequestHeaders",
        "desc": "Issue 18327: verify we always do a deep copy of the Request.Header map before any mutations."
      },
      {
        "name": "TestDumpRequest",
        "desc": ""
      },
      {
        "name": "TestDumpRequestOutIssue38352",
        "desc": "Issue 38352: Check for deadlock on canceled requests."
      },
      {
        "name": "TestDumpResponse",
        "desc": ""
      },
      {
        "name": "TestJoinURLPath",
        "desc": ""
      },
      {
        "name": "TestModifyResponseClosesBody",
        "desc": ""
      },
      {
        "name": "TestNilBody",
        "desc": "Issue 12344"
      },
      {
        "name": "TestReverseProxy",
        "desc": ""
      },
      {
        "name": "TestReverseProxyCancellation",
        "desc": ""
      },
      {
        "name": "TestReverseProxyErrorHandler",
        "desc": ""
      },
      {
        "name": "TestReverseProxyFlushInterval",
        "desc": ""
      },
      {
        "name": "TestReverseProxyFlushIntervalHeaders",
        "desc": ""
      },
      {
        "name": "TestReverseProxyGetPutBuffer",
        "desc": ""
      },
      {
        "name": "TestReverseProxyHijackCopyError",
        "desc": "Issue #72954: We should not call WriteHeader on a ResponseWriter after hijacking the connection."
      },
      {
        "name": "TestReverseProxyModifyResponse",
        "desc": "Issue 14237. Test ModifyResponse and that an error from it causes the proxy to return StatusBadGateway, or StatusOK otherwise."
      },
      {
        "name": "TestReverseProxyQuery",
        "desc": ""
      },
      {
        "name": "TestReverseProxyQueryParameterSmugglingDirectorDoesNotParseForm",
        "desc": ""
      },
      {
        "name": "TestReverseProxyQueryParameterSmugglingDirectorParsesForm",
        "desc": ""
      },
      {
        "name": "TestReverseProxyQueryParameterSmugglingRewrite",
        "desc": ""
      },
      {
        "name": "TestReverseProxyQueryParameterSmugglingRewritePreservesRawQuery",
        "desc": ""
      },
      {
        "name": "TestReverseProxyResponseControllerFlushInterval",
        "desc": ""
      },
      {
        "name": "TestReverseProxyRewriteReplacesOut",
        "desc": ""
      },
      {
        "name": "TestReverseProxyRewriteStripsForwarded",
        "desc": ""
      },
      {
        "name": "TestReverseProxyStripEmptyConnection",
        "desc": ""
      },
      {
        "name": "TestReverseProxyStripHeadersPresentInConnection",
        "desc": "Issue 16875: remove any proxied headers mentioned in the \"Connection\" header value."
      },
      {
        "name": "TestReverseProxyUpgradeNoCloseWrite",
        "desc": ""
      },
      {
        "name": "TestReverseProxyWebSocket",
        "desc": ""
      },
      {
        "name": "TestReverseProxyWebSocketCancellation",
        "desc": ""
      },
      {
        "name": "TestReverseProxyWebSocketHalfTCP",
        "desc": ""
      },
      {
        "name": "TestReverseProxy_AllocatedHeader",
        "desc": "Issue 33142: always allocate the request headers"
      },
      {
        "name": "TestReverseProxy_CopyBuffer",
        "desc": "Issue 16659: log errors from short read"
      },
      {
        "name": "TestReverseProxy_NilBody",
        "desc": "Issue 16036: send a Request with a nil Body when possible"
      },
      {
        "name": "TestReverseProxy_PanicBodyError",
        "desc": "Issue 23643: panic on body copy error"
      },
      {
        "name": "TestReverseProxy_PanicClosesIncomingBody",
        "desc": "Issue #46866: panic without closing incoming request body causes a panic"
      },
      {
        "name": "TestReverseProxy_Post",
        "desc": ""
      },
      {
        "name": "TestSelectFlushInterval",
        "desc": ""
      },
      {
        "name": "TestServeHTTPDeepCopy",
        "desc": ""
      },
      {
        "name": "TestSetURL",
        "desc": ""
      },
      {
        "name": "TestSingleJoinSlash",
        "desc": ""
      },
      {
        "name": "TestUnannouncedTrailer",
        "desc": ""
      },
      {
        "name": "TestUserAgentHeader",
        "desc": "Issue 15524"
      },
      {
        "name": "TestXForwardedFor",
        "desc": ""
      },
      {
        "name": "TestXForwardedFor_Omit",
        "desc": "Issue 38079: don't append to X-Forwarded-For if it's present but nil"
      },
      {
        "name": "chunk",
        "desc": ""
      },
      {
        "name": "cleanQueryParams",
        "desc": ""
      },
      {
        "name": "copyHeader",
        "desc": ""
      },
      {
        "name": "deadline",
        "desc": "deadline returns the time which is needed before t.Deadline() if one is configured and it is s greater than needed in the future, otherwise defaultDelay from the current time."
      },
      {
        "name": "drainBody",
        "desc": "drainBody reads all of b to memory and then returns two equivalent ReadClosers yielding the same bytes.  It returns an error if the initial slurp of all bytes fails. It does not attempt to make the returned ReadClosers have identical error-matching behavior."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "ishex",
        "desc": ""
      },
      {
        "name": "joinURLPath",
        "desc": ""
      },
      {
        "name": "mustNewRequest",
        "desc": ""
      },
      {
        "name": "mustParseURL",
        "desc": ""
      },
      {
        "name": "mustReadRequest",
        "desc": ""
      },
      {
        "name": "outgoingLength",
        "desc": "outgoingLength is a copy of the unexported (*http.Request).outgoingLength method."
      },
      {
        "name": "removeHopByHopHeaders",
        "desc": "removeHopByHopHeaders removes hop-by-hop headers."
      },
      {
        "name": "req",
        "desc": ""
      },
      {
        "name": "rewriteRequestURL",
        "desc": ""
      },
      {
        "name": "shouldPanicOnCopyError",
        "desc": "shouldPanicOnCopyError reports whether the reverse proxy should panic with http.ErrAbortHandler. This is the right thing to do by default, but Go 1.10 and earlier did not, so existing unit tests weren't expecting panics. Only panic in our own tests, or when running under the HTTP server."
      },
      {
        "name": "singleJoiningSlash",
        "desc": ""
      },
      {
        "name": "testReverseProxyQueryParameterSmuggling",
        "desc": ""
      },
      {
        "name": "upgradeType",
        "desc": ""
      },
      {
        "name": "valueOrDefault",
        "desc": "Return value if nonempty, def otherwise."
      },
      {
        "name": "Close",
        "desc": "Close calls [ClientConn.Hijack] and then also closes the underlying connection."
      },
      {
        "name": "Do",
        "desc": "Do is convenience method that writes a request and reads a response."
      },
      {
        "name": "Hijack",
        "desc": "Hijack detaches the [ClientConn] and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while [ClientConn.Read] or ClientConn.Write is in progress."
      },
      {
        "name": "Pending",
        "desc": "Pending returns the number of unanswered requests that have been sent on the connection."
      },
      {
        "name": "Read",
        "desc": "Read reads the next response from the wire. A valid response might be returned together with an [ErrPersistEOF], which means that the remote requested that this be the last request serviced. Read can be called concurrently with [ClientConn.Write], but not with another Read."
      },
      {
        "name": "Write",
        "desc": "Write writes a request. An [ErrPersistEOF] error is returned if the connection has been closed in an HTTP keep-alive sense. If req.Close equals true, the keep-alive connection is logically closed after this request and the opposing server is informed. An ErrUnexpectedEOF indicates the remote closed the underlying TCP connection, which is usually considered as graceful close."
      },
      {
        "name": "SetURL",
        "desc": "SetURL routes the outbound request to the scheme, host, and base path provided in target. If the target's path is \"/base\" and the incoming request was for \"/dir\", the target request will be for \"/base/dir\". To route requests without joining the incoming path, set r.Out.URL directly.  SetURL rewrites the outbound Host header to match the target's host. To preserve the inbound request's Host header (the default behavior of [NewSingleHostReverseProxy]):  \trewriteFunc := func(r *httputil.ProxyRequest) { \t\tr.SetURL(url) \t\tr.Out.Host = r.In.Host \t}"
      },
      {
        "name": "SetXForwarded",
        "desc": "SetXForwarded sets the X-Forwarded-For, X-Forwarded-Host, and X-Forwarded-Proto headers of the outbound request.    - The X-Forwarded-For header is set to the client IP address.   - The X-Forwarded-Host header is set to the host name requested     by the client.   - The X-Forwarded-Proto header is set to \"http\" or \"https\", depending     on whether the inbound request was made on a TLS-enabled connection.  If the outbound request contains an existing X-Forwarded-For header, SetXForwarded appends the client IP address to it. To append to the inbound request's X-Forwarded-For header (the default behavior of [ReverseProxy] when using a Director function), copy the header from the inbound request before calling SetXForwarded:  \trewriteFunc := func(r *httputil.ProxyRequest) { \t\tr.Out.Header[\"X-Forwarded-For\"] = r.In.Header[\"X-Forwarded-For\"] \t\tr.SetXForwarded() \t}"
      },
      {
        "name": "ServeHTTP",
        "desc": ""
      },
      {
        "name": "copyBuffer",
        "desc": "copyBuffer returns any write errors or non-EOF read errors, and the amount of bytes written."
      },
      {
        "name": "copyResponse",
        "desc": ""
      },
      {
        "name": "defaultErrorHandler",
        "desc": ""
      },
      {
        "name": "flushInterval",
        "desc": "flushInterval returns the p.FlushInterval value, conditionally overriding its value for a specific request/response."
      },
      {
        "name": "getErrorHandler",
        "desc": ""
      },
      {
        "name": "handleUpgradeResponse",
        "desc": ""
      },
      {
        "name": "logf",
        "desc": ""
      },
      {
        "name": "modifyResponse",
        "desc": "modifyResponse conditionally runs the optional ModifyResponse hook and reports whether the request should proceed."
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close calls [ServerConn.Hijack] and then also closes the underlying connection."
      },
      {
        "name": "Hijack",
        "desc": "Hijack detaches the [ServerConn] and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while [ServerConn.Read] or [ServerConn.Write] is in progress."
      },
      {
        "name": "Pending",
        "desc": "Pending returns the number of unanswered requests that have been received on the connection."
      },
      {
        "name": "Read",
        "desc": "Read returns the next request on the wire. An [ErrPersistEOF] is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection)."
      },
      {
        "name": "Write",
        "desc": "Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the [ServerConn.Read] side."
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "Put",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetDeadline",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "delayedFlush",
        "desc": ""
      },
      {
        "name": "stop",
        "desc": ""
      },
      {
        "name": "Flush",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "RoundTrip",
        "desc": ""
      },
      {
        "name": "copyFromBackend",
        "desc": ""
      },
      {
        "name": "copyToBackend",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Header",
        "desc": ""
      },
      {
        "name": "Hijack",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteHeader",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "BufferPool",
        "desc": "A BufferPool is an interface for getting and returning temporary byte slices for use by [io.CopyBuffer]."
      },
      {
        "name": "ClientConn",
        "desc": "ClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.  Deprecated: Use Client or Transport in package [net/http] instead."
      },
      {
        "name": "ProxyRequest",
        "desc": "A ProxyRequest contains a request to be rewritten by a [ReverseProxy]."
      },
      {
        "name": "ReverseProxy",
        "desc": "ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.  1xx responses are forwarded to the client if the underlying transport supports ClientTrace.Got1xxResponse.  Hop-by-hop headers (see RFC 9110, section 7.6.1), including Connection, Proxy-Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailer, Transfer-Encoding, and Upgrade, are removed from client requests and backend responses. The Rewrite function may be used to add hop-by-hop headers to the request, and the ModifyResponse function may be used to remove them from the response."
      },
      {
        "name": "RoundTripperFunc",
        "desc": ""
      },
      {
        "name": "ServerConn",
        "desc": "ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.  Deprecated: Use the Server in package [net/http] instead."
      },
      {
        "name": "bufferPool",
        "desc": ""
      },
      {
        "name": "checkCloser",
        "desc": ""
      },
      {
        "name": "delegateReader",
        "desc": "delegateReader is a reader that delegates to another reader, once it arrives on a channel."
      },
      {
        "name": "dumpConn",
        "desc": "dumpConn is a net.Conn which writes to Writer and reads from Reader"
      },
      {
        "name": "dumpTest",
        "desc": ""
      },
      {
        "name": "eofReader",
        "desc": ""
      },
      {
        "name": "failingRoundTripper",
        "desc": ""
      },
      {
        "name": "failureToReadBody",
        "desc": "failureToReadBody is an io.ReadCloser that just returns errNoBody on Read. It's swapped in when we don't actually want to consume the body, but need a non-nil one, and want to distinguish the error from reading the dummy body."
      },
      {
        "name": "maxLatencyWriter",
        "desc": ""
      },
      {
        "name": "mockFlusher",
        "desc": ""
      },
      {
        "name": "neverEnding",
        "desc": ""
      },
      {
        "name": "roundTripperFunc",
        "desc": ""
      },
      {
        "name": "staticResponseRoundTripper",
        "desc": ""
      },
      {
        "name": "staticTransport",
        "desc": ""
      },
      {
        "name": "switchProtocolCopier",
        "desc": "switchProtocolCopier exists so goroutines proxying data back and forth have nice names in stacks."
      },
      {
        "name": "testReadWriteCloser",
        "desc": ""
      },
      {
        "name": "testResponseWriter",
        "desc": ""
      },
      {
        "name": "wrappedRW",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/http/pprof",
    "desc": "Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.  The package is typically only imported for the side effect of registering its HTTP handlers. The handled paths all begin with /debug/pprof/. As of Go 1.22, all the paths must be requested with GET.  To use pprof, link this package into your program:  \timport _ \"net/http/pprof\"  If your application is not already running an http server, you need to start one. Add \"net/http\" and \"log\" to your imports and the following code to your main function:  \tgo func() { \t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil)) \t}()  By default, all the profiles listed in [runtime/pprof.Profile] are available (via [Handler]), in addition to the [Cmdline], [Profile], [Symbol], and [Trace] profiles defined in this package. If you are not using DefaultServeMux, you will have to register handlers with the mux you are using.  # Parameters  Parameters can be passed via GET query params:    - debug=N (all profiles): response format: N = 0: binary (default), N \u003e 0: plaintext   - gc=N (heap profile): N \u003e 0: run a garbage collection cycle before profiling   - seconds=N (allocs, block, goroutine, heap, mutex, threadcreate profiles): return a delta profile   - seconds=N (cpu (profile), trace profiles): profile for the given duration  # Usage examples  Use the pprof tool to look at the heap profile:  \tgo tool pprof http://localhost:6060/debug/pprof/heap  Or to look at a 30-second CPU profile:  \tgo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30  Or to look at the goroutine blocking profile, after calling [runtime.SetBlockProfileRate] in your program:  \tgo tool pprof http://localhost:6060/debug/pprof/block  Or to look at the holders of contended mutexes, after calling [runtime.SetMutexProfileFraction] in your program:  \tgo tool pprof http://localhost:6060/debug/pprof/mutex  The package also exports a handler that serves execution trace data for the \"go tool trace\" command. To collect a 5-second execution trace:  \tcurl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5 \tgo tool trace trace.out  To view all available profiles, open http://localhost:6060/debug/pprof/ in your browser.  For a study of the facility in action, visit https://blog.golang.org/2011/06/profiling-go-programs.html.",
    "functions": [
      {
        "name": "Cmdline",
        "desc": "Cmdline responds with the running program's command line, with arguments separated by NUL bytes. The package initialization registers it as /debug/pprof/cmdline."
      },
      {
        "name": "Handler",
        "desc": "Handler returns an HTTP handler that serves the named profile. Available profiles can be found in [runtime/pprof.Profile]."
      },
      {
        "name": "Index",
        "desc": "Index responds with the pprof-formatted profile named by the request. For example, \"/debug/pprof/heap\" serves the \"heap\" profile. Index responds to a request for \"/debug/pprof/\" with an HTML page listing the available profiles."
      },
      {
        "name": "Profile",
        "desc": "Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile."
      },
      {
        "name": "Symbol",
        "desc": "Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol."
      },
      {
        "name": "TestDeltaProfile",
        "desc": ""
      },
      {
        "name": "TestDeltaProfileEmptyBase",
        "desc": "TestDeltaProfileEmptyBase validates that we still receive a valid delta profile even if the base contains no samples.  Regression test for https://go.dev/issue/64566."
      },
      {
        "name": "TestDescriptions",
        "desc": "TestDescriptions checks that the profile names under runtime/pprof package have a key in the description map."
      },
      {
        "name": "TestHandlers",
        "desc": ""
      },
      {
        "name": "Trace",
        "desc": "Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace."
      },
      {
        "name": "collectProfile",
        "desc": ""
      },
      {
        "name": "configureWriteDeadline",
        "desc": ""
      },
      {
        "name": "indexTmplExecute",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "mutexHog",
        "desc": "mutexHog starts multiple goroutines that runs the given hogger function for the specified duration. The hogger function will be given two mutexes to lock \u0026 unlock."
      },
      {
        "name": "mutexHog1",
        "desc": ""
      },
      {
        "name": "mutexHog2",
        "desc": "mutexHog2 is almost identical to mutexHog but we keep them separate in order to distinguish them with function names in the stack trace. We make them slightly different, using Sink, because otherwise gccgo -c opt will merge them."
      },
      {
        "name": "query",
        "desc": ""
      },
      {
        "name": "seen",
        "desc": "seen returns true if the profile includes samples whose stacks include the specified function name (fname)."
      },
      {
        "name": "serveError",
        "desc": ""
      },
      {
        "name": "sleep",
        "desc": ""
      },
      {
        "name": "ServeHTTP",
        "desc": ""
      },
      {
        "name": "serveDeltaProfile",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "handler",
        "desc": ""
      },
      {
        "name": "profileEntry",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/mail",
    "desc": "",
    "functions": [
      {
        "name": "ExampleParseAddress",
        "desc": ""
      },
      {
        "name": "ExampleParseAddressList",
        "desc": ""
      },
      {
        "name": "ExampleParseDate",
        "desc": ""
      },
      {
        "name": "ExampleReadMessage",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "net/netip",
    "desc": "Package netip defines an IP address type that's a small value type. Building on that [Addr] type, the package also defines [AddrPort] (an IP address and a port) and [Prefix] (an IP address and a bit length prefix).  Compared to the [net.IP] type, [Addr] type takes less memory, is immutable, and is comparable (supports == and being a map key).",
    "functions": [
      {
        "name": "BenchmarkIPNextPrev",
        "desc": ""
      },
      {
        "name": "TestAddrPortMarshalUnmarshal",
        "desc": ""
      },
      {
        "name": "TestBitsClearedFrom",
        "desc": ""
      },
      {
        "name": "TestBitsSetFrom",
        "desc": ""
      },
      {
        "name": "TestIPBitLen",
        "desc": ""
      },
      {
        "name": "TestIPNextPrev",
        "desc": ""
      },
      {
        "name": "TestIPv6Accessor",
        "desc": ""
      },
      {
        "name": "TestInlining",
        "desc": ""
      },
      {
        "name": "TestParseAddrPort",
        "desc": ""
      },
      {
        "name": "TestParseIPError",
        "desc": ""
      },
      {
        "name": "TestPrefixContains",
        "desc": ""
      },
      {
        "name": "TestPrefixValid",
        "desc": ""
      },
      {
        "name": "TestUint128AddSub",
        "desc": ""
      },
      {
        "name": "appendDecimal",
        "desc": "appendDecimal appends the decimal string representation of x to b."
      },
      {
        "name": "appendHex",
        "desc": "appendHex appends the hex string representation of x to b."
      },
      {
        "name": "appendHexPad",
        "desc": "appendHexPad appends the fully padded hex string representation of x to b."
      },
      {
        "name": "doNextPrev",
        "desc": ""
      },
      {
        "name": "parseIPv4Fields",
        "desc": ""
      },
      {
        "name": "splitAddrPort",
        "desc": "splitAddrPort splits s into an IP address string and a port string. It splits strings shaped like \"foo:bar\" or \"[foo]:bar\", without further validating the substrings. v6 indicates whether the ip string should parse as an IPv6 address or an IPv4 address, in order for s to be a valid ip:port string."
      },
      {
        "name": "testAppendToMarshal",
        "desc": "testAppendToMarshal tests that x's AppendTo and MarshalText methods yield the same results. x's MarshalText method must not return an error."
      },
      {
        "name": "AppendBinary",
        "desc": "AppendBinary implements the [encoding.BinaryAppender] interface."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface, It is the same as [Addr.AppendTo]."
      },
      {
        "name": "AppendTo",
        "desc": "AppendTo appends a text encoding of ip, as generated by [Addr.MarshalText], to b and returns the extended buffer."
      },
      {
        "name": "As16",
        "desc": "As16 returns the IP address in its 16-byte representation. IPv4 addresses are returned as IPv4-mapped IPv6 addresses. IPv6 addresses with zones are returned without their zone (use the [Addr.Zone] method to get it). The ip zero value returns all zeroes."
      },
      {
        "name": "As4",
        "desc": "As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation. If ip is the zero [Addr] or an IPv6 address, As4 panics. Note that 0.0.0.0 is not the zero Addr."
      },
      {
        "name": "AsSlice",
        "desc": "AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte representation."
      },
      {
        "name": "BitLen",
        "desc": "BitLen returns the number of bits in the IP address: 128 for IPv6, 32 for IPv4, and 0 for the zero [Addr].  Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses and therefore have bit length 128."
      },
      {
        "name": "Compare",
        "desc": "Compare returns an integer comparing two IPs. The result will be 0 if ip == ip2, -1 if ip \u003c ip2, and +1 if ip \u003e ip2. The definition of \"less than\" is the same as the [Addr.Less] method."
      },
      {
        "name": "Is4",
        "desc": "Is4 reports whether ip is an IPv4 address.  It returns false for IPv4-mapped IPv6 addresses. See [Addr.Unmap]."
      },
      {
        "name": "Is4In6",
        "desc": "Is4In6 reports whether ip is an \"IPv4-mapped IPv6 address\" as defined by RFC 4291. That is, it reports whether ip is in ::ffff:0:0/96."
      },
      {
        "name": "Is6",
        "desc": "Is6 reports whether ip is an IPv6 address, including IPv4-mapped IPv6 addresses."
      },
      {
        "name": "IsGlobalUnicast",
        "desc": "IsGlobalUnicast reports whether ip is a global unicast address.  It returns true for IPv6 addresses which fall outside of the current IANA-allocated 2000::/3 global unicast space, with the exception of the link-local address space. It also returns true even if ip is in the IPv4 private address space or IPv6 unique local address space. It returns false for the zero [Addr].  For reference, see RFC 1122, RFC 4291, and RFC 4632."
      },
      {
        "name": "IsInterfaceLocalMulticast",
        "desc": "IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local multicast address."
      },
      {
        "name": "IsLinkLocalMulticast",
        "desc": "IsLinkLocalMulticast reports whether ip is a link-local multicast address."
      },
      {
        "name": "IsLinkLocalUnicast",
        "desc": "IsLinkLocalUnicast reports whether ip is a link-local unicast address."
      },
      {
        "name": "IsLoopback",
        "desc": "IsLoopback reports whether ip is a loopback address."
      },
      {
        "name": "IsMulticast",
        "desc": "IsMulticast reports whether ip is a multicast address."
      },
      {
        "name": "IsPrivate",
        "desc": "IsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the same as [net.IP.IsPrivate]."
      },
      {
        "name": "IsUnspecified",
        "desc": "IsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".  Note that the zero [Addr] is not an unspecified address."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether the [Addr] is an initialized address (not the zero Addr).  Note that \"0.0.0.0\" and \"::\" are both valid values."
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": "Less reports whether ip sorts before ip2. IP addresses sort first by length, then their address. IPv6 addresses with zones sort just after the same address without a zone."
      },
      {
        "name": "MarshalBinary",
        "desc": "MarshalBinary implements the [encoding.BinaryMarshaler] interface. It returns a zero-length slice for the zero [Addr], the 4-byte form for an IPv4 address, and the 16-byte form with zone appended for an IPv6 address."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface, The encoding is the same as returned by [Addr.String], with one exception: If ip is the zero [Addr], the encoding is the empty string."
      },
      {
        "name": "Next",
        "desc": "Next returns the address following ip. If there is none, it returns the zero [Addr]."
      },
      {
        "name": "Prefix",
        "desc": "Prefix keeps only the top b bits of IP, producing a Prefix of the specified length. If ip is a zero [Addr], Prefix always returns a zero Prefix and a nil error. Otherwise, if bits is less than zero or greater than ip.BitLen(), Prefix returns an error."
      },
      {
        "name": "Prev",
        "desc": "Prev returns the IP before ip. If there is none, it returns the IP zero value."
      },
      {
        "name": "String",
        "desc": "String returns the string form of the IP address ip. It returns one of 5 forms:    - \"invalid IP\", if ip is the zero [Addr]   - IPv4 dotted decimal (\"192.0.2.1\")   - IPv6 (\"2001:db8::1\")   - \"::ffff:1.2.3.4\" (if [Addr.Is4In6])   - IPv6 with zone (\"fe80:db8::1%eth0\")  Note that unlike package net's IP.String method, IPv4-mapped IPv6 addresses format with a \"::ffff:\" prefix before the dotted quad."
      },
      {
        "name": "StringExpanded",
        "desc": "StringExpanded is like [Addr.String] but IPv6 addresses are expanded with leading zeroes and no \"::\" compression. For example, \"2001:db8::1\" becomes \"2001:0db8:0000:0000:0000:0000:0000:0001\"."
      },
      {
        "name": "Unmap",
        "desc": "Unmap returns ip with any IPv4-mapped IPv6 address prefix removed.  That is, if ip is an IPv6 address wrapping an IPv4 address, it returns the wrapped IPv4 address. Otherwise it returns ip unmodified."
      },
      {
        "name": "UnmarshalBinary",
        "desc": "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. It expects data in the form generated by MarshalBinary."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by [ParseAddr].  If text is empty, UnmarshalText sets *ip to the zero [Addr] and returns no error."
      },
      {
        "name": "WithZone",
        "desc": "WithZone returns an IP that's the same as ip but with the provided zone. If zone is empty, the zone is removed. If ip is an IPv4 address, WithZone is a no-op and returns ip unchanged."
      },
      {
        "name": "Zone",
        "desc": "Zone returns ip's IPv6 scoped addressing zone, if any."
      },
      {
        "name": "appendTo4",
        "desc": ""
      },
      {
        "name": "appendTo4In6",
        "desc": ""
      },
      {
        "name": "appendTo6",
        "desc": ""
      },
      {
        "name": "hasZone",
        "desc": "hasZone reports whether ip has an IPv6 zone."
      },
      {
        "name": "isZero",
        "desc": "isZero reports whether ip is the zero value of the IP type. The zero value is not a valid IP address of any type.  Note that \"0.0.0.0\" and \"::\" are not the zero value. Use IsUnspecified to check for these values instead."
      },
      {
        "name": "marshalBinarySize",
        "desc": ""
      },
      {
        "name": "string4",
        "desc": ""
      },
      {
        "name": "string4In6",
        "desc": ""
      },
      {
        "name": "string6",
        "desc": "string6 formats ip in IPv6 textual representation. It follows the guidelines in section 4 of RFC 5952 (https://tools.ietf.org/html/rfc5952#section-4): no unnecessary zeros, use :: to elide the longest run of zeros, and don't use :: to compact a single zero field."
      },
      {
        "name": "v4",
        "desc": "v4 returns the i'th byte of ip. If ip is not an IPv4, v4 returns unspecified garbage."
      },
      {
        "name": "v6",
        "desc": "v6 returns the i'th byte of ip. If ip is an IPv4 address, this accesses the IPv4-mapped IPv6 address form of the IP."
      },
      {
        "name": "v6u16",
        "desc": "v6u16 returns the i'th 16-bit word of ip. If ip is an IPv4 address, this accesses the IPv4-mapped IPv6 address form of the IP."
      },
      {
        "name": "withoutZone",
        "desc": "withoutZone unconditionally strips the zone from ip. It's similar to WithZone, but small enough to be inlinable."
      },
      {
        "name": "Addr",
        "desc": "Addr returns p's IP address."
      },
      {
        "name": "AppendBinary",
        "desc": "AppendBinary implements the [encoding.BinaryAppendler] interface. It returns [Addr.AppendBinary] with an additional two bytes appended containing the port in little-endian."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface. The encoding is the same as returned by [AddrPort.AppendTo]."
      },
      {
        "name": "AppendTo",
        "desc": "AppendTo appends a text encoding of p, as generated by [AddrPort.MarshalText], to b and returns the extended buffer."
      },
      {
        "name": "Compare",
        "desc": "Compare returns an integer comparing two AddrPorts. The result will be 0 if p == p2, -1 if p \u003c p2, and +1 if p \u003e p2. AddrPorts sort first by IP address, then port."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether p.Addr() is valid. All ports are valid, including zero."
      },
      {
        "name": "MarshalBinary",
        "desc": "MarshalBinary implements the [encoding.BinaryMarshaler] interface. It returns [Addr.MarshalBinary] with an additional two bytes appended containing the port in little-endian."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface. The encoding is the same as returned by [AddrPort.String], with one exception: if p.Addr() is the zero [Addr], the encoding is the empty string."
      },
      {
        "name": "Port",
        "desc": "Port returns p's port."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "UnmarshalBinary",
        "desc": "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. It expects data in the form generated by [AddrPort.MarshalBinary]."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the encoding.TextUnmarshaler interface. The [AddrPort] is expected in a form generated by [AddrPort.MarshalText] or accepted by [ParseAddrPort]."
      },
      {
        "name": "Addr",
        "desc": "Addr returns p's IP address."
      },
      {
        "name": "AppendBinary",
        "desc": "AppendBinary implements the [encoding.AppendMarshaler] interface. It returns [Addr.AppendBinary] with an additional byte appended containing the prefix bits."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface. It is the same as [Prefix.AppendTo]."
      },
      {
        "name": "AppendTo",
        "desc": "AppendTo appends a text encoding of p, as generated by [Prefix.MarshalText], to b and returns the extended buffer."
      },
      {
        "name": "Bits",
        "desc": "Bits returns p's prefix length.  It reports -1 if invalid."
      },
      {
        "name": "Compare",
        "desc": ""
      },
      {
        "name": "Contains",
        "desc": "Contains reports whether the network p includes ip.  An IPv4 address will not match an IPv6 prefix. An IPv4-mapped IPv6 address will not match an IPv4 prefix. A zero-value IP will not match any prefix. If ip has an IPv6 zone, Contains returns false, because Prefixes strip zones."
      },
      {
        "name": "IsSingleIP",
        "desc": "IsSingleIP reports whether p contains exactly one IP."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether p.Bits() has a valid range for p.Addr(). If p.Addr() is the zero [Addr], IsValid returns false. Note that if p is the zero [Prefix], then p.IsValid() == false."
      },
      {
        "name": "IsZero",
        "desc": ""
      },
      {
        "name": "MarshalBinary",
        "desc": "MarshalBinary implements the [encoding.BinaryMarshaler] interface. It returns [Addr.MarshalBinary] with an additional byte appended containing the prefix bits."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface, The encoding is the same as returned by [Prefix.String], with one exception: If p is the zero value, the encoding is the empty string."
      },
      {
        "name": "Masked",
        "desc": "Masked returns p in its canonical form, with all but the high p.Bits() bits of p.Addr() masked off.  If p is zero or otherwise invalid, Masked returns the zero [Prefix]."
      },
      {
        "name": "Overlaps",
        "desc": "Overlaps reports whether p and o contain any IP addresses in common.  If p and o are of different address families or either have a zero IP, it reports false. Like the Contains method, a prefix with an IPv4-mapped IPv6 address is still treated as an IPv6 mask."
      },
      {
        "name": "String",
        "desc": "String returns the CIDR notation of p: \"\u003cip\u003e/\u003cbits\u003e\"."
      },
      {
        "name": "UnmarshalBinary",
        "desc": "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface. It expects data in the form generated by [Prefix.MarshalBinary]."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by [ParsePrefix] or generated by [Prefix.MarshalText]."
      },
      {
        "name": "compare",
        "desc": "compare returns an integer comparing two prefixes. The result will be 0 if p == p2, -1 if p \u003c p2, and +1 if p \u003e p2. Prefixes sort first by validity (invalid before valid), then address family (IPv4 before IPv6), then prefix length, then address.  Unexported for Go 1.22 because we may want to compare by p.Addr first. See post-acceptance discussion on go.dev/issue/61642."
      },
      {
        "name": "isZero",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "addOne",
        "desc": "addOne returns u + 1."
      },
      {
        "name": "and",
        "desc": "and returns the bitwise AND of u and m (u\u0026m)."
      },
      {
        "name": "bitsClearedFrom",
        "desc": "bitsClearedFrom returns a copy of u with the given bit and all subsequent ones cleared."
      },
      {
        "name": "bitsSetFrom",
        "desc": "bitsSetFrom returns a copy of u with the given bit and all subsequent ones set."
      },
      {
        "name": "halves",
        "desc": "halves returns the two uint64 halves of the uint128.  Logically, think of it as returning two uint64s. It only returns pointers for inlining reasons on 32-bit platforms."
      },
      {
        "name": "isZero",
        "desc": "isZero reports whether u == 0.  It's faster than u == (uint128{}) because the compiler (as of Go 1.15/1.16b1) doesn't do this trick and instead inserts a branch in its eq alg's generated code."
      },
      {
        "name": "not",
        "desc": "not returns the bitwise NOT of u."
      },
      {
        "name": "or",
        "desc": "or returns the bitwise OR of u and m (u|m)."
      },
      {
        "name": "subOne",
        "desc": "subOne returns u - 1."
      },
      {
        "name": "xor",
        "desc": "xor returns the bitwise XOR of u and m (u^m)."
      }
    ],
    "types": [
      {
        "name": "Addr",
        "desc": "Addr represents an IPv4 or IPv6 address (with or without a scoped addressing zone), similar to [net.IP] or [net.IPAddr].  Unlike [net.IP] or [net.IPAddr], Addr is a comparable value type (it supports == and can be a map key) and is immutable.  The zero Addr is not a valid IP address. Addr{} is distinct from both 0.0.0.0 and ::."
      },
      {
        "name": "AddrDetail",
        "desc": ""
      },
      {
        "name": "AddrPort",
        "desc": "AddrPort is an IP and a port number."
      },
      {
        "name": "Prefix",
        "desc": "Prefix is an IP address prefix (CIDR) representing an IP network.  The first [Prefix.Bits]() of [Addr]() are specified. The remaining bits match any address. The range of Bits() is [0,32] for IPv4 or [0,128] for IPv6."
      },
      {
        "name": "Uint128",
        "desc": ""
      },
      {
        "name": "addrDetail",
        "desc": "addrDetail represents the details of an Addr, like address family and IPv6 zone."
      },
      {
        "name": "appendMarshaler",
        "desc": ""
      },
      {
        "name": "parseAddrError",
        "desc": ""
      },
      {
        "name": "parsePrefixError",
        "desc": ""
      },
      {
        "name": "uint128",
        "desc": "uint128 represents a uint128 using two uint64s.  When the methods below mention a bit number, bit 0 is the most significant bit (in hi) and bit 127 is the lowest (lo\u00261)."
      }
    ]
  },
  {
    "name": "net/rpc",
    "desc": "Package rpc provides access to the exported methods of an object across a network or other I/O connection.  The net/rpc package is frozen and is not accepting new features.  A server registers an object, making it visible as a service with the name of the type of the object.  After registration, exported methods of the object will be accessible remotely.  A server may register multiple objects (services) of different types but it is an error to register multiple objects of the same type.  Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:    - the method's type is exported.   - the method is exported.   - the method has two arguments, both exported (or builtin) types.   - the method's second argument is a pointer.   - the method has return type error.  In effect, the method must look schematically like  \tfunc (t *T) MethodName(argType T1, replyType *T2) error  where T1 and T2 can be marshaled by encoding/gob. These requirements apply even if a different codec is used. (In the future, these requirements may soften for custom codecs.)  The method's first argument represents the arguments provided by the caller; the second argument represents the result parameters to be returned to the caller. The method's return value, if non-nil, is passed back as a string that the client sees as if created by [errors.New].  If an error is returned, the reply parameter will not be sent back to the client.  The server may handle requests on a single connection by calling [ServeConn].  More typically it will create a network listener and call [Accept] or, for an HTTP listener, [HandleHTTP] and [http.Serve].  A client wishing to use the service establishes a connection and then invokes [NewClient] on the connection.  The convenience function [Dial] ([DialHTTP]) performs both steps for a raw network connection (an HTTP connection).  The resulting [Client] object has two methods, [Call] and Go, that specify the service and method to call, a pointer containing the arguments, and a pointer to receive the result parameters.  The Call method waits for the remote call to complete while the Go method launches the call asynchronously and signals completion using the Call structure's Done channel.  Unless an explicit codec is set up, package [encoding/gob] is used to transport the data.  Here is a simple example.  A server wishes to export an object of type Arith:  \tpackage server  \timport \"errors\"  \ttype Args struct { \t\tA, B int \t}  \ttype Quotient struct { \t\tQuo, Rem int \t}  \ttype Arith int  \tfunc (t *Arith) Multiply(args *Args, reply *int) error { \t\t*reply = args.A * args.B \t\treturn nil \t}  \tfunc (t *Arith) Divide(args *Args, quo *Quotient) error { \t\tif args.B == 0 { \t\t\treturn errors.New(\"divide by zero\") \t\t} \t\tquo.Quo = args.A / args.B \t\tquo.Rem = args.A % args.B \t\treturn nil \t}  The server calls (for HTTP service):  \tarith := new(Arith) \trpc.Register(arith) \trpc.HandleHTTP() \tl, err := net.Listen(\"tcp\", \":1234\") \tif err != nil { \t\tlog.Fatal(\"listen error:\", err) \t} \tgo http.Serve(l, nil)  At this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and \"Arith.Divide\".  To invoke one, a client first dials the server:  \tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\") \tif err != nil { \t\tlog.Fatal(\"dialing:\", err) \t}  Then it can make a remote call:  \t// Synchronous call \targs := \u0026server.Args{7,8} \tvar reply int \terr = client.Call(\"Arith.Multiply\", args, \u0026reply) \tif err != nil { \t\tlog.Fatal(\"arith error:\", err) \t} \tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)  or  \t// Asynchronous call \tquotient := new(Quotient) \tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil) \treplyCall := \u003c-divCall.Done\t// will be equal to divCall \t// check errors, print, etc.  A server implementation will often provide a simple, type-safe wrapper for the client.",
    "functions": [
      {
        "name": "Accept",
        "desc": "Accept accepts connections on the listener and serves requests to [DefaultServer] for each incoming connection. Accept blocks; the caller typically invokes it in a go statement."
      },
      {
        "name": "BenchmarkEndToEnd",
        "desc": ""
      },
      {
        "name": "BenchmarkEndToEndAsync",
        "desc": ""
      },
      {
        "name": "BenchmarkEndToEndAsyncHTTP",
        "desc": ""
      },
      {
        "name": "BenchmarkEndToEndHTTP",
        "desc": ""
      },
      {
        "name": "HandleHTTP",
        "desc": "HandleHTTP registers an HTTP handler for RPC messages to [DefaultServer] on [DefaultRPCPath] and a debugging handler on [DefaultDebugPath]. It is still necessary to invoke [http.Serve](), typically in a go statement."
      },
      {
        "name": "Register",
        "desc": "Register publishes the receiver's methods in the [DefaultServer]."
      },
      {
        "name": "RegisterName",
        "desc": "RegisterName is like [Register] but uses the provided name for the type instead of the receiver's concrete type."
      },
      {
        "name": "ServeCodec",
        "desc": "ServeCodec is like [ServeConn] but uses the specified codec to decode requests and encode responses."
      },
      {
        "name": "ServeConn",
        "desc": "ServeConn runs the [DefaultServer] on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use [ServeCodec]. See [NewClient]'s comment for information about concurrent access."
      },
      {
        "name": "ServeRequest",
        "desc": "ServeRequest is like [ServeCodec] but synchronously serves a single request. It does not close the codec upon completion."
      },
      {
        "name": "TestAcceptExitAfterListenerClose",
        "desc": "Tests the fix to issue 11221. Without the fix, this loops forever or crashes."
      },
      {
        "name": "TestBuiltinTypes",
        "desc": ""
      },
      {
        "name": "TestClientWriteError",
        "desc": ""
      },
      {
        "name": "TestCloseCodec",
        "desc": ""
      },
      {
        "name": "TestCountMallocs",
        "desc": ""
      },
      {
        "name": "TestCountMallocsOverHTTP",
        "desc": ""
      },
      {
        "name": "TestErrorAfterClientClose",
        "desc": ""
      },
      {
        "name": "TestGobError",
        "desc": ""
      },
      {
        "name": "TestHTTP",
        "desc": ""
      },
      {
        "name": "TestRPC",
        "desc": ""
      },
      {
        "name": "TestRegistrationError",
        "desc": "Check that registration handles lots of bad methods and a type with no suitable methods."
      },
      {
        "name": "TestSendDeadlock",
        "desc": ""
      },
      {
        "name": "TestServeRequest",
        "desc": ""
      },
      {
        "name": "TestShutdown",
        "desc": ""
      },
      {
        "name": "TestTCPClose",
        "desc": ""
      },
      {
        "name": "benchmarkEndToEnd",
        "desc": ""
      },
      {
        "name": "benchmarkEndToEndAsync",
        "desc": ""
      },
      {
        "name": "countMallocs",
        "desc": ""
      },
      {
        "name": "isExportedOrBuiltinType",
        "desc": "Is this type exported or a builtin?"
      },
      {
        "name": "listenTCP",
        "desc": ""
      },
      {
        "name": "startHttpServer",
        "desc": ""
      },
      {
        "name": "startNewServer",
        "desc": ""
      },
      {
        "name": "startServer",
        "desc": ""
      },
      {
        "name": "suitableMethods",
        "desc": "suitableMethods returns suitable Rpc methods of typ. It will log errors if logErr is true."
      },
      {
        "name": "testHTTPRPC",
        "desc": ""
      },
      {
        "name": "testNewServerRPC",
        "desc": ""
      },
      {
        "name": "testRPC",
        "desc": ""
      },
      {
        "name": "testSendDeadlock",
        "desc": ""
      },
      {
        "name": "testServeRequest",
        "desc": ""
      },
      {
        "name": "ArgNotPublic",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": ""
      },
      {
        "name": "Div",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Mul",
        "desc": ""
      },
      {
        "name": "Scan",
        "desc": ""
      },
      {
        "name": "SleepMilli",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Array",
        "desc": ""
      },
      {
        "name": "Map",
        "desc": ""
      },
      {
        "name": "Slice",
        "desc": ""
      },
      {
        "name": "done",
        "desc": ""
      },
      {
        "name": "Call",
        "desc": "Call invokes the named function, waits for it to complete, and returns its error status."
      },
      {
        "name": "Close",
        "desc": "Close calls the underlying codec's Close method. If the connection is already shutting down, [ErrShutdown] is returned."
      },
      {
        "name": "Go",
        "desc": "Go invokes the function asynchronously. It returns the [Call] structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash."
      },
      {
        "name": "input",
        "desc": ""
      },
      {
        "name": "send",
        "desc": ""
      },
      {
        "name": "Call",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadRequestBody",
        "desc": ""
      },
      {
        "name": "ReadRequestHeader",
        "desc": ""
      },
      {
        "name": "WriteResponse",
        "desc": ""
      },
      {
        "name": "Exported",
        "desc": ""
      },
      {
        "name": "NeedsPtrType",
        "desc": ""
      },
      {
        "name": "ReplyNotPointer",
        "desc": ""
      },
      {
        "name": "ReplyNotPublic",
        "desc": ""
      },
      {
        "name": "Recv",
        "desc": ""
      },
      {
        "name": "Accept",
        "desc": "Accept accepts connections on the listener and serves requests for each incoming connection. Accept blocks until the listener returns a non-nil error. The caller typically invokes Accept in a go statement."
      },
      {
        "name": "HandleHTTP",
        "desc": "HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke [http.Serve](), typically in a go statement."
      },
      {
        "name": "Register",
        "desc": "Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:   - exported method of exported type   - two arguments, both of exported type   - the second argument is a pointer   - one return value, of type error  It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form \"Type.Method\", where Type is the receiver's concrete type."
      },
      {
        "name": "RegisterName",
        "desc": "RegisterName is like [Register] but uses the provided name for the type instead of the receiver's concrete type."
      },
      {
        "name": "ServeCodec",
        "desc": "ServeCodec is like [ServeConn] but uses the specified codec to decode requests and encode responses."
      },
      {
        "name": "ServeConn",
        "desc": "ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use [ServeCodec]. See [NewClient]'s comment for information about concurrent access."
      },
      {
        "name": "ServeHTTP",
        "desc": "ServeHTTP implements an [http.Handler] that answers RPC requests."
      },
      {
        "name": "ServeRequest",
        "desc": "ServeRequest is like [ServeCodec] but synchronously serves a single request. It does not close the codec upon completion."
      },
      {
        "name": "freeRequest",
        "desc": ""
      },
      {
        "name": "freeResponse",
        "desc": ""
      },
      {
        "name": "getRequest",
        "desc": ""
      },
      {
        "name": "getResponse",
        "desc": ""
      },
      {
        "name": "readRequest",
        "desc": ""
      },
      {
        "name": "readRequestHeader",
        "desc": ""
      },
      {
        "name": "register",
        "desc": ""
      },
      {
        "name": "sendResponse",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadResponseBody",
        "desc": ""
      },
      {
        "name": "ReadResponseHeader",
        "desc": ""
      },
      {
        "name": "WriteRequest",
        "desc": ""
      },
      {
        "name": "ServeHTTP",
        "desc": "Runs at /debug/rpc"
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadResponseBody",
        "desc": ""
      },
      {
        "name": "ReadResponseHeader",
        "desc": ""
      },
      {
        "name": "WriteRequest",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadRequestBody",
        "desc": ""
      },
      {
        "name": "ReadRequestHeader",
        "desc": ""
      },
      {
        "name": "WriteResponse",
        "desc": ""
      },
      {
        "name": "Exported",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "NumCalls",
        "desc": ""
      },
      {
        "name": "call",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadResponseBody",
        "desc": ""
      },
      {
        "name": "ReadResponseHeader",
        "desc": ""
      },
      {
        "name": "WriteRequest",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ArgNotPublic",
        "desc": ""
      },
      {
        "name": "Args",
        "desc": ""
      },
      {
        "name": "Arith",
        "desc": ""
      },
      {
        "name": "BuiltinTypes",
        "desc": ""
      },
      {
        "name": "Call",
        "desc": "Call represents an active RPC."
      },
      {
        "name": "Client",
        "desc": "Client represents an RPC Client. There may be multiple outstanding Calls associated with a single Client, and a Client may be used by multiple goroutines simultaneously."
      },
      {
        "name": "ClientCodec",
        "desc": "A ClientCodec implements writing of RPC requests and reading of RPC responses for the client side of an RPC session. The client calls [ClientCodec.WriteRequest] to write a request to the connection and calls [ClientCodec.ReadResponseHeader] and [ClientCodec.ReadResponseBody] in pairs to read responses. The client calls [ClientCodec.Close] when finished with the connection. ReadResponseBody may be called with a nil argument to force the body of the response to be read and then discarded. See [NewClient]'s comment for information about concurrent access."
      },
      {
        "name": "CodecEmulator",
        "desc": "CodecEmulator provides a client-like api and a ServerCodec interface. Can be used to test ServeRequest."
      },
      {
        "name": "Embed",
        "desc": ""
      },
      {
        "name": "NeedsPtrType",
        "desc": ""
      },
      {
        "name": "R",
        "desc": ""
      },
      {
        "name": "Reply",
        "desc": ""
      },
      {
        "name": "ReplyNotPointer",
        "desc": ""
      },
      {
        "name": "ReplyNotPublic",
        "desc": ""
      },
      {
        "name": "Request",
        "desc": "Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic."
      },
      {
        "name": "Response",
        "desc": "Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic."
      },
      {
        "name": "S",
        "desc": ""
      },
      {
        "name": "Server",
        "desc": "Server represents an RPC Server."
      },
      {
        "name": "ServerCodec",
        "desc": "A ServerCodec implements reading of RPC requests and writing of RPC responses for the server side of an RPC session. The server calls [ServerCodec.ReadRequestHeader] and [ServerCodec.ReadRequestBody] in pairs to read requests from the connection, and it calls [ServerCodec.WriteResponse] to write a response back. The server calls [ServerCodec.Close] when finished with the connection. ReadRequestBody may be called with a nil argument to force the body of the request to be read and discarded. See [NewClient]'s comment for information about concurrent access."
      },
      {
        "name": "ServerError",
        "desc": "ServerError represents an error that has been returned from the remote side of the RPC connection."
      },
      {
        "name": "WriteFailCodec",
        "desc": ""
      },
      {
        "name": "debugHTTP",
        "desc": ""
      },
      {
        "name": "debugMethod",
        "desc": ""
      },
      {
        "name": "debugService",
        "desc": ""
      },
      {
        "name": "gobClientCodec",
        "desc": ""
      },
      {
        "name": "gobServerCodec",
        "desc": ""
      },
      {
        "name": "hidden",
        "desc": ""
      },
      {
        "name": "local",
        "desc": ""
      },
      {
        "name": "methodArray",
        "desc": ""
      },
      {
        "name": "methodType",
        "desc": ""
      },
      {
        "name": "service",
        "desc": ""
      },
      {
        "name": "serviceArray",
        "desc": ""
      },
      {
        "name": "shutdownCodec",
        "desc": ""
      },
      {
        "name": "writeCrasher",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/rpc/jsonrpc",
    "desc": "Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. For JSON-RPC 2.0 support, see https://godoc.org/?q=json-rpc+2.0",
    "functions": [
      {
        "name": "Dial",
        "desc": "Dial connects to a JSON-RPC server at the specified network address."
      },
      {
        "name": "NewClient",
        "desc": "NewClient returns a new [rpc.Client] to handle requests to the set of services at the other end of the connection."
      },
      {
        "name": "NewClientCodec",
        "desc": "NewClientCodec returns a new [rpc.ClientCodec] using JSON-RPC on conn."
      },
      {
        "name": "NewServerCodec",
        "desc": "NewServerCodec returns a new [rpc.ServerCodec] using JSON-RPC on conn."
      },
      {
        "name": "ServeConn",
        "desc": "ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement."
      },
      {
        "name": "TestBuiltinTypes",
        "desc": ""
      },
      {
        "name": "TestClient",
        "desc": ""
      },
      {
        "name": "TestMalformedInput",
        "desc": ""
      },
      {
        "name": "TestMalformedOutput",
        "desc": ""
      },
      {
        "name": "TestServer",
        "desc": ""
      },
      {
        "name": "TestServerEmptyMessage",
        "desc": ""
      },
      {
        "name": "TestServerErrorHasNullResult",
        "desc": ""
      },
      {
        "name": "TestServerNoParams",
        "desc": ""
      },
      {
        "name": "TestUnexpectedError",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "myPipe",
        "desc": "Copied from package net."
      },
      {
        "name": "Add",
        "desc": ""
      },
      {
        "name": "Div",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Mul",
        "desc": ""
      },
      {
        "name": "Array",
        "desc": ""
      },
      {
        "name": "Map",
        "desc": ""
      },
      {
        "name": "Slice",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadResponseBody",
        "desc": ""
      },
      {
        "name": "ReadResponseHeader",
        "desc": ""
      },
      {
        "name": "WriteRequest",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "LocalAddr",
        "desc": ""
      },
      {
        "name": "RemoteAddr",
        "desc": ""
      },
      {
        "name": "SetReadTimeout",
        "desc": ""
      },
      {
        "name": "SetTimeout",
        "desc": ""
      },
      {
        "name": "SetWriteTimeout",
        "desc": ""
      },
      {
        "name": "Network",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "ReadRequestBody",
        "desc": ""
      },
      {
        "name": "ReadRequestHeader",
        "desc": ""
      },
      {
        "name": "WriteResponse",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Args",
        "desc": ""
      },
      {
        "name": "Arith",
        "desc": ""
      },
      {
        "name": "ArithAddResp",
        "desc": ""
      },
      {
        "name": "BuiltinTypes",
        "desc": ""
      },
      {
        "name": "Reply",
        "desc": ""
      },
      {
        "name": "clientCodec",
        "desc": ""
      },
      {
        "name": "clientRequest",
        "desc": ""
      },
      {
        "name": "clientResponse",
        "desc": ""
      },
      {
        "name": "pipe",
        "desc": ""
      },
      {
        "name": "pipeAddr",
        "desc": ""
      },
      {
        "name": "serverCodec",
        "desc": ""
      },
      {
        "name": "serverRequest",
        "desc": ""
      },
      {
        "name": "serverResponse",
        "desc": ""
      }
    ]
  },
  {
    "name": "net/smtp",
    "desc": "",
    "functions": [
      {
        "name": "Example",
        "desc": ""
      },
      {
        "name": "ExamplePlainAuth",
        "desc": ""
      },
      {
        "name": "ExampleSendMail",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "net/textproto",
    "desc": "Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.  This package enforces the HTTP/1.1 character set defined by RFC 9112 for header keys and values.  The package provides:  [Error], which represents a numeric error response from a server.  [Pipeline], to manage pipelined requests and responses in a client.  [Reader], to read numeric response code lines, key: value headers, lines wrapped with leading spaces on continuation lines, and whole text blocks ending with a dot on a line by itself.  [Writer], to write dot-encoded text blocks.  [Conn], a convenient packaging of [Reader], [Writer], and [Pipeline] for use with a single network connection.",
    "functions": [
      {
        "name": "BenchmarkReadMIMEHeader",
        "desc": ""
      },
      {
        "name": "BenchmarkUncommon",
        "desc": ""
      },
      {
        "name": "CanonicalMIMEHeaderKey",
        "desc": "CanonicalMIMEHeaderKey returns the canonical format of the MIME header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". MIME header keys are assumed to be ASCII only. If s contains a space or invalid header field bytes as defined by RFC 9112, it is returned without modifications."
      },
      {
        "name": "TestCanonicalMIMEHeaderKey",
        "desc": ""
      },
      {
        "name": "TestCommonHeaders",
        "desc": ""
      },
      {
        "name": "TestDotWriter",
        "desc": ""
      },
      {
        "name": "TestDotWriterCloseEmptyWrite",
        "desc": ""
      },
      {
        "name": "TestDotWriterCloseNoWrite",
        "desc": ""
      },
      {
        "name": "TestIssue46363",
        "desc": ""
      },
      {
        "name": "TestLargeReadMIMEHeader",
        "desc": ""
      },
      {
        "name": "TestMIMEHeaderMultipleValues",
        "desc": "Issue #34799 add a Header method to get multiple values []string, with canonicalized key"
      },
      {
        "name": "TestPrintfLine",
        "desc": ""
      },
      {
        "name": "TestRFC959Lines",
        "desc": "See https://www.ietf.org/rfc/rfc959.txt page 36."
      },
      {
        "name": "TestReadCodeLine",
        "desc": ""
      },
      {
        "name": "TestReadContinuedLine",
        "desc": ""
      },
      {
        "name": "TestReadDotBytes",
        "desc": ""
      },
      {
        "name": "TestReadDotLines",
        "desc": ""
      },
      {
        "name": "TestReadLine",
        "desc": ""
      },
      {
        "name": "TestReadLineLongLine",
        "desc": ""
      },
      {
        "name": "TestReadMIMEHeader",
        "desc": ""
      },
      {
        "name": "TestReadMIMEHeaderAllocations",
        "desc": "Test that reading a header doesn't overallocate. Issue 58975."
      },
      {
        "name": "TestReadMIMEHeaderBytes",
        "desc": ""
      },
      {
        "name": "TestReadMIMEHeaderMalformed",
        "desc": ""
      },
      {
        "name": "TestReadMIMEHeaderNoKey",
        "desc": ""
      },
      {
        "name": "TestReadMIMEHeaderNonCompliant",
        "desc": "TestReadMIMEHeaderNonCompliant checks that we don't normalize headers with spaces before colons, and accept spaces in keys."
      },
      {
        "name": "TestReadMIMEHeaderSingle",
        "desc": ""
      },
      {
        "name": "TestReadMIMEHeaderTrimContinued",
        "desc": "Test that continued lines are properly trimmed. Issue 11204."
      },
      {
        "name": "TestReadMultiLineError",
        "desc": "Test that multi-line errors are appropriately and fully read. Issue 10230."
      },
      {
        "name": "TestReaderUpcomingHeaderKeys",
        "desc": "TestReaderUpcomingHeaderKeys is testing an internal function, but it's very difficult to test well via the external API."
      },
      {
        "name": "TrimBytes",
        "desc": "TrimBytes returns b without leading and trailing ASCII space."
      },
      {
        "name": "TrimString",
        "desc": "TrimString returns s without leading and trailing ASCII space."
      },
      {
        "name": "canonicalMIMEHeaderKey",
        "desc": "canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is allowed to mutate the provided byte slice before returning the string.  For invalid inputs (if a contains spaces or non-token bytes), a is unchanged and a string copy is returned.  ok is true if the header key contains only valid characters and spaces. ReadMIMEHeader accepts header keys containing spaces, but does not canonicalize them."
      },
      {
        "name": "initCommonHeader",
        "desc": ""
      },
      {
        "name": "isASCIILetter",
        "desc": ""
      },
      {
        "name": "isASCIISpace",
        "desc": ""
      },
      {
        "name": "mustHaveFieldNameColon",
        "desc": "mustHaveFieldNameColon ensures that, per RFC 7230, the field-name is on a single line, so the first line must contain a colon."
      },
      {
        "name": "noValidation",
        "desc": "noValidation is a no-op validation func for readContinuedLineSlice that permits any lines."
      },
      {
        "name": "parseCodeLine",
        "desc": ""
      },
      {
        "name": "trim",
        "desc": "trim returns s with leading and trailing spaces and tabs removed. It does not assume Unicode or UTF-8."
      },
      {
        "name": "validHeaderFieldByte",
        "desc": "validHeaderFieldByte reports whether c is a valid byte in a header field name. RFC 7230 says:  \theader-field   = field-name \":\" OWS field-value OWS \tfield-name     = token \ttchar = \"!\" / \"#\" / \"$\" / \"%\" / \"\u0026\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \t        \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA \ttoken = 1*tchar"
      },
      {
        "name": "validHeaderValueByte",
        "desc": "validHeaderValueByte reports whether c is a valid byte in a header field value. RFC 7230 says:  \tfield-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ] \tfield-vchar    = VCHAR / obs-text \tobs-text       = %x80-FF  RFC 5234 says:  \tHTAB           =  %x09 \tSP             =  %x20 \tVCHAR          =  %x21-7E"
      },
      {
        "name": "Close",
        "desc": "Close closes the connection."
      },
      {
        "name": "Cmd",
        "desc": "Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \\r\\n. Cmd returns the id of the command, for use with StartResponse and EndResponse.  For example, a client might run a HELP command that returns a dot-body by using:  \tid, err := c.Cmd(\"HELP\") \tif err != nil { \t\treturn nil, err \t}  \tc.StartResponse(id) \tdefer c.EndResponse(id)  \tif _, _, err = c.ReadCodeLine(110); err != nil { \t\treturn nil, err \t} \ttext, err := c.ReadDotBytes() \tif err != nil { \t\treturn nil, err \t} \treturn c.ReadCodeLine(250)"
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": "Add adds the key, value pair to the header. It appends to any existing values associated with key."
      },
      {
        "name": "Del",
        "desc": "Del deletes the values associated with key."
      },
      {
        "name": "Get",
        "desc": "Get gets the first value associated with the given key. It is case insensitive; [CanonicalMIMEHeaderKey] is used to canonicalize the provided key. If there are no values associated with the key, Get returns \"\". To use non-canonical keys, access the map directly."
      },
      {
        "name": "Set",
        "desc": "Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key."
      },
      {
        "name": "Values",
        "desc": "Values returns all values associated with the given key. It is case insensitive; [CanonicalMIMEHeaderKey] is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy."
      },
      {
        "name": "EndRequest",
        "desc": "EndRequest notifies p that the request with the given id has been sent (or, if this is a server, received)."
      },
      {
        "name": "EndResponse",
        "desc": "EndResponse notifies p that the response with the given id has been received (or, if this is a server, sent)."
      },
      {
        "name": "Next",
        "desc": "Next returns the next id for a request/response pair."
      },
      {
        "name": "StartRequest",
        "desc": "StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id."
      },
      {
        "name": "StartResponse",
        "desc": "StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "DotReader",
        "desc": "DotReader returns a new [Reader] that satisfies Reads using the decoded text of a dot-encoded block read from r. The returned Reader is only valid until the next call to a method on r.  Dot encoding is a common framing used for data blocks in text protocols such as SMTP.  The data consists of a sequence of lines, each of which ends in \"\\r\\n\".  The sequence itself ends at a line containing just a dot: \".\\r\\n\".  Lines beginning with a dot are escaped with an additional dot to avoid looking like the end of the sequence.  The decoded form returned by the Reader's Read method rewrites the \"\\r\\n\" line endings into the simpler \"\\n\", removes leading dot escapes if present, and stops with error [io.EOF] after consuming (and discarding) the end-of-sequence line."
      },
      {
        "name": "ReadCodeLine",
        "desc": "ReadCodeLine reads a response code line of the form  \tcode message  where code is a three-digit status code and the message extends to the rest of the line. An example of such a line is:  \t220 plan9.bell-labs.com ESMTP  If the prefix of the status does not match the digits in expectCode, ReadCodeLine returns with err set to \u0026Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].  If the response is multi-line, ReadCodeLine returns an error.  An expectCode \u003c= 0 disables the check of the status code."
      },
      {
        "name": "ReadContinuedLine",
        "desc": "ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.  For example, consider this input:  \tLine 1 \t  continued... \tLine 2  The first call to ReadContinuedLine will return \"Line 1 continued...\" and the second will return \"Line 2\".  Empty lines are never continued."
      },
      {
        "name": "ReadContinuedLineBytes",
        "desc": "ReadContinuedLineBytes is like [Reader.ReadContinuedLine] but returns a []byte instead of a string."
      },
      {
        "name": "ReadDotBytes",
        "desc": "ReadDotBytes reads a dot-encoding and returns the decoded data.  See the documentation for the [Reader.DotReader] method for details about dot-encoding."
      },
      {
        "name": "ReadDotLines",
        "desc": "ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \\r\\n or \\n elided from each.  See the documentation for the [Reader.DotReader] method for details about dot-encoding."
      },
      {
        "name": "ReadLine",
        "desc": "ReadLine reads a single line from r, eliding the final \\n or \\r\\n from the returned string."
      },
      {
        "name": "ReadLineBytes",
        "desc": "ReadLineBytes is like [Reader.ReadLine] but returns a []byte instead of a string."
      },
      {
        "name": "ReadMIMEHeader",
        "desc": "ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps [CanonicalMIMEHeaderKey](key) to a sequence of values in the same order encountered in the input.  For example, consider this input:  \tMy-Key: Value 1 \tLong-Key: Even \t       Longer Value \tMy-Key: Value 2  Given that input, ReadMIMEHeader returns the map:  \tmap[string][]string{ \t\t\"My-Key\": {\"Value 1\", \"Value 2\"}, \t\t\"Long-Key\": {\"Even Longer Value\"}, \t}"
      },
      {
        "name": "ReadResponse",
        "desc": "ReadResponse reads a multi-line response of the form:  \tcode-message line 1 \tcode-message line 2 \t... \tcode message line n  where code is a three-digit status code. The first line starts with the code and a hyphen. The response is terminated by a line that starts with the same code followed by a space. Each line in message is separated by a newline (\\n).  See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for details of another form of response accepted:  \tcode-message line 1 \tmessage line 2 \t... \tcode message line n  If the prefix of the status does not match the digits in expectCode, ReadResponse returns with err set to \u0026Error{code, message}. For example, if expectCode is 31, an error will be returned if the status is not in the range [310,319].  An expectCode \u003c= 0 disables the check of the status code."
      },
      {
        "name": "closeDot",
        "desc": "closeDot drains the current DotReader if any, making sure that it reads until the ending dot line."
      },
      {
        "name": "readCodeLine",
        "desc": ""
      },
      {
        "name": "readContinuedLineSlice",
        "desc": "readContinuedLineSlice reads continued lines from the reader buffer, returning a byte slice with all lines. The validateFirstLine function is run on the first read line, and if it returns an error then this error is returned from readContinuedLineSlice. It reads up to lim bytes of data (or unlimited if lim is less than 0)."
      },
      {
        "name": "readLineSlice",
        "desc": "readLineSlice reads a single line from r, up to lim bytes long (or unlimited if lim is less than 0), eliding the final \\r or \\r\\n from the returned string."
      },
      {
        "name": "skipSpace",
        "desc": "skipSpace skips R over all spaces and returns the number of bytes skipped."
      },
      {
        "name": "upcomingHeaderKeys",
        "desc": "upcomingHeaderKeys returns an approximation of the number of keys that will be in this header. If it gets confused, it returns 0."
      },
      {
        "name": "DotWriter",
        "desc": "DotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \\n into \\r\\n, and adding the final .\\r\\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w.  See the documentation for the [Reader.DotReader] method for details about dot-encoding."
      },
      {
        "name": "PrintfLine",
        "desc": "PrintfLine writes the formatted output followed by \\r\\n."
      },
      {
        "name": "closeDot",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": "Read satisfies reads by decoding dot-encoded data read from d.r."
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "End",
        "desc": "End notifies the sequencer that the event numbered id has completed, allowing it to schedule the event numbered id+1.  It is a run-time error to call End with an id that is not the number of the active event."
      },
      {
        "name": "Start",
        "desc": "Start waits until it is time for the event numbered id to begin. That is, except for the first event, it waits until End(id-1) has been called."
      }
    ],
    "types": [
      {
        "name": "Conn",
        "desc": "A Conn represents a textual network protocol connection. It consists of a [Reader] and [Writer] to manage I/O and a [Pipeline] to sequence concurrent requests on the connection. These embedded types carry methods with them; see the documentation of those types for details."
      },
      {
        "name": "Error",
        "desc": "An Error represents a numeric error response from a server."
      },
      {
        "name": "MIMEHeader",
        "desc": "A MIMEHeader represents a MIME-style header mapping keys to sets of values."
      },
      {
        "name": "Pipeline",
        "desc": "A Pipeline manages a pipelined in-order request/response sequence.  To use a Pipeline p to manage multiple clients on a connection, each client should run:  \tid := p.Next()\t// take a number  \tp.StartRequest(id)\t// wait for turn to send request \t«send request» \tp.EndRequest(id)\t// notify Pipeline that request is sent  \tp.StartResponse(id)\t// wait for turn to read response \t«read response» \tp.EndResponse(id)\t// notify Pipeline that response is read  A pipelined server can use the same calls to ensure that responses computed in parallel are written in the correct order."
      },
      {
        "name": "ProtocolError",
        "desc": "A ProtocolError describes a protocol violation such as an invalid response or a hung-up connection."
      },
      {
        "name": "Reader",
        "desc": "A Reader implements convenience methods for reading requests or responses from a text protocol network connection."
      },
      {
        "name": "Writer",
        "desc": "A Writer implements convenience methods for writing requests or responses to a text protocol network connection."
      },
      {
        "name": "canonicalHeaderKeyTest",
        "desc": ""
      },
      {
        "name": "dotReader",
        "desc": ""
      },
      {
        "name": "dotWriter",
        "desc": ""
      },
      {
        "name": "readResponseTest",
        "desc": ""
      },
      {
        "name": "sequencer",
        "desc": "A sequencer schedules a sequence of numbered events that must happen in order, one after the other. The event numbering must start at 0 and increment without skipping. The event number wraps around safely as long as there are not 2^32 simultaneous events pending."
      }
    ]
  },
  {
    "name": "net/url",
    "desc": "",
    "functions": [
      {
        "name": "ExampleParseQuery",
        "desc": ""
      },
      {
        "name": "ExamplePathEscape",
        "desc": ""
      },
      {
        "name": "ExamplePathUnescape",
        "desc": ""
      },
      {
        "name": "ExampleQueryEscape",
        "desc": ""
      },
      {
        "name": "ExampleQueryUnescape",
        "desc": ""
      },
      {
        "name": "ExampleURL",
        "desc": ""
      },
      {
        "name": "ExampleURL_EscapedFragment",
        "desc": ""
      },
      {
        "name": "ExampleURL_EscapedPath",
        "desc": ""
      },
      {
        "name": "ExampleURL_Hostname",
        "desc": ""
      },
      {
        "name": "ExampleURL_IsAbs",
        "desc": ""
      },
      {
        "name": "ExampleURL_JoinPath",
        "desc": ""
      },
      {
        "name": "ExampleURL_MarshalBinary",
        "desc": ""
      },
      {
        "name": "ExampleURL_Parse",
        "desc": ""
      },
      {
        "name": "ExampleURL_Port",
        "desc": ""
      },
      {
        "name": "ExampleURL_Query",
        "desc": ""
      },
      {
        "name": "ExampleURL_Redacted",
        "desc": ""
      },
      {
        "name": "ExampleURL_RequestURI",
        "desc": ""
      },
      {
        "name": "ExampleURL_ResolveReference",
        "desc": ""
      },
      {
        "name": "ExampleURL_String",
        "desc": ""
      },
      {
        "name": "ExampleURL_UnmarshalBinary",
        "desc": ""
      },
      {
        "name": "ExampleURL_roundtrip",
        "desc": ""
      },
      {
        "name": "ExampleValues",
        "desc": ""
      },
      {
        "name": "ExampleValues_Add",
        "desc": ""
      },
      {
        "name": "ExampleValues_Del",
        "desc": ""
      },
      {
        "name": "ExampleValues_Encode",
        "desc": ""
      },
      {
        "name": "ExampleValues_Get",
        "desc": ""
      },
      {
        "name": "ExampleValues_Has",
        "desc": ""
      },
      {
        "name": "ExampleValues_Set",
        "desc": ""
      },
      {
        "name": "toJSON",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "os",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkAddExtendedPrefix",
        "desc": ""
      },
      {
        "name": "BenchmarkExpand",
        "desc": ""
      },
      {
        "name": "BenchmarkLstatDir",
        "desc": ""
      },
      {
        "name": "BenchmarkLstatDot",
        "desc": ""
      },
      {
        "name": "BenchmarkLstatFile",
        "desc": ""
      },
      {
        "name": "BenchmarkReadDir",
        "desc": ""
      },
      {
        "name": "BenchmarkReaddir",
        "desc": ""
      },
      {
        "name": "BenchmarkReaddirname",
        "desc": ""
      },
      {
        "name": "BenchmarkRemoveAll",
        "desc": ""
      },
      {
        "name": "BenchmarkSendFile",
        "desc": ""
      },
      {
        "name": "BenchmarkStatDir",
        "desc": ""
      },
      {
        "name": "BenchmarkStatDot",
        "desc": ""
      },
      {
        "name": "BenchmarkStatFile",
        "desc": ""
      },
      {
        "name": "ExampleChmod",
        "desc": ""
      },
      {
        "name": "ExampleChtimes",
        "desc": ""
      },
      {
        "name": "ExampleCreateTemp",
        "desc": ""
      },
      {
        "name": "ExampleCreateTemp_suffix",
        "desc": ""
      },
      {
        "name": "ExampleErrNotExist",
        "desc": ""
      },
      {
        "name": "ExampleExpand",
        "desc": ""
      },
      {
        "name": "ExampleExpandEnv",
        "desc": ""
      },
      {
        "name": "ExampleFileMode",
        "desc": ""
      },
      {
        "name": "ExampleGetenv",
        "desc": ""
      },
      {
        "name": "ExampleLookupEnv",
        "desc": ""
      },
      {
        "name": "ExampleMkdir",
        "desc": ""
      },
      {
        "name": "ExampleMkdirAll",
        "desc": ""
      },
      {
        "name": "ExampleMkdirTemp",
        "desc": ""
      },
      {
        "name": "ExampleMkdirTemp_suffix",
        "desc": ""
      },
      {
        "name": "ExampleOpenFile",
        "desc": ""
      },
      {
        "name": "ExampleOpenFile_append",
        "desc": ""
      },
      {
        "name": "ExampleReadDir",
        "desc": ""
      },
      {
        "name": "ExampleReadFile",
        "desc": ""
      },
      {
        "name": "ExampleReadlink",
        "desc": ""
      },
      {
        "name": "ExampleUnsetenv",
        "desc": ""
      },
      {
        "name": "ExampleUserCacheDir",
        "desc": ""
      },
      {
        "name": "ExampleUserConfigDir",
        "desc": ""
      },
      {
        "name": "ExampleWriteFile",
        "desc": ""
      },
      {
        "name": "TestAddExtendedPrefix",
        "desc": ""
      },
      {
        "name": "TestAppExecLinkStat",
        "desc": ""
      },
      {
        "name": "TestAppend",
        "desc": ""
      },
      {
        "name": "TestAppendDoesntOverwrite",
        "desc": ""
      },
      {
        "name": "TestBadNetPathError",
        "desc": ""
      },
      {
        "name": "TestChdirAndGetwd",
        "desc": ""
      },
      {
        "name": "TestChmod",
        "desc": ""
      },
      {
        "name": "TestChown",
        "desc": ""
      },
      {
        "name": "TestChtimes",
        "desc": ""
      },
      {
        "name": "TestChtimesDir",
        "desc": ""
      },
      {
        "name": "TestChtimesOmit",
        "desc": ""
      },
      {
        "name": "TestChtimesToUnixZero",
        "desc": ""
      },
      {
        "name": "TestClearenv",
        "desc": ""
      },
      {
        "name": "TestCloseWithBlockingReadByFd",
        "desc": ""
      },
      {
        "name": "TestCloseWithBlockingReadByNewFile",
        "desc": ""
      },
      {
        "name": "TestClosedPipeRaceRead",
        "desc": ""
      },
      {
        "name": "TestClosedPipeRaceWrite",
        "desc": ""
      },
      {
        "name": "TestClosedStat",
        "desc": ""
      },
      {
        "name": "TestCmdArgs",
        "desc": ""
      },
      {
        "name": "TestConsistentEnviron",
        "desc": ""
      },
      {
        "name": "TestCopyFS",
        "desc": ""
      },
      {
        "name": "TestCopyFSWithSymlinks",
        "desc": ""
      },
      {
        "name": "TestCopyFile",
        "desc": ""
      },
      {
        "name": "TestCopyFileToFile",
        "desc": ""
      },
      {
        "name": "TestCreateTemp",
        "desc": ""
      },
      {
        "name": "TestCreateTempBadPattern",
        "desc": ""
      },
      {
        "name": "TestCreateTempPattern",
        "desc": ""
      },
      {
        "name": "TestDeleteReadOnly",
        "desc": ""
      },
      {
        "name": "TestDevNullFile",
        "desc": ""
      },
      {
        "name": "TestDirAndSymlinkStats",
        "desc": ""
      },
      {
        "name": "TestDirFS",
        "desc": ""
      },
      {
        "name": "TestDirFSEmptyDir",
        "desc": ""
      },
      {
        "name": "TestDirFSLstat",
        "desc": ""
      },
      {
        "name": "TestDirFSPathsValid",
        "desc": ""
      },
      {
        "name": "TestDirFSReadFileProc",
        "desc": ""
      },
      {
        "name": "TestDirFSReadLink",
        "desc": ""
      },
      {
        "name": "TestDirFSRootDir",
        "desc": ""
      },
      {
        "name": "TestDirFSWalkDir",
        "desc": ""
      },
      {
        "name": "TestDirSeek",
        "desc": ""
      },
      {
        "name": "TestDirectoryJunction",
        "desc": ""
      },
      {
        "name": "TestDirectorySymbolicLink",
        "desc": ""
      },
      {
        "name": "TestDoubleCloseError",
        "desc": ""
      },
      {
        "name": "TestEPIPE",
        "desc": ""
      },
      {
        "name": "TestEnvironConsistency",
        "desc": "On Windows, Environ was observed to report keys with a single leading \"=\". Check that they are properly reported by LookupEnv and can be set by SetEnv. See https://golang.org/issue/49886."
      },
      {
        "name": "TestErrIsExist",
        "desc": ""
      },
      {
        "name": "TestErrIsNotExist",
        "desc": ""
      },
      {
        "name": "TestErrPathNUL",
        "desc": ""
      },
      {
        "name": "TestErrProcessDone",
        "desc": ""
      },
      {
        "name": "TestErrorIsMethods",
        "desc": ""
      },
      {
        "name": "TestExecutable",
        "desc": ""
      },
      {
        "name": "TestExecutableDeleted",
        "desc": ""
      },
      {
        "name": "TestExpand",
        "desc": ""
      },
      {
        "name": "TestExpandEnvShellSpecialVar",
        "desc": ""
      },
      {
        "name": "TestFIFONonBlockingEOF",
        "desc": ""
      },
      {
        "name": "TestFTruncate",
        "desc": ""
      },
      {
        "name": "TestFdRace",
        "desc": "Issue 24481."
      },
      {
        "name": "TestFdReadRace",
        "desc": ""
      },
      {
        "name": "TestFifoEOF",
        "desc": ""
      },
      {
        "name": "TestFile",
        "desc": ""
      },
      {
        "name": "TestFileAndSymlinkStats",
        "desc": ""
      },
      {
        "name": "TestFileAssociatedWithExternalIOCP",
        "desc": ""
      },
      {
        "name": "TestFileChdir",
        "desc": ""
      },
      {
        "name": "TestFileChown",
        "desc": ""
      },
      {
        "name": "TestFileOverlappedReadAtVolume",
        "desc": ""
      },
      {
        "name": "TestFileOverlappedSeek",
        "desc": ""
      },
      {
        "name": "TestFilePermissions",
        "desc": "TestFilePermissions tests setting Unix permission bits on file creation."
      },
      {
        "name": "TestFileRDWRFlags",
        "desc": "TestFileRDWRFlags tests the O_RDONLY, O_WRONLY, and O_RDWR flags."
      },
      {
        "name": "TestFileReadDir",
        "desc": ""
      },
      {
        "name": "TestFileReaddir",
        "desc": ""
      },
      {
        "name": "TestFileReaddirnames",
        "desc": ""
      },
      {
        "name": "TestFileStatNUL",
        "desc": ""
      },
      {
        "name": "TestFileWriteFdRace",
        "desc": ""
      },
      {
        "name": "TestFindProcessViaPidfd",
        "desc": ""
      },
      {
        "name": "TestFstat",
        "desc": ""
      },
      {
        "name": "TestGetPollFDAndNetwork",
        "desc": ""
      },
      {
        "name": "TestGetppid",
        "desc": ""
      },
      {
        "name": "TestGetwdDeep",
        "desc": ""
      },
      {
        "name": "TestGetwdDeepWithPWDSet",
        "desc": ""
      },
      {
        "name": "TestHardLink",
        "desc": ""
      },
      {
        "name": "TestHostname",
        "desc": ""
      },
      {
        "name": "TestIllformedUTF16FileName",
        "desc": ""
      },
      {
        "name": "TestIsExist",
        "desc": ""
      },
      {
        "name": "TestIsPermission",
        "desc": ""
      },
      {
        "name": "TestIssue60181",
        "desc": "Test that copying to files opened with O_APPEND works and the copy_file_range syscall isn't used on Linux.  Regression test for go.dev/issue/60181"
      },
      {
        "name": "TestKillFindProcess",
        "desc": ""
      },
      {
        "name": "TestKillStartProcess",
        "desc": ""
      },
      {
        "name": "TestLargeCopyViaNetwork",
        "desc": ""
      },
      {
        "name": "TestLargeWriteToConsole",
        "desc": ""
      },
      {
        "name": "TestLchown",
        "desc": ""
      },
      {
        "name": "TestLongPath",
        "desc": ""
      },
      {
        "name": "TestLongPathAbs",
        "desc": ""
      },
      {
        "name": "TestLongPathRel",
        "desc": ""
      },
      {
        "name": "TestLongSymlink",
        "desc": ""
      },
      {
        "name": "TestLookupEnv",
        "desc": ""
      },
      {
        "name": "TestLstat",
        "desc": ""
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "TestMkdirAll",
        "desc": ""
      },
      {
        "name": "TestMkdirAllAbsPath",
        "desc": ""
      },
      {
        "name": "TestMkdirAllAtSlash",
        "desc": ""
      },
      {
        "name": "TestMkdirAllExtendedLength",
        "desc": ""
      },
      {
        "name": "TestMkdirAllExtendedLengthAtRoot",
        "desc": ""
      },
      {
        "name": "TestMkdirAllLongPath",
        "desc": ""
      },
      {
        "name": "TestMkdirAllVolumeNameAtRoot",
        "desc": ""
      },
      {
        "name": "TestMkdirAllWithSymlink",
        "desc": ""
      },
      {
        "name": "TestMkdirStickyUmask",
        "desc": "Issue 23120: respect umask when doing Mkdir with the sticky bit"
      },
      {
        "name": "TestMkdirTemp",
        "desc": ""
      },
      {
        "name": "TestMkdirTempBadDir",
        "desc": "test that we return a nice error message if the dir argument to TempDir doesn't exist (or that it's empty and TempDir doesn't exist)"
      },
      {
        "name": "TestMkdirTempBadPattern",
        "desc": ""
      },
      {
        "name": "TestNamedPipe",
        "desc": ""
      },
      {
        "name": "TestNetworkSymbolicLink",
        "desc": ""
      },
      {
        "name": "TestNewFileBlock",
        "desc": ""
      },
      {
        "name": "TestNewFileInvalid",
        "desc": ""
      },
      {
        "name": "TestNewFileNonBlock",
        "desc": ""
      },
      {
        "name": "TestNewFileNonBlocking",
        "desc": ""
      },
      {
        "name": "TestNilFileMethods",
        "desc": "Test that all File methods give ErrInvalid if the receiver is nil."
      },
      {
        "name": "TestNilProcessStateString",
        "desc": ""
      },
      {
        "name": "TestNonPollable",
        "desc": "Issue #59545."
      },
      {
        "name": "TestNonpollableDeadline",
        "desc": ""
      },
      {
        "name": "TestOneDrive",
        "desc": "TestOneDrive verifies that OneDrive folder is a directory and not a symlink."
      },
      {
        "name": "TestOpenDirTOCTOU",
        "desc": ""
      },
      {
        "name": "TestOpenError",
        "desc": ""
      },
      {
        "name": "TestOpenFileCreateExclDanglingSymlink",
        "desc": ""
      },
      {
        "name": "TestOpenFileDevNull",
        "desc": ""
      },
      {
        "name": "TestOpenFileKeepsPermissions",
        "desc": "Test that opening a file does not change its permissions.  Issue 38225."
      },
      {
        "name": "TestOpenFileNonBlocking",
        "desc": "Issue 60211."
      },
      {
        "name": "TestOpenInRoot",
        "desc": ""
      },
      {
        "name": "TestOpenNoName",
        "desc": ""
      },
      {
        "name": "TestOpenRootSlash",
        "desc": ""
      },
      {
        "name": "TestOpenVolumeName",
        "desc": ""
      },
      {
        "name": "TestPathErrorUnwrap",
        "desc": ""
      },
      {
        "name": "TestPidfdLeak",
        "desc": "Issue #69284"
      },
      {
        "name": "TestPipe",
        "desc": ""
      },
      {
        "name": "TestPipeCanceled",
        "desc": ""
      },
      {
        "name": "TestPipeCloseRace",
        "desc": "Test that it's OK to call Close concurrently on a pipe."
      },
      {
        "name": "TestPipeClosedEOF",
        "desc": ""
      },
      {
        "name": "TestPipeEOF",
        "desc": ""
      },
      {
        "name": "TestPipeIOCloseRace",
        "desc": "Test that it's OK to have parallel I/O and Close on a pipe."
      },
      {
        "name": "TestPipeMessageReadEOF",
        "desc": ""
      },
      {
        "name": "TestPipeReadTimeout",
        "desc": ""
      },
      {
        "name": "TestPipeThreads",
        "desc": "Test that reading from a pipe doesn't use up a thread."
      },
      {
        "name": "TestProcCopy",
        "desc": "On some kernels copy_file_range fails on files in /proc."
      },
      {
        "name": "TestProcessAlreadyDone",
        "desc": "Lookup of a process that does not exist at time of lookup."
      },
      {
        "name": "TestProcessBadPID",
        "desc": ""
      },
      {
        "name": "TestProcessLiteral",
        "desc": ""
      },
      {
        "name": "TestProcessReleaseTwice",
        "desc": ""
      },
      {
        "name": "TestProgWideChdir",
        "desc": "Test that Chdir+Getwd is program-wide."
      },
      {
        "name": "TestRacyRead",
        "desc": "TestRacyRead tests that it is safe to mutate the input Read buffer immediately after cancellation has occurred."
      },
      {
        "name": "TestRacyWrite",
        "desc": "TestRacyWrite tests that it is safe to mutate the input Write buffer immediately after cancellation has occurred."
      },
      {
        "name": "TestRandomLen",
        "desc": ""
      },
      {
        "name": "TestRawConnReadWrite",
        "desc": ""
      },
      {
        "name": "TestRead0",
        "desc": "Read with length 0 should not return EOF."
      },
      {
        "name": "TestReadAt",
        "desc": ""
      },
      {
        "name": "TestReadAtEOF",
        "desc": ""
      },
      {
        "name": "TestReadAtNegativeOffset",
        "desc": "Verify that ReadAt doesn't allow negative offset."
      },
      {
        "name": "TestReadAtOffset",
        "desc": "Verify that ReadAt doesn't affect seek offset. In the Plan 9 kernel, there used to be a bug in the implementation of the pread syscall, where the channel offset was erroneously updated after calling pread on a file."
      },
      {
        "name": "TestReadClosed",
        "desc": "Reading a closed file should return ErrClosed error"
      },
      {
        "name": "TestReadDir",
        "desc": ""
      },
      {
        "name": "TestReadDirNoFileID",
        "desc": ""
      },
      {
        "name": "TestReadDirPipe",
        "desc": ""
      },
      {
        "name": "TestReadFile",
        "desc": ""
      },
      {
        "name": "TestReadFileContents",
        "desc": ""
      },
      {
        "name": "TestReadFileProc",
        "desc": ""
      },
      {
        "name": "TestReadNonblockingFd",
        "desc": "Issue 20915: Reading on nonblocking fd should not return \"waiting for unsupported file type.\" Currently it returns EAGAIN; it is possible that in the future it will simply wait for data."
      },
      {
        "name": "TestReadOnlyWriteFile",
        "desc": ""
      },
      {
        "name": "TestReadStdin",
        "desc": ""
      },
      {
        "name": "TestReadTimeout",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestReadTimeoutFluctuation",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestReadTimeoutMustNotReturn",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestReadWriteDeadlineRace",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestReadWriteFileOverlapped",
        "desc": ""
      },
      {
        "name": "TestReaddirNValues",
        "desc": ""
      },
      {
        "name": "TestReaddirOfFile",
        "desc": "Readdir on a regular file should fail."
      },
      {
        "name": "TestReaddirRemoveRace",
        "desc": "Issue 16919: Readdir must return a non-empty slice or an error."
      },
      {
        "name": "TestReaddirSmallSeek",
        "desc": ""
      },
      {
        "name": "TestReaddirStatFailures",
        "desc": ""
      },
      {
        "name": "TestReaddirnamesOneAtATime",
        "desc": "Check that reading a directory one entry at a time gives the same result as reading it all at once."
      },
      {
        "name": "TestReadlink",
        "desc": ""
      },
      {
        "name": "TestRemoveAll",
        "desc": ""
      },
      {
        "name": "TestRemoveAllButReadOnlyAndPathError",
        "desc": "Issue #29983."
      },
      {
        "name": "TestRemoveAllDot",
        "desc": ""
      },
      {
        "name": "TestRemoveAllDotDot",
        "desc": ""
      },
      {
        "name": "TestRemoveAllLarge",
        "desc": "Test RemoveAll on a large directory."
      },
      {
        "name": "TestRemoveAllLongPath",
        "desc": ""
      },
      {
        "name": "TestRemoveAllLongPathRelative",
        "desc": ""
      },
      {
        "name": "TestRemoveAllNoFcntl",
        "desc": ""
      },
      {
        "name": "TestRemoveAllRace",
        "desc": "Test that simultaneous RemoveAll do not report an error. As long as it gets removed, we should be happy."
      },
      {
        "name": "TestRemoveAllTrailingSlash",
        "desc": ""
      },
      {
        "name": "TestRemoveAllWithExecutedProcess",
        "desc": ""
      },
      {
        "name": "TestRemoveAllWithMoreErrorThanReqSize",
        "desc": "Issue 29921"
      },
      {
        "name": "TestRemoveReadOnlyDir",
        "desc": "Issue #29178."
      },
      {
        "name": "TestRemoveReadOnlyFile",
        "desc": ""
      },
      {
        "name": "TestRemoveUnreadableDir",
        "desc": ""
      },
      {
        "name": "TestRename",
        "desc": ""
      },
      {
        "name": "TestRenameCaseDifference",
        "desc": ""
      },
      {
        "name": "TestRenameFailed",
        "desc": ""
      },
      {
        "name": "TestRenameNotExisting",
        "desc": ""
      },
      {
        "name": "TestRenameOverwriteDest",
        "desc": ""
      },
      {
        "name": "TestRenameToDirFailed",
        "desc": ""
      },
      {
        "name": "TestRootChmod",
        "desc": ""
      },
      {
        "name": "TestRootChown",
        "desc": ""
      },
      {
        "name": "TestRootChtimes",
        "desc": ""
      },
      {
        "name": "TestRootConcurrentClose",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyChmod",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyChown",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyCreate",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyLchown",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyLink",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyLstat",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyMkdir",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyMkdirAll",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyOpen",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyReadlink",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyRemove",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyRemoveAll",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyRename",
        "desc": ""
      },
      {
        "name": "TestRootConsistencyStat",
        "desc": ""
      },
      {
        "name": "TestRootConsistencySymlink",
        "desc": ""
      },
      {
        "name": "TestRootCreate",
        "desc": ""
      },
      {
        "name": "TestRootDirAsTemp",
        "desc": ""
      },
      {
        "name": "TestRootDirFS",
        "desc": ""
      },
      {
        "name": "TestRootLchown",
        "desc": ""
      },
      {
        "name": "TestRootLinkFrom",
        "desc": "TestRootRenameFrom tests linking the test case target to a known-good path."
      },
      {
        "name": "TestRootLinkTo",
        "desc": "TestRootLinkTo tests renaming a known-good path to the test case target."
      },
      {
        "name": "TestRootLstat",
        "desc": ""
      },
      {
        "name": "TestRootMkdir",
        "desc": ""
      },
      {
        "name": "TestRootMkdirAll",
        "desc": ""
      },
      {
        "name": "TestRootName",
        "desc": ""
      },
      {
        "name": "TestRootNonPermissionMode",
        "desc": ""
      },
      {
        "name": "TestRootOpenFileAsRoot",
        "desc": ""
      },
      {
        "name": "TestRootOpenRoot",
        "desc": ""
      },
      {
        "name": "TestRootOpen_Directory",
        "desc": ""
      },
      {
        "name": "TestRootOpen_File",
        "desc": ""
      },
      {
        "name": "TestRootRaceRenameDir",
        "desc": "TestRootRaceRenameDir attempts to escape a Root by renaming a path component mid-parse.  We create a deeply nested directory:  \tbase/a/a/a/a/ [...] /a  And a path that descends into the tree, then returns to the top using ..:  \tbase/a/a/a/a/ [...] /a/../../../ [..] /../a/f  While opening this file, we rename base/a/a to base/b. A naive lookup operation will resolve the path to base/f."
      },
      {
        "name": "TestRootReadlink",
        "desc": ""
      },
      {
        "name": "TestRootRelativeDirSymlink",
        "desc": "TestRootRelativeDirSymlink verifies that symlinks to paths relative to the drive root (beginning with \"\\\" but no volume name) are created with the correct symlink type. (See https://golang.org/issue/39183#issuecomment-632175728.)"
      },
      {
        "name": "TestRootRemoveAll",
        "desc": ""
      },
      {
        "name": "TestRootRemoveDirectory",
        "desc": ""
      },
      {
        "name": "TestRootRemoveDot",
        "desc": ""
      },
      {
        "name": "TestRootRemoveFile",
        "desc": ""
      },
      {
        "name": "TestRootRenameAfterOpen",
        "desc": ""
      },
      {
        "name": "TestRootRenameFrom",
        "desc": "TestRootRenameFrom tests renaming the test case target to a known-good path."
      },
      {
        "name": "TestRootRenameTo",
        "desc": "TestRootRenameTo tests renaming a known-good path to the test case target."
      },
      {
        "name": "TestRootStat",
        "desc": ""
      },
      {
        "name": "TestRootSymlink",
        "desc": ""
      },
      {
        "name": "TestRootSymlinkRelativity",
        "desc": "TestRootSymlinkRelativity tests that symlinks created using Root.Symlink have the same SYMLINK_FLAG_RELATIVE value as ones creates using os.Symlink."
      },
      {
        "name": "TestRootSymlinkToDirectory",
        "desc": "TestRootSymlinkToDirectory tests that Root.Symlink creates directory links when the target is a directory contained within the root."
      },
      {
        "name": "TestRootSymlinkToRoot",
        "desc": ""
      },
      {
        "name": "TestRootUseAfterClose",
        "desc": ""
      },
      {
        "name": "TestRootWindowsCaseInsensitivity",
        "desc": "Verify that Root.Open is case-insensitive. (The wrong options to NtOpenFile could make operations case-sensitive, so this is worth checking.)"
      },
      {
        "name": "TestRootWindowsDeviceNames",
        "desc": "Verify that Root.Open rejects Windows reserved names."
      },
      {
        "name": "TestRootWriteReadFile",
        "desc": ""
      },
      {
        "name": "TestSameFile",
        "desc": ""
      },
      {
        "name": "TestSameWindowsFile",
        "desc": ""
      },
      {
        "name": "TestSeek",
        "desc": ""
      },
      {
        "name": "TestSeekError",
        "desc": ""
      },
      {
        "name": "TestSendFile",
        "desc": ""
      },
      {
        "name": "TestSetenvUnixEinval",
        "desc": ""
      },
      {
        "name": "TestShareNotExistError",
        "desc": ""
      },
      {
        "name": "TestSpliceFile",
        "desc": ""
      },
      {
        "name": "TestSplitPath",
        "desc": ""
      },
      {
        "name": "TestStartProcess",
        "desc": ""
      },
      {
        "name": "TestStartProcessAttr",
        "desc": ""
      },
      {
        "name": "TestStartProcessWithPidfd",
        "desc": ""
      },
      {
        "name": "TestStat",
        "desc": ""
      },
      {
        "name": "TestStatConsole",
        "desc": ""
      },
      {
        "name": "TestStatDir",
        "desc": ""
      },
      {
        "name": "TestStatDirModeExec",
        "desc": ""
      },
      {
        "name": "TestStatDirWithTrailingSlash",
        "desc": ""
      },
      {
        "name": "TestStatError",
        "desc": ""
      },
      {
        "name": "TestStatLxSymLink",
        "desc": ""
      },
      {
        "name": "TestStatNUL",
        "desc": ""
      },
      {
        "name": "TestStatNotExist",
        "desc": ""
      },
      {
        "name": "TestStatOfInvalidName",
        "desc": "TestStatOfInvalidName is regression test for issue #24999."
      },
      {
        "name": "TestStatPagefile",
        "desc": ""
      },
      {
        "name": "TestStatRelativeSymlink",
        "desc": ""
      },
      {
        "name": "TestStatStdin",
        "desc": ""
      },
      {
        "name": "TestStatSymlinkLoop",
        "desc": ""
      },
      {
        "name": "TestStdPipe",
        "desc": ""
      },
      {
        "name": "TestStdinOverlappedPipe",
        "desc": ""
      },
      {
        "name": "TestSymlink",
        "desc": ""
      },
      {
        "name": "TestSymlinkCreation",
        "desc": "TestSymlinkCreation verifies that creating a symbolic link works on Windows when developer mode is active. This is supported starting Windows 10 (1703, v10.0.14972)."
      },
      {
        "name": "TestSymlinkWithTrailingSlash",
        "desc": "see issue 27225 for details"
      },
      {
        "name": "TestTTYClose",
        "desc": "Closing a TTY while reading from it should not hang.  Issue 23943."
      },
      {
        "name": "TestTruncate",
        "desc": ""
      },
      {
        "name": "TestTruncateNonexistentFile",
        "desc": ""
      },
      {
        "name": "TestUNIXProcessAlive",
        "desc": ""
      },
      {
        "name": "TestUTF16Alloc",
        "desc": ""
      },
      {
        "name": "TestUnsetenv",
        "desc": ""
      },
      {
        "name": "TestUserCacheDir",
        "desc": ""
      },
      {
        "name": "TestUserCacheDirXDGConfigDirEnvVar",
        "desc": ""
      },
      {
        "name": "TestUserConfigDir",
        "desc": ""
      },
      {
        "name": "TestUserConfigDirXDGConfigDirEnvVar",
        "desc": ""
      },
      {
        "name": "TestUserHomeDir",
        "desc": ""
      },
      {
        "name": "TestVariousDeadlines",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestVariousDeadlines1Proc",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestVariousDeadlines4Proc",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestWindowsDevNullFile",
        "desc": ""
      },
      {
        "name": "TestWorkingDirectoryRelativeSymlink",
        "desc": "TestWorkingDirectoryRelativeSymlink verifies that symlinks to paths relative to the current working directory for the drive, such as \"C:File.txt\", are correctly converted to absolute links of the correct symlink type (per https://docs.microsoft.com/en-us/windows/win32/fileio/creating-symbolic-links)."
      },
      {
        "name": "TestWriteAt",
        "desc": ""
      },
      {
        "name": "TestWriteAtConcurrent",
        "desc": ""
      },
      {
        "name": "TestWriteAtInAppendMode",
        "desc": "Verify that WriteAt doesn't work in append mode."
      },
      {
        "name": "TestWriteAtNegativeOffset",
        "desc": "Verify that WriteAt doesn't allow negative offset."
      },
      {
        "name": "TestWriteFile",
        "desc": ""
      },
      {
        "name": "TestWriteStringAlloc",
        "desc": ""
      },
      {
        "name": "TestWriteTimeout",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestWriteTimeoutFluctuation",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "TestWriteTimeoutMustNotReturn",
        "desc": "There is a very similar copy of this in net/timeout_test.go."
      },
      {
        "name": "benchmarkLstat",
        "desc": ""
      },
      {
        "name": "benchmarkReadDir",
        "desc": ""
      },
      {
        "name": "benchmarkReaddir",
        "desc": ""
      },
      {
        "name": "benchmarkReaddirname",
        "desc": ""
      },
      {
        "name": "benchmarkStat",
        "desc": ""
      },
      {
        "name": "checkErrorPredicate",
        "desc": ""
      },
      {
        "name": "checkMode",
        "desc": ""
      },
      {
        "name": "checkNamedSize",
        "desc": ""
      },
      {
        "name": "checkSize",
        "desc": ""
      },
      {
        "name": "checkUidGid",
        "desc": ""
      },
      {
        "name": "compareCommandLineToArgvWithSyscall",
        "desc": "compareCommandLineToArgvWithSyscall ensures that os.CommandLineToArgv(cmd) and syscall.CommandLineToArgv(cmd) return the same result."
      },
      {
        "name": "compareReaders",
        "desc": ""
      },
      {
        "name": "createDirLink",
        "desc": ""
      },
      {
        "name": "createMountPoint",
        "desc": ""
      },
      {
        "name": "createSocketPair",
        "desc": ""
      },
      {
        "name": "createSymbolicLink",
        "desc": ""
      },
      {
        "name": "createTempFile",
        "desc": ""
      },
      {
        "name": "enableCurrentThreadPrivilege",
        "desc": ""
      },
      {
        "name": "equal",
        "desc": ""
      },
      {
        "name": "errEndsTest",
        "desc": "errEndsTest checks the error result of a test, verifying that it succeeded or failed as expected.  It returns true if the test is done due to encountering an expected error. false if the test should continue."
      },
      {
        "name": "findOneDriveDir",
        "desc": ""
      },
      {
        "name": "findUnusedDriveLetter",
        "desc": "findUnusedDriveLetter searches mounted drive list on the system (starting from Z: and ending at D:) for unused drive letter. It returns path to the found drive root directory (like Z:\\) or error."
      },
      {
        "name": "forceMFTUpdateOnWindows",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "iocpAssociateFile",
        "desc": ""
      },
      {
        "name": "isDeadlineExceeded",
        "desc": "isDeadlineExceeded reports whether err is or wraps ErrDeadlineExceeded. We also check that the error has a Timeout method that returns true."
      },
      {
        "name": "makefs",
        "desc": "makefs creates a test filesystem layout and returns the path to its root.  Each entry in the slice is a file, directory, or symbolic link to create:    - \"d/\": directory d   - \"f\": file f with contents f   - \"a =\u003e b\": symlink a with target b  The directory containing the filesystem is always named ROOT. $ABS is replaced with the absolute path of the directory containing the filesystem.  Parent directories are automatically created as needed.  makefs calls t.Skip if the layout contains features not supported by the current GOOS."
      },
      {
        "name": "mkdirTree",
        "desc": ""
      },
      {
        "name": "mustContainData",
        "desc": "mustContainData ensures that the specified file contains exactly the specified data."
      },
      {
        "name": "mustHaveWorkstation",
        "desc": ""
      },
      {
        "name": "mustSeekStart",
        "desc": ""
      },
      {
        "name": "newBytePipe",
        "desc": ""
      },
      {
        "name": "newCopyFileRangeTest",
        "desc": "newCopyFileRangeTest initializes a new test for copy_file_range.  It hooks package os' call to poll.CopyFileRange and returns the hook, so it can be inspected."
      },
      {
        "name": "newCopyFileTest",
        "desc": "newCopyFileTest initializes a new test for copying data between files. It creates source and destination files, and populates the source file with random data of the specified size, then rewind it, so it can be consumed by copy_file_range(2) or sendfile(2)."
      },
      {
        "name": "newFile",
        "desc": ""
      },
      {
        "name": "newFileOverlapped",
        "desc": ""
      },
      {
        "name": "newFileTest",
        "desc": "See also issues: 22939, 24331"
      },
      {
        "name": "newMessagePipe",
        "desc": ""
      },
      {
        "name": "newPipe",
        "desc": ""
      },
      {
        "name": "newSendFileTest",
        "desc": "newSendFileTest initializes a new test for sendfile.  It creates source file and destination sockets, and populates the source file with random data of the specified size. It also hooks package os' call to poll.Sendfile and returns the hook so it can be inspected."
      },
      {
        "name": "newSendfileTest",
        "desc": "newSendFileTest initializes a new test for sendfile over copy_file_range. It hooks package os' call to poll.SendFile and returns the hook, so it can be inspected."
      },
      {
        "name": "newSpliceFileTest",
        "desc": "newSpliceFileTest initializes a new test for splice.  It creates source sockets and destination file, and populates the source sockets with random data of the specified size. It also hooks package os' call to poll.Splice and returns the hook so it can be inspected."
      },
      {
        "name": "nextTimeout",
        "desc": "nextTimeout returns the next timeout to try after an operation took the given actual duration with a timeout shorter than that duration."
      },
      {
        "name": "pipeName",
        "desc": ""
      },
      {
        "name": "readSymlinkReparseData",
        "desc": ""
      },
      {
        "name": "replaceDriveWithVolumeID",
        "desc": "replaceDriveWithVolumeID returns path with its volume name replaced with the mounted volume ID. E.g. C:\\foo -\u003e \\\\?\\Volume{GUID}\\foo."
      },
      {
        "name": "runBinHostname",
        "desc": ""
      },
      {
        "name": "sameFile",
        "desc": ""
      },
      {
        "name": "size",
        "desc": ""
      },
      {
        "name": "smallReaddirnames",
        "desc": "Read the directory one entry at a time."
      },
      {
        "name": "syscallCommandLineToArgv",
        "desc": "syscallCommandLineToArgv calls syscall.CommandLineToArgv and converts returned result into []string."
      },
      {
        "name": "tempDirWithUnixSocket",
        "desc": ""
      },
      {
        "name": "testChtimes",
        "desc": ""
      },
      {
        "name": "testChtimesOmit",
        "desc": ""
      },
      {
        "name": "testCloseWithBlockingRead",
        "desc": "Test that we don't let a blocking read prevent a close."
      },
      {
        "name": "testClosedPipeRace",
        "desc": ""
      },
      {
        "name": "testCopyFile",
        "desc": ""
      },
      {
        "name": "testCopyFileRange",
        "desc": ""
      },
      {
        "name": "testCopyFiles",
        "desc": ""
      },
      {
        "name": "testDevNullFile",
        "desc": ""
      },
      {
        "name": "testDevNullFileInfo",
        "desc": ""
      },
      {
        "name": "testDirFS",
        "desc": ""
      },
      {
        "name": "testDirLinks",
        "desc": ""
      },
      {
        "name": "testDirStats",
        "desc": ""
      },
      {
        "name": "testDoubleCloseError",
        "desc": ""
      },
      {
        "name": "testErrNotExist",
        "desc": ""
      },
      {
        "name": "testFileReadEOF",
        "desc": ""
      },
      {
        "name": "testFileStats",
        "desc": ""
      },
      {
        "name": "testGetPollFDAndNetwork",
        "desc": ""
      },
      {
        "name": "testGetenv",
        "desc": "testGetenv gives us a controlled set of variables for testing Expand."
      },
      {
        "name": "testGetwdDeep",
        "desc": "testGetwdDeep checks that os.Getwd is able to return paths longer than syscall.PathMax (with or without PWD set)."
      },
      {
        "name": "testHardLink",
        "desc": ""
      },
      {
        "name": "testIsDir",
        "desc": "testIsDir verifies that fi refers to directory."
      },
      {
        "name": "testIsFile",
        "desc": "testIsFile verifies that fi refers to file."
      },
      {
        "name": "testIsSymlink",
        "desc": "testIsSymlink verifies that fi refers to symlink."
      },
      {
        "name": "testKillProcess",
        "desc": ""
      },
      {
        "name": "testLongPathAbs",
        "desc": ""
      },
      {
        "name": "testMaybeRooted",
        "desc": "testMaybeRooted calls f in two subtests, one with a Root and one with a nil r."
      },
      {
        "name": "testMkdirAllAtRoot",
        "desc": ""
      },
      {
        "name": "testOpenError",
        "desc": ""
      },
      {
        "name": "testOpenFileKeepsPermissions",
        "desc": ""
      },
      {
        "name": "testPipeEOF",
        "desc": "testPipeEOF tests that when the write side of a pipe or FIFO is closed, a blocked Read call on the reader side returns io.EOF.  This scenario previously failed to unblock the Read call on darwin. (See https://go.dev/issue/24164.)"
      },
      {
        "name": "testPreadPwrite",
        "desc": ""
      },
      {
        "name": "testReadDir",
        "desc": ""
      },
      {
        "name": "testReadWrite",
        "desc": ""
      },
      {
        "name": "testReaddir",
        "desc": ""
      },
      {
        "name": "testReaddirnames",
        "desc": ""
      },
      {
        "name": "testRootConsistencyMove",
        "desc": ""
      },
      {
        "name": "testRootMoveFrom",
        "desc": ""
      },
      {
        "name": "testRootMoveTo",
        "desc": ""
      },
      {
        "name": "testSendFile",
        "desc": ""
      },
      {
        "name": "testSendfile",
        "desc": ""
      },
      {
        "name": "testSpliceFile",
        "desc": ""
      },
      {
        "name": "testSpliceToTTY",
        "desc": "Issue #59041."
      },
      {
        "name": "testStartProcess",
        "desc": ""
      },
      {
        "name": "testStatAndLstat",
        "desc": "testStatAndLstat verifies that all os.Stat, os.Lstat os.File.Stat and os.Readdir work."
      },
      {
        "name": "testSymlink",
        "desc": ""
      },
      {
        "name": "testSymlinkSameFile",
        "desc": ""
      },
      {
        "name": "testSymlinkSameFileOpen",
        "desc": ""
      },
      {
        "name": "testSymlinkStats",
        "desc": ""
      },
      {
        "name": "testVariousDeadlines",
        "desc": ""
      },
      {
        "name": "testWindowsHostname",
        "desc": ""
      },
      {
        "name": "timeoutUpperBound",
        "desc": "timeoutUpperBound returns the maximum time that we expect a timeout of duration d to take to return the caller."
      },
      {
        "name": "touch",
        "desc": ""
      },
      {
        "name": "verifyCopyFS",
        "desc": "verifyCopyFS checks the content and permission of each file inside copied FS to ensure the copied files satisfy the convention stipulated in CopyFS."
      },
      {
        "name": "writeFile",
        "desc": ""
      },
      {
        "name": "Is",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "addPrintName",
        "desc": ""
      },
      {
        "name": "addPrintNameNoNUL",
        "desc": ""
      },
      {
        "name": "addString",
        "desc": ""
      },
      {
        "name": "addStringNoNUL",
        "desc": ""
      },
      {
        "name": "addSubstituteName",
        "desc": ""
      },
      {
        "name": "addSubstituteNameNoNUL",
        "desc": ""
      },
      {
        "name": "addUTF16s",
        "desc": ""
      },
      {
        "name": "pathBuffeLen",
        "desc": "pathBuffeLen returns length of rd pathBuf in bytes."
      },
      {
        "name": "run",
        "desc": ""
      },
      {
        "name": "run",
        "desc": "run sets up the test filesystem layout, os.OpenDirs the root, and calls f."
      },
      {
        "name": "install",
        "desc": ""
      },
      {
        "name": "uninstall",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "_REPARSE_DATA_BUFFER",
        "desc": "Windows REPARSE_DATA_BUFFER contains union member, and cannot be translated into Go directly. _REPARSE_DATA_BUFFER type is to help construct alternative versions of Windows REPARSE_DATA_BUFFER with union part of SymbolicLinkReparseBuffer or MountPointReparseBuffer type."
      },
      {
        "name": "copyFileHook",
        "desc": ""
      },
      {
        "name": "copyFileTestFunc",
        "desc": ""
      },
      {
        "name": "copyFileTestHook",
        "desc": ""
      },
      {
        "name": "dirLinkTest",
        "desc": ""
      },
      {
        "name": "isExistTest",
        "desc": ""
      },
      {
        "name": "isPermissionTest",
        "desc": ""
      },
      {
        "name": "myErrorIs",
        "desc": ""
      },
      {
        "name": "namePosition",
        "desc": ""
      },
      {
        "name": "neverEnding",
        "desc": ""
      },
      {
        "name": "pipeDeadlineTest",
        "desc": ""
      },
      {
        "name": "randReader",
        "desc": ""
      },
      {
        "name": "reparseData",
        "desc": "reparseData is used to build reparse buffer data required for tests."
      },
      {
        "name": "rootConsistencyTest",
        "desc": "A rootConsistencyTest is a test case comparing os.Root behavior with the corresponding non-Root function.  These tests verify that, for example, Root.Open(\"file/./\") and os.Open(\"file/./\") have the same result, although the specific result may vary by platform."
      },
      {
        "name": "rootTest",
        "desc": "A rootTest is a test case for os.Root."
      },
      {
        "name": "sendFileHook",
        "desc": ""
      },
      {
        "name": "spliceFileHook",
        "desc": ""
      },
      {
        "name": "sysDir",
        "desc": ""
      },
      {
        "name": "syscallDescriptor",
        "desc": "For TestRawConnReadWrite."
      },
      {
        "name": "testStatAndLstatParams",
        "desc": ""
      },
      {
        "name": "zeroReader",
        "desc": ""
      }
    ]
  },
  {
    "name": "os/exec",
    "desc": "",
    "functions": [
      {
        "name": "ExampleCmd_CombinedOutput",
        "desc": ""
      },
      {
        "name": "ExampleCmd_Environ",
        "desc": ""
      },
      {
        "name": "ExampleCmd_Output",
        "desc": ""
      },
      {
        "name": "ExampleCmd_Run",
        "desc": ""
      },
      {
        "name": "ExampleCmd_Start",
        "desc": ""
      },
      {
        "name": "ExampleCmd_StderrPipe",
        "desc": ""
      },
      {
        "name": "ExampleCmd_StdinPipe",
        "desc": ""
      },
      {
        "name": "ExampleCmd_StdoutPipe",
        "desc": ""
      },
      {
        "name": "ExampleCommand",
        "desc": ""
      },
      {
        "name": "ExampleCommandContext",
        "desc": ""
      },
      {
        "name": "ExampleCommand_environment",
        "desc": ""
      },
      {
        "name": "ExampleLookPath",
        "desc": ""
      },
      {
        "name": "TestAbsCommandWithDoubledExtension",
        "desc": ""
      },
      {
        "name": "TestAbsPathExec",
        "desc": ""
      },
      {
        "name": "TestCancelErrors",
        "desc": ""
      },
      {
        "name": "TestCatGoodAndBadFile",
        "desc": ""
      },
      {
        "name": "TestCatStdin",
        "desc": ""
      },
      {
        "name": "TestChildCriticalEnv",
        "desc": "start a child process without the user code explicitly starting with a copy of the parent's SYSTEMROOT. (See issue 25210.)"
      },
      {
        "name": "TestClosePipeOnCopyError",
        "desc": ""
      },
      {
        "name": "TestCommand",
        "desc": ""
      },
      {
        "name": "TestCommandRelativeName",
        "desc": ""
      },
      {
        "name": "TestConcurrentExec",
        "desc": "TestConcurrentExec is a regression test for https://go.dev/issue/61080.  Forking multiple child processes concurrently would sometimes hang on darwin. (This test hung on a gomote with -count=100 after only a few iterations.)"
      },
      {
        "name": "TestContext",
        "desc": ""
      },
      {
        "name": "TestContextCancel",
        "desc": ""
      },
      {
        "name": "TestCredentialNoSetGroups",
        "desc": ""
      },
      {
        "name": "TestDedupEnvEcho",
        "desc": "test that environment variables are de-duped."
      },
      {
        "name": "TestDoubleStartLeavesPipesOpen",
        "desc": "TestDoubleStartLeavesPipesOpen checks for a regression in which calling Start twice, which returns an error on the second call, would spuriously close the pipes established in the first call."
      },
      {
        "name": "TestEcho",
        "desc": ""
      },
      {
        "name": "TestEchoFileRace",
        "desc": ""
      },
      {
        "name": "TestEnvNULCharacter",
        "desc": ""
      },
      {
        "name": "TestExitCode",
        "desc": ""
      },
      {
        "name": "TestExitStatus",
        "desc": ""
      },
      {
        "name": "TestExplicitPWD",
        "desc": "However, if cmd.Env is set explicitly, setting Dir should not override it. (This checks that the implementation for https://go.dev/issue/50599 doesn't break existing users who may have explicitly mismatched the PWD variable.)"
      },
      {
        "name": "TestExtraFiles",
        "desc": ""
      },
      {
        "name": "TestExtraFilesRace",
        "desc": ""
      },
      {
        "name": "TestFindExecutableVsNoexec",
        "desc": ""
      },
      {
        "name": "TestIgnorePipeErrorOnSuccess",
        "desc": "Issue 9173: ignore stdin pipe writes if the program completes successfully."
      },
      {
        "name": "TestImplicitPWD",
        "desc": "https://go.dev/issue/50599: if Env is not set explicitly, setting Dir should implicitly update PWD to the correct path, and Environ should list the updated value."
      },
      {
        "name": "TestLookPath",
        "desc": ""
      },
      {
        "name": "TestLookPathUnixEmptyPath",
        "desc": ""
      },
      {
        "name": "TestLookPathWindows",
        "desc": ""
      },
      {
        "name": "TestMain",
        "desc": "TestMain allows the test binary to impersonate many other binaries, some of which may manipulate os.Stdin, os.Stdout, and/or os.Stderr (and thus cannot run as an ordinary Test function, since the testing package monkey-patches those variables before running tests)."
      },
      {
        "name": "TestNoExistExecutable",
        "desc": ""
      },
      {
        "name": "TestNoInheritHandles",
        "desc": ""
      },
      {
        "name": "TestNoPath",
        "desc": ""
      },
      {
        "name": "TestOutputStderrCapture",
        "desc": ""
      },
      {
        "name": "TestPathRace",
        "desc": "TestPathRace tests that [Cmd.String] can be called concurrently with [Cmd.Start]."
      },
      {
        "name": "TestPipeLookPathLeak",
        "desc": "Issue 5071"
      },
      {
        "name": "TestPipePassing",
        "desc": ""
      },
      {
        "name": "TestPipes",
        "desc": ""
      },
      {
        "name": "TestSIGCHLD",
        "desc": "Issue 71828."
      },
      {
        "name": "TestStdinClose",
        "desc": "Issue 6270."
      },
      {
        "name": "TestStdinCloseRace",
        "desc": "Issue 17647. It used to be the case that TestStdinClose, above, would fail when run under the race detector. This test is a variant of TestStdinClose that also used to fail when run under the race detector. This test is run by cmd/dist under the race detector to verify that the race detector no longer reports any problems."
      },
      {
        "name": "TestString",
        "desc": ""
      },
      {
        "name": "TestStringPathNotResolved",
        "desc": ""
      },
      {
        "name": "TestWaitInterrupt",
        "desc": ""
      },
      {
        "name": "TestWaitid",
        "desc": "For issue #19314: make sure that SIGSTOP does not cause the process to appear done."
      },
      {
        "name": "cmdCat",
        "desc": ""
      },
      {
        "name": "cmdDescribeFiles",
        "desc": ""
      },
      {
        "name": "cmdEcho",
        "desc": ""
      },
      {
        "name": "cmdEchoEnv",
        "desc": ""
      },
      {
        "name": "cmdExit",
        "desc": ""
      },
      {
        "name": "cmdHang",
        "desc": ""
      },
      {
        "name": "cmdPipeHandle",
        "desc": ""
      },
      {
        "name": "cmdPipeTest",
        "desc": ""
      },
      {
        "name": "cmdPrintPath",
        "desc": ""
      },
      {
        "name": "cmdPwd",
        "desc": ""
      },
      {
        "name": "cmdSignalTest",
        "desc": "cmdSignaltest is for TestSIGCHLD. This runs in a separate process because the bug only happened the first time that a child process was started."
      },
      {
        "name": "cmdStderrFail",
        "desc": ""
      },
      {
        "name": "cmdStdinClose",
        "desc": ""
      },
      {
        "name": "cmdYes",
        "desc": ""
      },
      {
        "name": "helperCommand",
        "desc": "helperCommand returns an exec.Cmd that will run the named helper command."
      },
      {
        "name": "helperCommandContext",
        "desc": "helperCommandContext is like helperCommand, but also accepts a Context under which to run the command."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "installBat",
        "desc": "installBat creates a batch file at dst that prints its own path when run."
      },
      {
        "name": "installExe",
        "desc": "installExe installs a copy of the test executable at the given location, creating directories as needed.  (We use a copy instead of just a symlink to ensure that os.Executable always reports an unambiguous path, regardless of how it is implemented.)"
      },
      {
        "name": "installProgs",
        "desc": "installProgs creates executable files (or symlinks to executable files) at multiple destination paths. It uses root as prefix for all destination files."
      },
      {
        "name": "makePATH",
        "desc": "makePATH returns a PATH variable referring to the given directories relative to a root directory.  The empty string results in an empty entry. Paths beginning with . are kept as relative entries."
      },
      {
        "name": "maySkipHelperCommand",
        "desc": "maySkipHelperCommand records that the test that uses the named helper command was invoked, but may call Skip on the test before actually calling helperCommand."
      },
      {
        "name": "registerHelperCommand",
        "desc": "registerHelperCommand registers a command that the test process can impersonate. A command should be registered in the same source file in which it is used. If all tests are run and pass, all registered commands must be used. (This prevents stale commands from accreting if tests are removed or refactored over time.)"
      },
      {
        "name": "startHang",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "badWriter",
        "desc": ""
      },
      {
        "name": "commandTest",
        "desc": ""
      },
      {
        "name": "delayedInfiniteReader",
        "desc": ""
      },
      {
        "name": "lookPathTest",
        "desc": ""
      },
      {
        "name": "tickReader",
        "desc": "A tickReader reads an unbounded sequence of timestamps at no more than a fixed interval."
      }
    ]
  },
  {
    "name": "os/signal",
    "desc": "Package signal implements access to incoming signals.  Signals are primarily used on Unix-like systems. For the use of this package on Windows and Plan 9, see below.  # Types of signals  The signals SIGKILL and SIGSTOP may not be caught by a program, and therefore cannot be affected by this package.  Synchronous signals are signals triggered by errors in program execution: SIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused by program execution, not when sent using [os.Process.Kill] or the kill program or some similar mechanism. In general, except as discussed below, Go programs will convert a synchronous signal into a run-time panic.  The remaining signals are asynchronous signals. They are not triggered by program errors, but are instead sent from the kernel or from some other program.  Of the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\\.  # Default behavior of signals in Go programs  By default, a synchronous signal is converted into a run-time panic. A SIGHUP, SIGINT, or SIGTERM signal causes the program to exit. A SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit with a stack dump. A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default behavior (these signals are used by the shell for job control). The SIGPROF signal is handled directly by the Go runtime to implement runtime.CPUProfile. Other signals will be caught but no action will be taken.  If the Go program is started with either SIGHUP or SIGINT ignored (signal handler set to SIG_IGN), they will remain ignored.  If the Go program is started with a non-empty signal mask, that will generally be honored. However, some signals are explicitly unblocked: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on Linux, signals 32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally by glibc). Subprocesses started by [os.Exec], or by [os/exec], will inherit the modified signal mask.  # Changing the behavior of signals in Go programs  The functions in this package allow a program to change the way Go programs handle signals.  Notify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems.  If the program was started with SIGHUP or SIGINT ignored, and [Notify] is called for either signal, a signal handler will be installed for that signal and it will no longer be ignored. If, later, [Reset] or [Ignore] is called for that signal, or [Stop] is called on all channels passed to Notify for that signal, the signal will once again be ignored. Reset will restore the system default behavior for the signal, while Ignore will cause the system to ignore the signal entirely.  If the program is started with a non-empty signal mask, some signals will be explicitly unblocked as described above. If Notify is called for a blocked signal, it will be unblocked. If, later, Reset is called for that signal, or Stop is called on all channels passed to Notify for that signal, the signal will once again be blocked.  # SIGPIPE  When a Go program writes to a broken pipe, the kernel will raise a SIGPIPE signal.  If the program has not called Notify to receive SIGPIPE signals, then the behavior depends on the file descriptor number. A write to a broken pipe on file descriptors 1 or 2 (standard output or standard error) will cause the program to exit with a SIGPIPE signal. A write to a broken pipe on some other file descriptor will take no action on the SIGPIPE signal, and the write will fail with a [syscall.EPIPE] error.  If the program has called Notify to receive SIGPIPE signals, the file descriptor number does not matter. The SIGPIPE signal will be delivered to the Notify channel, and the write will fail with a [syscall.EPIPE] error.  This means that, by default, command line programs will behave like typical Unix command line programs, while other programs will not crash with SIGPIPE when writing to a closed network connection.  # Go programs that use cgo or SWIG  In a Go program that includes non-Go code, typically C/C++ code accessed using cgo or SWIG, Go's startup code normally runs first. It configures the signal handlers as expected by the Go runtime, before the non-Go startup code runs. If the non-Go startup code wishes to install its own signal handlers, it must take certain steps to keep Go working well. This section documents those steps and the overall effect changes to signal handler settings by the non-Go code can have on Go programs. In rare cases, the non-Go code may run before the Go code, in which case the next section also applies.  If the non-Go code called by the Go program does not change any signal handlers or masks, then the behavior is the same as for a pure Go program.  If the non-Go code installs any signal handlers, it must use the SA_ONSTACK flag with sigaction. Failing to do so is likely to cause the program to crash if the signal is received. Go programs routinely run with a limited stack, and therefore set up an alternate signal stack.  If the non-Go code installs a signal handler for any of the synchronous signals (SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler. If those signals occur while executing Go code, it should invoke the Go signal handler (whether the signal occurs while executing Go code can be determined by looking at the PC passed to the signal handler). Otherwise some Go run-time panics will not occur as expected.  If the non-Go code installs a signal handler for any of the asynchronous signals, it may invoke the Go signal handler or not as it chooses. Naturally, if it does not invoke the Go signal handler, the Go behavior described above will not occur. This can be an issue with the SIGPROF signal in particular.  The non-Go code should not change the signal mask on any threads created by the Go runtime. If the non-Go code starts new threads itself, those threads may set the signal mask as they please.  If the non-Go code starts a new thread, changes the signal mask, and then invokes a Go function in that thread, the Go runtime will automatically unblock certain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go signal mask will be restored.  If the Go signal handler is invoked on a non-Go thread not running Go code, the handler generally forwards the signal to the non-Go code, as follows. If the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler removes itself, unblocks the signal, and raises it again, to invoke any non-Go handler or default system handler. If the program does not exit, the Go handler then reinstalls itself and continues execution of the program.  If a SIGPIPE signal is received, the Go program will invoke the special handling described above if the SIGPIPE is received on a Go thread.  If the SIGPIPE is received on a non-Go thread the signal will be forwarded to the non-Go handler, if any; if there is none the default system handler will cause the program to terminate.  # Non-Go programs that call Go code  When Go code is built with options like -buildmode=c-shared, it will be run as part of an existing non-Go program. The non-Go code may have already installed signal handlers when the Go code starts (that may also happen in unusual cases when using cgo or SWIG; in that case, the discussion here applies).  For -buildmode=c-archive the Go runtime will initialize signals at global constructor time.  For -buildmode=c-shared the Go runtime will initialize signals when the shared library is loaded.  If the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID signals (which are used only on Linux), it will turn on the SA_ONSTACK flag and otherwise keep the signal handler.  For the synchronous signals and SIGPIPE, the Go runtime will install a signal handler. It will save any existing signal handler. If a synchronous signal arrives while executing non-Go code, the Go runtime will invoke the existing signal handler instead of the Go signal handler.  Go code built with -buildmode=c-archive or -buildmode=c-shared will not install any other signal handlers by default. If there is an existing signal handler, the Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal handler. If Notify is called for an asynchronous signal, a Go signal handler will be installed for that signal. If, later, Reset is called for that signal, the original handling for that signal will be reinstalled, restoring the non-Go signal handler if any.  Go code built without -buildmode=c-archive or -buildmode=c-shared will install a signal handler for the asynchronous signals listed above, and save any existing signal handler. If a signal is delivered to a non-Go thread, it will act as described above, except that if there is an existing non-Go signal handler, that handler will be installed before raising the signal.  # Windows  On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for [os.Interrupt], ^C or ^BREAK will cause [os.Interrupt] to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored.  Additionally, if Notify is called, and Windows sends CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT to the process, Notify will return syscall.SIGTERM. Unlike Control-C and Control-Break, Notify does not change process behavior when either CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT is received - the process will still get terminated unless it exits. But receiving syscall.SIGTERM will give the process an opportunity to clean up before termination.  # Plan 9  On Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note.",
    "functions": [
      {
        "name": "Ignore",
        "desc": "Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to [Notify] for the provided signals. If no signals are provided, all incoming signals will be ignored."
      },
      {
        "name": "Ignored",
        "desc": "Ignored reports whether sig is currently ignored."
      },
      {
        "name": "Notify",
        "desc": "Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.  Package signal will not block sending to c: the caller must ensure that c has sufficient buffer space to keep up with the expected signal rate. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.  It is allowed to call Notify multiple times with the same channel: each call expands the set of signals sent to that channel. The only way to remove signals from the set is to call [Stop].  It is allowed to call Notify multiple times with different channels and the same signals: each channel receives copies of incoming signals independently."
      },
      {
        "name": "NotifyContext",
        "desc": "NotifyContext returns a copy of the parent context that is marked done (its Done channel is closed) when one of the listed signals arrives, when the returned stop function is called, or when the parent context's Done channel is closed, whichever happens first.  The stop function unregisters the signal behavior, which, like [signal.Reset], may restore the default behavior for a given signal. For example, the default behavior of a Go program receiving [os.Interrupt] is to exit. Calling NotifyContext(parent, os.Interrupt) will change the behavior to cancel the returned context. Future interrupts received will not trigger the default (exit) behavior until the returned stop function is called.  The stop function releases resources associated with it, so code should call stop as soon as the operations running in this Context complete and signals no longer need to be diverted to the context."
      },
      {
        "name": "Reset",
        "desc": "Reset undoes the effect of any prior calls to [Notify] for the provided signals. If no signals are provided, all signal handlers will be reset."
      },
      {
        "name": "Stop",
        "desc": "Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to [Notify] using c. When Stop returns, it is guaranteed that c will receive no more signals."
      },
      {
        "name": "TestAllThreadsSyscallSignals",
        "desc": "This test validates that syscall.AllThreadsSyscall() can reliably reach all 'm' (threads) of the nocgo runtime even when one thread is blocked waiting to receive signals from the kernel. This monitors for a regression vs. the fix for #43149."
      },
      {
        "name": "TestAtomicStop",
        "desc": "Test race between stopping and receiving a signal (issue 14571)."
      },
      {
        "name": "TestCtrlBreak",
        "desc": ""
      },
      {
        "name": "TestDetectNohup",
        "desc": "Test that Ignored(SIGHUP) correctly detects whether it is being run under nohup."
      },
      {
        "name": "TestIgnore",
        "desc": "Test that Ignore cancels registration for listed signals on all channels."
      },
      {
        "name": "TestIgnored",
        "desc": "Test that Ignored correctly detects changes to the ignored status of a signal."
      },
      {
        "name": "TestNohup",
        "desc": "Test that when run under nohup, an uncaught SIGHUP does not kill the program."
      },
      {
        "name": "TestNotifyContextCancelParent",
        "desc": ""
      },
      {
        "name": "TestNotifyContextNotifications",
        "desc": ""
      },
      {
        "name": "TestNotifyContextPrematureCancelParent",
        "desc": ""
      },
      {
        "name": "TestNotifyContextSimultaneousStop",
        "desc": ""
      },
      {
        "name": "TestNotifyContextStop",
        "desc": ""
      },
      {
        "name": "TestNotifyContextStringer",
        "desc": ""
      },
      {
        "name": "TestReset",
        "desc": "Test that Reset cancels registration for listed signals on all channels."
      },
      {
        "name": "TestSIGCONT",
        "desc": "Test that SIGCONT works (issue 8953)."
      },
      {
        "name": "TestSignal",
        "desc": "Test that basic signal handling works."
      },
      {
        "name": "TestSignalTrace",
        "desc": "#44193 test signal handling while stopping and starting the world."
      },
      {
        "name": "TestStop",
        "desc": "Test that Stop cancels the channel's registrations."
      },
      {
        "name": "TestStress",
        "desc": ""
      },
      {
        "name": "TestTime",
        "desc": ""
      },
      {
        "name": "atomicStopTestProgram",
        "desc": "atomicStopTestProgram is run in a subprocess by TestAtomicStop. It tries to trigger a signal delivery race. This function should either catch a signal or die from it."
      },
      {
        "name": "cancel",
        "desc": "Stop relaying the signals, sigs, to any channels previously registered to receive them and either reset the signal handlers to their original values (action=disableSignal) or ignore the signals (action=ignoreSignal)."
      },
      {
        "name": "disableSignal",
        "desc": ""
      },
      {
        "name": "enableSignal",
        "desc": ""
      },
      {
        "name": "ignoreSignal",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "loop",
        "desc": ""
      },
      {
        "name": "postNote",
        "desc": ""
      },
      {
        "name": "process",
        "desc": ""
      },
      {
        "name": "quiesce",
        "desc": "quiesce waits until we can be reasonably confident that all pending signals have been delivered by the OS."
      },
      {
        "name": "sendCtrlBreak",
        "desc": ""
      },
      {
        "name": "signalIgnored",
        "desc": ""
      },
      {
        "name": "signalWaitUntilIdle",
        "desc": "Wait until there are no more signals waiting to be delivered. Defined by the runtime package."
      },
      {
        "name": "signal_disable",
        "desc": "Defined by the runtime package."
      },
      {
        "name": "signal_enable",
        "desc": ""
      },
      {
        "name": "signal_ignore",
        "desc": ""
      },
      {
        "name": "signal_ignored",
        "desc": ""
      },
      {
        "name": "signal_recv",
        "desc": ""
      },
      {
        "name": "signum",
        "desc": ""
      },
      {
        "name": "testCancel",
        "desc": ""
      },
      {
        "name": "waitSig",
        "desc": ""
      },
      {
        "name": "waitSig1",
        "desc": ""
      },
      {
        "name": "waitSigAll",
        "desc": ""
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "want",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "stop",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "handler",
        "desc": ""
      },
      {
        "name": "signalCtx",
        "desc": ""
      },
      {
        "name": "stopping",
        "desc": ""
      },
      {
        "name": "stringer",
        "desc": ""
      }
    ]
  },
  {
    "name": "os/user",
    "desc": "Package user allows user account lookups by name or id.  For most Unix systems, this package has two internal implementations of resolving user and group ids to names, and listing supplementary group IDs. One is written in pure Go and parses /etc/passwd and /etc/group. The other is cgo-based and relies on the standard C library (libc) routines such as getpwuid_r, getgrnam_r, and getgrouplist.  When cgo is available, and the required routines are implemented in libc for a particular platform, cgo-based (libc-backed) code is used. This can be overridden by using osusergo build tag, which enforces the pure Go implementation.",
    "functions": [
      {
        "name": "BenchmarkCurrent",
        "desc": ""
      },
      {
        "name": "TestCurrent",
        "desc": ""
      },
      {
        "name": "TestCurrentNetapi32",
        "desc": ""
      },
      {
        "name": "TestFindGroupId",
        "desc": ""
      },
      {
        "name": "TestFindGroupName",
        "desc": ""
      },
      {
        "name": "TestGroupIds",
        "desc": ""
      },
      {
        "name": "TestGroupIdsTestUser",
        "desc": ""
      },
      {
        "name": "TestImpersonated",
        "desc": ""
      },
      {
        "name": "TestImpersonatedSelf",
        "desc": ""
      },
      {
        "name": "TestInvalidUserId",
        "desc": ""
      },
      {
        "name": "TestListGroups",
        "desc": ""
      },
      {
        "name": "TestLookup",
        "desc": ""
      },
      {
        "name": "TestLookupGroup",
        "desc": ""
      },
      {
        "name": "TestLookupGroupIdServiceAccount",
        "desc": ""
      },
      {
        "name": "TestLookupGroupServiceAccount",
        "desc": ""
      },
      {
        "name": "TestLookupId",
        "desc": ""
      },
      {
        "name": "TestLookupIdServiceAccount",
        "desc": ""
      },
      {
        "name": "TestLookupServiceAccount",
        "desc": ""
      },
      {
        "name": "TestLookupUser",
        "desc": ""
      },
      {
        "name": "TestLookupUserId",
        "desc": ""
      },
      {
        "name": "TestLookupUserPopulatesAllFields",
        "desc": ""
      },
      {
        "name": "TestNegativeUid",
        "desc": "Issue 22739"
      },
      {
        "name": "_C_GoString",
        "desc": ""
      },
      {
        "name": "addUserAccount",
        "desc": "addUserAccount creates a local user account. It returns the name and password of the new account. Multiple programs or goroutines calling addUserAccount simultaneously will not choose the same directory."
      },
      {
        "name": "checkGroup",
        "desc": ""
      },
      {
        "name": "checkGroupList",
        "desc": ""
      },
      {
        "name": "checkSameIDs",
        "desc": ""
      },
      {
        "name": "checkUser",
        "desc": ""
      },
      {
        "name": "compare",
        "desc": ""
      },
      {
        "name": "currentGID",
        "desc": ""
      },
      {
        "name": "currentUID",
        "desc": ""
      },
      {
        "name": "findHomeDirInRegistry",
        "desc": "findHomeDirInRegistry finds the user home path based on the uid."
      },
      {
        "name": "getCurrentToken",
        "desc": "getCurrentToken returns the current thread token, or the process token if the thread doesn't have a token."
      },
      {
        "name": "getProfilesDirectory",
        "desc": "getProfilesDirectory retrieves the path to the root directory where user profiles are stored."
      },
      {
        "name": "groupRetry",
        "desc": "groupRetry retries getGroupList with much larger size for n. The result is stored in gids."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "isDomainJoined",
        "desc": ""
      },
      {
        "name": "isServiceAccount",
        "desc": ""
      },
      {
        "name": "isSizeReasonable",
        "desc": ""
      },
      {
        "name": "isValidGroupAccountType",
        "desc": ""
      },
      {
        "name": "isValidUserAccountType",
        "desc": ""
      },
      {
        "name": "largeGroup",
        "desc": ""
      },
      {
        "name": "listGroups",
        "desc": ""
      },
      {
        "name": "listGroupsForUsernameAndDomain",
        "desc": "listGroupsForUsernameAndDomain accepts username and domain and retrieves a SID list of the local groups where this user is a member."
      },
      {
        "name": "listGroupsFromReader",
        "desc": ""
      },
      {
        "name": "lookupFullName",
        "desc": ""
      },
      {
        "name": "lookupFullNameDomain",
        "desc": ""
      },
      {
        "name": "lookupFullNameServer",
        "desc": ""
      },
      {
        "name": "lookupGroupName",
        "desc": "lookupGroupName accepts the name of a group and retrieves the group SID."
      },
      {
        "name": "lookupUserPrimaryGroup",
        "desc": "lookupUserPrimaryGroup obtains the primary group SID for a user using this method: https://support.microsoft.com/en-us/help/297951/how-to-use-the-primarygroupid-attribute-to-find-the-primary-group-for The method follows this formula: domainRID + \"-\" + primaryGroupRID"
      },
      {
        "name": "lookupUsernameAndDomain",
        "desc": "lookupUsernameAndDomain obtains the username and domain for usid."
      },
      {
        "name": "readColonFile",
        "desc": "readColonFile parses r as an /etc/group or /etc/passwd style file, running fn for each row. readColonFile returns a value, an error, or (nil, nil) if the end of the file is reached without a match.  readCols is the minimum number of colon-separated fields that will be passed to fn; in a long line additional fields may be silently discarded."
      },
      {
        "name": "retryWithBuffer",
        "desc": "retryWithBuffer repeatedly calls f(), increasing the size of the buffer each time, until f succeeds, fails with a non-ERANGE error, or the buffer exceeds a reasonable limit."
      },
      {
        "name": "runAsProcessOwner",
        "desc": "runAsProcessOwner runs f in the context of the current process owner, that is, removing any impersonation that may be in effect before calling f, and restoring the impersonation afterwards."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "GroupIds",
        "desc": "GroupIds returns the list of group IDs that the user is a member of."
      },
      {
        "name": "initialSize",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Group",
        "desc": "Group represents a grouping of users.  On POSIX systems Gid contains a decimal number representing the group ID."
      },
      {
        "name": "UnknownGroupError",
        "desc": "UnknownGroupError is returned by [LookupGroup] when a group cannot be found."
      },
      {
        "name": "UnknownGroupIdError",
        "desc": "UnknownGroupIdError is returned by [LookupGroupId] when a group cannot be found."
      },
      {
        "name": "UnknownUserError",
        "desc": "UnknownUserError is returned by [Lookup] when a user cannot be found."
      },
      {
        "name": "UnknownUserIdError",
        "desc": "UnknownUserIdError is returned by [LookupId] when a user cannot be found."
      },
      {
        "name": "User",
        "desc": "User represents a user account."
      },
      {
        "name": "_C_char",
        "desc": ""
      },
      {
        "name": "_C_gid_t",
        "desc": ""
      },
      {
        "name": "_C_int",
        "desc": ""
      },
      {
        "name": "_C_long",
        "desc": ""
      },
      {
        "name": "_C_size_t",
        "desc": ""
      },
      {
        "name": "_C_struct_group",
        "desc": ""
      },
      {
        "name": "_C_struct_passwd",
        "desc": ""
      },
      {
        "name": "_C_uid_t",
        "desc": ""
      },
      {
        "name": "bufferKind",
        "desc": ""
      },
      {
        "name": "lineFunc",
        "desc": "lineFunc returns a value, an error, or (nil, nil) to skip the row."
      }
    ]
  },
  {
    "name": "path",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkJoin",
        "desc": ""
      },
      {
        "name": "ExampleBase",
        "desc": ""
      },
      {
        "name": "ExampleClean",
        "desc": ""
      },
      {
        "name": "ExampleDir",
        "desc": ""
      },
      {
        "name": "ExampleExt",
        "desc": ""
      },
      {
        "name": "ExampleIsAbs",
        "desc": ""
      },
      {
        "name": "ExampleJoin",
        "desc": ""
      },
      {
        "name": "ExampleMatch",
        "desc": ""
      },
      {
        "name": "ExampleSplit",
        "desc": ""
      },
      {
        "name": "TestBase",
        "desc": ""
      },
      {
        "name": "TestClean",
        "desc": ""
      },
      {
        "name": "TestCleanMallocs",
        "desc": ""
      },
      {
        "name": "TestDir",
        "desc": ""
      },
      {
        "name": "TestExt",
        "desc": ""
      },
      {
        "name": "TestIsAbs",
        "desc": ""
      },
      {
        "name": "TestJoin",
        "desc": ""
      },
      {
        "name": "TestMatch",
        "desc": ""
      },
      {
        "name": "TestSplit",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "ExtTest",
        "desc": ""
      },
      {
        "name": "IsAbsTest",
        "desc": ""
      },
      {
        "name": "JoinTest",
        "desc": ""
      },
      {
        "name": "MatchTest",
        "desc": ""
      },
      {
        "name": "PathTest",
        "desc": ""
      },
      {
        "name": "SplitTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "path/filepath",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkIsLocal",
        "desc": ""
      },
      {
        "name": "ExampleBase",
        "desc": ""
      },
      {
        "name": "ExampleDir",
        "desc": ""
      },
      {
        "name": "ExampleExt",
        "desc": ""
      },
      {
        "name": "ExampleIsAbs",
        "desc": ""
      },
      {
        "name": "ExampleJoin",
        "desc": ""
      },
      {
        "name": "ExampleMatch",
        "desc": ""
      },
      {
        "name": "ExampleRel",
        "desc": ""
      },
      {
        "name": "ExampleSplit",
        "desc": ""
      },
      {
        "name": "ExampleSplitList",
        "desc": ""
      },
      {
        "name": "ExampleWalk",
        "desc": ""
      },
      {
        "name": "TestAbs",
        "desc": ""
      },
      {
        "name": "TestAbsEmptyString",
        "desc": "Empty path needs to be special-cased on Windows. See golang.org/issue/24441. We test it separately from all other absTests because the empty string is not a valid path, so it can't be used with os.Stat."
      },
      {
        "name": "TestAbsWindows",
        "desc": ""
      },
      {
        "name": "TestBase",
        "desc": ""
      },
      {
        "name": "TestBug3486",
        "desc": ""
      },
      {
        "name": "TestCVE202230632",
        "desc": ""
      },
      {
        "name": "TestClean",
        "desc": ""
      },
      {
        "name": "TestDir",
        "desc": ""
      },
      {
        "name": "TestDriveLetterInEvalSymlinks",
        "desc": ""
      },
      {
        "name": "TestEscaping",
        "desc": ""
      },
      {
        "name": "TestEvalSymlinks",
        "desc": ""
      },
      {
        "name": "TestEvalSymlinksAboveRoot",
        "desc": "Issue 30520 part 1."
      },
      {
        "name": "TestEvalSymlinksAboveRootChdir",
        "desc": "Issue 30520 part 2."
      },
      {
        "name": "TestEvalSymlinksCanonicalNames",
        "desc": "TestEvalSymlinksCanonicalNames verify that EvalSymlinks returns \"canonical\" path names on windows."
      },
      {
        "name": "TestEvalSymlinksCanonicalNamesWith8dot3Disabled",
        "desc": "This test assumes registry state of NtfsDisable8dot3NameCreation is 2, the default (Volume level setting)."
      },
      {
        "name": "TestEvalSymlinksIsNotExist",
        "desc": ""
      },
      {
        "name": "TestEvalSymlinksJunctionToVolumeID",
        "desc": ""
      },
      {
        "name": "TestEvalSymlinksMountPointRecursion",
        "desc": ""
      },
      {
        "name": "TestEvalSymlinksTooManyLinks",
        "desc": ""
      },
      {
        "name": "TestExt",
        "desc": ""
      },
      {
        "name": "TestFromAndToSlash",
        "desc": ""
      },
      {
        "name": "TestGlob",
        "desc": ""
      },
      {
        "name": "TestGlobError",
        "desc": ""
      },
      {
        "name": "TestGlobSymlink",
        "desc": ""
      },
      {
        "name": "TestGlobUNC",
        "desc": ""
      },
      {
        "name": "TestIsAbs",
        "desc": ""
      },
      {
        "name": "TestIsLocal",
        "desc": ""
      },
      {
        "name": "TestIssue13582",
        "desc": ""
      },
      {
        "name": "TestIssue29372",
        "desc": ""
      },
      {
        "name": "TestIssue51617",
        "desc": ""
      },
      {
        "name": "TestIssue52476",
        "desc": ""
      },
      {
        "name": "TestJoin",
        "desc": ""
      },
      {
        "name": "TestLocalize",
        "desc": ""
      },
      {
        "name": "TestMatch",
        "desc": ""
      },
      {
        "name": "TestNTNamespaceSymlink",
        "desc": ""
      },
      {
        "name": "TestNonWindowsGlobEscape",
        "desc": ""
      },
      {
        "name": "TestRel",
        "desc": ""
      },
      {
        "name": "TestRelativeSymlinkToAbsolute",
        "desc": "Issue 57905."
      },
      {
        "name": "TestSplit",
        "desc": ""
      },
      {
        "name": "TestSplitList",
        "desc": ""
      },
      {
        "name": "TestToNorm",
        "desc": ""
      },
      {
        "name": "TestUNC",
        "desc": ""
      },
      {
        "name": "TestVolumeName",
        "desc": ""
      },
      {
        "name": "TestWalk",
        "desc": ""
      },
      {
        "name": "TestWalkDir",
        "desc": ""
      },
      {
        "name": "TestWalkDirectoryJunction",
        "desc": ""
      },
      {
        "name": "TestWalkDirectorySymlink",
        "desc": ""
      },
      {
        "name": "TestWalkFileError",
        "desc": ""
      },
      {
        "name": "TestWalkSkipAllOnFile",
        "desc": ""
      },
      {
        "name": "TestWalkSkipDirOnFile",
        "desc": ""
      },
      {
        "name": "TestWalkSymlink",
        "desc": ""
      },
      {
        "name": "TestWalkSymlinkRoot",
        "desc": ""
      },
      {
        "name": "TestWinSplitListTestsAreValid",
        "desc": ""
      },
      {
        "name": "TestWindowsEvalSymlinks",
        "desc": ""
      },
      {
        "name": "TestWindowsGlob",
        "desc": ""
      },
      {
        "name": "checkMarks",
        "desc": ""
      },
      {
        "name": "checkVolume8dot3Setting",
        "desc": "checkVolume8dot3Setting runs \"fsutil 8dot3name query c:\" command (where c: is vol parameter) to discover \"8dot3 name creation state\". The state is combination of 2 flags. The global flag controls if it is per volume or global setting:  \t0 - Enable 8dot3 name creation on all volumes on the system \t1 - Disable 8dot3 name creation on all volumes on the system \t2 - Set 8dot3 name creation on a per volume basis \t3 - Disable 8dot3 name creation on all volumes except the system volume  If global flag is set to 2, then per-volume flag needs to be examined:  \t0 - Enable 8dot3 name creation on this volume \t1 - Disable 8dot3 name creation on this volume  checkVolume8dot3Setting verifies that \"8dot3 name creation\" flags are set to 2 and 0, if enabled parameter is true, or 2 and 1, if enabled is false. Otherwise checkVolume8dot3Setting returns error."
      },
      {
        "name": "createMountPartition",
        "desc": ""
      },
      {
        "name": "errp",
        "desc": ""
      },
      {
        "name": "makeTree",
        "desc": ""
      },
      {
        "name": "mark",
        "desc": "Assumes that each node name is unique. Good enough for a test. If clear is true, any incoming error is cleared before return. The errors are always accumulated, though."
      },
      {
        "name": "markTree",
        "desc": ""
      },
      {
        "name": "prepareTestDirTree",
        "desc": ""
      },
      {
        "name": "setVolume8dot3Setting",
        "desc": ""
      },
      {
        "name": "simpleJoin",
        "desc": "simpleJoin builds a file name from the directory and path. It does not use Join because we don't want \"..\" to be evaluated."
      },
      {
        "name": "tempDirCanonical",
        "desc": "tempDirCanonical returns a temporary directory for the test to use, ensuring that the returned path does not contain symlinks."
      },
      {
        "name": "testEvalSymlinks",
        "desc": ""
      },
      {
        "name": "testEvalSymlinksAfterChdir",
        "desc": ""
      },
      {
        "name": "testWalk",
        "desc": ""
      },
      {
        "name": "testWalkMklink",
        "desc": ""
      },
      {
        "name": "testWalkSymlink",
        "desc": ""
      },
      {
        "name": "testWinSplitListTestIsValid",
        "desc": ""
      },
      {
        "name": "touch",
        "desc": ""
      },
      {
        "name": "walkTree",
        "desc": ""
      },
      {
        "name": "buildWant",
        "desc": ""
      },
      {
        "name": "globAbs",
        "desc": ""
      },
      {
        "name": "globRel",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "EvalSymlinksTest",
        "desc": ""
      },
      {
        "name": "ExtTest",
        "desc": ""
      },
      {
        "name": "IsAbsTest",
        "desc": ""
      },
      {
        "name": "IsLocalTest",
        "desc": ""
      },
      {
        "name": "JoinTest",
        "desc": ""
      },
      {
        "name": "LocalizeTest",
        "desc": ""
      },
      {
        "name": "MatchTest",
        "desc": ""
      },
      {
        "name": "Node",
        "desc": ""
      },
      {
        "name": "PathTest",
        "desc": ""
      },
      {
        "name": "RelTests",
        "desc": ""
      },
      {
        "name": "SplitListTest",
        "desc": ""
      },
      {
        "name": "SplitTest",
        "desc": ""
      },
      {
        "name": "VolumeNameTest",
        "desc": ""
      },
      {
        "name": "globTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "plugin",
    "desc": "",
    "functions": [
      {
        "name": "TestPlugin",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "reflect",
    "desc": "Package reflect implements run-time reflection, allowing a program to manipulate objects with arbitrary types. The typical use is to take a value with static type interface{} and extract its dynamic type information by calling TypeOf, which returns a Type.  A call to ValueOf returns a Value representing the run-time data. Zero takes a Type and returns a Value representing a zero value for that type.  See \"The Laws of Reflection\" for an introduction to reflection in Go: https://golang.org/doc/articles/laws_of_reflection.html",
    "functions": [
      {
        "name": "Copy",
        "desc": "Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind [Slice] or [Array], and dst and src must have the same element type. It dst is an [Array], it panics if [Value.CanSet] returns false.  As a special case, src can have kind [String] if the element type of dst is kind [Uint8]."
      },
      {
        "name": "DeepEqual",
        "desc": "DeepEqual reports whether x and y are “deeply equal,” defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal.  Array values are deeply equal when their corresponding elements are deeply equal.  Struct values are deeply equal if their corresponding fields, both exported and unexported, are deeply equal.  Func values are deeply equal if both are nil; otherwise they are not deeply equal.  Interface values are deeply equal if they hold deeply equal concrete values.  Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.  Pointer values are deeply equal if they are equal using Go's == operator or if they point to deeply equal values.  Slice values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they point to the same initial entry of the same underlying array (that is, \u0026x[0] == \u0026y[0]) or their corresponding elements (up to length) are deeply equal. Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil)) are not deeply equal.  Other values - numbers, bools, strings, and channels - are deeply equal if they are equal using Go's == operator.  In general DeepEqual is a recursive relaxation of Go's == operator. However, this idea is impossible to implement without some inconsistency. Specifically, it is possible for a value to be unequal to itself, either because it is of func type (uncomparable in general) or because it is a floating-point NaN value (not equal to itself in floating-point comparison), or because it is an array, struct, or interface containing such a value. On the other hand, pointer values are always equal to themselves, even if they point at or contain such problematic values, because they compare equal using Go's == operator, and that is a sufficient condition to be deeply equal, regardless of content. DeepEqual has been defined so that the same short-cut applies to slices and maps: if x and y are the same slice or the same map, they are deeply equal regardless of content.  As DeepEqual traverses the data values it may find a cycle. The second and subsequent times that DeepEqual compares two pointer values that have been compared before, it treats the values as equal rather than examining the values to which they point. This ensures that DeepEqual terminates."
      },
      {
        "name": "FirstMethodNameBytes",
        "desc": ""
      },
      {
        "name": "FuncLayout",
        "desc": "FuncLayout calls funcLayout and returns a subset of the results for testing.  Bitmaps like stack, gc, inReg, and outReg are expanded such that each bit takes up one byte, so that writing out test cases is a little clearer. If ptrs is false, gc will be nil."
      },
      {
        "name": "IsExported",
        "desc": ""
      },
      {
        "name": "IsRO",
        "desc": "IsRO reports whether v's read-only flag is set."
      },
      {
        "name": "ResolveReflectName",
        "desc": ""
      },
      {
        "name": "Select",
        "desc": "Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed). Select supports a maximum of 65536 cases."
      },
      {
        "name": "SetArgRegs",
        "desc": ""
      },
      {
        "name": "Swapper",
        "desc": "Swapper returns a function that swaps the elements in the provided slice.  Swapper panics if the provided interface is not a slice."
      },
      {
        "name": "TypeAssert",
        "desc": "TypeAssert is semantically equivalent to:  \tv2, ok := v.Interface().(T)"
      },
      {
        "name": "TypeLinks",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "add returns p+x.  The whySafe string is ignored, so that the function still inlines as efficiently as p+x, but all call sites should use the string to record why the addition is safe, which is to say why the addition does not cause x to advance to the very end of p's allocation and therefore point incorrectly at the next block in memory.  add should be an internal detail (and is trivially copyable), but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/pinpoint-apm/pinpoint-go-agent   - github.com/vmware/govmomi  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "addReflectOff",
        "desc": "addReflectOff adds a pointer to the reflection lookup map in the runtime. It returns a new ID that can be used as a typeOff or textOff, and will be resolved correctly. Implemented in the runtime package.  addReflectOff should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/goplus/reflectx  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "addTypeBits",
        "desc": ""
      },
      {
        "name": "align",
        "desc": "align returns the result of rounding x up to a multiple of n. n must be a power of two."
      },
      {
        "name": "appendVarint",
        "desc": ""
      },
      {
        "name": "archFloat32FromReg",
        "desc": ""
      },
      {
        "name": "archFloat32ToReg",
        "desc": ""
      },
      {
        "name": "arena_New",
        "desc": ""
      },
      {
        "name": "arrayAt",
        "desc": "arrayAt returns the i-th element of p, an array whose elements are eltSize bytes wide. The array pointed at by p must have at least i+1 elements: it is invalid (but impossible to check here) to pass i \u003e= len, because then the result will point outside the array. whySafe must explain why i \u003c len. (Passing \"i \u003c len\" is fine; the benefit is to surface this assumption at the call site.)"
      },
      {
        "name": "badlinkname_Value_pointer",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Align",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_AssignableTo",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Bits",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Comparable",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_ConvertibleTo",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_FieldAlign",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_FieldByName",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_FieldByNameFunc",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Implements",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_IsVariadic",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Len",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_MethodByName",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Name",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_NumField",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_NumIn",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_NumMethod",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_NumOut",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_PkgPath",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_Size",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_String",
        "desc": ""
      },
      {
        "name": "badlinkname_rtype_ptrTo",
        "desc": ""
      },
      {
        "name": "bucketOf",
        "desc": ""
      },
      {
        "name": "call",
        "desc": "call calls fn with \"stackArgsSize\" bytes of stack arguments laid out at stackArgs and register arguments laid out in regArgs. frameSize is the total amount of stack space that will be reserved by call, so this should include enough space to spill register arguments to the stack in case of preemption.  After fn returns, call copies stackArgsSize-stackRetOffset result bytes back into stackArgs+stackRetOffset before returning, for any return values passed on the stack. Register-based return values will be found in the same regArgs structure.  regArgs must also be prepared with an appropriate ReturnIsPtr bitmap indicating which registers will contain pointer-valued return values. The purpose of this bitmap is to keep pointers visible to the GC between returning from reflectcall and actually using them.  If copying result bytes back from the stack, the caller must pass the argument frame type as stackArgsType, so that call can execute appropriate write barriers during the copy.  Arguments passed through to call do not escape. The type is used only in a very limited callee of call, the stackArgs are copied, and regArgs is only used in the call frame."
      },
      {
        "name": "callMethod",
        "desc": "callMethod is the call implementation used by a function returned by makeMethodValue (used by v.Method(i).Interface()). It is a streamlined version of the usual reflect call: the caller has already laid out the argument frame for us, so we don't have to deal with individual Values for each argument. It is in this file so that it can be next to the two similar functions above. The remainder of the makeMethodValue implementation is in makefunc.go.  NOTE: This function must be marked as a \"wrapper\" in the generated code, so that the linker can make it work correctly for panic and recover. The gc compilers know to do that for the name \"reflect.callMethod\".  ctxt is the \"closure\" generated by makeMethodValue. frame is a pointer to the arguments to that closure on the stack. retValid points to a boolean which should be set when the results section of frame is set.  regs contains the argument values passed in registers and will contain the values returned from ctxt.fn in registers."
      },
      {
        "name": "callReflect",
        "desc": "callReflect is the call implementation used by a function returned by MakeFunc. In many ways it is the opposite of the method Value.call above. The method above converts a call using Values into a call of a function with a concrete argument frame, while callReflect converts a call of a function with a concrete argument frame into a call using Values. It is in this file so that it can be next to the call method above. The remainder of the MakeFunc implementation is in makefunc.go.  NOTE: This function must be marked as a \"wrapper\" in the generated code, so that the linker can make it work correctly for panic and recover. The gc compilers know to do that for the name \"reflect.callReflect\".  ctxt is the \"closure\" generated by MakeFunc. frame is a pointer to the arguments to that closure on the stack. retValid points to a boolean which should be set when the results section of frame is set.  regs contains the argument values passed in registers and will contain the values returned from ctxt.fn in registers."
      },
      {
        "name": "canRangeFunc",
        "desc": ""
      },
      {
        "name": "canRangeFunc2",
        "desc": ""
      },
      {
        "name": "chancap",
        "desc": "implemented in ../runtime"
      },
      {
        "name": "chanclose",
        "desc": ""
      },
      {
        "name": "chanlen",
        "desc": ""
      },
      {
        "name": "chanrecv",
        "desc": ""
      },
      {
        "name": "chansend",
        "desc": ""
      },
      {
        "name": "chansend0",
        "desc": ""
      },
      {
        "name": "clearLayoutCache",
        "desc": ""
      },
      {
        "name": "contentEscapes",
        "desc": "Dummy annotation marking that the content of value x escapes (i.e. modeling roughly heap=*x), for use in cases where the reflect code is so clever that the compiler cannot follow."
      },
      {
        "name": "convertOp",
        "desc": "convertOp returns the function to convert a value of type src to a value of type dst. If the conversion is illegal, convertOp returns nil."
      },
      {
        "name": "deepValueEqual",
        "desc": "Tests for deep equality using reflected types. The map argument tracks comparisons that have already been seen, which allows short circuiting on recursive types."
      },
      {
        "name": "directlyAssignable",
        "desc": "directlyAssignable reports whether a value x of type V can be directly assigned (using memmove) to a value of type T. https://golang.org/doc/go_spec.html#Assignability Ignoring the interface rules (implemented elsewhere) and the ideal constant rules (no ideal constants at run time)."
      },
      {
        "name": "dumpPtrBitMap",
        "desc": ""
      },
      {
        "name": "elem",
        "desc": ""
      },
      {
        "name": "embeddedIfaceMethStub",
        "desc": ""
      },
      {
        "name": "emitGCMask",
        "desc": "emitGCMask writes the GC mask for [n]typ into out, starting at bit offset base."
      },
      {
        "name": "escapes",
        "desc": "Dummy annotation marking that the value x escapes, for use in cases where the reflect code is so clever that the compiler cannot follow."
      },
      {
        "name": "floatFromReg",
        "desc": "floatFromReg loads a float value from its register representation in r.  argSize must be 4 or 8."
      },
      {
        "name": "floatToReg",
        "desc": "floatToReg stores a float value in its register representation in r.  argSize must be either 4 or 8."
      },
      {
        "name": "fnv1",
        "desc": "fnv1 incorporates the list of bytes into the hash x using the FNV-1 hash function."
      },
      {
        "name": "funcName",
        "desc": "funcName returns the name of f, for use in error messages."
      },
      {
        "name": "funcStr",
        "desc": "funcStr builds a string representation of a funcType."
      },
      {
        "name": "gcbits",
        "desc": ""
      },
      {
        "name": "getStaticuint64s",
        "desc": "getStaticuint64s returns a pointer to an array of 256 uint64 values, defined in the runtime package in read-only memory. staticuint64s[0] == 0, staticuint64s[1] == 1, and so forth."
      },
      {
        "name": "groupAndSlotOf",
        "desc": ""
      },
      {
        "name": "growslice",
        "desc": ""
      },
      {
        "name": "hashMightPanic",
        "desc": "hashMightPanic reports whether the hash of a map key of type t might panic."
      },
      {
        "name": "haveIdenticalType",
        "desc": ""
      },
      {
        "name": "haveIdenticalUnderlyingType",
        "desc": ""
      },
      {
        "name": "ifaceE2I",
        "desc": ""
      },
      {
        "name": "implements",
        "desc": "implements reports whether the type V implements the interface type T."
      },
      {
        "name": "intFromReg",
        "desc": "intFromReg loads an argSize sized integer from reg and places it at to.  argSize must be non-zero, fit in a register, and a power-of-two."
      },
      {
        "name": "intToReg",
        "desc": "intToReg loads an argSize sized integer and stores it into reg.  argSize must be non-zero, fit in a register, and a power-of-two."
      },
      {
        "name": "isLetter",
        "desc": "isLetter reports whether a given 'rune' is classified as a Letter."
      },
      {
        "name": "isPaddedField",
        "desc": "isPaddedField reports whether the i'th field of struct type t is followed by padding."
      },
      {
        "name": "isReflexive",
        "desc": "isReflexive reports whether the == operation on the type is reflexive. That is, x == x for all values x of type t."
      },
      {
        "name": "isRegularMemory",
        "desc": "This must match cmd/compile/internal/compare.IsRegularMemory"
      },
      {
        "name": "isValidFieldName",
        "desc": "isValidFieldName checks if a string is a valid (struct) field name or not.  According to the language spec, a field name should be an identifier.  identifier = letter { letter | unicode_digit } . letter = unicode_letter | \"_\" ."
      },
      {
        "name": "isZero",
        "desc": "isZero For all zeros, performance is not as good as return bytealg.Count(b, byte(0)) == len(b)"
      },
      {
        "name": "makeFuncStub",
        "desc": "makeFuncStub is an assembly function that is the code half of the function returned from MakeFunc. It expects a *callReflectFunc as its context register, and its job is to invoke callReflect(ctxt, frame) where ctxt is the context register and frame is a pointer to the first word in the passed-in argument frame."
      },
      {
        "name": "makechan",
        "desc": ""
      },
      {
        "name": "makemap",
        "desc": ""
      },
      {
        "name": "mapIterNext",
        "desc": "Equivalent to runtime.mapIterNext."
      },
      {
        "name": "mapIterStart",
        "desc": "Equivalent to runtime.mapIterStart."
      },
      {
        "name": "mapaccess",
        "desc": ""
      },
      {
        "name": "mapaccess_faststr",
        "desc": ""
      },
      {
        "name": "mapassign",
        "desc": "mapassign should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/modern-go/reflect2   - github.com/goccy/go-json  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapassign0",
        "desc": ""
      },
      {
        "name": "mapassign_faststr",
        "desc": ""
      },
      {
        "name": "mapassign_faststr0",
        "desc": ""
      },
      {
        "name": "mapclear",
        "desc": ""
      },
      {
        "name": "mapdelete",
        "desc": ""
      },
      {
        "name": "mapdelete_faststr",
        "desc": ""
      },
      {
        "name": "mapiterinit",
        "desc": ""
      },
      {
        "name": "mapiternext",
        "desc": ""
      },
      {
        "name": "maplen",
        "desc": ""
      },
      {
        "name": "memmove",
        "desc": "memmove copies size bytes to dst from src. No write barriers are used."
      },
      {
        "name": "methodValueCall",
        "desc": "methodValueCall is an assembly function that is the code half of the function returned from makeMethodValue. It expects a *methodValue as its context register, and its job is to invoke callMethod(ctxt, frame) where ctxt is the context register and frame is a pointer to the first word in the passed-in argument frame."
      },
      {
        "name": "methodValueCallCodePtr",
        "desc": ""
      },
      {
        "name": "moveMakeFuncArgPtrs",
        "desc": "moveMakeFuncArgPtrs uses ctxt.regPtrs to copy integer pointer arguments in args.Ints to args.Ptrs where the GC can see them.  This is similar to what reflectcallmove does in the runtime, except that happens on the return path, whereas this happens on the call path.  nosplit because pointers are being held in uintptr slots in args, so having our stack scanned now could lead to accidentally freeing memory."
      },
      {
        "name": "nameFor",
        "desc": ""
      },
      {
        "name": "nameOffFor",
        "desc": ""
      },
      {
        "name": "needKeyUpdate",
        "desc": "needKeyUpdate reports whether map overwrites require the key to be copied."
      },
      {
        "name": "newName",
        "desc": ""
      },
      {
        "name": "overflowFloat32",
        "desc": ""
      },
      {
        "name": "packEface",
        "desc": "packEface converts v to the empty interface."
      },
      {
        "name": "packIfaceValueIntoEmptyIface",
        "desc": "packIfaceValueIntoEmptyIface converts an interface Value into an empty interface.  Precondition: v.kind() == Interface"
      },
      {
        "name": "pkgPath",
        "desc": ""
      },
      {
        "name": "pkgPathFor",
        "desc": ""
      },
      {
        "name": "ptrTo",
        "desc": ""
      },
      {
        "name": "rangeNum",
        "desc": ""
      },
      {
        "name": "resolveNameOff",
        "desc": "resolveNameOff resolves a name offset from a base pointer. The (*rtype).nameOff method is a convenience wrapper for this function. Implemented in the runtime package."
      },
      {
        "name": "resolveTextOff",
        "desc": "resolveTextOff resolves a function pointer offset from a base type. The (*rtype).textOff method is a convenience wrapper for this function. Implemented in the runtime package."
      },
      {
        "name": "resolveTypeOff",
        "desc": "resolveTypeOff resolves an *rtype offset from a base type. The (*rtype).typeOff method is a convenience wrapper for this function. Implemented in the runtime package."
      },
      {
        "name": "rselect",
        "desc": "rselect runs a select. It returns the index of the chosen case. If the case was a receive, val is filled in with the received value. The conventional OK bool indicates whether the receive corresponds to a sent value.  rselect generally doesn't escape the runtimeSelect slice, except that for the send case the value to send needs to escape. We don't have a way to represent that in the function signature. So we handle that with a forced escape in function Select."
      },
      {
        "name": "rtypeOf",
        "desc": "rtypeOf directly extracts the *rtype of the provided value."
      },
      {
        "name": "rtypeOff",
        "desc": "rtypeOff should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/goccy/go-json  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "specialChannelAssignability",
        "desc": "specialChannelAssignability reports whether a value x of channel type V can be directly assigned (using memmove) to another channel type T. https://golang.org/doc/go_spec.html#Assignability T and V must be both of Chan kind."
      },
      {
        "name": "storeRcvr",
        "desc": "v is a method receiver. Store at p the word which is used to encode that receiver at the start of the argument list. Reflect uses the \"interface\" calling convention for methods, which always uses one word to record the receiver."
      },
      {
        "name": "stringFor",
        "desc": ""
      },
      {
        "name": "textOffFor",
        "desc": ""
      },
      {
        "name": "typeOffFor",
        "desc": ""
      },
      {
        "name": "typedarrayclear",
        "desc": "typedarrayclear zeroes the value at ptr of an array of elemType, only clears len elem."
      },
      {
        "name": "typedmemclr",
        "desc": "typedmemclr zeros the value at ptr of type t."
      },
      {
        "name": "typedmemclrpartial",
        "desc": "typedmemclrpartial is like typedmemclr but assumes that dst points off bytes into the value and only clears size bytes."
      },
      {
        "name": "typedmemmove",
        "desc": "typedmemmove copies a value of type t to dst from src."
      },
      {
        "name": "typedslicecopy",
        "desc": "typedslicecopy copies a slice of elemType values from src to dst, returning the number of elements copied."
      },
      {
        "name": "typehash",
        "desc": ""
      },
      {
        "name": "typelinks",
        "desc": "typelinks is implemented in package runtime. It returns a slice of the sections in each module, and a slice of *rtype offsets in each module.  The types in each module are sorted by string. That is, the first two linked types of the first module are:  \td0 := sections[0] \tt1 := (*rtype)(add(d0, offset[0][0])) \tt2 := (*rtype)(add(d0, offset[0][1]))  and  \tt1.String() \u003c t2.String()  Note that strings are not unique identifiers for types: there can be more than one with a given string. Only types we might want to look up are included: pointers, channels, maps, slices, and arrays."
      },
      {
        "name": "typeptrdata",
        "desc": "typeptrdata returns the length in bytes of the prefix of t containing pointer data. Anything after this offset is scalar data. keep in sync with ../cmd/compile/internal/reflectdata/reflect.go"
      },
      {
        "name": "typesByString",
        "desc": "typesByString returns the subslice of typelinks() whose elements have the given string representation. It may be empty (no known types with that string) or may have multiple elements (multiple types with that string).  typesByString should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/aristanetworks/goarista   - fortio.org/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "typesMustMatch",
        "desc": ""
      },
      {
        "name": "unsafe_New",
        "desc": ""
      },
      {
        "name": "unsafe_NewArray",
        "desc": ""
      },
      {
        "name": "unsafeslice",
        "desc": ""
      },
      {
        "name": "unusedIfaceIndir",
        "desc": "ifaceIndir reports whether t is stored indirectly in an interface value. It is no longer used by this package and is here entirely for the linkname uses."
      },
      {
        "name": "valueInterface",
        "desc": ""
      },
      {
        "name": "valueMethodName",
        "desc": "valueMethodName returns the name of the exported calling method on Value."
      },
      {
        "name": "verifyNotInHeapPtr",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "f",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String returns the name of k."
      },
      {
        "name": "Key",
        "desc": "Key returns the key of iter's current map entry."
      },
      {
        "name": "Next",
        "desc": "Next advances the map iterator and reports whether there is another entry. It returns false when iter is exhausted; subsequent calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic."
      },
      {
        "name": "Reset",
        "desc": "Reset modifies iter to iterate over v. It panics if v's Kind is not [Map] and v is not the zero Value. Reset(Value{}) causes iter to not to refer to any map, which may allow the previously iterated-over map to be garbage collected."
      },
      {
        "name": "Value",
        "desc": "Value returns the value of iter's current map entry."
      },
      {
        "name": "IsExported",
        "desc": "IsExported reports whether the method is exported."
      },
      {
        "name": "IsExported",
        "desc": "IsExported reports whether the field is exported."
      },
      {
        "name": "Get",
        "desc": "Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use [StructTag.Lookup]."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified."
      },
      {
        "name": "Addr",
        "desc": "Addr returns a pointer value representing the address of v. It panics if [Value.CanAddr] returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver."
      },
      {
        "name": "Bool",
        "desc": "Bool returns v's underlying value. It panics if v's kind is not [Bool]."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns v's underlying value. It panics if v's underlying value is not a slice of bytes or an addressable array of bytes."
      },
      {
        "name": "Call",
        "desc": "Call calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v's Kind is not [Func]. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values."
      },
      {
        "name": "CallSlice",
        "desc": "CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v's final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...). CallSlice panics if v's Kind is not [Func] or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter."
      },
      {
        "name": "CanAddr",
        "desc": "CanAddr reports whether the value's address can be obtained with [Value.Addr]. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling [Value.Addr] will panic."
      },
      {
        "name": "CanComplex",
        "desc": "CanComplex reports whether [Value.Complex] can be used without panicking."
      },
      {
        "name": "CanConvert",
        "desc": "CanConvert reports whether the value v can be converted to type t. If v.CanConvert(t) returns true then v.Convert(t) will not panic."
      },
      {
        "name": "CanFloat",
        "desc": "CanFloat reports whether [Value.Float] can be used without panicking."
      },
      {
        "name": "CanInt",
        "desc": "CanInt reports whether Int can be used without panicking."
      },
      {
        "name": "CanInterface",
        "desc": "CanInterface reports whether [Value.Interface] can be used without panicking."
      },
      {
        "name": "CanSet",
        "desc": "CanSet reports whether the value of v can be changed. A [Value] can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling [Value.Set] or any type-specific setter (e.g., [Value.SetBool], [Value.SetInt]) will panic."
      },
      {
        "name": "CanUint",
        "desc": "CanUint reports whether [Value.Uint] can be used without panicking."
      },
      {
        "name": "Cap",
        "desc": "Cap returns v's capacity. It panics if v's Kind is not [Array], [Chan], [Slice] or pointer to [Array]."
      },
      {
        "name": "Clear",
        "desc": "Clear clears the contents of a map or zeros the contents of a slice.  It panics if v's Kind is not [Map] or [Slice]."
      },
      {
        "name": "Close",
        "desc": "Close closes the channel v. It panics if v's Kind is not [Chan] or v is a receive-only channel."
      },
      {
        "name": "Comparable",
        "desc": "Comparable reports whether the value v is comparable. If the type of v is an interface, this checks the dynamic type. If this reports true then v.Interface() == x will not panic for any x, nor will v.Equal(u) for any Value u."
      },
      {
        "name": "Complex",
        "desc": "Complex returns v's underlying value, as a complex128. It panics if v's Kind is not [Complex64] or [Complex128]"
      },
      {
        "name": "Convert",
        "desc": "Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, or if converting v to type t panics, Convert panics."
      },
      {
        "name": "Elem",
        "desc": "Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not [Interface] or [Pointer]. It returns the zero Value if v is nil."
      },
      {
        "name": "Equal",
        "desc": "Equal reports true if v is equal to u. For two invalid values, Equal will report true. For an interface value, Equal will compare the value within the interface. Otherwise, If the values have different types, Equal will report false. Otherwise, for arrays and structs Equal will compare each element in order, and report false if it finds non-equal elements. During all comparisons, if values of the same type are compared, and the type is not comparable, Equal will panic."
      },
      {
        "name": "Field",
        "desc": "Field returns the i'th field of the struct v. It panics if v's Kind is not [Struct] or i is out of range."
      },
      {
        "name": "FieldByIndex",
        "desc": "FieldByIndex returns the nested field corresponding to index. It panics if evaluation requires stepping through a nil pointer or a field that is not a struct."
      },
      {
        "name": "FieldByIndexErr",
        "desc": "FieldByIndexErr returns the nested field corresponding to index. It returns an error if evaluation requires stepping through a nil pointer, but panics if it must step through a field that is not a struct."
      },
      {
        "name": "FieldByName",
        "desc": "FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not [Struct]."
      },
      {
        "name": "FieldByNameFunc",
        "desc": "FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not [Struct]. It returns the zero Value if no field was found."
      },
      {
        "name": "Float",
        "desc": "Float returns v's underlying value, as a float64. It panics if v's Kind is not [Float32] or [Float64]"
      },
      {
        "name": "Grow",
        "desc": "Grow increases the slice's capacity, if necessary, to guarantee space for another n elements. After Grow(n), at least n elements can be appended to the slice without another allocation.  It panics if v's Kind is not a [Slice], or if n is negative or too large to allocate the memory, or if [Value.CanSet] returns false."
      },
      {
        "name": "Index",
        "desc": "Index returns v's i'th element. It panics if v's Kind is not [Array], [Slice], or [String] or i is out of range."
      },
      {
        "name": "Int",
        "desc": "Int returns v's underlying value, as an int64. It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64]."
      },
      {
        "name": "Interface",
        "desc": "Interface returns v's current value as an interface{}. It is equivalent to:  \tvar i interface{} = (v's underlying value)  It panics if the Value was obtained by accessing unexported struct fields."
      },
      {
        "name": "InterfaceData",
        "desc": "InterfaceData returns a pair of unspecified uintptr values. It panics if v's Kind is not Interface.  In earlier versions of Go, this function returned the interface's value as a uintptr pair. As of Go 1.4, the implementation of interface values precludes any defined use of InterfaceData.  Deprecated: The memory representation of interface values is not compatible with InterfaceData."
      },
      {
        "name": "IsNil",
        "desc": "IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling [ValueOf] with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value."
      },
      {
        "name": "IsValid",
        "desc": "IsValid reports whether v represents a value. It returns false if v is the zero Value. If [Value.IsValid] returns false, all other methods except String panic. Most functions and methods never return an invalid Value. If one does, its documentation states the conditions explicitly."
      },
      {
        "name": "IsZero",
        "desc": "IsZero reports whether v is the zero value for its type. It panics if the argument is invalid."
      },
      {
        "name": "Kind",
        "desc": "Kind returns v's Kind. If v is the zero Value ([Value.IsValid] returns false), Kind returns Invalid."
      },
      {
        "name": "Len",
        "desc": "Len returns v's length. It panics if v's Kind is not [Array], [Chan], [Map], [Slice], [String], or pointer to [Array]."
      },
      {
        "name": "MapIndex",
        "desc": "MapIndex returns the value associated with key in the map v. It panics if v's Kind is not [Map]. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type."
      },
      {
        "name": "MapKeys",
        "desc": "MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not [Map]. It returns an empty slice if v represents a nil map."
      },
      {
        "name": "MapRange",
        "desc": "MapRange returns a range iterator for a map. It panics if v's Kind is not [Map].  Call [MapIter.Next] to advance the iterator, and [MapIter.Key]/[MapIter.Value] to access each entry. [MapIter.Next] returns false when the iterator is exhausted. MapRange follows the same iteration semantics as a range statement.  Example:  \titer := reflect.ValueOf(m).MapRange() \tfor iter.Next() { \t\tk := iter.Key() \t\tv := iter.Value() \t\t... \t}"
      },
      {
        "name": "Method",
        "desc": "Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.  Calling this method will force the linker to retain all exported methods in all packages. This may make the executable binary larger but will not affect execution time."
      },
      {
        "name": "MethodByName",
        "desc": "MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.  Calling this method will cause the linker to retain all methods with this name in all packages. If the linker can't determine the name, it will retain all exported methods. This may make the executable binary larger but will not affect execution time."
      },
      {
        "name": "NumField",
        "desc": "NumField returns the number of fields in the struct v. It panics if v's Kind is not [Struct]."
      },
      {
        "name": "NumMethod",
        "desc": "NumMethod returns the number of methods in the value's method set.  For a non-interface type, it returns the number of exported methods.  For an interface type, it returns the number of exported and unexported methods."
      },
      {
        "name": "OverflowComplex",
        "desc": "OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not [Complex64] or [Complex128]."
      },
      {
        "name": "OverflowFloat",
        "desc": "OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not [Float32] or [Float64]."
      },
      {
        "name": "OverflowInt",
        "desc": "OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64]."
      },
      {
        "name": "OverflowUint",
        "desc": "OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64]."
      },
      {
        "name": "Pointer",
        "desc": "Pointer returns v's value as a uintptr. It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], [String], or [UnsafePointer].  If v's Kind is [Func], the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.  If v's Kind is [Slice], the returned pointer is to the first element of the slice. If the slice is nil the returned value is 0.  If the slice is empty but non-nil the return value is non-zero.  If v's Kind is [String], the returned pointer is to the first element of the underlying bytes of string.  It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result."
      },
      {
        "name": "Recv",
        "desc": "Recv receives and returns a value from the channel v. It panics if v's Kind is not [Chan]. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed."
      },
      {
        "name": "Send",
        "desc": "Send sends x on the channel v. It panics if v's kind is not [Chan] or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type."
      },
      {
        "name": "Seq",
        "desc": "Seq returns an iter.Seq[Value] that loops over the elements of v. If v's kind is Func, it must be a function that has no results and that takes a single argument of type func(T) bool for some type T. If v's kind is Pointer, the pointer element type must have kind Array. Otherwise v's kind must be Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr, Array, Chan, Map, Slice, or String."
      },
      {
        "name": "Seq2",
        "desc": "Seq2 returns an iter.Seq2[Value, Value] that loops over the elements of v. If v's kind is Func, it must be a function that has no results and that takes a single argument of type func(K, V) bool for some type K, V. If v's kind is Pointer, the pointer element type must have kind Array. Otherwise v's kind must be Array, Map, Slice, or String."
      },
      {
        "name": "Set",
        "desc": "Set assigns x to the value v. It panics if [Value.CanSet] returns false. As in Go, x's value must be assignable to v's type and must not be derived from an unexported field."
      },
      {
        "name": "SetBool",
        "desc": "SetBool sets v's underlying value. It panics if v's Kind is not [Bool] or if [Value.CanSet] returns false."
      },
      {
        "name": "SetBytes",
        "desc": "SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes or if [Value.CanSet] returns false."
      },
      {
        "name": "SetCap",
        "desc": "SetCap sets v's capacity to n. It panics if v's Kind is not [Slice], or if n is smaller than the length or greater than the capacity of the slice, or if [Value.CanSet] returns false."
      },
      {
        "name": "SetComplex",
        "desc": "SetComplex sets v's underlying value to x. It panics if v's Kind is not [Complex64] or [Complex128], or if [Value.CanSet] returns false."
      },
      {
        "name": "SetFloat",
        "desc": "SetFloat sets v's underlying value to x. It panics if v's Kind is not [Float32] or [Float64], or if [Value.CanSet] returns false."
      },
      {
        "name": "SetInt",
        "desc": "SetInt sets v's underlying value to x. It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64], or if [Value.CanSet] returns false."
      },
      {
        "name": "SetIterKey",
        "desc": "SetIterKey assigns to v the key of iter's current map entry. It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value. As in Go, the key must be assignable to v's type and must not be derived from an unexported field. It panics if [Value.CanSet] returns false."
      },
      {
        "name": "SetIterValue",
        "desc": "SetIterValue assigns to v the value of iter's current map entry. It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value. As in Go, the value must be assignable to v's type and must not be derived from an unexported field. It panics if [Value.CanSet] returns false."
      },
      {
        "name": "SetLen",
        "desc": "SetLen sets v's length to n. It panics if v's Kind is not [Slice], or if n is negative or greater than the capacity of the slice, or if [Value.CanSet] returns false."
      },
      {
        "name": "SetMapIndex",
        "desc": "SetMapIndex sets the element associated with key in the map v to elem. It panics if v's Kind is not [Map]. If elem is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's elem must be assignable to the map's key type, and elem's value must be assignable to the map's elem type."
      },
      {
        "name": "SetPointer",
        "desc": "SetPointer sets the [unsafe.Pointer] value v to x. It panics if v's Kind is not [UnsafePointer] or if [Value.CanSet] returns false."
      },
      {
        "name": "SetString",
        "desc": "SetString sets v's underlying value to x. It panics if v's Kind is not [String] or if [Value.CanSet] returns false."
      },
      {
        "name": "SetUint",
        "desc": "SetUint sets v's underlying value to x. It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64], or if [Value.CanSet] returns false."
      },
      {
        "name": "SetZero",
        "desc": "SetZero sets v to be the zero value of v's type. It panics if [Value.CanSet] returns false."
      },
      {
        "name": "Slice",
        "desc": "Slice returns v[i:j]. It panics if v's Kind is not [Array], [Slice] or [String], or if v is an unaddressable array, or if the indexes are out of bounds."
      },
      {
        "name": "Slice3",
        "desc": "Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not [Array] or [Slice], or if v is an unaddressable array, or if the indexes are out of bounds."
      },
      {
        "name": "String",
        "desc": "String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not [String]. Instead, it returns a string of the form \"\u003cT value\u003e\" where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold."
      },
      {
        "name": "TryRecv",
        "desc": "TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not [Chan]. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false."
      },
      {
        "name": "TrySend",
        "desc": "TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not [Chan]. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type."
      },
      {
        "name": "Type",
        "desc": "Type returns v's type."
      },
      {
        "name": "Uint",
        "desc": "Uint returns v's underlying value, as a uint64. It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64]."
      },
      {
        "name": "UnsafeAddr",
        "desc": "UnsafeAddr returns a pointer to v's data, as a uintptr. It panics if v is not addressable.  It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result."
      },
      {
        "name": "UnsafePointer",
        "desc": "UnsafePointer returns v's value as a [unsafe.Pointer]. It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], [String] or [UnsafePointer].  If v's Kind is [Func], the returned pointer is an underlying code pointer, but not necessarily enough to identify a single function uniquely. The only guarantee is that the result is zero if and only if v is a nil func Value.  If v's Kind is [Slice], the returned pointer is to the first element of the slice. If the slice is nil the returned value is nil.  If the slice is empty but non-nil the return value is non-nil.  If v's Kind is [String], the returned pointer is to the first element of the underlying bytes of string."
      },
      {
        "name": "abiType",
        "desc": ""
      },
      {
        "name": "abiTypeSlow",
        "desc": ""
      },
      {
        "name": "assignTo",
        "desc": "assignTo returns a value v that can be assigned directly to dst. It panics if v is not assignable to dst. For a conversion to an interface type, target, if not nil, is a suggested scratch space to use. target must be initialized memory (or nil)."
      },
      {
        "name": "bytesSlow",
        "desc": ""
      },
      {
        "name": "call",
        "desc": ""
      },
      {
        "name": "capNonSlice",
        "desc": ""
      },
      {
        "name": "extendSlice",
        "desc": "extendSlice extends a slice by n elements.  Unlike Value.grow, which modifies the slice in place and does not change the length of the slice in place, extendSlice returns a new slice value with the length incremented by the number of specified elements."
      },
      {
        "name": "grow",
        "desc": "grow is identical to Grow but does not check for assignability."
      },
      {
        "name": "kind",
        "desc": ""
      },
      {
        "name": "lenNonSlice",
        "desc": ""
      },
      {
        "name": "mustBe",
        "desc": "mustBe panics if f's kind is not expected. Making this a method on flag instead of on Value (and embedding flag in Value) means that we can write the very clear v.mustBe(Bool) and have it compile into v.flag.mustBe(Bool), which will only bother to copy the single important word for the receiver."
      },
      {
        "name": "mustBeAssignable",
        "desc": "mustBeAssignable panics if f records that the value is not assignable, which is to say that either it was obtained using an unexported field or it is not addressable."
      },
      {
        "name": "mustBeAssignableSlow",
        "desc": ""
      },
      {
        "name": "mustBeExported",
        "desc": "mustBeExported panics if f records that the value was obtained using an unexported field."
      },
      {
        "name": "mustBeExportedSlow",
        "desc": ""
      },
      {
        "name": "panicNotBool",
        "desc": ""
      },
      {
        "name": "panicNotMap",
        "desc": "Force slow panicking path not inlined, so it won't add to the inlining budget of the caller. TODO: undo when the inliner is no longer bottom-up only."
      },
      {
        "name": "pointer",
        "desc": "pointer returns the underlying pointer represented by v. v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer if v.Kind() == Pointer, the base type must not be not-in-heap."
      },
      {
        "name": "recv",
        "desc": "internal recv, possibly non-blocking (nb). v is known to be a channel."
      },
      {
        "name": "ro",
        "desc": ""
      },
      {
        "name": "runes",
        "desc": "runes returns v's underlying value. It panics if v's underlying value is not a slice of runes (int32s)."
      },
      {
        "name": "send",
        "desc": "internal send, possibly non-blocking. v is known to be a channel."
      },
      {
        "name": "setRunes",
        "desc": "setRunes sets v's underlying value. It panics if v's underlying value is not a slice of runes (int32s) or if [Value.CanSet] returns false."
      },
      {
        "name": "stringNonString",
        "desc": ""
      },
      {
        "name": "typ",
        "desc": "typ returns the *abi.Type stored in the Value. This method is fast, but it doesn't always return the correct type for the Value. See abiType and Type, which do return the correct type."
      },
      {
        "name": "typeSlow",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "dump",
        "desc": ""
      },
      {
        "name": "addArg",
        "desc": "addArg extends the abiSeq with a new Go value of type t.  If the value was stack-assigned, returns the single abiStep describing that translation, and nil otherwise."
      },
      {
        "name": "addRcvr",
        "desc": "addRcvr extends the abiSeq with a new method call receiver according to the interface calling convention.  If the receiver was stack-assigned, returns the single abiStep describing that translation, and nil otherwise. Returns true if the receiver is a pointer."
      },
      {
        "name": "assignFloatN",
        "desc": "assignFloatN assigns n values to registers, each \"size\" bytes large, from the data at [offset, offset+n*size) in memory. Each value at [offset+i*size, offset+(i+1)*size) for i \u003c n is assigned to the next n floating-point registers.  Returns whether assignment succeeded."
      },
      {
        "name": "assignIntN",
        "desc": "assignIntN assigns n values to registers, each \"size\" bytes large, from the data at [offset, offset+n*size) in memory. Each value at [offset+i*size, offset+(i+1)*size) for i \u003c n is assigned to the next n integer registers.  Bit i in ptrMap indicates whether the i'th value is a pointer. n must be \u003c= 8.  Returns whether assignment succeeded."
      },
      {
        "name": "dump",
        "desc": ""
      },
      {
        "name": "regAssign",
        "desc": "regAssign attempts to reserve argument registers for a value of type t, stored at some offset.  It returns whether or not the assignment succeeded, but leaves any changes it made to a.steps behind, so the caller must undo that work by adjusting a.steps if it fails.  This method along with the assign* methods represent the complete register-assignment algorithm for the Go ABI."
      },
      {
        "name": "stackAssign",
        "desc": "stackAssign reserves space for one value that is \"size\" bytes large with alignment \"alignment\" to the stack.  Should not be called directly; use addArg instead."
      },
      {
        "name": "stepsForValue",
        "desc": "stepsForValue returns the ABI instructions for translating the i'th Go argument or return value represented by this abiSeq to the Go ABI."
      },
      {
        "name": "append",
        "desc": "append a bit to the bitmap."
      },
      {
        "name": "kind",
        "desc": ""
      },
      {
        "name": "mustBe",
        "desc": "mustBe panics if f's kind is not expected. Making this a method on flag instead of on Value (and embedding flag in Value) means that we can write the very clear v.mustBe(Bool) and have it compile into v.flag.mustBe(Bool), which will only bother to copy the single important word for the receiver."
      },
      {
        "name": "mustBeAssignable",
        "desc": "mustBeAssignable panics if f records that the value is not assignable, which is to say that either it was obtained using an unexported field or it is not addressable."
      },
      {
        "name": "mustBeAssignableSlow",
        "desc": ""
      },
      {
        "name": "mustBeExported",
        "desc": "mustBeExported panics if f records that the value was obtained using an unexported field."
      },
      {
        "name": "mustBeExportedSlow",
        "desc": ""
      },
      {
        "name": "panicNotMap",
        "desc": "Force slow panicking path not inlined, so it won't add to the inlining budget of the caller. TODO: undo when the inliner is no longer bottom-up only."
      },
      {
        "name": "ro",
        "desc": ""
      },
      {
        "name": "initialized",
        "desc": ""
      },
      {
        "name": "Method",
        "desc": "Method returns the i'th method in the type's method set."
      },
      {
        "name": "MethodByName",
        "desc": "MethodByName method with the given name in the type's method set."
      },
      {
        "name": "NumMethod",
        "desc": "NumMethod returns the number of interface methods in the type's method set."
      },
      {
        "name": "common",
        "desc": ""
      },
      {
        "name": "nameOff",
        "desc": ""
      },
      {
        "name": "typeOff",
        "desc": ""
      },
      {
        "name": "uncommon",
        "desc": ""
      },
      {
        "name": "Align",
        "desc": ""
      },
      {
        "name": "AssignableTo",
        "desc": ""
      },
      {
        "name": "Bits",
        "desc": ""
      },
      {
        "name": "CanSeq",
        "desc": ""
      },
      {
        "name": "CanSeq2",
        "desc": ""
      },
      {
        "name": "ChanDir",
        "desc": ""
      },
      {
        "name": "Comparable",
        "desc": ""
      },
      {
        "name": "ConvertibleTo",
        "desc": ""
      },
      {
        "name": "Elem",
        "desc": ""
      },
      {
        "name": "Field",
        "desc": ""
      },
      {
        "name": "FieldAlign",
        "desc": ""
      },
      {
        "name": "FieldByIndex",
        "desc": ""
      },
      {
        "name": "FieldByName",
        "desc": ""
      },
      {
        "name": "FieldByNameFunc",
        "desc": ""
      },
      {
        "name": "Implements",
        "desc": ""
      },
      {
        "name": "In",
        "desc": ""
      },
      {
        "name": "IsVariadic",
        "desc": ""
      },
      {
        "name": "Key",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Method",
        "desc": ""
      },
      {
        "name": "MethodByName",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "NumField",
        "desc": ""
      },
      {
        "name": "NumIn",
        "desc": ""
      },
      {
        "name": "NumMethod",
        "desc": ""
      },
      {
        "name": "NumOut",
        "desc": ""
      },
      {
        "name": "Out",
        "desc": ""
      },
      {
        "name": "OverflowComplex",
        "desc": ""
      },
      {
        "name": "OverflowFloat",
        "desc": ""
      },
      {
        "name": "OverflowInt",
        "desc": ""
      },
      {
        "name": "OverflowUint",
        "desc": ""
      },
      {
        "name": "PkgPath",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "common",
        "desc": ""
      },
      {
        "name": "exportedMethods",
        "desc": ""
      },
      {
        "name": "nameOff",
        "desc": ""
      },
      {
        "name": "ptrTo",
        "desc": ""
      },
      {
        "name": "textOff",
        "desc": ""
      },
      {
        "name": "typeOff",
        "desc": ""
      },
      {
        "name": "uncommon",
        "desc": ""
      },
      {
        "name": "Field",
        "desc": "Field returns the i'th struct field."
      },
      {
        "name": "FieldByIndex",
        "desc": "FieldByIndex returns the nested field corresponding to index."
      },
      {
        "name": "FieldByName",
        "desc": "FieldByName returns the struct field with the given name and a boolean to indicate if the field was found."
      },
      {
        "name": "FieldByNameFunc",
        "desc": "FieldByNameFunc returns the struct field with a name that satisfies the match function and a boolean to indicate if the field was found."
      },
      {
        "name": "Field",
        "desc": "Field returns the i'th struct field."
      },
      {
        "name": "FieldByIndex",
        "desc": "FieldByIndex returns the nested field corresponding to index."
      },
      {
        "name": "FieldByName",
        "desc": "FieldByName returns the struct field with the given name and a boolean to indicate if the field was found."
      },
      {
        "name": "FieldByNameFunc",
        "desc": "FieldByNameFunc returns the struct field with a name that satisfies the match function and a boolean to indicate if the field was found."
      },
      {
        "name": "walk",
        "desc": "walk walks all the fields in the struct type t, visiting fields in index preorder and appending them to w.fields (this maintains the required ordering). Fields that have been overridden have their Name field cleared."
      }
    ],
    "types": [
      {
        "name": "Buffer",
        "desc": ""
      },
      {
        "name": "ChanDir",
        "desc": "ChanDir represents a channel type's direction."
      },
      {
        "name": "EmbedWithUnexpMeth",
        "desc": ""
      },
      {
        "name": "Kind",
        "desc": "A Kind represents the specific kind of type that a [Type] represents. The zero Kind is not a valid kind."
      },
      {
        "name": "MapIter",
        "desc": "A MapIter is an iterator for ranging over a map. See [Value.MapRange]."
      },
      {
        "name": "Method",
        "desc": "Method represents a single method."
      },
      {
        "name": "OtherPkgFields",
        "desc": ""
      },
      {
        "name": "SelectCase",
        "desc": "A SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction.  If Dir is SelectDefault, the case represents a default case. Chan and Send must be zero Values.  If Dir is SelectSend, the case represents a send operation. Normally Chan's underlying value must be a channel, and Send's underlying value must be assignable to the channel's element type. As a special case, if Chan is a zero Value, then the case is ignored, and the field Send will also be ignored and may be either zero or non-zero.  If Dir is [SelectRecv], the case represents a receive operation. Normally Chan's underlying value must be a channel and Send must be a zero Value. If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value. When a receive operation is selected, the received Value is returned by Select."
      },
      {
        "name": "SelectDir",
        "desc": "A SelectDir describes the communication direction of a select case."
      },
      {
        "name": "SliceHeader",
        "desc": "SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.  Deprecated: Use unsafe.Slice or unsafe.SliceData instead."
      },
      {
        "name": "StringHeader",
        "desc": "StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.  Deprecated: Use unsafe.String or unsafe.StringData instead."
      },
      {
        "name": "StructField",
        "desc": "A StructField describes a single field in a struct."
      },
      {
        "name": "StructTag",
        "desc": "A StructTag is the tag string in a struct field.  By convention, tag strings are a concatenation of optionally space-separated key:\"value\" pairs. Each key is a non-empty string consisting of non-control characters other than space (U+0020 ' '), quote (U+0022 '\"'), and colon (U+003A ':').  Each value is quoted using U+0022 '\"' characters and Go string literal syntax."
      },
      {
        "name": "Type",
        "desc": "Type is the representation of a Go type.  Not all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic.  Type values are comparable, such as with the == operator, so they can be used as map keys. Two Type values are equal if they represent identical types."
      },
      {
        "name": "Value",
        "desc": "Value is the reflection interface to a Go value.  Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.  The zero Value represents no value. Its [Value.IsValid] method returns false, its Kind method returns [Invalid], its String method returns \"\u003cinvalid Value\u003e\", and all other methods panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.  A Value can be used concurrently by multiple goroutines provided that the underlying Go value can be used concurrently for the equivalent direct operations.  To compare two Values, compare the results of the Interface method. Using == on two Values does not compare the underlying values they represent."
      },
      {
        "name": "ValueError",
        "desc": "A ValueError occurs when a Value method is invoked on a [Value] that does not support it. Such cases are documented in the description of each method."
      },
      {
        "name": "aNameOff",
        "desc": ""
      },
      {
        "name": "aTextOff",
        "desc": ""
      },
      {
        "name": "aTypeOff",
        "desc": ""
      },
      {
        "name": "abiDesc",
        "desc": "abiDesc describes the ABI for a function or method."
      },
      {
        "name": "abiSeq",
        "desc": "abiSeq represents a sequence of ABI instructions for copying from a series of reflect.Values to a call frame (for call arguments) or vice-versa (for call results).  An abiSeq should be populated by calling its addArg method."
      },
      {
        "name": "abiStep",
        "desc": "abiStep represents an ABI \"instruction.\" Each instruction describes one part of how to translate between a Go value in memory and a call frame."
      },
      {
        "name": "abiStepKind",
        "desc": "abiStepKind is the \"op-code\" for an abiStep instruction."
      },
      {
        "name": "arrayType",
        "desc": "arrayType represents a fixed array type."
      },
      {
        "name": "bitVector",
        "desc": "Note: this type must agree with runtime.bitvector."
      },
      {
        "name": "cacheKey",
        "desc": "A cacheKey is the key for use in the lookupCache. Four values describe any of the types we are looking for: type kind, one or two subtypes, and an extra integer."
      },
      {
        "name": "chanType",
        "desc": "chanType represents a channel type."
      },
      {
        "name": "common",
        "desc": "Embed this type to get common/uncommon"
      },
      {
        "name": "fieldScan",
        "desc": "A fieldScan represents an item on the fieldByNameFunc scan work list."
      },
      {
        "name": "flag",
        "desc": ""
      },
      {
        "name": "funcType",
        "desc": "funcType represents a function type.  A *rtype for each in and out parameter is stored in an array that directly follows the funcType (and possibly its uncommonType). So a function type with one method, one input, and one output is:  \tstruct { \t\tfuncType \t\tuncommonType \t\t[2]*rtype    // [0] is in, [1] is out \t}"
      },
      {
        "name": "hiter",
        "desc": "TODO(prattmic): only for sharing the linkname declarations with old maps. Remove with old maps."
      },
      {
        "name": "interfaceType",
        "desc": "interfaceType represents an interface type."
      },
      {
        "name": "layoutKey",
        "desc": ""
      },
      {
        "name": "layoutType",
        "desc": ""
      },
      {
        "name": "makeFuncCtxt",
        "desc": "This structure must be kept in sync with runtime.reflectMethodValue. Any changes should be reflected in all both."
      },
      {
        "name": "makeFuncImpl",
        "desc": "makeFuncImpl is the closure value implementing the function returned by MakeFunc. The first three words of this type must be kept in sync with methodValue and runtime.reflectMethodValue. Any changes should be reflected in all three."
      },
      {
        "name": "mapType",
        "desc": "mapType represents a map type.  TODO(prattmic): Only used within this file, could be cleaned up."
      },
      {
        "name": "methodValue",
        "desc": "The first 3 words of this type must be kept in sync with makeFuncImpl and runtime.reflectMethodValue. Any changes should be reflected in all three."
      },
      {
        "name": "nonEmptyInterface",
        "desc": "nonEmptyInterface is the header for an interface value with methods."
      },
      {
        "name": "pinUnexpMeth",
        "desc": ""
      },
      {
        "name": "ptrType",
        "desc": "ptrType represents a pointer type."
      },
      {
        "name": "rtype",
        "desc": "rtype is the common implementation of most values. It is embedded in other struct types."
      },
      {
        "name": "runtimeSelect",
        "desc": "A runtimeSelect is a single case passed to rselect. This must match ../runtime/select.go:/runtimeSelect"
      },
      {
        "name": "sliceType",
        "desc": "sliceType represents a slice type."
      },
      {
        "name": "structField",
        "desc": "Struct field"
      },
      {
        "name": "structType",
        "desc": "structType represents a struct type."
      },
      {
        "name": "structTypeUncommon",
        "desc": ""
      },
      {
        "name": "uncommonType",
        "desc": "uncommonType is present only for defined types or types with methods (if T is a defined type, the uncommonTypes for T and *T have methods). Using a pointer to this struct reduces the overall size required to describe a non-defined type with no methods."
      },
      {
        "name": "visibleFieldsWalker",
        "desc": ""
      },
      {
        "name": "visit",
        "desc": "During deepValueEqual, must keep track of checks that are in progress. The comparison algorithm assumes that all checks in progress are true when it reencounters them. Visited comparisons are stored in a map indexed by visit."
      }
    ]
  },
  {
    "name": "regexp",
    "desc": "Package regexp implements regular expression search.  The syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at https://golang.org/s/re2syntax, except for \\C. For an overview of the syntax, see the [regexp/syntax] package.  The regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see https://swtch.com/~rsc/regexp/regexp1.html or any book about automata theory.  All characters are UTF-8-encoded code points. Following [utf8.DecodeRune], each byte of an invalid UTF-8 sequence is treated as if it encoded utf8.RuneError (U+FFFD).  There are 16 methods of [Regexp] that match a regular expression and identify the matched text. Their names are matched by this regular expression:  \tFind(All)?(String)?(Submatch)?(Index)?  If 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n \u003e= 0, the function returns at most n matches/submatches; otherwise, it returns all of them.  If 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate.  If 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 is the match of the first parenthesized subexpression, and so on.  If 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+2] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match.  There is also a subset of the methods that can be applied to text read from an [io.RuneReader]: [Regexp.MatchReader], [Regexp.FindReaderIndex], [Regexp.FindReaderSubmatchIndex].  This set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from an [io.RuneReader] may read arbitrarily far into the input before returning.  (There are a few other methods that do not match this pattern.)",
    "functions": [
      {
        "name": "BenchmarkAnchoredLiteralLongNonMatch",
        "desc": ""
      },
      {
        "name": "BenchmarkAnchoredLiteralShortNonMatch",
        "desc": ""
      },
      {
        "name": "BenchmarkAnchoredLongMatch",
        "desc": ""
      },
      {
        "name": "BenchmarkAnchoredShortMatch",
        "desc": ""
      },
      {
        "name": "BenchmarkCompile",
        "desc": ""
      },
      {
        "name": "BenchmarkFind",
        "desc": ""
      },
      {
        "name": "BenchmarkFindAllNoMatches",
        "desc": ""
      },
      {
        "name": "BenchmarkFindString",
        "desc": ""
      },
      {
        "name": "BenchmarkFindStringSubmatch",
        "desc": ""
      },
      {
        "name": "BenchmarkFindSubmatch",
        "desc": ""
      },
      {
        "name": "BenchmarkLiteral",
        "desc": ""
      },
      {
        "name": "BenchmarkMatch",
        "desc": ""
      },
      {
        "name": "BenchmarkMatchClass",
        "desc": ""
      },
      {
        "name": "BenchmarkMatchClass_InRange",
        "desc": ""
      },
      {
        "name": "BenchmarkMatchParallelCopied",
        "desc": ""
      },
      {
        "name": "BenchmarkMatchParallelShared",
        "desc": ""
      },
      {
        "name": "BenchmarkMatch_onepass_regex",
        "desc": ""
      },
      {
        "name": "BenchmarkNotLiteral",
        "desc": ""
      },
      {
        "name": "BenchmarkNotOnePassShortA",
        "desc": ""
      },
      {
        "name": "BenchmarkNotOnePassShortB",
        "desc": ""
      },
      {
        "name": "BenchmarkOnePassLongNotPrefix",
        "desc": ""
      },
      {
        "name": "BenchmarkOnePassLongPrefix",
        "desc": ""
      },
      {
        "name": "BenchmarkOnePassShortA",
        "desc": ""
      },
      {
        "name": "BenchmarkOnePassShortB",
        "desc": ""
      },
      {
        "name": "BenchmarkQuoteMetaAll",
        "desc": ""
      },
      {
        "name": "BenchmarkQuoteMetaNone",
        "desc": ""
      },
      {
        "name": "BenchmarkReplaceAll",
        "desc": ""
      },
      {
        "name": "Match",
        "desc": "Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use [Compile] and the full [Regexp] interface."
      },
      {
        "name": "MatchReader",
        "desc": "MatchReader reports whether the text returned by the [io.RuneReader] contains any match of the regular expression pattern. More complicated queries need to use [Compile] and the full [Regexp] interface."
      },
      {
        "name": "MatchString",
        "desc": "MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use [Compile] and the full [Regexp] interface."
      },
      {
        "name": "QuoteMeta",
        "desc": "QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text."
      },
      {
        "name": "TestBadCompile",
        "desc": ""
      },
      {
        "name": "TestCompileOnePass",
        "desc": ""
      },
      {
        "name": "TestCopyMatch",
        "desc": ""
      },
      {
        "name": "TestDeepEqual",
        "desc": ""
      },
      {
        "name": "TestFind",
        "desc": ""
      },
      {
        "name": "TestFindAll",
        "desc": ""
      },
      {
        "name": "TestFindAllIndex",
        "desc": ""
      },
      {
        "name": "TestFindAllString",
        "desc": ""
      },
      {
        "name": "TestFindAllStringIndex",
        "desc": ""
      },
      {
        "name": "TestFindAllStringSubmatch",
        "desc": ""
      },
      {
        "name": "TestFindAllStringSubmatchIndex",
        "desc": ""
      },
      {
        "name": "TestFindAllSubmatch",
        "desc": ""
      },
      {
        "name": "TestFindAllSubmatchIndex",
        "desc": ""
      },
      {
        "name": "TestFindIndex",
        "desc": ""
      },
      {
        "name": "TestFindReaderIndex",
        "desc": ""
      },
      {
        "name": "TestFindReaderSubmatchIndex",
        "desc": ""
      },
      {
        "name": "TestFindString",
        "desc": ""
      },
      {
        "name": "TestFindStringIndex",
        "desc": ""
      },
      {
        "name": "TestFindStringSubmatch",
        "desc": ""
      },
      {
        "name": "TestFindStringSubmatchIndex",
        "desc": ""
      },
      {
        "name": "TestFindSubmatch",
        "desc": ""
      },
      {
        "name": "TestFindSubmatchIndex",
        "desc": ""
      },
      {
        "name": "TestFowler",
        "desc": "TestFowler runs this package's regexp API against the POSIX regular expression tests collected by Glenn Fowler at http://www2.research.att.com/~astopen/testregex/testregex.html."
      },
      {
        "name": "TestGoodCompile",
        "desc": ""
      },
      {
        "name": "TestLiteralPrefix",
        "desc": ""
      },
      {
        "name": "TestLongest",
        "desc": ""
      },
      {
        "name": "TestMatch",
        "desc": ""
      },
      {
        "name": "TestMatchFunction",
        "desc": ""
      },
      {
        "name": "TestMergeRuneSet",
        "desc": ""
      },
      {
        "name": "TestMinInputLen",
        "desc": ""
      },
      {
        "name": "TestOnePassCutoff",
        "desc": "Check that one-pass cutoff does trigger."
      },
      {
        "name": "TestParseAndCompile",
        "desc": "The following sequence of Match calls used to panic. See issue #12980."
      },
      {
        "name": "TestProgramTooLongForBacktrack",
        "desc": "TestProgramTooLongForBacktrack tests that a regex which is too long for the backtracker still executes properly."
      },
      {
        "name": "TestQuoteMeta",
        "desc": ""
      },
      {
        "name": "TestRE2Exhaustive",
        "desc": "This test is excluded when running under the race detector because it is a very expensive test and takes too long."
      },
      {
        "name": "TestRE2Search",
        "desc": "TestRE2 tests this package's regexp API against test cases considered during RE2's exhaustive tests, which run all possible regexps over a given set of atoms and operators, up to a given complexity, over all possible strings over a given alphabet, up to a given size. Rather than try to link with RE2, we read a log file containing the test cases and the expected matches. The log file, re2-exhaustive.txt, is generated by running 'make log' in the open source RE2 distribution https://github.com/google/re2/.  The test file format is a sequence of stanzas like:  \tstrings \t\"abc\" \t\"123x\" \tregexps \t\"[a-z]+\" \t0-3;0-3 \t-;- \t\"([0-9])([0-9])([0-9])\" \t-;- \t-;0-3 0-1 1-2 2-3  The stanza begins by defining a set of strings, quoted using Go double-quote syntax, one per line. Then the regexps section gives a sequence of regexps to run on the strings. In the block that follows a regexp, each line gives the semicolon-separated match results of running the regexp on the corresponding string. Each match result is either a single -, meaning no match, or a space-separated sequence of pairs giving the match and submatch indices. An unmatched subexpression formats its pair as a single - (not illustrated above).  For now each regexp run produces two match results, one for a “full match” that restricts the regexp to matching the entire string or nothing, and one for a “partial match” that gives the leftmost first match found in the string.  Lines beginning with # are comments. Lines beginning with a capital letter are test names printed during RE2's test suite and are echoed into t but otherwise ignored.  At time of writing, re2-exhaustive.txt is 59 MB but compresses to 385 kB, so we store re2-exhaustive.txt.bz2 in the repository and decompress it on the fly."
      },
      {
        "name": "TestReplaceAll",
        "desc": ""
      },
      {
        "name": "TestReplaceAllFunc",
        "desc": ""
      },
      {
        "name": "TestReplaceAllLiteral",
        "desc": ""
      },
      {
        "name": "TestRunOnePass",
        "desc": ""
      },
      {
        "name": "TestSplit",
        "desc": ""
      },
      {
        "name": "TestSubexp",
        "desc": ""
      },
      {
        "name": "TestSwitchBacktrack",
        "desc": "Check that the same machine can be used with the standard matcher and then the backtracker when there are no captures."
      },
      {
        "name": "TestUnmarshalText",
        "desc": ""
      },
      {
        "name": "build",
        "desc": "build is a helper to construct a [][]int by extracting n sequences from x. This represents n matches with len(x)/n submatches each."
      },
      {
        "name": "cleanupOnePass",
        "desc": "cleanupOnePass drops working memory, and restores certain shortcut instructions."
      },
      {
        "name": "copyMatchTest",
        "desc": ""
      },
      {
        "name": "extract",
        "desc": "extract returns the name from a leading \"name\" or \"{name}\" in str. (The $ has already been removed by the caller.) If it is a number, extract returns num set to that number; otherwise num = -1."
      },
      {
        "name": "freeBitState",
        "desc": ""
      },
      {
        "name": "freeOnePassMachine",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "iop",
        "desc": ""
      },
      {
        "name": "isSingleBytes",
        "desc": ""
      },
      {
        "name": "makeText",
        "desc": ""
      },
      {
        "name": "matchFull",
        "desc": ""
      },
      {
        "name": "matchFullLongest",
        "desc": ""
      },
      {
        "name": "matchFunctionTest",
        "desc": ""
      },
      {
        "name": "matchPartial",
        "desc": ""
      },
      {
        "name": "matchPartialLongest",
        "desc": ""
      },
      {
        "name": "matchTest",
        "desc": ""
      },
      {
        "name": "maxBitStateLen",
        "desc": "maxBitStateLen returns the maximum length of a string to search with the backtracker using prog."
      },
      {
        "name": "mergeRuneSets",
        "desc": ""
      },
      {
        "name": "minInputLen",
        "desc": "minInputLen walks the regexp to find the minimum length of any matchable input."
      },
      {
        "name": "onePassNext",
        "desc": "onePassNext selects the next actionable state of the prog, based on the input character. It should only be called when i.Op == InstAlt or InstAltMatch, and from the one-pass machine. One of the alternates may ultimately lead without input to end of line. If the instruction is InstAltMatch the path to the InstMatch is in i.Out, the normal node in i.Next."
      },
      {
        "name": "onePassPrefix",
        "desc": "onePassPrefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. Pc is the index of the last rune instruction in the string. The onePassPrefix skips over the mandatory EmptyBeginText."
      },
      {
        "name": "parseFowlerResult",
        "desc": ""
      },
      {
        "name": "parseResult",
        "desc": ""
      },
      {
        "name": "quote",
        "desc": ""
      },
      {
        "name": "runFull",
        "desc": ""
      },
      {
        "name": "runFullLongest",
        "desc": ""
      },
      {
        "name": "runPartial",
        "desc": ""
      },
      {
        "name": "runPartialLongest",
        "desc": ""
      },
      {
        "name": "shouldBacktrack",
        "desc": "shouldBacktrack reports whether the program is too long for the backtracker to run."
      },
      {
        "name": "special",
        "desc": "special reports whether byte b needs to be escaped by QuoteMeta."
      },
      {
        "name": "testFindAllIndex",
        "desc": ""
      },
      {
        "name": "testFindAllSubmatchIndex",
        "desc": ""
      },
      {
        "name": "testFindIndex",
        "desc": ""
      },
      {
        "name": "testFindSubmatchIndex",
        "desc": ""
      },
      {
        "name": "testFowler",
        "desc": ""
      },
      {
        "name": "testRE2",
        "desc": ""
      },
      {
        "name": "testSubmatchBytes",
        "desc": ""
      },
      {
        "name": "testSubmatchIndices",
        "desc": ""
      },
      {
        "name": "testSubmatchString",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements [encoding.TextAppender]. The output matches that of calling the [Regexp.String] method.  Note that the output is lossy in some cases: This method does not indicate POSIX regular expressions (i.e. those compiled by calling [CompilePOSIX]), or those for which the [Regexp.Longest] method has been called."
      },
      {
        "name": "Copy",
        "desc": "Copy returns a new [Regexp] object copied from re. Calling [Regexp.Longest] on one copy does not affect another.  Deprecated: In earlier releases, when using a [Regexp] in multiple goroutines, giving each goroutine its own copy helped to avoid lock contention. As of Go 1.12, using Copy is no longer necessary to avoid lock contention. Copy may still be appropriate if the reason for its use is to make two copies with different [Regexp.Longest] settings."
      },
      {
        "name": "Expand",
        "desc": "Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by [Regexp.FindSubmatchIndex].  In the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P\u003cname\u003e...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice.  In the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.  To insert a literal $ in the output, use $$ in the template."
      },
      {
        "name": "ExpandString",
        "desc": "ExpandString is like [Regexp.Expand] but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation."
      },
      {
        "name": "Find",
        "desc": "Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match."
      },
      {
        "name": "FindAll",
        "desc": "FindAll is the 'All' version of [Regexp.Find]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllIndex",
        "desc": "FindAllIndex is the 'All' version of [Regexp.FindIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllString",
        "desc": "FindAllString is the 'All' version of [Regexp.FindString]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllStringIndex",
        "desc": "FindAllStringIndex is the 'All' version of [Regexp.FindStringIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllStringSubmatch",
        "desc": "FindAllStringSubmatch is the 'All' version of [Regexp.FindStringSubmatch]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllStringSubmatchIndex",
        "desc": "FindAllStringSubmatchIndex is the 'All' version of [Regexp.FindStringSubmatchIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllSubmatch",
        "desc": "FindAllSubmatch is the 'All' version of [Regexp.FindSubmatch]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindAllSubmatchIndex",
        "desc": "FindAllSubmatchIndex is the 'All' version of [Regexp.FindSubmatchIndex]; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindIndex",
        "desc": "FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match."
      },
      {
        "name": "FindReaderIndex",
        "desc": "FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the [io.RuneReader]. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match."
      },
      {
        "name": "FindReaderSubmatchIndex",
        "desc": "FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the [io.RuneReader], and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindString",
        "desc": "FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use [Regexp.FindStringIndex] or [Regexp.FindStringSubmatch] if it is necessary to distinguish these cases."
      },
      {
        "name": "FindStringIndex",
        "desc": "FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match."
      },
      {
        "name": "FindStringSubmatch",
        "desc": "FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindStringSubmatchIndex",
        "desc": "FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindSubmatch",
        "desc": "FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "FindSubmatchIndex",
        "desc": "FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match."
      },
      {
        "name": "LiteralPrefix",
        "desc": "LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression."
      },
      {
        "name": "Longest",
        "desc": "Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the [Regexp] and may not be called concurrently with any other methods."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements [encoding.TextMarshaler]. The output matches that of calling the [Regexp.AppendText] method.  See [Regexp.AppendText] for more information."
      },
      {
        "name": "Match",
        "desc": "Match reports whether the byte slice b contains any match of the regular expression re."
      },
      {
        "name": "MatchReader",
        "desc": "MatchReader reports whether the text returned by the [io.RuneReader] contains any match of the regular expression re."
      },
      {
        "name": "MatchString",
        "desc": "MatchString reports whether the string s contains any match of the regular expression re."
      },
      {
        "name": "NumSubexp",
        "desc": "NumSubexp returns the number of parenthesized subexpressions in this [Regexp]."
      },
      {
        "name": "ReplaceAll",
        "desc": "ReplaceAll returns a copy of src, replacing matches of the [Regexp] with the replacement text repl. Inside repl, $ signs are interpreted as in [Regexp.Expand]."
      },
      {
        "name": "ReplaceAllFunc",
        "desc": "ReplaceAllFunc returns a copy of src in which all matches of the [Regexp] have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using [Regexp.Expand]."
      },
      {
        "name": "ReplaceAllLiteral",
        "desc": "ReplaceAllLiteral returns a copy of src, replacing matches of the [Regexp] with the replacement bytes repl. The replacement repl is substituted directly, without using [Regexp.Expand]."
      },
      {
        "name": "ReplaceAllLiteralString",
        "desc": "ReplaceAllLiteralString returns a copy of src, replacing matches of the [Regexp] with the replacement string repl. The replacement repl is substituted directly, without using [Regexp.Expand]."
      },
      {
        "name": "ReplaceAllString",
        "desc": "ReplaceAllString returns a copy of src, replacing matches of the [Regexp] with the replacement string repl. Inside repl, $ signs are interpreted as in [Regexp.Expand]."
      },
      {
        "name": "ReplaceAllStringFunc",
        "desc": "ReplaceAllStringFunc returns a copy of src in which all matches of the [Regexp] have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using [Regexp.Expand]."
      },
      {
        "name": "Split",
        "desc": "Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.  The slice returned by this method consists of all the substrings of s not contained in the slice returned by [Regexp.FindAllString]. When called on an expression that contains no metacharacters, it is equivalent to [strings.SplitN].  Example:  \ts := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5) \t// s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]  The count determines the number of substrings to return:   - n \u003e 0: at most n substrings; the last substring will be the unsplit remainder;   - n == 0: the result is nil (zero substrings);   - n \u003c 0: all substrings."
      },
      {
        "name": "String",
        "desc": "String returns the source text used to compile the regular expression."
      },
      {
        "name": "SubexpIndex",
        "desc": "SubexpIndex returns the index of the first subexpression with the given name, or -1 if there is no subexpression with that name.  Note that multiple subexpressions can be written using the same name, as in (?P\u003cbob\u003ea+)(?P\u003cbob\u003eb+), which declares two subexpressions named \"bob\". In this case, SubexpIndex returns the index of the leftmost such subexpression in the regular expression."
      },
      {
        "name": "SubexpNames",
        "desc": "SubexpNames returns the names of the parenthesized subexpressions in this [Regexp]. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements [encoding.TextUnmarshaler] by calling [Compile] on the encoded value."
      },
      {
        "name": "allMatches",
        "desc": "allMatches calls deliver at most n times with the location of successive matches in the input text. The input text is b if non-nil, otherwise s."
      },
      {
        "name": "backtrack",
        "desc": "backtrack runs a backtracking search of prog on the input starting at pos."
      },
      {
        "name": "doExecute",
        "desc": "doExecute finds the leftmost match in the input, appends the position of its subexpressions to dstCap and returns dstCap.  nil is returned if no matches are found and non-nil if matches are found."
      },
      {
        "name": "doMatch",
        "desc": "doMatch reports whether either r, b or s match the regexp."
      },
      {
        "name": "doOnePass",
        "desc": "doOnePass implements r.doExecute using the one-pass execution engine."
      },
      {
        "name": "expand",
        "desc": ""
      },
      {
        "name": "get",
        "desc": "get returns a machine to use for matching re. It uses the re's machine cache if possible, to avoid unnecessary allocation."
      },
      {
        "name": "pad",
        "desc": "The number of capture values in the program may correspond to fewer capturing expressions than are in the regexp. For example, \"(a){0}\" turns into an empty program, so the maximum capture in the program is 0 but we need to return an expression for \\1.  Pad appends -1s to the slice a as needed."
      },
      {
        "name": "put",
        "desc": "put returns a machine to the correct machine pool."
      },
      {
        "name": "replaceAll",
        "desc": ""
      },
      {
        "name": "tryBacktrack",
        "desc": "tryBacktrack runs a backtracking search starting at pos."
      },
      {
        "name": "push",
        "desc": "push pushes (pc, pos, arg) onto the job stack if it should be visited."
      },
      {
        "name": "reset",
        "desc": "reset resets the state of the backtracker. end is the end position in the input. ncap is the number of captures."
      },
      {
        "name": "shouldVisit",
        "desc": "shouldVisit reports whether the combination of (pc, pos) has not been visited yet."
      },
      {
        "name": "canCheckPrefix",
        "desc": ""
      },
      {
        "name": "context",
        "desc": ""
      },
      {
        "name": "hasPrefix",
        "desc": ""
      },
      {
        "name": "index",
        "desc": ""
      },
      {
        "name": "step",
        "desc": ""
      },
      {
        "name": "canCheckPrefix",
        "desc": ""
      },
      {
        "name": "context",
        "desc": ""
      },
      {
        "name": "hasPrefix",
        "desc": ""
      },
      {
        "name": "index",
        "desc": ""
      },
      {
        "name": "step",
        "desc": ""
      },
      {
        "name": "canCheckPrefix",
        "desc": ""
      },
      {
        "name": "context",
        "desc": ""
      },
      {
        "name": "hasPrefix",
        "desc": ""
      },
      {
        "name": "index",
        "desc": ""
      },
      {
        "name": "step",
        "desc": ""
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "newBytes",
        "desc": ""
      },
      {
        "name": "newReader",
        "desc": ""
      },
      {
        "name": "newString",
        "desc": ""
      },
      {
        "name": "match",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "add adds an entry to q for pc, unless the q already has such an entry. It also recursively adds an entry for all instructions reachable from pc by following empty-width conditions satisfied by cond.  pos gives the current position in the input."
      },
      {
        "name": "alloc",
        "desc": "alloc allocates a new thread with the given instruction. It uses the free pool if possible."
      },
      {
        "name": "clear",
        "desc": "clear frees all threads on the thread queue."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "match",
        "desc": "match runs the machine over the input starting at pos. It reports whether a match was found. If so, m.matchcap holds the submatch information."
      },
      {
        "name": "step",
        "desc": "step executes one step of the machine, running each of the threads on runq and appending new threads to nextq. The step processes the rune c (which may be endOfText), which starts at position pos and ends at nextPos. nextCond gives the setting for the empty-width flags after c."
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "contains",
        "desc": ""
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "insert",
        "desc": ""
      },
      {
        "name": "insertNew",
        "desc": ""
      },
      {
        "name": "next",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "FindTest",
        "desc": "For each pattern/text pair, what is the expected output of each function? We can derive the textual results from the indexed results, the non-submatch results from the submatched results, the single results from the 'all' results, and the byte results from the string results. Therefore the table includes only the FindAllStringSubmatchIndex result."
      },
      {
        "name": "MetaTest",
        "desc": ""
      },
      {
        "name": "Regexp",
        "desc": "Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as [Regexp.Longest]."
      },
      {
        "name": "ReplaceFuncTest",
        "desc": ""
      },
      {
        "name": "ReplaceTest",
        "desc": ""
      },
      {
        "name": "bitState",
        "desc": "bitState holds state for the backtracker."
      },
      {
        "name": "entry",
        "desc": "An entry is an entry on a queue. It holds both the instruction pc and the actual thread. Some queue entries are just place holders so that the machine knows it has considered that pc. Such entries have t == nil."
      },
      {
        "name": "input",
        "desc": "input abstracts different representations of the input text. It provides one-character lookahead."
      },
      {
        "name": "inputBytes",
        "desc": "inputBytes scans a byte slice."
      },
      {
        "name": "inputReader",
        "desc": "inputReader scans a RuneReader."
      },
      {
        "name": "inputString",
        "desc": "inputString scans a string."
      },
      {
        "name": "inputs",
        "desc": ""
      },
      {
        "name": "job",
        "desc": "A job is an entry on the backtracker's job stack. It holds the instruction pc and the position in the input."
      },
      {
        "name": "lazyFlag",
        "desc": "A lazyFlag is a lazily-evaluated syntax.EmptyOp, for checking zero-width flags like ^ $ \\A \\z \\B \\b. It records the pair of relevant runes and does not determine the implied flags until absolutely necessary (most of the time, that means never)."
      },
      {
        "name": "machine",
        "desc": "A machine holds all the state during an NFA simulation for p."
      },
      {
        "name": "onePassInst",
        "desc": "A onePassInst is a single instruction in a one-pass regular expression program. It is the same as syntax.Inst except for the new 'Next' field."
      },
      {
        "name": "onePassMachine",
        "desc": ""
      },
      {
        "name": "onePassProg",
        "desc": "A onePassProg is a compiled one-pass regular expression program. It is the same as syntax.Prog except for the use of onePassInst."
      },
      {
        "name": "queue",
        "desc": "A queue is a 'sparse array' holding pending threads of execution. See https://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html"
      },
      {
        "name": "queueOnePass",
        "desc": "Sparse Array implementation is used as a queueOnePass."
      },
      {
        "name": "stringError",
        "desc": ""
      },
      {
        "name": "subexpCase",
        "desc": ""
      },
      {
        "name": "subexpIndex",
        "desc": ""
      },
      {
        "name": "thread",
        "desc": "A thread is the state of a single path through the machine: an instruction and a corresponding capture array. See https://swtch.com/~rsc/regexp/regexp2.html"
      }
    ]
  },
  {
    "name": "regexp/syntax",
    "desc": "Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package [regexp] (such as [regexp.Compile] and [regexp.Match]) instead of this package.  # Syntax  The regular expression syntax understood by this package when parsing with the [Perl] flag is as follows. Parts of the syntax can be disabled by passing alternate flags to [Parse].  Single characters:  \t.              any character, possibly including newline (flag s=true) \t[xyz]          character class \t[^xyz]         negated character class \t\\d             Perl character class \t\\D             negated Perl character class \t[[:alpha:]]    ASCII character class \t[[:^alpha:]]   negated ASCII character class \t\\pN            Unicode character class (one-letter name) \t\\p{Greek}      Unicode character class \t\\PN            negated Unicode character class (one-letter name) \t\\P{Greek}      negated Unicode character class  Composites:  \txy             x followed by y \tx|y            x or y (prefer x)  Repetitions:  \tx*             zero or more x, prefer more \tx+             one or more x, prefer more \tx?             zero or one x, prefer one \tx{n,m}         n or n+1 or ... or m x, prefer more \tx{n,}          n or more x, prefer more \tx{n}           exactly n x \tx*?            zero or more x, prefer fewer \tx+?            one or more x, prefer fewer \tx??            zero or one x, prefer zero \tx{n,m}?        n or n+1 or ... or m x, prefer fewer \tx{n,}?         n or more x, prefer fewer \tx{n}?          exactly n x  Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction.  Grouping:  \t(re)           numbered capturing group (submatch) \t(?P\u003cname\u003ere)   named \u0026 numbered capturing group (submatch) \t(?\u003cname\u003ere)    named \u0026 numbered capturing group (submatch) \t(?:re)         non-capturing group \t(?flags)       set flags within current group; non-capturing \t(?flags:re)    set flags during re; non-capturing  \tFlag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:  \ti              case-insensitive (default false) \tm              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false) \ts              let . match \\n (default false) \tU              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)  Empty strings:  \t^              at beginning of text or line (flag m=true) \t$              at end of text (like \\z not \\Z) or line (flag m=true) \t\\A             at beginning of text \t\\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other) \t\\B             not at ASCII word boundary \t\\z             at end of text  Escape sequences:  \t\\a             bell (== \\007) \t\\f             form feed (== \\014) \t\\t             horizontal tab (== \\011) \t\\n             newline (== \\012) \t\\r             carriage return (== \\015) \t\\v             vertical tab character (== \\013) \t\\*             literal *, for any punctuation character * \t\\123           octal character code (up to three digits) \t\\x7F           hex character code (exactly two digits) \t\\x{10FFFF}     hex character code \t\\Q...\\E        literal text ... even if ... has punctuation  Character class elements:  \tx              single character \tA-Z            character range (inclusive) \t\\d             Perl character class \t[:foo:]        ASCII character class foo \t\\p{Foo}        Unicode character class Foo \t\\pF            Unicode character class F (one-letter name)  Named character classes as character class elements:  \t[\\d]           digits (== \\d) \t[^\\d]          not digits (== \\D) \t[\\D]           not digits (== \\D) \t[^\\D]          not not digits (== \\d) \t[[:name:]]     named ASCII class inside character class (== [:name:]) \t[^[:name:]]    named ASCII class inside negated character class (== [:^name:]) \t[\\p{Name}]     named Unicode property inside character class (== \\p{Name}) \t[^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})  Perl character classes (all ASCII-only):  \t\\d             digits (== [0-9]) \t\\D             not digits (== [^0-9]) \t\\s             whitespace (== [\\t\\n\\f\\r ]) \t\\S             not whitespace (== [^\\t\\n\\f\\r ]) \t\\w             word characters (== [0-9A-Za-z_]) \t\\W             not word characters (== [^0-9A-Za-z_])  ASCII character classes:  \t[[:alnum:]]    alphanumeric (== [0-9A-Za-z]) \t[[:alpha:]]    alphabetic (== [A-Za-z]) \t[[:ascii:]]    ASCII (== [\\x00-\\x7F]) \t[[:blank:]]    blank (== [\\t ]) \t[[:cntrl:]]    control (== [\\x00-\\x1F\\x7F]) \t[[:digit:]]    digits (== [0-9]) \t[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%\u0026'()*+,\\-./:;\u003c=\u003e?@[\\\\\\]^_`{|}~]) \t[[:lower:]]    lower case (== [a-z]) \t[[:print:]]    printable (== [ -~] == [ [:graph:]]) \t[[:punct:]]    punctuation (== [!-/:-@[-`{-~]) \t[[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ]) \t[[:upper:]]    upper case (== [A-Z]) \t[[:word:]]     word characters (== [0-9A-Za-z_]) \t[[:xdigit:]]   hex digit (== [0-9A-Fa-f])  Unicode character classes are those in [unicode.Categories], [unicode.CategoryAliases], and [unicode.Scripts].",
    "functions": [
      {
        "name": "BenchmarkEmptyOpContext",
        "desc": ""
      },
      {
        "name": "BenchmarkIsWordChar",
        "desc": ""
      },
      {
        "name": "IsWordChar",
        "desc": "IsWordChar reports whether r is considered a “word character” during the evaluation of the \\b and \\B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_]."
      },
      {
        "name": "TestAppendRangeCollapse",
        "desc": ""
      },
      {
        "name": "TestCompile",
        "desc": ""
      },
      {
        "name": "TestFoldConstants",
        "desc": ""
      },
      {
        "name": "TestParseFoldCase",
        "desc": ""
      },
      {
        "name": "TestParseInvalidRegexps",
        "desc": ""
      },
      {
        "name": "TestParseLiteral",
        "desc": ""
      },
      {
        "name": "TestParseMatchNL",
        "desc": ""
      },
      {
        "name": "TestParseNoMatchNL",
        "desc": ""
      },
      {
        "name": "TestParseSimple",
        "desc": ""
      },
      {
        "name": "TestSimplify",
        "desc": ""
      },
      {
        "name": "TestString",
        "desc": ""
      },
      {
        "name": "TestToStringEquivalentParse",
        "desc": ""
      },
      {
        "name": "_",
        "desc": ""
      },
      {
        "name": "addSpan",
        "desc": "addSpan enables the flags f around start..last, by setting flags[start] = f and flags[last] = flagOff."
      },
      {
        "name": "appendClass",
        "desc": "appendClass returns the result of appending the class x to the class r. It assume x is clean."
      },
      {
        "name": "appendFoldedClass",
        "desc": "appendFoldedClass returns the result of appending the case folding of the class x to the class r."
      },
      {
        "name": "appendFoldedRange",
        "desc": "appendFoldedRange returns the result of appending the range lo-hi and its case folding-equivalent runes to the class r."
      },
      {
        "name": "appendLiteral",
        "desc": "appendLiteral returns the result of appending the literal x to the class r."
      },
      {
        "name": "appendNegatedClass",
        "desc": "appendNegatedClass returns the result of appending the negation of the class x to the class r. It assumes x is clean."
      },
      {
        "name": "appendNegatedTable",
        "desc": "appendNegatedTable returns the result of appending the negation of x to the class r."
      },
      {
        "name": "appendRange",
        "desc": "appendRange returns the result of appending the range lo-hi to the class r."
      },
      {
        "name": "appendTable",
        "desc": "appendTable returns the result of appending x to the class r."
      },
      {
        "name": "bw",
        "desc": ""
      },
      {
        "name": "canonicalName",
        "desc": "canonicalName returns the canonical lookup string for name. The canonical name has a leading uppercase letter and then lowercase letters, and it omits all underscores, spaces, and hyphens. (We could have used all lowercase, but this way most package unicode map keys are already canonical.)"
      },
      {
        "name": "checkUTF8",
        "desc": ""
      },
      {
        "name": "cleanAlt",
        "desc": "cleanAlt cleans re for eventual inclusion in an alternation."
      },
      {
        "name": "cleanClass",
        "desc": "cleanClass sorts the ranges (pairs of elements of r), merges them, and eliminates duplicates."
      },
      {
        "name": "dump",
        "desc": "dump prints a string representation of the regexp showing the structure explicitly."
      },
      {
        "name": "dumpInst",
        "desc": ""
      },
      {
        "name": "dumpProg",
        "desc": ""
      },
      {
        "name": "dumpRegexp",
        "desc": "dumpRegexp writes an encoding of the syntax tree for the regexp re to b. It is used during testing to distinguish between parses that might print the same using re's String method."
      },
      {
        "name": "escape",
        "desc": ""
      },
      {
        "name": "inCharClass",
        "desc": "inCharClass reports whether r is in the class. It assumes the class has been cleaned by cleanClass."
      },
      {
        "name": "initCategoryAliases",
        "desc": "initCategoryAliases initializes categoryAliases by canonicalizing unicode.CategoryAliases."
      },
      {
        "name": "isCharClass",
        "desc": "can this be represented as a character class? single-rune literal string, char class, ., and .|\\n."
      },
      {
        "name": "isUpperFold",
        "desc": ""
      },
      {
        "name": "isValidCaptureName",
        "desc": "isValidCaptureName reports whether name is a valid capture name: [A-Za-z0-9_]+. PCRE limits names to 32 bytes. Python rejects names starting with digits. We don't enforce either of those."
      },
      {
        "name": "isalnum",
        "desc": ""
      },
      {
        "name": "matchRune",
        "desc": "does re match r?"
      },
      {
        "name": "mergeCharClass",
        "desc": "mergeCharClass makes dst = dst|src. The caller must ensure that dst.Op \u003e= src.Op, to reduce the amount of copying."
      },
      {
        "name": "minFoldRune",
        "desc": "minFoldRune returns the minimum rune fold-equivalent to r."
      },
      {
        "name": "mkCharClass",
        "desc": ""
      },
      {
        "name": "negateClass",
        "desc": "negateClass overwrites r and returns r's negation. It assumes the class r is already clean."
      },
      {
        "name": "nextRune",
        "desc": ""
      },
      {
        "name": "repeatIsValid",
        "desc": "repeatIsValid reports whether the repetition re is valid. Valid means that the combination of the top-level repetition and any inner repetitions does not exceed n copies of the innermost thing. This function rewalks the regexp tree and is called for every repetition, so we have to worry about inducing quadratic behavior in the parser. We avoid this by only calling repeatIsValid when min or max \u003e= 2. In that case the depth of any \u003e= 2 nesting can only get to 9 without triggering a parse error, so each subtree can only be rewalked 9 times."
      },
      {
        "name": "testParseDump",
        "desc": "Test Parse -\u003e Dump."
      },
      {
        "name": "u32",
        "desc": ""
      },
      {
        "name": "unhex",
        "desc": ""
      },
      {
        "name": "unicodeTable",
        "desc": "unicodeTable returns the unicode.RangeTable identified by name and the table of additional fold-equivalent code points. If sign \u003c 0, the result should be inverted."
      },
      {
        "name": "writeRegexp",
        "desc": "writeRegexp writes the Perl syntax for the regular expression re to b."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "MatchEmptyWidth",
        "desc": "MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == [InstEmptyWidth]."
      },
      {
        "name": "MatchRune",
        "desc": "MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == [InstRune]."
      },
      {
        "name": "MatchRunePos",
        "desc": "MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == [InstRune]."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "op",
        "desc": "op returns i.Op but merges all the Rune special cases into InstRune"
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Prefix",
        "desc": "Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match."
      },
      {
        "name": "StartCond",
        "desc": "StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "skipNop",
        "desc": "skipNop follows any no-op or capturing instructions."
      },
      {
        "name": "CapNames",
        "desc": "CapNames walks the regexp to find the names of capturing groups."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether x and y have identical structure."
      },
      {
        "name": "MaxCap",
        "desc": "MaxCap walks the regexp to find the maximum capture index."
      },
      {
        "name": "Simplify",
        "desc": "Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "capNames",
        "desc": ""
      },
      {
        "name": "alt",
        "desc": ""
      },
      {
        "name": "cap",
        "desc": ""
      },
      {
        "name": "cat",
        "desc": ""
      },
      {
        "name": "compile",
        "desc": ""
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "fail",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "inst",
        "desc": ""
      },
      {
        "name": "loop",
        "desc": "loop returns the fragment for the main loop of a plus or star. For plus, it can be used after changing the entry to f1.i. For star, it can be used directly when f1 can't match an empty string. (When f1 can match an empty string, f1* must be implemented as (f1+)? to get the priority match order correct.)"
      },
      {
        "name": "nop",
        "desc": ""
      },
      {
        "name": "plus",
        "desc": ""
      },
      {
        "name": "quest",
        "desc": ""
      },
      {
        "name": "rune",
        "desc": ""
      },
      {
        "name": "star",
        "desc": ""
      },
      {
        "name": "alternate",
        "desc": "alternate replaces the top of the stack (above the topmost '(') with its alternation."
      },
      {
        "name": "appendGroup",
        "desc": ""
      },
      {
        "name": "calcHeight",
        "desc": ""
      },
      {
        "name": "calcSize",
        "desc": ""
      },
      {
        "name": "checkHeight",
        "desc": ""
      },
      {
        "name": "checkLimits",
        "desc": ""
      },
      {
        "name": "checkSize",
        "desc": ""
      },
      {
        "name": "collapse",
        "desc": "collapse returns the result of applying op to sub. If sub contains op nodes, they all get hoisted up so that there is never a concat of a concat or an alternate of an alternate."
      },
      {
        "name": "concat",
        "desc": "concat replaces the top of the stack (above the topmost '|' or '(') with its concatenation."
      },
      {
        "name": "factor",
        "desc": "factor factors common prefixes from the alternation list sub. It returns a replacement list that reuses the same storage and frees (passes to p.reuse) any removed *Regexps.  For example,  \tABC|ABD|AEF|BCX|BCY  simplifies by literal prefix extraction to  \tA(B(C|D)|EF)|BC(X|Y)  which simplifies by character class introduction to  \tA(B[CD]|EF)|BC[XY]"
      },
      {
        "name": "leadingRegexp",
        "desc": "leadingRegexp returns the leading regexp that re begins with. The regexp refers to storage in re or its children."
      },
      {
        "name": "leadingString",
        "desc": "leadingString returns the leading literal string that re begins with. The string refers to storage in re or its children."
      },
      {
        "name": "literal",
        "desc": "literal pushes a literal regexp for the rune r on the stack."
      },
      {
        "name": "maybeConcat",
        "desc": "maybeConcat implements incremental concatenation of literal runes into string nodes. The parser calls this before each push, so only the top fragment of the stack might need processing. Since this is called before a push, the topmost literal is no longer subject to operators like * (Otherwise ab* would turn into (ab)*.) If r \u003e= 0 and there's a node left over, maybeConcat uses it to push r with the given flags. maybeConcat reports whether r was pushed."
      },
      {
        "name": "newRegexp",
        "desc": ""
      },
      {
        "name": "op",
        "desc": "op pushes a regexp with the given op onto the stack and returns that regexp."
      },
      {
        "name": "parseClass",
        "desc": "parseClass parses a character class at the beginning of s and pushes it onto the parse stack."
      },
      {
        "name": "parseClassChar",
        "desc": "parseClassChar parses a character class character at the beginning of s and returns it."
      },
      {
        "name": "parseEscape",
        "desc": "parseEscape parses an escape sequence at the beginning of s and returns the rune."
      },
      {
        "name": "parseInt",
        "desc": "parseInt parses a decimal integer."
      },
      {
        "name": "parseNamedClass",
        "desc": "parseNamedClass parses a leading POSIX named character class like [:alnum:] from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string."
      },
      {
        "name": "parsePerlClassEscape",
        "desc": "parsePerlClassEscape parses a leading Perl character class escape like \\d from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string."
      },
      {
        "name": "parsePerlFlags",
        "desc": "parsePerlFlags parses a Perl flag setting or non-capturing group or both, like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state. The caller must have ensured that s begins with \"(?\"."
      },
      {
        "name": "parseRepeat",
        "desc": "parseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}. If s is not of that form, it returns ok == false. If s has the right form but the values are too big, it returns min == -1, ok == true."
      },
      {
        "name": "parseRightParen",
        "desc": "parseRightParen handles a ) in the input."
      },
      {
        "name": "parseUnicodeClass",
        "desc": "parseUnicodeClass parses a leading Unicode character class like \\p{Han} from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string."
      },
      {
        "name": "parseVerticalBar",
        "desc": "parseVerticalBar handles a | in the input."
      },
      {
        "name": "push",
        "desc": "push pushes the regexp re onto the parse stack and returns the regexp."
      },
      {
        "name": "removeLeadingRegexp",
        "desc": "removeLeadingRegexp removes the leading regexp in re. It returns the replacement for re. If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse."
      },
      {
        "name": "removeLeadingString",
        "desc": "removeLeadingString removes the first n leading runes from the beginning of re. It returns the replacement for re."
      },
      {
        "name": "repeat",
        "desc": "repeat replaces the top stack element with itself repeated according to op, min, max. before is the regexp suffix starting at the repetition operator. after is the regexp suffix following after the repetition operator. repeat returns an updated 'after' and an error, if any."
      },
      {
        "name": "reuse",
        "desc": ""
      },
      {
        "name": "swapVerticalBar",
        "desc": "If the top of the stack is an element followed by an opVerticalBar swapVerticalBar swaps the two and returns true. Otherwise it returns false."
      },
      {
        "name": "append",
        "desc": ""
      },
      {
        "name": "patch",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "EmptyOp",
        "desc": "An EmptyOp specifies a kind or mixture of zero-width assertions."
      },
      {
        "name": "Error",
        "desc": "An Error describes a failure to parse a regular expression and gives the offending expression."
      },
      {
        "name": "ErrorCode",
        "desc": "An ErrorCode describes a failure to parse a regular expression."
      },
      {
        "name": "Flags",
        "desc": "Flags control the behavior of the parser and record information about regexp context."
      },
      {
        "name": "Inst",
        "desc": "An Inst is a single instruction in a regular expression program."
      },
      {
        "name": "InstOp",
        "desc": "An InstOp is an instruction opcode."
      },
      {
        "name": "Op",
        "desc": "An Op is a single regular expression operator."
      },
      {
        "name": "Prog",
        "desc": "A Prog is a compiled regular expression program."
      },
      {
        "name": "Regexp",
        "desc": "A Regexp is a node in a regular expression syntax tree."
      },
      {
        "name": "charGroup",
        "desc": ""
      },
      {
        "name": "compiler",
        "desc": ""
      },
      {
        "name": "frag",
        "desc": "A frag represents a compiled program fragment."
      },
      {
        "name": "parseTest",
        "desc": ""
      },
      {
        "name": "parser",
        "desc": ""
      },
      {
        "name": "patchList",
        "desc": "A patchList is a list of instruction pointers that need to be filled in (patched). Because the pointers haven't been filled in yet, we can reuse their storage to hold the list. It's kind of sleazy, but works well in practice. See https://swtch.com/~rsc/regexp/regexp1.html for inspiration.  These aren't really pointers: they're integers, so we can reinterpret them this way without using package unsafe. A value l.head denotes p.inst[l.head\u003e\u003e1].Out (l.head\u00261==0) or .Arg (l.head\u00261==1). head == 0 denotes the empty list, okay because we start every program with a fail instruction, so we'll never want to point at its output link."
      },
      {
        "name": "printFlags",
        "desc": "printFlags is a bit set indicating which flags (including non-capturing parens) to print around a regexp."
      },
      {
        "name": "ranges",
        "desc": "ranges implements sort.Interface on a []rune. The choice of receiver type definition is strange but avoids an allocation since we already have a *[]rune."
      }
    ]
  },
  {
    "name": "runtime",
    "desc": "Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see [reflect]'s documentation for the programmable interface to the run-time type system.  # Environment Variables  The following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release.  The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. [runtime/debug.SetGCPercent] allows changing this percentage at run time.  The GOMEMLIMIT variable sets a soft memory limit for the runtime. This memory limit includes the Go heap and all other memory managed by the runtime, and excludes external memory sources such as mappings of the binary itself, memory managed in other languages, and memory held by the operating system on behalf of the Go program. GOMEMLIMIT is a numeric value in bytes with an optional unit suffix. The supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes represent quantities of bytes as defined by the IEC 80000-13 standard. That is, they are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes, and so on. The default setting is [math.MaxInt64], which effectively disables the memory limit. [runtime/debug.SetMemoryLimit] allows changing this limit at run time.  The GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables:  \tclobberfree: setting clobberfree=1 causes the garbage collector to \tclobber the memory content of an object with bad content when it frees \tthe object.  \tcpu.*: cpu.all=off disables the use of all optional instruction set extensions. \tcpu.extension=off disables use of instructions from the specified instruction set extension. \textension is the lower case name for the instruction set extension such as sse41 or avx \tas listed in internal/cpu package. As an example cpu.avx=off disables runtime detection \tand thereby use of AVX instructions.  \tcgocheck: setting cgocheck=0 disables all checks for packages \tusing cgo to incorrectly pass Go pointers to non-Go code. \tSetting cgocheck=1 (the default) enables relatively cheap \tchecks that may miss some errors. A more complete, but slow, \tcgocheck mode can be enabled using GOEXPERIMENT (which \trequires a rebuild), see https://pkg.go.dev/internal/goexperiment for details.  \tcheckfinalizers: setting checkfinalizers=1 causes the garbage collector to run \tmultiple partial non-parallel stop-the-world collections to identify common issues with \tfinalizers and cleanups, like those listed at \thttps://go.dev/doc/gc-guide#Finalizers_cleanups_and_weak_pointers. If a potential issue \tis found, the program will terminate with a description of all potential issues, the \tassociated values, and a list of those values' finalizers and cleanups, including where \tthey were created. It also adds tracking for tiny blocks to help diagnose issues with \tthose as well. The analysis performed during the partial collection is conservative. \tNotably, it flags any path back to the original object from the cleanup function, \tcleanup arguments, or finalizer function as a potential issue, even if that path might \tbe severed sometime later during execution (though this is not a recommended pattern). \tThis mode also produces one line of output to stderr every GC cycle with information \tabout the finalizer and cleanup queue lengths. Lines produced by this mode start with \t\"checkfinalizers:\".  \tdecoratemappings: controls whether the Go runtime annotates OS \tanonymous memory mappings with context about their purpose. These \tannotations appear in /proc/self/maps and /proc/self/smaps as \t\"[anon: Go: ...]\". This setting is only used on Linux. For Go 1.25, it \tdefaults to `decoratemappings=1`, enabling annotations. Using \t`decoratemappings=0` reverts to the pre-Go 1.25 behavior.  \tdisablethp: setting disablethp=1 on Linux disables transparent huge pages for the heap. \tIt has no effect on other platforms. disablethp is meant for compatibility with versions \tof Go before 1.21, which stopped working around a Linux kernel default that can result \tin significant memory overuse. See https://go.dev/issue/64332. This setting will be \tremoved in a future release, so operators should tweak their Linux configuration to suit \ttheir needs before then. See https://go.dev/doc/gc-guide#Linux_transparent_huge_pages.  \tdontfreezetheworld: by default, the start of a fatal panic or throw \t\"freezes the world\", preempting all threads to stop all running \tgoroutines, which makes it possible to traceback all goroutines, and \tkeeps their state close to the point of panic. Setting \tdontfreezetheworld=1 disables this preemption, allowing goroutines to \tcontinue executing during panic processing. Note that goroutines that \tnaturally enter the scheduler will still stop. This can be useful when \tdebugging the runtime scheduler, as freezetheworld perturbs scheduler \tstate and thus may hide problems.  \tefence: setting efence=1 causes the allocator to run in a mode \twhere each object is allocated on a unique page and addresses are \tnever recycled.  \tgccheckmark: setting gccheckmark=1 enables verification of the \tgarbage collector's concurrent mark phase by performing a \tsecond mark pass while the world is stopped.  If the second \tpass finds a reachable object that was not found by concurrent \tmark, the garbage collector will panic.  \tgcpacertrace: setting gcpacertrace=1 causes the garbage collector to \tprint information about the internal state of the concurrent pacer.  \tgcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines \tonto smaller stacks. In this mode, a goroutine's stack can only grow.  \tgcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection, \tmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2 \talso disables concurrent sweeping after the garbage collection finishes.  \tgctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard \terror at each collection, summarizing the amount of memory collected and the \tlength of the pause. The format of this line is subject to change. Included in \tthe explanation below is also the relevant runtime/metrics metric for each field. \tCurrently, it is: \t\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-\u003e#-\u003e# MB, # MB goal, # MB stacks, #MB globals, # P \twhere the fields are as follows: \t\tgc #         the GC number, incremented at each GC \t\t@#s          time in seconds since program start \t\t#%           percentage of time spent in GC since program start \t\t#+...+#      wall-clock/CPU times for the phases of the GC \t\t#-\u003e#-\u003e# MB   heap size at GC start, at GC end, and live heap, or /gc/scan/heap:bytes \t\t# MB goal    goal heap size, or /gc/heap/goal:bytes \t\t# MB stacks  estimated scannable stack size, or /gc/scan/stack:bytes \t\t# MB globals scannable global size, or /gc/scan/globals:bytes \t\t# P          number of processors used, or /sched/gomaxprocs:threads \tThe phases are stop-the-world (STW) sweep termination, concurrent \tmark and scan, and STW mark termination. The CPU times \tfor mark/scan are broken down in to assist time (GC performed in \tline with allocation), background GC time, and idle GC time. \tIf the line ends with \"(forced)\", this GC was forced by a \truntime.GC() call.  \tharddecommit: setting harddecommit=1 causes memory that is returned to the OS to \talso have protections removed on it. This is the only mode of operation on Windows, \tbut is helpful in debugging scavenger-related issues on other platforms. Currently, \tonly supported on Linux.  \tinittrace: setting inittrace=1 causes the runtime to emit a single line to standard \terror for each package with init work, summarizing the execution time and memory \tallocation. No information is printed for inits executed as part of plugin loading \tand for packages without both user defined and compiler generated init work. \tThe format of this line is subject to change. Currently, it is: \t\tinit # @#ms, # ms clock, # bytes, # allocs \twhere the fields are as follows: \t\tinit #      the package name \t\t@# ms       time in milliseconds when the init started since program start \t\t# clock     wall-clock time for package initialization work \t\t# bytes     memory allocated on the heap \t\t# allocs    number of heap allocations  \tmadvdontneed: setting madvdontneed=0 will use MADV_FREE \tinstead of MADV_DONTNEED on Linux when returning memory to the \tkernel. This is more efficient, but means RSS numbers will \tdrop only when the OS is under memory pressure. On the BSDs and \tIllumos/Solaris, setting madvdontneed=1 will use MADV_DONTNEED instead \tof MADV_FREE. This is less efficient, but causes RSS numbers to drop \tmore quickly.  \tmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate. \tWhen set to 0 memory profiling is disabled.  Refer to the description of \tMemProfileRate for the default value.  \tprofstackdepth: profstackdepth=128 (the default) will set the maximum stack \tdepth used by all pprof profilers except for the CPU profiler to 128 frames. \tStack traces that exceed this limit will be truncated to the limit starting \tfrom the leaf frame. Setting profstackdepth to any value above 1024 will \tsilently default to 1024. Future versions of Go may remove this limitation \tand extend profstackdepth to apply to the CPU profiler and execution tracer.  \tpagetrace: setting pagetrace=/path/to/file will write out a trace of page events \tthat can be viewed, analyzed, and visualized using the x/debug/cmd/pagetrace tool. \tBuild your program with GOEXPERIMENT=pagetrace to enable this functionality. Do not \tenable this functionality if your program is a setuid binary as it introduces a security \trisk in that scenario. Currently not supported on Windows, plan9 or js/wasm. Setting this \toption for some applications can produce large traces, so use with care.  \tpanicnil: setting panicnil=1 disables the runtime error when calling panic with nil \tinterface value or an untyped nil.  \tinvalidptr: invalidptr=1 (the default) causes the garbage collector and stack \tcopier to crash the program if an invalid pointer value (for example, 1) \tis found in a pointer-typed location. Setting invalidptr=0 disables this check. \tThis should only be used as a temporary workaround to diagnose buggy code. \tThe real fix is to not store integers in pointer-typed locations.  \tsbrk: setting sbrk=1 replaces the memory allocator and garbage collector \twith a trivial allocator that obtains memory from the operating system and \tnever reclaims any memory.  \tscavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard \terror, roughly once per GC cycle, summarizing the amount of work done by the \tscavenger as well as the total amount of memory returned to the operating system \tand an estimate of physical memory utilization. The format of this line is subject \tto change, but currently it is: \t\tscav # KiB work (bg), # KiB work (eager), # KiB total, #% util \twhere the fields are as follows: \t\t# KiB work (bg)    the amount of memory returned to the OS in the background since \t\t                   the last line \t\t# KiB work (eager) the amount of memory returned to the OS eagerly since the last line \t\t# KiB now          the amount of address space currently returned to the OS \t\t#% util            the fraction of all unscavenged heap memory which is in-use \tIf the line ends with \"(forced)\", then scavenging was forced by a \tdebug.FreeOSMemory() call.  \tscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit \tdetailed multiline info every X milliseconds, describing state of the scheduler, \tprocessors, threads and goroutines.  \tschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard \terror every X milliseconds, summarizing the scheduler state.  \ttracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at \twhich goroutines were created, where N limits the number of ancestor goroutines to \treport. This also extends the information returned by runtime.Stack. \tSetting N to 0 will report no ancestry information.  \ttracefpunwindoff: setting tracefpunwindoff=1 forces the execution tracer to \tuse the runtime's default stack unwinder instead of frame pointer unwinding. \tThis increases tracer overhead, but could be helpful as a workaround or for \tdebugging unexpected regressions caused by frame pointer unwinding.  \ttraceadvanceperiod: the approximate period in nanoseconds between trace generations. Only \tapplies if a program is built with GOEXPERIMENT=exectracer2. Used primarily for testing \tand debugging the execution tracer.  \ttracecheckstackownership: setting tracecheckstackownership=1 enables a debug check in the \texecution tracer to double-check stack ownership before taking a stack trace.  \tasyncpreemptoff: asyncpreemptoff=1 disables signal-based \tasynchronous goroutine preemption. This makes some loops \tnon-preemptible for long periods, which may delay GC and \tgoroutine scheduling. This is useful for debugging GC issues \tbecause it also disables the conservative stack scanning used \tfor asynchronously preempted goroutines.  The [net] and [net/http] packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details.  The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's [GOMAXPROCS] function queries and changes the limit.  The GORACE variable configures the race detector, for programs built using -race. See the [Race Detector article] for details.  The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. GOTRACEBACK=wer is like “crash” but doesn't disable Windows Error Reporting (WER). For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The [runtime/debug.SetTraceback] function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable.  The GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see [cmd/go] and [go/build]). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system.  # Security  On Unix platforms, Go's runtime system behaves slightly differently when a binary is setuid/setgid or executed with setuid/setgid-like properties, in order to prevent dangerous behaviors. On Linux this is determined by checking for the AT_SECURE flag in the auxiliary vector, on the BSDs and Solaris/Illumos it is determined by checking the issetugid syscall, and on AIX it is determined by checking if the uid/gid match the effective uid/gid.  When the runtime determines the binary is setuid/setgid-like, it does three main things:   - The standard input/output file descriptors (0, 1, 2) are checked to be open.     If any of them are closed, they are opened pointing at /dev/null.   - The value of the GOTRACEBACK environment variable is set to 'none'.   - When a signal is received that terminates the program, or the program     encounters an unrecoverable panic that would otherwise override the value     of GOTRACEBACK, the goroutine stack, registers, and other memory related     information are omitted.  [Race Detector article]: https://go.dev/doc/articles/race_detector",
    "functions": [
      {
        "name": "ASanRead",
        "desc": "Public address sanitizer API."
      },
      {
        "name": "ASanWrite",
        "desc": ""
      },
      {
        "name": "Acquirem",
        "desc": "Acquirem blocks preemption."
      },
      {
        "name": "BlockOnSystemStack",
        "desc": "BlockOnSystemStack switches to the system stack, prints \"x\\n\" to stderr, and blocks in a stack containing \"runtime.blockOnSystemStackInternal\"."
      },
      {
        "name": "BlockProfile",
        "desc": "BlockProfile returns n, the number of records in the current blocking profile. If len(p) \u003e= n, BlockProfile copies the profile into p and returns n, true. If len(p) \u003c n, BlockProfile does not change p and returns n, false.  Most clients should use the [runtime/pprof] package or the [testing] package's -test.blockprofile flag instead of calling BlockProfile directly."
      },
      {
        "name": "BlockUntilEmptyCleanupQueue",
        "desc": ""
      },
      {
        "name": "BlockUntilEmptyFinalizerQueue",
        "desc": ""
      },
      {
        "name": "Breakpoint",
        "desc": "Breakpoint executes a breakpoint trap."
      },
      {
        "name": "CPUProfile",
        "desc": "CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed.  Deprecated: Use the [runtime/pprof] package, or the handlers in the [net/http/pprof] package, or the [testing] package's -test.cpuprofile flag instead."
      },
      {
        "name": "Caller",
        "desc": "Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller. (For historical reasons the meaning of skip differs between Caller and [Callers].) The return values report the program counter, the file name (using forward slashes as path separator, even on Windows), and the line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information."
      },
      {
        "name": "Callers",
        "desc": "Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc.  To translate these PCs into symbolic information such as function names and line numbers, use [CallersFrames]. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using [FuncForPC] on any of the returned PCs, since these cannot account for inlining or return program counter adjustment."
      },
      {
        "name": "CheckPackScavChunkData",
        "desc": ""
      },
      {
        "name": "CheckScavengedBitsCleared",
        "desc": ""
      },
      {
        "name": "CountDebugLog",
        "desc": ""
      },
      {
        "name": "CountPagesInUse",
        "desc": ""
      },
      {
        "name": "DumpDebugLog",
        "desc": ""
      },
      {
        "name": "Envs",
        "desc": ""
      },
      {
        "name": "Escape",
        "desc": ""
      },
      {
        "name": "FPCallers",
        "desc": "FPCallers works like Callers and uses frame pointer unwinding to populate pcBuf with the return addresses of the physical frames on the stack."
      },
      {
        "name": "Fastrand",
        "desc": ""
      },
      {
        "name": "Fastrand64",
        "desc": ""
      },
      {
        "name": "Fastrandn",
        "desc": ""
      },
      {
        "name": "FillAligned",
        "desc": "Expose fillAligned for testing."
      },
      {
        "name": "FinalizerGAsleep",
        "desc": ""
      },
      {
        "name": "FindBitRange64",
        "desc": "Expose non-trivial helpers for testing."
      },
      {
        "name": "FrameStartLine",
        "desc": ""
      },
      {
        "name": "FreeMSpan",
        "desc": "Free an allocated mspan."
      },
      {
        "name": "FreePageAlloc",
        "desc": "FreePageAlloc releases hard OS resources owned by the pageAlloc. Once this is called the pageAlloc may no longer be used. The object itself will be collected by the garbage collector once it is no longer live."
      },
      {
        "name": "G0StackOverflow",
        "desc": ""
      },
      {
        "name": "GC",
        "desc": "GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program."
      },
      {
        "name": "GCMarkDoneResetRestartFlag",
        "desc": ""
      },
      {
        "name": "GCMarkDoneRestarted",
        "desc": ""
      },
      {
        "name": "GCTestIsReachable",
        "desc": "For GCTestIsReachable, it's important that we do this as a call so escape analysis can see through it."
      },
      {
        "name": "GCTestPointerClass",
        "desc": "For GCTestPointerClass, it's important that we do this as a call so escape analysis can see through it.  This is nosplit because gcTestPointerClass is."
      },
      {
        "name": "GIsWaitingOnMutex",
        "desc": ""
      },
      {
        "name": "GOMAXPROCS",
        "desc": "GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n \u003c 1, it does not change the current setting.  # Default  If the GOMAXPROCS environment variable is set to a positive whole number, GOMAXPROCS defaults to that value.  Otherwise, the Go runtime selects an appropriate default value from a combination of   - the number of logical CPUs on the machine,   - the process’s CPU affinity mask,   - and, on Linux, the process’s average CPU throughput limit based on cgroup CPU     quota, if any.  If GODEBUG=containermaxprocs=0 is set and GOMAXPROCS is not set by the environment variable, then GOMAXPROCS instead defaults to the value of [runtime.NumCPU]. Note that GODEBUG=containermaxprocs=0 is [default] for language version 1.24 and below.  # Updates  The Go runtime periodically updates the default value based on changes to the total logical CPU count, the CPU affinity mask, or cgroup quota. Setting a custom value with the GOMAXPROCS environment variable or by calling GOMAXPROCS disables automatic updates. The default value and automatic updates can be restored by calling [SetDefaultGOMAXPROCS].  If GODEBUG=updatemaxprocs=0 is set, the Go runtime does not perform automatic GOMAXPROCS updating. Note that GODEBUG=updatemaxprocs=0 is [default] for language version 1.24 and below.  # Compatibility  Note that the default GOMAXPROCS behavior may change as the scheduler improves, especially the implementation detail below.  # Implementation details  When computing default GOMAXPROCS via cgroups, the Go runtime computes the \"average CPU throughput limit\" as the cgroup CPU quota / period. In cgroup v2, these values come from the cpu.max file. In cgroup v1, they come from cpu.cfs_quota_us and cpu.cfs_period_us, respectively. In container runtimes that allow configuring CPU limits, this value usually corresponds to the \"CPU limit\" option, not \"CPU request\".  The Go runtime typically selects the default GOMAXPROCS as the minimum of the logical CPU count, the CPU affinity mask count, or the cgroup CPU throughput limit. However, it will never set GOMAXPROCS less than 2 unless the logical CPU count or CPU affinity mask count are below 2.  If the cgroup CPU throughput limit is not a whole number, the Go runtime rounds up to the next whole number.  GOMAXPROCS updates are performed up to once per second, or less if the application is idle.  [default]: https://go.dev/doc/godebug#default"
      },
      {
        "name": "GOROOT",
        "desc": "GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.  Deprecated: The root used during the Go build will not be meaningful if the binary is copied to another machine. Use the system path to locate the “go” binary, and use “go env GOROOT” to find its GOROOT."
      },
      {
        "name": "GetNextArenaHint",
        "desc": ""
      },
      {
        "name": "GetPhysPageSize",
        "desc": ""
      },
      {
        "name": "GetPinnerLeakPanic",
        "desc": ""
      },
      {
        "name": "GlobalWaitingArenaChunks",
        "desc": ""
      },
      {
        "name": "Goexit",
        "desc": "Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.  Calling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutines. If all other goroutines exit, the program crashes.  It crashes if called from a thread not created by the Go runtime."
      },
      {
        "name": "Goid",
        "desc": ""
      },
      {
        "name": "GoroutineProfile",
        "desc": "GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) \u003e= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) \u003c n, GoroutineProfile does not change p and returns n, false.  Most clients should use the [runtime/pprof] package instead of calling GoroutineProfile directly."
      },
      {
        "name": "Gosched",
        "desc": "Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically."
      },
      {
        "name": "GostringW",
        "desc": "entry point for testing"
      },
      {
        "name": "InjectDebugCall",
        "desc": "InjectDebugCall injects a debugger call to fn into g. regArgs must contain any arguments to fn that are passed in registers, according to the internal Go ABI. It may be nil if no arguments are passed in registers to fn. args must be a pointer to a valid call frame (including arguments and return space) for fn, or nil. tkill must be a function that will send SIGTRAP to thread ID tid. gp must be locked to its OS thread and running.  On success, InjectDebugCall returns the panic value of fn or nil. If fn did not panic, its results will be available in args."
      },
      {
        "name": "KeepAlive",
        "desc": "KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.  A very simplified example showing where KeepAlive is required:  \ttype File struct { d int } \td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0) \t// ... do something if err != nil ... \tp := \u0026File{d} \truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) }) \tvar buf [10]byte \tn, err := syscall.Read(p.d, buf[:]) \t// Ensure p is not finalized until Read returns. \truntime.KeepAlive(p) \t// No more uses of p after this point.  Without the KeepAlive call, the finalizer could run at the start of [syscall.Read], closing the file descriptor before syscall.Read makes the actual system call.  Note: KeepAlive should only be used to prevent finalizers from running prematurely. In particular, when used with [unsafe.Pointer], the rules for valid uses of unsafe.Pointer still apply."
      },
      {
        "name": "KeepNArenaHints",
        "desc": ""
      },
      {
        "name": "LFNodeValidate",
        "desc": ""
      },
      {
        "name": "LFStackPush",
        "desc": ""
      },
      {
        "name": "LockOSCounts",
        "desc": ""
      },
      {
        "name": "LockOSThread",
        "desc": "LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to [UnlockOSThread] as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.  All init functions are run on the startup thread. Calling LockOSThread from an init function will cause the main function to be invoked on that thread.  A goroutine should call LockOSThread before calling OS services or non-Go library functions that depend on per-thread state."
      },
      {
        "name": "MSanRead",
        "desc": ""
      },
      {
        "name": "MSanWrite",
        "desc": ""
      },
      {
        "name": "MSpanCountAlloc",
        "desc": ""
      },
      {
        "name": "MapBucketsCount",
        "desc": ""
      },
      {
        "name": "MapBucketsPointerIsNil",
        "desc": ""
      },
      {
        "name": "MapNextArenaHint",
        "desc": "MapNextArenaHint reserves a page at the next arena growth hint, preventing the arena from growing there, and returns the range of addresses that are no longer viable.  This may fail to reserve memory. If it fails, it still returns the address range it attempted to reserve."
      },
      {
        "name": "MapTombstoneCheck",
        "desc": ""
      },
      {
        "name": "MemProfile",
        "desc": "MemProfile returns a profile of memory allocated and freed per allocation site.  MemProfile returns n, the number of records in the current memory profile. If len(p) \u003e= n, MemProfile copies the profile into p and returns n, true. If len(p) \u003c n, MemProfile does not change p and returns n, false.  If inuseZero is true, the profile includes allocation records where r.AllocBytes \u003e 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime.  The returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector.  Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly."
      },
      {
        "name": "MemclrBytes",
        "desc": ""
      },
      {
        "name": "MutexProfile",
        "desc": "MutexProfile returns n, the number of records in the current mutex profile. If len(p) \u003e= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.  Most clients should use the [runtime/pprof] package instead of calling MutexProfile directly."
      },
      {
        "name": "MyGenericFunc",
        "desc": ""
      },
      {
        "name": "Netpoll",
        "desc": ""
      },
      {
        "name": "NumCPU",
        "desc": "NumCPU returns the number of logical CPUs usable by the current process.  The set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected."
      },
      {
        "name": "NumCgoCall",
        "desc": "NumCgoCall returns the number of cgo calls made by the current process."
      },
      {
        "name": "NumGoroutine",
        "desc": "NumGoroutine returns the number of goroutines that currently exist."
      },
      {
        "name": "NumberOfProcessors",
        "desc": ""
      },
      {
        "name": "OverLoadFactor",
        "desc": ""
      },
      {
        "name": "PageBase",
        "desc": "PageBase returns an address given a chunk index and a page index relative to that chunk."
      },
      {
        "name": "PageCachePagesLeaked",
        "desc": ""
      },
      {
        "name": "PanicForTesting",
        "desc": ""
      },
      {
        "name": "PersistentAlloc",
        "desc": "PersistentAlloc allocates some memory that lives outside the Go heap. This memory will never be freed; use sparingly."
      },
      {
        "name": "Pipe",
        "desc": ""
      },
      {
        "name": "PointerMask",
        "desc": ""
      },
      {
        "name": "RaceAcquire",
        "desc": "RaceAcquire/RaceRelease/RaceReleaseMerge establish happens-before relations between goroutines. These inform the race detector about actual synchronization that it can't see for some reason (e.g. synchronization within RaceDisable/RaceEnable sections of code). RaceAcquire establishes a happens-before relation with the preceding RaceReleaseMerge on addr up to and including the last RaceRelease on addr. In terms of the C memory model (C11 §5.1.2.4, §7.17.3), RaceAcquire is equivalent to atomic_load(memory_order_acquire)."
      },
      {
        "name": "RaceDisable",
        "desc": "RaceDisable disables handling of race synchronization events in the current goroutine. Handling is re-enabled with RaceEnable. RaceDisable/RaceEnable can be nested. Non-synchronization events (memory accesses, function entry/exit) still affect the race detector."
      },
      {
        "name": "RaceEnable",
        "desc": "RaceEnable re-enables handling of race events in the current goroutine."
      },
      {
        "name": "RaceErrors",
        "desc": ""
      },
      {
        "name": "RaceRead",
        "desc": ""
      },
      {
        "name": "RaceReadRange",
        "desc": ""
      },
      {
        "name": "RaceRelease",
        "desc": "RaceRelease performs a release operation on addr that can synchronize with a later RaceAcquire on addr.  In terms of the C memory model, RaceRelease is equivalent to atomic_store(memory_order_release)."
      },
      {
        "name": "RaceReleaseMerge",
        "desc": "RaceReleaseMerge is like RaceRelease, but also establishes a happens-before relation with the preceding RaceRelease or RaceReleaseMerge on addr.  In terms of the C memory model, RaceReleaseMerge is equivalent to atomic_exchange(memory_order_release)."
      },
      {
        "name": "RaceWrite",
        "desc": ""
      },
      {
        "name": "RaceWriteRange",
        "desc": ""
      },
      {
        "name": "ReadMemStats",
        "desc": "ReadMemStats populates m with memory allocator statistics.  The returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle."
      },
      {
        "name": "ReadMetricsSlow",
        "desc": ""
      },
      {
        "name": "ReadTrace",
        "desc": "ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time."
      },
      {
        "name": "Releasem",
        "desc": ""
      },
      {
        "name": "ResetDebugLog",
        "desc": ""
      },
      {
        "name": "RunGetgThreadSwitchTest",
        "desc": ""
      },
      {
        "name": "RunSchedLocalQueueEmptyTest",
        "desc": ""
      },
      {
        "name": "RunSchedLocalQueueStealTest",
        "desc": ""
      },
      {
        "name": "RunSchedLocalQueueTest",
        "desc": ""
      },
      {
        "name": "RunStealOrderTest",
        "desc": ""
      },
      {
        "name": "SemNwait",
        "desc": ""
      },
      {
        "name": "SendSigusr1",
        "desc": "SendSigusr1 sends SIGUSR1 to mp."
      },
      {
        "name": "SetBlockProfileRate",
        "desc": "SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.  To include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate \u003c= 0."
      },
      {
        "name": "SetCPUProfileRate",
        "desc": "SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz \u003c= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.  Most clients should use the [runtime/pprof] package or the [testing] package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly."
      },
      {
        "name": "SetCgoTraceback",
        "desc": "SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.  The traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory.  None of the functions may call back into Go.  The context function will be called with a single argument, a pointer to a struct:  \tstruct { \t\tContext uintptr \t}  In C syntax, this struct will be  \tstruct { \t\tuintptr_t Context; \t};  If the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code.  If the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources.  While it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient.  The traceback function will be called with a single argument, a pointer to a struct:  \tstruct { \t\tContext    uintptr \t\tSigContext uintptr \t\tBuf        *uintptr \t\tMax        uintptr \t}  In C syntax, this struct will be  \tstruct { \t\tuintptr_t  Context; \t\tuintptr_t  SigContext; \t\tuintptr_t* Buf; \t\tuintptr_t  Max; \t};  The Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code.  Otherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value.  If the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero.  Buf is where the traceback information should be stored. It should be PC values, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that function's caller, and so on.  Max is the maximum number of entries to store.  The function should store a zero to indicate the top of the stack, or that the caller is on a different stack, presumably a Go stack.  Unlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction.  No additional subtraction is required or appropriate.  On all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, linux/arm64, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls.  The symbolizer function will be called with a single argument, a pointer to a struct:  \tstruct { \t\tPC      uintptr // program counter to fetch information for \t\tFile    *byte   // file name (NUL terminated) \t\tLineno  uintptr // line number \t\tFunc    *byte   // function name (NUL terminated) \t\tEntry   uintptr // function entry point \t\tMore    uintptr // set non-zero if more info for this PC \t\tData    uintptr // unused by runtime, available for function \t}  In C syntax, this struct will be  \tstruct { \t\tuintptr_t PC; \t\tchar*     File; \t\tuintptr_t Lineno; \t\tchar*     Func; \t\tuintptr_t Entry; \t\tuintptr_t More; \t\tuintptr_t Data; \t};  The PC field will be a value returned by a call to the traceback function.  The first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls.  When calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero.  The symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero.  If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack.  SetCgoTraceback should be called only once, ideally from an init function."
      },
      {
        "name": "SetDefaultGOMAXPROCS",
        "desc": "SetDefaultGOMAXPROCS updates the GOMAXPROCS setting to the runtime default, as described by [GOMAXPROCS], ignoring the GOMAXPROCS environment variable.  SetDefaultGOMAXPROCS can be used to enable the default automatic updating GOMAXPROCS behavior if it has been disabled by the GOMAXPROCS environment variable or a prior call to [GOMAXPROCS], or to force an immediate update if the caller is aware of a change to the total logical CPU count, CPU affinity mask or cgroup quota."
      },
      {
        "name": "SetEnvs",
        "desc": ""
      },
      {
        "name": "SetFinalizer",
        "desc": "SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.  SetFinalizer(obj, nil) clears any finalizer associated with obj.  New Go code should consider using [AddCleanup] instead, which is much less error-prone than SetFinalizer.  The argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program.  Finalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies.  The finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an [os.File] object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a [bufio.Writer], because the buffer would not be flushed at program exit.  It is not guaranteed that a finalizer will run if the size of *obj is zero bytes, because it may share same address with other zero-size objects in memory. See https://go.dev/ref/spec#Size_and_alignment_guarantees.  It is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated.  Note that because finalizers may execute arbitrarily far into the future after an object is no longer referenced, the runtime is allowed to perform a space-saving optimization that batches objects together in a single allocation slot. The finalizer for an unreferenced object in such an allocation may never run if it always exists in the same batch as a referenced object. Typically, this batching only happens for tiny (on the order of 16 bytes or less) and pointer-free objects.  A finalizer may run as soon as an object becomes unreachable. In order to use finalizers correctly, the program must ensure that the object is reachable until it is no longer required. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. A function argument or receiver may become unreachable at the last point where the function mentions it. To make an unreachable object reachable, pass the object to a call of the [KeepAlive] function to mark the last point in the function where the object must be reachable.  For example, if p points to a struct, such as os.File, that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters [syscall.Write]. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call KeepAlive(p) after the call to syscall.Write.  A single goroutine runs all finalizers for a program, sequentially. If a finalizer must run for a long time, it should do so by starting a new goroutine.  In the terminology of the Go memory model, a call SetFinalizer(x, f) “synchronizes before” the finalization call f(x). However, there is no guarantee that KeepAlive(x) or any other use of x “synchronizes before” f(x), so in general a finalizer should use a mutex or other synchronization mechanism if it needs to access mutable state in x. For example, consider a finalizer that inspects a mutable field in x that is modified from time to time in the main program before x becomes unreachable and the finalizer is invoked. The modifications in the main program and the inspection in the finalizer need to use appropriate synchronization, such as mutexes or atomic updates, to avoid read-write races."
      },
      {
        "name": "SetIntArgRegs",
        "desc": ""
      },
      {
        "name": "SetMutexProfileFraction",
        "desc": "SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.  To turn off profiling entirely, pass rate 0. To just read the current rate, pass rate \u003c 0. (For n\u003e1 the details of sampling may change.)"
      },
      {
        "name": "SetPinnerLeakPanic",
        "desc": ""
      },
      {
        "name": "SetSpinInGCMarkDone",
        "desc": ""
      },
      {
        "name": "SetTracebackEnv",
        "desc": "SetTracebackEnv is like runtime/debug.SetTraceback, but it raises the \"environment\" traceback level, so later calls to debug.SetTraceback (e.g., from testing timeouts) can't lower it."
      },
      {
        "name": "SetVMANameSupported",
        "desc": ""
      },
      {
        "name": "ShrinkStackAndVerifyFramePointers",
        "desc": "ShrinkStackAndVerifyFramePointers attempts to shrink the stack of the current goroutine and verifies that unwinding the new stack doesn't crash, even if the old stack has been freed or reused (simulated via poisoning)."
      },
      {
        "name": "Sigisblocked",
        "desc": ""
      },
      {
        "name": "Stack",
        "desc": "Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine."
      },
      {
        "name": "StartTrace",
        "desc": "StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via [ReadTrace]. StartTrace returns an error if tracing is already enabled. Most clients should use the [runtime/trace] package or the [testing] package's -test.trace flag instead of calling StartTrace directly."
      },
      {
        "name": "StopTrace",
        "desc": "StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed."
      },
      {
        "name": "StringifyPallocBits",
        "desc": "StringifyPallocBits gets the bits in the bit range r from b, and returns a string containing the bits as ASCII 0 and 1 characters."
      },
      {
        "name": "ThreadCreateProfile",
        "desc": "ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) \u003e= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) \u003c n, ThreadCreateProfile does not change p and returns n, false.  Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly."
      },
      {
        "name": "TraceStack",
        "desc": ""
      },
      {
        "name": "TracebackSystemstack",
        "desc": ""
      },
      {
        "name": "UnlockOSThread",
        "desc": "UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.  Before calling UnlockOSThread, the caller must ensure that the OS thread is suitable for running other goroutines. If the caller made any permanent changes to the state of the thread that would affect other goroutines, it should not call this function and thus leave the goroutine locked to the OS thread until the goroutine (and hence the thread) exits."
      },
      {
        "name": "UnsafePoint",
        "desc": ""
      },
      {
        "name": "UserArenaClone",
        "desc": ""
      },
      {
        "name": "Version",
        "desc": "Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\"."
      },
      {
        "name": "WaitForSigusr1",
        "desc": "WaitForSigusr1 blocks until a SIGUSR1 is received. It calls ready when it is set up to receive SIGUSR1. The ready function should cause a SIGUSR1 to be sent. The r and w arguments are a pipe that the signal handler can use to report when the signal is received.  Once SIGUSR1 is received, it returns the ID of the current M and the ID of the M the SIGUSR1 was received on. If the caller writes a non-zero byte to w, WaitForSigusr1 returns immediately with -1, -1."
      },
      {
        "name": "XTestInlineUnwinder",
        "desc": ""
      },
      {
        "name": "XTestSPWrite",
        "desc": ""
      },
      {
        "name": "_ELF_ST_BIND",
        "desc": "How to extract and insert information held in the st_info field."
      },
      {
        "name": "_ELF_ST_TYPE",
        "desc": ""
      },
      {
        "name": "_ExternalCode",
        "desc": ""
      },
      {
        "name": "_GC",
        "desc": ""
      },
      {
        "name": "_LostContendedRuntimeLock",
        "desc": ""
      },
      {
        "name": "_LostExternalCode",
        "desc": ""
      },
      {
        "name": "_LostSIGPROFDuringAtomic64",
        "desc": ""
      },
      {
        "name": "_System",
        "desc": ""
      },
      {
        "name": "_VDSO",
        "desc": ""
      },
      {
        "name": "_atoi",
        "desc": ""
      },
      {
        "name": "_cgo_panic_internal",
        "desc": ""
      },
      {
        "name": "_d2v",
        "desc": ""
      },
      {
        "name": "_div",
        "desc": ""
      },
      {
        "name": "_div64by32",
        "desc": ""
      },
      {
        "name": "_divu",
        "desc": ""
      },
      {
        "name": "_initcgo",
        "desc": ""
      },
      {
        "name": "_mod",
        "desc": ""
      },
      {
        "name": "_modu",
        "desc": ""
      },
      {
        "name": "_mul64by32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AddInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AddInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AddUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AddUint64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AddUintptr",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AndInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AndInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AndUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AndUint64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_AndUintptr",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_CompareAndSwapInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_CompareAndSwapInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_CompareAndSwapUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_CompareAndSwapUint64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_LoadInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_LoadInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_LoadPointer",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_LoadUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_LoadUint64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_LoadUintptr",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_OrInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_OrInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_OrUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_OrUint64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_OrUintptr",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_StoreInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_StoreInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_StoreUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_StoreUint64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_SwapInt32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_SwapInt64",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_SwapUint32",
        "desc": ""
      },
      {
        "name": "abigen_sync_atomic_SwapUint64",
        "desc": ""
      },
      {
        "name": "abort",
        "desc": "abort crashes the runtime in situations where even throw might not work. In general it should do something a debugger will recognize (e.g., an INT3 on x86). A crash in abort is recognized by the signal handler, which will attempt to tear down the runtime immediately."
      },
      {
        "name": "abs",
        "desc": "abs returns the absolute value of x.  Special cases are:  \tabs(±Inf) = +Inf \tabs(NaN) = NaN"
      },
      {
        "name": "access",
        "desc": "Called from write_err_android.go only, but defined in sys_linux_*.s; declared here (instead of in write_err_android.go) for go vet on non-android builds. The return value is the raw syscall result, which may encode an error number."
      },
      {
        "name": "acquireLockRankAndM",
        "desc": "acquireLockRankAndM acquires a rank which is not associated with a mutex lock. To maintain the invariant that an M with m.locks==0 does not hold any lock-like resources, it also acquires the M.  This function may be called in nosplit context and thus must be nosplit."
      },
      {
        "name": "acquirep",
        "desc": "Associate p and the current m.  This function is allowed to have write barriers even if the caller isn't because it immediately acquires pp."
      },
      {
        "name": "add",
        "desc": "Should be a built-in for unsafe.Pointer?  add should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - fortio.org/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "add1",
        "desc": "add1 returns the byte pointer p+1."
      },
      {
        "name": "addCleanup",
        "desc": "addCleanup attaches a cleanup function to the object. Multiple cleanups are allowed on an object, and even the same pointer. A cleanup id is returned which can be used to uniquely identify the cleanup."
      },
      {
        "name": "addCovMeta",
        "desc": "The compiler emits calls to runtime.addCovMeta but this code has moved to rtcov.AddMeta."
      },
      {
        "name": "addExtraM",
        "desc": "Adds a newly allocated M to the extra M list."
      },
      {
        "name": "addWakeupEvent",
        "desc": ""
      },
      {
        "name": "addb",
        "desc": "addb returns the byte pointer p+n."
      },
      {
        "name": "addfinalizer",
        "desc": "Adds a finalizer to the object p. Returns true if it succeeded."
      },
      {
        "name": "addmoduledata",
        "desc": "Called from linker-generated .initarray; declared for go vet; do NOT call from Go."
      },
      {
        "name": "addrsToSummaryRange",
        "desc": "addrsToSummaryRange converts base and limit pointers into a range of entries for the given summary level.  The returned range is inclusive on the lower bound and exclusive on the upper bound."
      },
      {
        "name": "addspecial",
        "desc": "addspecial adds the special record s to the list of special records for the object p. All fields of s should be filled in except for offset \u0026 next, which this routine will fill in. Returns true if the special was successfully added, false otherwise. (The add will fail only if a record with the same p and s-\u003ekind already exists unless force is set to true.)"
      },
      {
        "name": "adjustCgroupGOMAXPROCS",
        "desc": "Lower procs as necessary for the current cgroup CPU limit."
      },
      {
        "name": "adjustSignalStack",
        "desc": "adjustSignalStack adjusts the current stack guard based on the stack pointer that is actually in use while handling a signal. We do this in case some non-Go code called sigaltstack. This reports whether the stack was adjusted, and if so stores the old signal stack in *gsigstack."
      },
      {
        "name": "adjustSignalStack2",
        "desc": ""
      },
      {
        "name": "adjustctxt",
        "desc": ""
      },
      {
        "name": "adjustdefers",
        "desc": ""
      },
      {
        "name": "adjustframe",
        "desc": "Note: the argument/return area is adjusted by the callee."
      },
      {
        "name": "adjustpanics",
        "desc": ""
      },
      {
        "name": "adjustpointer",
        "desc": "adjustpointer checks whether *vpp is in the old stack described by adjinfo. If so, it rewrites *vpp to point into the new stack."
      },
      {
        "name": "adjustpointers",
        "desc": "bv describes the memory starting at address scanp. Adjust any pointers contained therein."
      },
      {
        "name": "adjustsudogs",
        "desc": ""
      },
      {
        "name": "advanceEvacuationMark",
        "desc": ""
      },
      {
        "name": "alginit",
        "desc": ""
      },
      {
        "name": "alignDown",
        "desc": "alignDown rounds n down to a multiple of a. a must be a power of 2."
      },
      {
        "name": "alignUp",
        "desc": "alignUp rounds n up to a multiple of a. a must be a power of 2."
      },
      {
        "name": "allZero",
        "desc": ""
      },
      {
        "name": "allgadd",
        "desc": ""
      },
      {
        "name": "appendIntStr",
        "desc": ""
      },
      {
        "name": "arc4random_buf",
        "desc": ""
      },
      {
        "name": "arc4random_buf_trampoline",
        "desc": ""
      },
      {
        "name": "archauxv",
        "desc": ""
      },
      {
        "name": "arenaBase",
        "desc": "arenaBase returns the low address of the region covered by heap arena i."
      },
      {
        "name": "arena_arena_Free",
        "desc": "arena_arena_Free is a wrapper around (*userArena).free."
      },
      {
        "name": "arena_arena_New",
        "desc": "arena_arena_New is a wrapper around (*userArena).new, except that typ is an any (must be a *_type, still) and typ must be a type descriptor for a pointer to the type to actually be allocated, i.e. pass a *T to allocate a T. This is necessary because this function returns a *T."
      },
      {
        "name": "arena_arena_Slice",
        "desc": "arena_arena_Slice is a wrapper around (*userArena).slice."
      },
      {
        "name": "arena_heapify",
        "desc": "arena_heapify takes a value that lives in an arena and makes a copy of it on the heap. Values that don't live in an arena are returned unmodified."
      },
      {
        "name": "arena_newArena",
        "desc": "arena_newArena is a wrapper around newUserArena."
      },
      {
        "name": "args",
        "desc": ""
      },
      {
        "name": "argv_index",
        "desc": "nosplit for use in linux startup sysargs."
      },
      {
        "name": "asanpoison",
        "desc": ""
      },
      {
        "name": "asanread",
        "desc": ""
      },
      {
        "name": "asanregisterglobals",
        "desc": ""
      },
      {
        "name": "asanunpoison",
        "desc": ""
      },
      {
        "name": "asanwrite",
        "desc": ""
      },
      {
        "name": "asmSigaction",
        "desc": "asmSigaction is implemented in assembly."
      },
      {
        "name": "asmcgocall",
        "desc": ""
      },
      {
        "name": "asmcgocall_landingpad",
        "desc": ""
      },
      {
        "name": "asmcgocall_no_g",
        "desc": ""
      },
      {
        "name": "asminit",
        "desc": ""
      },
      {
        "name": "asmstdcall",
        "desc": "Call a Windows function with stdcall conventions, and switch to os stack during the call."
      },
      {
        "name": "asmstdcall_trampoline",
        "desc": "asmstdcall_trampoline calls asmstdcall converting from Go to C calling convention."
      },
      {
        "name": "asmsysvicall6",
        "desc": ""
      },
      {
        "name": "assertLockHeld",
        "desc": "assertLockHeld throws if l is not held by the caller.  nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "assertRankHeld",
        "desc": "assertRankHeld throws if a mutex with rank r is not held by the caller.  This is less precise than assertLockHeld, but can be used in places where a pointer to the exact mutex is not available.  nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "assertWorldStopped",
        "desc": "assertWorldStopped throws if the world is not stopped. It does not check which M stopped the world.  nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "assertWorldStoppedOrLockHeld",
        "desc": "assertWorldStoppedOrLockHeld throws if the world is not stopped and the passed lock is not held.  nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "asyncPreempt",
        "desc": "asyncPreempt saves all user registers and calls asyncPreempt2.  When stack scanning encounters an asyncPreempt frame, it scans that frame and its parent frame conservatively.  asyncPreempt is implemented in assembly."
      },
      {
        "name": "asyncPreempt2",
        "desc": ""
      },
      {
        "name": "atolwhex",
        "desc": ""
      },
      {
        "name": "atomicAllG",
        "desc": "atomicAllG returns \u0026allgs[0] and len(allgs) for use with atomicAllGIndex."
      },
      {
        "name": "atomic_casPointer",
        "desc": "atomic_casPointer is the implementation of internal/runtime/atomic.UnsafePointer.CompareAndSwap (like CompareAndSwapNoWB but with the write barrier)."
      },
      {
        "name": "atomic_storePointer",
        "desc": "atomic_storePointer is the implementation of internal/runtime/atomic.UnsafePointer.Store (like StoreNoWB but with the write barrier)."
      },
      {
        "name": "atomicstorep",
        "desc": "atomicstorep performs *ptr = new atomically and invokes a write barrier."
      },
      {
        "name": "atomicwb",
        "desc": "atomicwb performs a write barrier before an atomic pointer write. The caller should guard the call with \"if writeBarrier.enabled\".  atomicwb should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/songzhibin97/gkit  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "badFuncInfoEntry",
        "desc": ""
      },
      {
        "name": "badPointer",
        "desc": "badPointer throws bad pointer in heap panic."
      },
      {
        "name": "badSrcFuncName",
        "desc": ""
      },
      {
        "name": "badTimer",
        "desc": "badTimer is called if the timer data structures have been corrupted, presumably due to racy use by the program. We panic here rather than panicking due to invalid slice access while holding locks. See issue #25686."
      },
      {
        "name": "badcgocallback",
        "desc": "called from assembly."
      },
      {
        "name": "badctxt",
        "desc": ""
      },
      {
        "name": "badmcall",
        "desc": "called from assembly."
      },
      {
        "name": "badmcall2",
        "desc": ""
      },
      {
        "name": "badmorestackg0",
        "desc": ""
      },
      {
        "name": "badmorestackgsignal",
        "desc": ""
      },
      {
        "name": "badreflectcall",
        "desc": ""
      },
      {
        "name": "badsignal",
        "desc": "This runs on a foreign stack, without an m or a g. No stack split."
      },
      {
        "name": "badsignal2",
        "desc": "This runs on a foreign stack, without an m or a g. No stack split."
      },
      {
        "name": "badsystemstack",
        "desc": ""
      },
      {
        "name": "badunlockosthread",
        "desc": ""
      },
      {
        "name": "beforeIdle",
        "desc": "beforeIdle gets called by the scheduler if no goroutine is awake. If we are not already handling an event, then we pause for an async event. If an event handler returned, we resume it and it will pause the execution. beforeIdle either returns the specific goroutine to schedule next or indicates with otherReady that some goroutine became ready. TODO(drchase): need to understand if write barriers are really okay in this context."
      },
      {
        "name": "bgscavenge",
        "desc": "Background scavenger.  The background scavenger maintains the RSS of the application below the line described by the proportional scavenging statistics in the mheap struct."
      },
      {
        "name": "bgsweep",
        "desc": ""
      },
      {
        "name": "binarySearchTree",
        "desc": "Build a binary search tree with the n objects in the list x.obj[idx], x.obj[idx+1], ..., x.next.obj[0], ... Returns the root of that tree, and the buf+idx of the nth object after x.obj[idx]. (The first object that was not included in the binary search tree.) If n == 0, returns nil, x."
      },
      {
        "name": "block",
        "desc": ""
      },
      {
        "name": "blockAlignSummaryRange",
        "desc": "blockAlignSummaryRange aligns indices into the given level to that level's block width (1 \u003c\u003c levelBits[level]). It assumes lo is inclusive and hi is exclusive, and so aligns them down and up respectively."
      },
      {
        "name": "blockOnSystemStackInternal",
        "desc": ""
      },
      {
        "name": "blockProfileInternal",
        "desc": "blockProfileInternal returns the number of records n in the profile. If there are less than size records, copyFn is invoked for each record, and ok returns true."
      },
      {
        "name": "blockTimerChan",
        "desc": "blockTimerChan is called when a channel op has decided to block on c. The caller holds the channel lock for c and possibly other channels. blockTimerChan makes sure that c is in a timer heap, adding it if needed."
      },
      {
        "name": "blockUntilEmptyFinalizerQueue",
        "desc": "blockUntilEmptyFinalizerQueue blocks until either the finalizer queue is emptied (and the finalizers have executed) or the timeout is reached. Returns true if the finalizer queue was emptied. This is used by the runtime, sync, and unique tests."
      },
      {
        "name": "blockableSig",
        "desc": "blockableSig reports whether sig may be blocked by the signal mask. We never want to block the signals marked _SigUnblock; these are the synchronous signals that turn into a Go panic. We never want to block the preemption signal if it is being used. In a Go program--not a c-archive/c-shared--we never want to block the signals marked _SigKill or _SigThrow, as otherwise it's possible for all running threads to block them and delay their delivery until we start a new thread. When linked into a C program we let the C code decide on the disposition of those signals."
      },
      {
        "name": "blockevent",
        "desc": ""
      },
      {
        "name": "blocksampled",
        "desc": "blocksampled returns true for all events where cycles \u003e= rate. Shorter events have a cycles/rate random chance of returning true."
      },
      {
        "name": "bool2int",
        "desc": "bool2int returns 0 if x is false or 1 if x is true."
      },
      {
        "name": "bootstrapRand",
        "desc": "bootstrapRand returns a random uint64 from the global random generator."
      },
      {
        "name": "bootstrapRandReseed",
        "desc": "bootstrapRandReseed reseeds the bootstrap random number generator, clearing from memory any trace of previously returned random numbers."
      },
      {
        "name": "boring_registerCache",
        "desc": ""
      },
      {
        "name": "boring_runtime_arg0",
        "desc": ""
      },
      {
        "name": "breakpoint",
        "desc": ""
      },
      {
        "name": "brk_",
        "desc": ""
      },
      {
        "name": "bswapIfBigEndian",
        "desc": "bswapIfBigEndian swaps the byte order of the uintptr on goarch.BigEndian platforms, and leaves it alone elsewhere."
      },
      {
        "name": "bucketEvacuated",
        "desc": ""
      },
      {
        "name": "bucketMask",
        "desc": "bucketMask returns 1\u003c\u003cb - 1, optimized for code generation."
      },
      {
        "name": "bucketShift",
        "desc": "bucketShift returns 1\u003c\u003cb, optimized for code generation."
      },
      {
        "name": "buildGCMask",
        "desc": "buildGCMask writes the ptr/nonptr bitmap for t to dst. t must have a pointer."
      },
      {
        "name": "buildInterfaceSwitchCache",
        "desc": "buildInterfaceSwitchCache constructs an interface switch cache containing all the entries from oldC plus the new entry (typ,case_,tab)."
      },
      {
        "name": "buildTypeAssertCache",
        "desc": ""
      },
      {
        "name": "bulkBarrierBitmap",
        "desc": "bulkBarrierBitmap executes write barriers for copying from [src, src+size) to [dst, dst+size) using a 1-bit pointer bitmap. src is assumed to start maskOffset bytes into the data covered by the bitmap in bits (which may not be a multiple of 8).  This is used by bulkBarrierPreWrite for writes to data and BSS."
      },
      {
        "name": "bulkBarrierPreWrite",
        "desc": "bulkBarrierPreWrite executes a write barrier for every pointer slot in the memory range [src, src+size), using pointer/scalar information from [dst, dst+size). This executes the write barriers necessary before a memmove. src, dst, and size must be pointer-aligned. The range [dst, dst+size) must lie within a single object. It does not perform the actual writes.  As a special case, src == 0 indicates that this is being used for a memclr. bulkBarrierPreWrite will pass 0 for the src of each write barrier.  Callers should call bulkBarrierPreWrite immediately before calling memmove(dst, src, size). This function is marked nosplit to avoid being preempted; the GC must not stop the goroutine between the memmove and the execution of the barriers. The caller is also responsible for cgo pointer checks if this may be writing Go pointers into non-Go memory.  Pointer data is not maintained for allocations containing no pointers at all; any caller of bulkBarrierPreWrite must first make sure the underlying allocation contains pointers, usually by checking typ.PtrBytes.  The typ argument is the type of the space at src and dst (and the element type if src and dst refer to arrays) and it is optional. If typ is nil, the barrier will still behave as expected and typ is used purely as an optimization. However, it must be used with care.  If typ is not nil, then src and dst must point to one or more values of type typ. The caller must ensure that the ranges [src, src+size) and [dst, dst+size) refer to one or more whole values of type src and dst (leaving off the pointerless tail of the space is OK). If this precondition is not followed, this function will fail to scan the right pointers.  When in doubt, pass nil for typ. That is safe and will always work.  Callers must perform cgo checks if goexperiment.CgoCheck2."
      },
      {
        "name": "bulkBarrierPreWriteSrcOnly",
        "desc": "bulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but does not execute write barriers for [dst, dst+size).  In addition to the requirements of bulkBarrierPreWrite callers need to ensure [dst, dst+size) is zeroed.  This is used for special cases where e.g. dst was just created and zeroed with malloc.  The type of the space can be provided purely as an optimization. See bulkBarrierPreWrite's comment for more details -- use this optimization with great care."
      },
      {
        "name": "bytealg_MakeNoZero",
        "desc": ""
      },
      {
        "name": "bytes",
        "desc": ""
      },
      {
        "name": "bytesHasPrefix",
        "desc": ""
      },
      {
        "name": "bytesHash",
        "desc": ""
      },
      {
        "name": "c128equal",
        "desc": ""
      },
      {
        "name": "c128hash",
        "desc": ""
      },
      {
        "name": "c64equal",
        "desc": ""
      },
      {
        "name": "c64hash",
        "desc": ""
      },
      {
        "name": "call1024",
        "desc": ""
      },
      {
        "name": "call1048576",
        "desc": ""
      },
      {
        "name": "call1073741824",
        "desc": ""
      },
      {
        "name": "call128",
        "desc": ""
      },
      {
        "name": "call131072",
        "desc": ""
      },
      {
        "name": "call134217728",
        "desc": ""
      },
      {
        "name": "call16",
        "desc": "in asm_*.s not called directly; definitions here supply type information for traceback. These must have the same signature (arg pointer map) as reflectcall."
      },
      {
        "name": "call16384",
        "desc": ""
      },
      {
        "name": "call16777216",
        "desc": ""
      },
      {
        "name": "call2048",
        "desc": ""
      },
      {
        "name": "call2097152",
        "desc": ""
      },
      {
        "name": "call256",
        "desc": ""
      },
      {
        "name": "call262144",
        "desc": ""
      },
      {
        "name": "call268435456",
        "desc": ""
      },
      {
        "name": "call32",
        "desc": ""
      },
      {
        "name": "call32768",
        "desc": ""
      },
      {
        "name": "call33554432",
        "desc": ""
      },
      {
        "name": "call4096",
        "desc": ""
      },
      {
        "name": "call4194304",
        "desc": ""
      },
      {
        "name": "call512",
        "desc": ""
      },
      {
        "name": "call524288",
        "desc": ""
      },
      {
        "name": "call536870912",
        "desc": ""
      },
      {
        "name": "call64",
        "desc": ""
      },
      {
        "name": "call65536",
        "desc": ""
      },
      {
        "name": "call67108864",
        "desc": ""
      },
      {
        "name": "call8192",
        "desc": ""
      },
      {
        "name": "call8388608",
        "desc": ""
      },
      {
        "name": "callCgoMmap",
        "desc": "callCgoMmap calls the mmap function in the runtime/cgo package using the GCC calling convention. It is implemented in assembly."
      },
      {
        "name": "callCgoMunmap",
        "desc": "callCgoMunmap calls the munmap function in the runtime/cgo package using the GCC calling convention. It is implemented in assembly."
      },
      {
        "name": "callCgoSigaction",
        "desc": "callCgoSigaction calls the sigaction function in the runtime/cgo package using the GCC calling convention. It is implemented in assembly."
      },
      {
        "name": "callCgoSymbolizer",
        "desc": "callCgoSymbolizer calls the cgoSymbolizer function."
      },
      {
        "name": "callbackUpdateSystemStack",
        "desc": "Set or reset the system stack bounds for a callback on sp.  Must be nosplit because it is called by needm prior to fully initializing the M."
      },
      {
        "name": "callbackWrap",
        "desc": "callbackWrap is called by callbackasm to invoke a registered C callback."
      },
      {
        "name": "callbackasm",
        "desc": ""
      },
      {
        "name": "callbackasm1",
        "desc": "called from zcallback_windows_*.s to sys_windows_*.s"
      },
      {
        "name": "callbackasmAddr",
        "desc": "callbackasmAddr returns address of runtime.callbackasm function adjusted by i. On x86 and amd64, runtime.callbackasm is a series of CALL instructions, and we want callback to arrive at correspondent call instruction instead of start of runtime.callbackasm. On ARM, runtime.callbackasm is a series of mov and branch instructions. R12 is loaded with the callback index. Each entry is two instructions, hence 8 bytes."
      },
      {
        "name": "callers",
        "desc": "callers should be an internal detail, (and is almost identical to Callers), but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "canPreemptM",
        "desc": "canPreemptM reports whether mp is in a state that is safe to preempt.  It is nosplit because it has nosplit callers."
      },
      {
        "name": "canpanic",
        "desc": "canpanic returns false if a signal should throw instead of panicking."
      },
      {
        "name": "cansemacquire",
        "desc": ""
      },
      {
        "name": "casGFromPreempted",
        "desc": "casGFromPreempted attempts to transition gp from _Gpreempted to _Gwaiting. If successful, the caller is responsible for re-scheduling gp."
      },
      {
        "name": "casGToPreemptScan",
        "desc": "casGToPreemptScan transitions gp from _Grunning to _Gscan|_Gpreempted.  TODO(austin): This is the only status operation that both changes the status and locks the _Gscan bit. Rethink this."
      },
      {
        "name": "casGToWaiting",
        "desc": "casGToWaiting transitions gp from old to _Gwaiting, and sets the wait reason.  Use this over casgstatus when possible to ensure that a waitreason is set."
      },
      {
        "name": "casGToWaitingForSuspendG",
        "desc": "casGToWaitingForSuspendG transitions gp from old to _Gwaiting, and sets the wait reason. The wait reason must be a valid isWaitingForSuspendG wait reason.  Use this over casgstatus when possible to ensure that a waitreason is set."
      },
      {
        "name": "casfrom_Gscanstatus",
        "desc": "The Gscanstatuses are acting like locks and this releases them. If it proves to be a performance hit we should be able to make these simple atomic stores but for now we are going to throw if we see an inconsistent state."
      },
      {
        "name": "casgstatus",
        "desc": "If asked to move to or from a Gscanstatus this will throw. Use the castogscanstatus and casfrom_Gscanstatus instead. casgstatus will loop if the g-\u003eatomicstatus is in a Gscan status until the routine that put it in the Gscan state is finished."
      },
      {
        "name": "castogscanstatus",
        "desc": "This will return false if the gp is not in the expected status and the cas fails. This acts like a lock acquire while the casfromgstatus acts like a lock release."
      },
      {
        "name": "cbsLock",
        "desc": ""
      },
      {
        "name": "cbsUnlock",
        "desc": ""
      },
      {
        "name": "ceil",
        "desc": "ceil returns the least integer value greater than or equal to x.  Special cases are:  \tCeil(±0) = ±0 \tCeil(±Inf) = ±Inf \tCeil(NaN) = NaN  N.B. Portable ceil copied from math. math also has optimized arch-specific implementations."
      },
      {
        "name": "cgoBindM",
        "desc": "bindm store the g0 of the current m into a thread-specific value.  We allocate a pthread per-thread variable using pthread_key_create, to register a thread-exit-time destructor. We are here setting the thread-specific value of the pthread key, to enable the destructor. So that the pthread_key_destructor would dropm while the C thread is exiting.  And the saved g will be used in pthread_key_destructor, since the g stored in the TLS by Go might be cleared in some platforms, before the destructor invoked, so, we restore g by the stored g, before dropm.  We store g0 instead of m, to make the assembly code simpler, since we need to restore g0 in runtime.cgocallback.  On systems without pthreads, like Windows, bindm shouldn't be used.  NOTE: this always runs without a P, so, nowritebarrierrec required."
      },
      {
        "name": "cgoCheckArg",
        "desc": "cgoCheckArg is the real work of cgoCheckPointer. The argument p is either a pointer to the value (of type t), or the value itself, depending on indir. The top parameter is whether we are at the top level, where Go pointers are allowed. Go pointers to pinned objects are allowed as long as they don't reference other unpinned pointers."
      },
      {
        "name": "cgoCheckBits",
        "desc": "cgoCheckBits checks the block of memory at src, for up to size bytes, and throws if it finds an unpinned Go pointer. The gcbits mark each pointer value. The src pointer is off bytes into the gcbits."
      },
      {
        "name": "cgoCheckMemmove",
        "desc": "cgoCheckMemmove is called when moving a block of memory. It throws if the program is copying a block that contains an unpinned Go pointer into non-Go memory.  This is called from generated code when GOEXPERIMENT=cgocheck2 is enabled."
      },
      {
        "name": "cgoCheckMemmove2",
        "desc": "cgoCheckMemmove2 is called when moving a block of memory. dst and src point off bytes into the value to copy. size is the number of bytes to copy. It throws if the program is copying a block that contains an unpinned Go pointer into non-Go memory."
      },
      {
        "name": "cgoCheckPointer",
        "desc": "cgoCheckPointer checks if the argument contains a Go pointer that points to an unpinned Go pointer, and panics if it does."
      },
      {
        "name": "cgoCheckPtrWrite",
        "desc": "cgoCheckPtrWrite is called whenever a pointer is stored into memory. It throws if the program is storing an unpinned Go pointer into non-Go memory.  This is called from generated code when GOEXPERIMENT=cgocheck2 is enabled."
      },
      {
        "name": "cgoCheckResult",
        "desc": "cgoCheckResult is called to check the result parameter of an exported Go function. It panics if the result is or contains any other pointer into unpinned Go memory."
      },
      {
        "name": "cgoCheckSliceCopy",
        "desc": "cgoCheckSliceCopy is called when copying n elements of a slice. src and dst are pointers to the first element of the slice. typ is the element type of the slice. It throws if the program is copying slice elements that contain unpinned Go pointers into non-Go memory."
      },
      {
        "name": "cgoCheckTypedBlock",
        "desc": "cgoCheckTypedBlock checks the block of memory at src, for up to size bytes, and throws if it finds an unpinned Go pointer. The type of the memory is typ, and src is off bytes into that type."
      },
      {
        "name": "cgoCheckUnknownPointer",
        "desc": "cgoCheckUnknownPointer is called for an arbitrary pointer into Go memory. It checks whether that Go memory contains any other pointer into unpinned Go memory. If it does, we panic. The return values are unused but useful to see in panic tracebacks."
      },
      {
        "name": "cgoCheckUsingType",
        "desc": "cgoCheckUsingType is like cgoCheckTypedBlock, but is a last ditch fall back to look for pointers in src using the type information. We only use this when looking at a value on the stack when the type uses a GC program, because otherwise it's more efficient to use the GC bits. This is called on the system stack."
      },
      {
        "name": "cgoContextPCs",
        "desc": "cgoContextPCs gets the PC values from a cgo traceback."
      },
      {
        "name": "cgoInRange",
        "desc": "cgoInRange reports whether p is between start and end."
      },
      {
        "name": "cgoIsGoPointer",
        "desc": "cgoIsGoPointer reports whether the pointer is a Go pointer--a pointer to Go memory. We only care about Go memory that might contain pointers."
      },
      {
        "name": "cgoKeepAlive",
        "desc": "cgoKeepAlive is called by cgo-generated code (using go:linkname to get at an unexported name). This call keeps its argument alive until the call site; cgo emits the call after the last possible use of the argument by C code. cgoKeepAlive is marked in the cgo-generated code as //go:noescape, so unlike cgoUse it does not force the argument to escape to the heap. This is used to implement the #cgo noescape directive."
      },
      {
        "name": "cgoNoCallback",
        "desc": ""
      },
      {
        "name": "cgoSigtramp",
        "desc": ""
      },
      {
        "name": "cgoUse",
        "desc": "cgoUse is called by cgo-generated code (using go:linkname to get at an unexported name). The calls serve two purposes: 1) they are opaque to escape analysis, so the argument is considered to escape to the heap. 2) they keep the argument alive until the call site; the call is emitted after the end of the (presumed) use of the argument by C. cgoUse should not actually be called (see cgoAlwaysFalse)."
      },
      {
        "name": "cgocall",
        "desc": "Call from Go to C.  This must be nosplit because it's used for syscalls on some platforms. Syscalls may have untyped arguments on the stack, so it's not safe to grow or scan the stack.  cgocall should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ebitengine/purego  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "cgocallback",
        "desc": "Not all cgocallback frames are actually cgocallback, so not all have these arguments. Mark them uintptr so that the GC does not misinterpret memory when the arguments are not present. cgocallback is not called from Go, only from crosscall2. This in turn calls cgocallbackg, which is where we'll find pointer-declared arguments.  When fn is nil (frame is saved g), call dropm instead, this is used when the C thread is exiting."
      },
      {
        "name": "cgocallbackg",
        "desc": "Call from C back to Go. fn must point to an ABIInternal Go entry-point."
      },
      {
        "name": "cgocallbackg1",
        "desc": ""
      },
      {
        "name": "cgounimpl",
        "desc": "called from (incomplete) assembly."
      },
      {
        "name": "cgroup_throw",
        "desc": ""
      },
      {
        "name": "chanbuf",
        "desc": "chanbuf(c, i) is pointer to the i'th slot in the buffer.  chanbuf should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/fjl/memsize  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "chancap",
        "desc": ""
      },
      {
        "name": "chanlen",
        "desc": ""
      },
      {
        "name": "chanparkcommit",
        "desc": ""
      },
      {
        "name": "chanrecv",
        "desc": "chanrecv receives on channel c and writes the received data to ep. ep may be nil, in which case received data is ignored. If block == false and no elements are available, returns (false, false). Otherwise, if c is closed, zeros *ep and returns (true, false). Otherwise, fills in *ep with an element and returns (true, true). A non-nil ep must point to the heap or the caller's stack."
      },
      {
        "name": "chanrecv1",
        "desc": "entry points for \u003c- c from compiled code."
      },
      {
        "name": "chanrecv2",
        "desc": ""
      },
      {
        "name": "chansend",
        "desc": "* generic single channel send/recv  * If block is not nil,  * then the protocol will not  * sleep but return if it could  * not complete.  *  * sleep can wake up with g.param == nil  * when a channel involved in the sleep has  * been closed.  it is easiest to loop and re-run  * the operation; we'll see that it's now closed."
      },
      {
        "name": "chansend1",
        "desc": "entry point for c \u003c- x from compiled code."
      },
      {
        "name": "cheaprand",
        "desc": "cheaprand is a non-cryptographic-quality 32-bit random generator suitable for calling at very high frequency (such as during scheduling decisions) and at sensitive moments in the runtime (such as during stack unwinding). it is \"cheap\" in the sense of both expense and quality.  cheaprand must not be exported to other packages: the rule is that other packages using runtime-provided randomness must always use rand.  cheaprand should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "cheaprand64",
        "desc": "cheaprand64 is a non-cryptographic-quality 63-bit random generator suitable for calling at very high frequency (such as during sampling decisions). it is \"cheap\" in the sense of both expense and quality.  cheaprand64 must not be exported to other packages: the rule is that other packages using runtime-provided randomness must always use rand.  cheaprand64 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/zhangyunhao116/fastrand  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "cheaprandn",
        "desc": "cheaprandn is like cheaprand() % n but faster.  cheaprandn must not be exported to other packages: the rule is that other packages using runtime-provided randomness must always use randn.  cheaprandn should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "check",
        "desc": ""
      },
      {
        "name": "checkASM",
        "desc": "checkASM reports whether assembly runtime checks have passed."
      },
      {
        "name": "checkFinalizersAndCleanups",
        "desc": "checkFinalizersAndCleanups uses checkmarks to check for potential issues with the program's use of cleanups and finalizers."
      },
      {
        "name": "checkIdleGCNoP",
        "desc": "Check for idle-priority GC, without a P on entry.  If some GC work, a P, and a worker G are all available, the P and G will be returned. The returned P has not been wired yet."
      },
      {
        "name": "checkLockHeld",
        "desc": "nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "checkRanks",
        "desc": "checkRanks checks if goroutine g, which has mostly recently acquired a lock with rank 'prevRank', can now acquire a lock with rank 'rank'."
      },
      {
        "name": "checkS390xCPU",
        "desc": ""
      },
      {
        "name": "checkTimeouts",
        "desc": "checkTimeouts resumes goroutines that are waiting on a note which has reached its deadline."
      },
      {
        "name": "checkTimersNoP",
        "desc": "Check all Ps for a timer expiring sooner than pollUntil.  Returns updated pollUntil value."
      },
      {
        "name": "checkWorldStopped",
        "desc": "nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "checkdead",
        "desc": "Check for deadlock situation. The check is based on number of running M's, if 0 -\u003e deadlock. sched.lock must be held."
      },
      {
        "name": "checkfds",
        "desc": ""
      },
      {
        "name": "checkgoarm",
        "desc": ""
      },
      {
        "name": "checkmcount",
        "desc": "sched.lock must be held."
      },
      {
        "name": "checkptrAlignment",
        "desc": ""
      },
      {
        "name": "checkptrArithmetic",
        "desc": ""
      },
      {
        "name": "checkptrBase",
        "desc": "checkptrBase returns the base address for the allocation containing the address p.  Importantly, if p1 and p2 point into the same variable, then checkptrBase(p1) == checkptrBase(p2). However, the converse/inverse is not necessarily true as allocations can have trailing padding, and multiple variables may be packed into a single allocation.  checkptrBase should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "checkptrStraddles",
        "desc": "checkptrStraddles reports whether the first size-bytes of memory addressed by ptr is known to straddle more than one Go allocation."
      },
      {
        "name": "chunkBase",
        "desc": "chunkBase returns the base address of the palloc chunk at index ci."
      },
      {
        "name": "chunkPageIndex",
        "desc": "chunkPageIndex computes the index of the page that contains p, relative to the chunk which contains p."
      },
      {
        "name": "clearCleanupContext",
        "desc": "clearFinalizerContext removes the specialCheckFinalizer for the given pointer and cleanup ID, if any."
      },
      {
        "name": "clearFinalizerContext",
        "desc": "clearFinalizerContext removes the specialCheckFinalizer for the given pointer, if any."
      },
      {
        "name": "clearIdleTimeout",
        "desc": "clearIdleTimeout clears our record of the timeout started by beforeIdle."
      },
      {
        "name": "clearSignalHandlers",
        "desc": "clearSignalHandlers clears all signal handlers that are not ignored back to the default. This is called by the child after a fork, so that we can enable the signal mask for the exec without worrying about running a signal handler in the child."
      },
      {
        "name": "clearTimeoutEvent",
        "desc": "clearTimeoutEvent clears a timeout event scheduled by scheduleTimeoutEvent."
      },
      {
        "name": "clearpools",
        "desc": ""
      },
      {
        "name": "clobberfree",
        "desc": "clobberfree sets the memory content at x to bad content, for debugging purposes."
      },
      {
        "name": "clock_gettime",
        "desc": ""
      },
      {
        "name": "clock_gettime_trampoline",
        "desc": ""
      },
      {
        "name": "clone",
        "desc": ""
      },
      {
        "name": "close_trampoline",
        "desc": ""
      },
      {
        "name": "closechan",
        "desc": ""
      },
      {
        "name": "closefd",
        "desc": ""
      },
      {
        "name": "closeonexec",
        "desc": ""
      },
      {
        "name": "compileCallback",
        "desc": "compileCallback converts a Go function fn into a C function pointer that can be passed to Windows APIs.  On 386, if cdecl is true, the returned C function will use the cdecl calling convention; otherwise, it will use stdcall. On amd64, it always uses fastcall. On arm, it always uses the ARM convention."
      },
      {
        "name": "complex128div",
        "desc": ""
      },
      {
        "name": "compute0",
        "desc": ""
      },
      {
        "name": "concatbyte2",
        "desc": ""
      },
      {
        "name": "concatbyte3",
        "desc": ""
      },
      {
        "name": "concatbyte4",
        "desc": ""
      },
      {
        "name": "concatbyte5",
        "desc": ""
      },
      {
        "name": "concatbytes",
        "desc": "concatbytes implements a Go string concatenation x+y+z+... returning a slice of bytes. The operands are passed in the slice a."
      },
      {
        "name": "concatstring2",
        "desc": ""
      },
      {
        "name": "concatstring3",
        "desc": ""
      },
      {
        "name": "concatstring4",
        "desc": ""
      },
      {
        "name": "concatstring5",
        "desc": ""
      },
      {
        "name": "concatstrings",
        "desc": "concatstrings implements a Go string concatenation x+y+z+... The operands are passed in the slice a. If buf != nil, the compiler has determined that the result does not escape the calling function, so the string data can be stored in buf if small enough."
      },
      {
        "name": "connect",
        "desc": ""
      },
      {
        "name": "convT",
        "desc": "convT converts a value of type t, which is pointed to by v, to a pointer that can be used as the second word of an interface value."
      },
      {
        "name": "convT16",
        "desc": ""
      },
      {
        "name": "convT32",
        "desc": ""
      },
      {
        "name": "convT64",
        "desc": "convT64 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "convTnoptr",
        "desc": ""
      },
      {
        "name": "convTslice",
        "desc": "convTslice should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "convTstring",
        "desc": "convTstring should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "copyBlockProfileRecord",
        "desc": "copyBlockProfileRecord copies the sample values and call stack from src to dst. The call stack is copied as-is. The caller is responsible for handling inline expansion, needed when the call stack was collected with frame pointer unwinding."
      },
      {
        "name": "copyKeys",
        "desc": ""
      },
      {
        "name": "copyMemProfileRecord",
        "desc": ""
      },
      {
        "name": "copyValues",
        "desc": ""
      },
      {
        "name": "copysign",
        "desc": "copysign returns a value with the magnitude of x and the sign of y."
      },
      {
        "name": "copystack",
        "desc": "Copies gp's stack to a new stack of a different size. Caller must have changed gp status to Gcopystack."
      },
      {
        "name": "coroexit",
        "desc": "coroexit is like coroswitch but closes the coro and exits the current goroutine"
      },
      {
        "name": "corostart",
        "desc": "corostart is the entry func for a new coroutine. It runs the coroutine user function f passed to corostart and then calls coroexit to remove the extra concurrency."
      },
      {
        "name": "coroswitch",
        "desc": "coroswitch switches to the goroutine blocked on c and then blocks the current goroutine on c."
      },
      {
        "name": "coroswitch_m",
        "desc": "coroswitch_m is the implementation of coroswitch that runs on the m stack.  Note: Coroutine switches are expected to happen at an order of magnitude (or more) higher frequency than regular goroutine switches, so this path is heavily optimized to remove unnecessary work. The fast path here is three CAS: the one at the top on gp.atomicstatus, the one in the middle to choose the next g, and the one at the bottom on gnext.atomicstatus. It is important not to add more atomic operations or other expensive operations to the fast path."
      },
      {
        "name": "countSub",
        "desc": "countSub subtracts two counts obtained from profIndex.dataCount or profIndex.tagCount, assuming that they are no more than 2^29 apart (guaranteed since they are never more than len(data) or len(tags) apart, respectively). tagCount wraps at 2^30, while dataCount wraps at 2^32. This function works for both."
      },
      {
        "name": "countrunes",
        "desc": "countrunes returns the number of runes in s."
      },
      {
        "name": "coverage_getCovCounterList",
        "desc": ""
      },
      {
        "name": "cpuinit",
        "desc": "cpuinit sets up CPU feature flags and calls internal/cpu.Initialize. env should be the complete value of the GODEBUG environment variable."
      },
      {
        "name": "cpuset_getaffinity",
        "desc": ""
      },
      {
        "name": "cputicks",
        "desc": "careful: cputicks is not guaranteed to be monotonic! In particular, we have noticed drift between cpus on certain os/arch combinations. See issue 8976."
      },
      {
        "name": "crash",
        "desc": ""
      },
      {
        "name": "create",
        "desc": "create returns an fd to a write-only file."
      },
      {
        "name": "createHighResTimer",
        "desc": "createHighResTimer calls CreateWaitableTimerEx with CREATE_WAITABLE_TIMER_HIGH_RESOLUTION flag to create high resolution timer. createHighResTimer returns new timer handle or 0, if CreateWaitableTimerEx failed."
      },
      {
        "name": "createfing",
        "desc": ""
      },
      {
        "name": "crypto_x509_syscall",
        "desc": ""
      },
      {
        "name": "cstring",
        "desc": ""
      },
      {
        "name": "ctrlHandler",
        "desc": ""
      },
      {
        "name": "currentMemory",
        "desc": ""
      },
      {
        "name": "debugCallCheck",
        "desc": "debugCallCheck checks whether it is safe to inject a debugger function call with return PC pc. If not, it returns a string explaining why."
      },
      {
        "name": "debugCallPanicked",
        "desc": ""
      },
      {
        "name": "debugCallV2",
        "desc": ""
      },
      {
        "name": "debugCallWrap",
        "desc": "debugCallWrap starts a new goroutine to run a debug call and blocks the calling goroutine. On the goroutine, it prepares to recover panics from the debug call, and then calls the call dispatching function at PC dispatch.  This must be deeply nosplit because there are untyped values on the stack from debugCallV2."
      },
      {
        "name": "debugCallWrap1",
        "desc": "debugCallWrap1 is the continuation of debugCallWrap on the callee goroutine."
      },
      {
        "name": "debugCallWrap2",
        "desc": ""
      },
      {
        "name": "debug_modinfo",
        "desc": ""
      },
      {
        "name": "decoderune",
        "desc": "decoderune returns the non-ASCII rune at the start of s[k:] and the index after the rune in s.  decoderune assumes that caller has checked that the to be decoded rune is a non-ASCII rune.  If the string appears to be incomplete or decoding problems are encountered (runeerror, k + 1) is returned to ensure progress when decoderune is used to iterate over a string."
      },
      {
        "name": "deductAssistCredit",
        "desc": "deductAssistCredit reduces the current G's assist credit by size bytes, and assists the GC if necessary.  Caller must be preemptible.  Returns the G for which the assist credit was accounted."
      },
      {
        "name": "deductSweepCredit",
        "desc": "deductSweepCredit deducts sweep credit for allocating a span of size spanBytes. This must be performed *before* the span is allocated to ensure the system has enough credit. If necessary, it performs sweeping to prevent going in to debt. If the caller will also sweep pages (e.g., for a large allocation), it can pass a non-zero callerSweepPages to leave that many pages unswept.  deductSweepCredit makes a worst-case assumption that all spanBytes bytes of the ultimately allocated span will be available for object allocation.  deductSweepCredit is the core of the \"proportional sweep\" system. It uses statistics gathered by the garbage collector to perform enough sweeping so that all pages are swept during the concurrent sweep phase between GC cycles.  mheap_ must NOT be locked."
      },
      {
        "name": "defaultGOMAXPROCS",
        "desc": "Return the default value for GOMAXPROCS when it has not been set explicitly.  ncpu is the optional precomputed value of getCPUCount. If passed as 0, defaultGOMAXPROCS will call getCPUCount."
      },
      {
        "name": "defaultGOMAXPROCSInit",
        "desc": "Prepare for defaultGOMAXPROCS.  Must run after parsedebugvars."
      },
      {
        "name": "defaultGOMAXPROCSUpdateEnable",
        "desc": "Start GOMAXPROCS update helper goroutine.  This is based on forcegchelper."
      },
      {
        "name": "defaultGOMAXPROCSUpdateGODEBUG",
        "desc": "defaultGOMAXPROCSUpdateGODEBUG updates the internal/godebug counter for container GOMAXPROCS, once internal/godebug is initialized."
      },
      {
        "name": "deferconvert",
        "desc": "deferconvert converts the rangefunc defer list of d0 into an ordinary list following d0. See the doc comment for deferrangefunc for details."
      },
      {
        "name": "deferproc",
        "desc": "Create a new deferred function fn, which has no arguments and results. The compiler turns a defer statement into a call to this."
      },
      {
        "name": "deferprocStack",
        "desc": "deferprocStack queues a new deferred function with a defer record on the stack. The defer record must have its fn field initialized. All other fields can contain junk. Nosplit because of the uninitialized pointer fields on the stack."
      },
      {
        "name": "deferprocat",
        "desc": "deferprocat is like deferproc but adds to the atomic list represented by frame. See the doc comment for deferrangefunc for details."
      },
      {
        "name": "deferrangefunc",
        "desc": "deferrangefunc is called by functions that are about to execute a range-over-function loop in which the loop body may execute a defer statement. That defer needs to add to the chain for the current function, not the func literal synthesized to represent the loop body. To do that, the original function calls deferrangefunc to obtain an opaque token representing the current frame, and then the loop body uses deferprocat instead of deferproc to add to that frame's defer lists.  The token is an 'any' with underlying type *atomic.Pointer[_defer]. It is the atomically-updated head of a linked list of _defer structs representing deferred calls. At the same time, we create a _defer struct on the main g._defer list with d.head set to this head pointer.  The g._defer list is now a linked list of deferred calls, but an atomic list hanging off:  \t\tg._defer =\u003e d4 -\u003e d3 -\u003e drangefunc -\u003e d2 -\u003e d1 -\u003e nil \t                             | .head \t                             | \t                             +--\u003e dY -\u003e dX -\u003e nil  with each -\u003e indicating a d.link pointer, and where drangefunc has the d.rangefunc = true bit set. Note that the function being ranged over may have added its own defers (d4 and d3), so drangefunc need not be at the top of the list when deferprocat is used. This is why we pass the atomic head explicitly.  To keep misbehaving programs from crashing the runtime, deferprocat pushes new defers onto the .head list atomically. The fact that it is a separate list from the main goroutine defer list means that the main goroutine's defers can still be handled non-atomically.  In the diagram, dY and dX are meant to be processed when drangefunc would be processed, which is to say the defer order should be d4, d3, dY, dX, d2, d1. To make that happen, when defer processing reaches a d with rangefunc=true, it calls deferconvert to atomically take the extras away from d.head and then adds them to the main list.  That is, deferconvert changes this list:  \t\tg._defer =\u003e drangefunc -\u003e d2 -\u003e d1 -\u003e nil \t                 | .head \t                 | \t                 +--\u003e dY -\u003e dX -\u003e nil  into this list:  \tg._defer =\u003e dY -\u003e dX -\u003e d2 -\u003e d1 -\u003e nil  It also poisons *drangefunc.head so that any future deferprocat using that head will throw. (The atomic head is ordinary garbage collected memory so that it's not a problem if user code holds onto it beyond the lifetime of drangefunc.)  TODO: We could arrange for the compiler to call into the runtime after the loop finishes normally, to do an eager deferconvert, which would catch calling the loop body and having it defer after the loop is done. If we have a more general catch of loop body misuse, though, this might not be worth worrying about in addition.  See also ../cmd/compile/internal/rangefunc/rewrite.go."
      },
      {
        "name": "deferreturn",
        "desc": "deferreturn runs deferred functions for the caller's frame. The compiler inserts a call to this at the end of any function which calls defer."
      },
      {
        "name": "dieFromException",
        "desc": "dieFromException raises an exception that bypasses all exception handlers. This provides the expected exit status for the shell."
      },
      {
        "name": "dieFromSignal",
        "desc": "dieFromSignal kills the program with a signal. This provides the expected exit status for the shell. This is only called with fatal signals expected to kill the process."
      },
      {
        "name": "divRoundUp",
        "desc": "divRoundUp returns ceil(n / a)."
      },
      {
        "name": "divlu",
        "desc": "128/64 -\u003e 64 quotient, 64 remainder. adapted from hacker's delight"
      },
      {
        "name": "doInit",
        "desc": ""
      },
      {
        "name": "doInit1",
        "desc": ""
      },
      {
        "name": "doMmap",
        "desc": ""
      },
      {
        "name": "doRecordGoroutineProfile",
        "desc": "doRecordGoroutineProfile writes gp1's call stack and labels to an in-progress goroutine profile. Preemption is disabled.  This may be called via tryRecordGoroutineProfile in two ways: by the goroutine that is coordinating the goroutine profile (running on its own stack), or from the scheduler in preparation to execute gp1 (running on the system stack)."
      },
      {
        "name": "doSigPreempt",
        "desc": "doSigPreempt handles a preemption signal on gp."
      },
      {
        "name": "doasanread",
        "desc": ""
      },
      {
        "name": "doasanwrite",
        "desc": ""
      },
      {
        "name": "dodiv",
        "desc": ""
      },
      {
        "name": "dofiles",
        "desc": "dofiles reads the directory opened with file descriptor fd, applying function f to each filename in it."
      },
      {
        "name": "dolockOSThread",
        "desc": "dolockOSThread is called by LockOSThread and lockOSThread below after they modify m.locked. Do not allow preemption during this call, or else the m might be different in this function than in the caller."
      },
      {
        "name": "domsanread",
        "desc": ""
      },
      {
        "name": "dopanic_m",
        "desc": "gp is the crashing g running on this M, but may be a user G, while getg() is always g0. If bubble is non-nil, print the stacks for goroutines in this group as well."
      },
      {
        "name": "doubleCheckHeapPointers",
        "desc": ""
      },
      {
        "name": "doubleCheckHeapPointersInterior",
        "desc": ""
      },
      {
        "name": "doubleCheckHeapType",
        "desc": ""
      },
      {
        "name": "doubleCheckTypePointersOfType",
        "desc": ""
      },
      {
        "name": "dounlockOSThread",
        "desc": "dounlockOSThread is called by UnlockOSThread and unlockOSThread below after they update m-\u003elocked. Do not allow preemption during this call, or else the m might be in different in this function than in the caller."
      },
      {
        "name": "dropg",
        "desc": "dropg removes the association between m and the current goroutine m-\u003ecurg (gp for short). Typically a caller sets gp's status away from Grunning and then immediately calls dropg to finish the job. The caller is also responsible for arranging that gp will be restarted using ready at an appropriate time. After calling dropg and arranging for gp to be readied later, the caller can do other work but eventually should call schedule to restart the scheduling of goroutines on this m."
      },
      {
        "name": "dropm",
        "desc": "dropm puts the current m back onto the extra list.  1. On systems without pthreads, like Windows dropm is called when a cgo callback has called needm but is now done with the callback and returning back into the non-Go thread.  The main expense here is the call to signalstack to release the m's signal stack, and then the call to needm on the next callback from this thread. It is tempting to try to save the m for next time, which would eliminate both these costs, but there might not be a next time: the current thread (which Go does not control) might exit. If we saved the m for that thread, there would be an m leak each time such a thread exited. Instead, we acquire and release an m on each call. These should typically not be scheduling operations, just a few atomics, so the cost should be small.  2. On systems with pthreads dropm is called while a non-Go thread is exiting. We allocate a pthread per-thread variable using pthread_key_create, to register a thread-exit-time destructor. And store the g into a thread-specific value associated with the pthread key, when first return back to C. So that the destructor would invoke dropm while the non-Go thread is exiting. This is much faster since it avoids expensive signal-related syscalls.  This always runs without a P, so //go:nowritebarrierrec is required.  This may run with a different stack than was recorded in g0 (there is no call to callbackUpdateSystemStack prior to dropm), so this must be //go:nosplit to avoid the stack bounds check."
      },
      {
        "name": "duffcopy",
        "desc": ""
      },
      {
        "name": "duffzero",
        "desc": ""
      },
      {
        "name": "dumpGCProg",
        "desc": ""
      },
      {
        "name": "dumpScanStats",
        "desc": ""
      },
      {
        "name": "dumpTypePointers",
        "desc": ""
      },
      {
        "name": "dumpbool",
        "desc": ""
      },
      {
        "name": "dumpbv",
        "desc": "dump kinds \u0026 offsets of interesting fields in bv."
      },
      {
        "name": "dumpfields",
        "desc": "dumpint() the kind \u0026 offset of each field in an object."
      },
      {
        "name": "dumpfinalizer",
        "desc": ""
      },
      {
        "name": "dumpframe",
        "desc": ""
      },
      {
        "name": "dumpgoroutine",
        "desc": ""
      },
      {
        "name": "dumpgs",
        "desc": ""
      },
      {
        "name": "dumpgstatus",
        "desc": ""
      },
      {
        "name": "dumpint",
        "desc": "dump a uint64 in a varint format parseable by encoding/binary."
      },
      {
        "name": "dumpitabs",
        "desc": ""
      },
      {
        "name": "dumpmemprof",
        "desc": ""
      },
      {
        "name": "dumpmemprof_callback",
        "desc": ""
      },
      {
        "name": "dumpmemrange",
        "desc": "dump varint uint64 length followed by memory contents."
      },
      {
        "name": "dumpmemstats",
        "desc": ""
      },
      {
        "name": "dumpms",
        "desc": ""
      },
      {
        "name": "dumpobj",
        "desc": "dump an object."
      },
      {
        "name": "dumpobjs",
        "desc": ""
      },
      {
        "name": "dumpotherroot",
        "desc": ""
      },
      {
        "name": "dumpparams",
        "desc": ""
      },
      {
        "name": "dumpregs",
        "desc": ""
      },
      {
        "name": "dumproots",
        "desc": ""
      },
      {
        "name": "dumpslice",
        "desc": ""
      },
      {
        "name": "dumpstr",
        "desc": ""
      },
      {
        "name": "dumptype",
        "desc": "dump information for a type."
      },
      {
        "name": "dupfd",
        "desc": ""
      },
      {
        "name": "dwrite",
        "desc": ""
      },
      {
        "name": "dwritebyte",
        "desc": ""
      },
      {
        "name": "efaceHash",
        "desc": ""
      },
      {
        "name": "efaceeq",
        "desc": ""
      },
      {
        "name": "elideWrapperCalling",
        "desc": "elideWrapperCalling reports whether a wrapper function that called function id should be elided from stack traces."
      },
      {
        "name": "empty",
        "desc": "empty reports whether a read from c would block (that is, the channel is empty).  It is atomically correct and sequentially consistent at the moment it returns, but since the channel is unlocked, the channel may become non-empty immediately afterward."
      },
      {
        "name": "emptyfunc",
        "desc": ""
      },
      {
        "name": "enableWER",
        "desc": "enableWER is called by setTraceback(\"wer\"). Windows Error Reporting (WER) is only supported on Windows."
      },
      {
        "name": "encoderune",
        "desc": "encoderune writes into p (which must be large enough) the UTF-8 encoding of the rune. It returns the number of bytes written."
      },
      {
        "name": "endCheckmarks",
        "desc": "endCheckmarks ends the checkmarks phase."
      },
      {
        "name": "ensureSigM",
        "desc": "ensureSigM starts one global, sleeping thread to make sure at least one thread is available to catch signals enabled for os/signal."
      },
      {
        "name": "entersyscall",
        "desc": "Standard syscall entry used by the go syscall library and normal cgo calls.  This is exported via linkname to assembly in the syscall package and x/sys.  Other packages should not be accessing entersyscall directly, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "entersyscall_gcwait",
        "desc": ""
      },
      {
        "name": "entersyscall_sysmon",
        "desc": ""
      },
      {
        "name": "entersyscallblock",
        "desc": "entersyscallblock should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "entersyscallblock_handoff",
        "desc": ""
      },
      {
        "name": "envKeyEqual",
        "desc": "envKeyEqual reports whether a == b, with ASCII-only case insensitivity on Windows. The two strings must have the same length."
      },
      {
        "name": "environ",
        "desc": ""
      },
      {
        "name": "eqslice",
        "desc": ""
      },
      {
        "name": "errno",
        "desc": ""
      },
      {
        "name": "errstr",
        "desc": ""
      },
      {
        "name": "evacuate",
        "desc": ""
      },
      {
        "name": "evacuate_fast32",
        "desc": ""
      },
      {
        "name": "evacuate_fast64",
        "desc": ""
      },
      {
        "name": "evacuate_faststr",
        "desc": ""
      },
      {
        "name": "evacuated",
        "desc": ""
      },
      {
        "name": "exceptionhandler",
        "desc": "Called by sigtramp from Windows VEH handler. Return value signals whether the exception has been handled (EXCEPTION_CONTINUE_EXECUTION) or should be made available to other handlers in the chain (EXCEPTION_CONTINUE_SEARCH).  This is nosplit to avoid growing the stack until we've checked for _EXCEPTION_BREAKPOINT, which is raised by abort() if we overflow the g0 stack."
      },
      {
        "name": "exceptiontramp",
        "desc": "in sys_windows_386.s, sys_windows_amd64.s, sys_windows_arm.s, and sys_windows_arm64.s"
      },
      {
        "name": "execute",
        "desc": "Schedules gp to run on the current M. If inheritTime is true, gp inherits the remaining time in the current time slice. Otherwise, it starts a new time slice. Never returns.  Write barriers are allowed because this is called immediately after acquiring a P in several places."
      },
      {
        "name": "exit",
        "desc": "This is exported via linkname to assembly in runtime/cgo."
      },
      {
        "name": "exit1",
        "desc": ""
      },
      {
        "name": "exitThread",
        "desc": "exitThread terminates the current thread, writing *wait = freeMStack when the stack is safe to reclaim."
      },
      {
        "name": "exit_trampoline",
        "desc": ""
      },
      {
        "name": "exits",
        "desc": ""
      },
      {
        "name": "exitsyscall",
        "desc": "The goroutine g exited its system call. Arrange for it to run on a cpu again. This is called only from the go syscall library, not from the low-level system calls used by the runtime.  Write barriers are not allowed because our P may have been stolen.  This is exported via linkname to assembly in the syscall package.  exitsyscall should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "exitsyscall0",
        "desc": "exitsyscall slow path on g0. Failed to acquire P, enqueue gp as runnable.  Called via mcall, so gp is the calling g from this M."
      },
      {
        "name": "exitsyscallfast",
        "desc": ""
      },
      {
        "name": "exitsyscallfast_pidle",
        "desc": ""
      },
      {
        "name": "exitsyscallfast_reacquired",
        "desc": "exitsyscallfast_reacquired is the exitsyscall path on which this G has successfully reacquired the P it was running on before the syscall."
      },
      {
        "name": "expandFrames",
        "desc": ""
      },
      {
        "name": "f32equal",
        "desc": ""
      },
      {
        "name": "f32hash",
        "desc": ""
      },
      {
        "name": "f32to64",
        "desc": ""
      },
      {
        "name": "f32toint32",
        "desc": ""
      },
      {
        "name": "f32toint64",
        "desc": ""
      },
      {
        "name": "f32touint64",
        "desc": ""
      },
      {
        "name": "f64equal",
        "desc": ""
      },
      {
        "name": "f64hash",
        "desc": ""
      },
      {
        "name": "f64to32",
        "desc": ""
      },
      {
        "name": "f64toint",
        "desc": ""
      },
      {
        "name": "f64toint32",
        "desc": ""
      },
      {
        "name": "f64toint64",
        "desc": ""
      },
      {
        "name": "f64touint64",
        "desc": ""
      },
      {
        "name": "fadd32",
        "desc": ""
      },
      {
        "name": "fadd64",
        "desc": ""
      },
      {
        "name": "fallback_nanotime",
        "desc": ""
      },
      {
        "name": "fallback_walltime",
        "desc": ""
      },
      {
        "name": "fandbits",
        "desc": ""
      },
      {
        "name": "fastexprand",
        "desc": "fastexprand returns a random number from an exponential distribution with the specified mean."
      },
      {
        "name": "fastlog2",
        "desc": "fastlog2 implements a fast approximation to the base 2 log of a float64. This is used to compute a geometric distribution for heap sampling, without introducing dependencies into package math. This uses a very rough approximation using the float64 exponent and the first 25 bits of the mantissa. The top 5 bits of the mantissa are used to load limits from a table of constants and the rest are used to scale linearly between them."
      },
      {
        "name": "fatal",
        "desc": "fatal triggers a fatal error that dumps a stack trace and exits.  fatal is equivalent to throw, but is used when user code is expected to be at fault for the failure, such as racing map writes.  fatal does not include runtime frames, system goroutines, or frame metadata (fp, sp, pc) in the stack trace unless GOTRACEBACK=system or higher."
      },
      {
        "name": "fatalpanic",
        "desc": "fatalpanic implements an unrecoverable panic. It is like fatalthrow, except that if msgs != nil, fatalpanic also prints panic messages and decrements runningPanicDefers once main is blocked from exiting."
      },
      {
        "name": "fatalthrow",
        "desc": "fatalthrow implements an unrecoverable runtime throw. It freezes the system, prints stack traces starting from its caller, and terminates the process."
      },
      {
        "name": "fcmp64",
        "desc": ""
      },
      {
        "name": "fcntl",
        "desc": ""
      },
      {
        "name": "fcntl_trampoline",
        "desc": ""
      },
      {
        "name": "fdiv32",
        "desc": ""
      },
      {
        "name": "fdiv64",
        "desc": ""
      },
      {
        "name": "feq32",
        "desc": ""
      },
      {
        "name": "feq64",
        "desc": ""
      },
      {
        "name": "fge32",
        "desc": ""
      },
      {
        "name": "fge64",
        "desc": ""
      },
      {
        "name": "fgt32",
        "desc": ""
      },
      {
        "name": "fgt64",
        "desc": ""
      },
      {
        "name": "fillAligned",
        "desc": "fillAligned returns x but with all zeroes in m-aligned groups of m bits set to 1 if any bit in the group is non-zero.  For example, fillAligned(0x0100a3, 8) == 0xff00ff.  Note that if m == 1, this is a no-op.  m must be a power of 2 \u003c= maxPagesPerPhysPage."
      },
      {
        "name": "fillstack",
        "desc": ""
      },
      {
        "name": "finReadQueueStats",
        "desc": ""
      },
      {
        "name": "finalizercommit",
        "desc": ""
      },
      {
        "name": "findBitRange64",
        "desc": "findBitRange64 returns the bit index of the first set of n consecutive 1 bits. If no consecutive set of 1 bits of size n may be found in c, then it returns an integer \u003e= 64. n must be \u003e 0."
      },
      {
        "name": "findObject",
        "desc": "findObject returns the base address for the heap object containing the address p, the object's span, and the index of the object in s. If p does not point into a heap object, it returns base == 0.  If p points is an invalid heap pointer and debug.invalidptr != 0, findObject panics.  refBase and refOff optionally give the base address of the object in which the pointer p was found and the byte offset at which it was found. These are used for error reporting.  It is nosplit so it is safe for p to be a pointer to the current goroutine's stack. Since p is a uintptr, it would not be adjusted if the stack were to move.  findObject should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "findRunnable",
        "desc": "Finds a runnable goroutine to execute. Tries to steal from other P's, get g from local or global queue, poll network. tryWakeP indicates that the returned goroutine is not normal (GC worker, trace reader) so the caller should try to wake a P."
      },
      {
        "name": "findnull",
        "desc": ""
      },
      {
        "name": "findnullw",
        "desc": ""
      },
      {
        "name": "findsghi",
        "desc": ""
      },
      {
        "name": "finishDebugVarsSetup",
        "desc": ""
      },
      {
        "name": "finishsweep_m",
        "desc": "finishsweep_m ensures that all spans are swept.  The world must be stopped. This ensures there are no sweeps in progress."
      },
      {
        "name": "finq_callback",
        "desc": ""
      },
      {
        "name": "fint32to32",
        "desc": ""
      },
      {
        "name": "fint32to64",
        "desc": ""
      },
      {
        "name": "fint64to32",
        "desc": ""
      },
      {
        "name": "fint64to64",
        "desc": ""
      },
      {
        "name": "fintto32",
        "desc": ""
      },
      {
        "name": "fintto64",
        "desc": ""
      },
      {
        "name": "fips_fatal",
        "desc": ""
      },
      {
        "name": "fips_getIndicator",
        "desc": ""
      },
      {
        "name": "fips_setIndicator",
        "desc": ""
      },
      {
        "name": "firstcontinuehandler",
        "desc": "It seems Windows searches ContinueHandler's list even if ExceptionHandler returns EXCEPTION_CONTINUE_EXECUTION. firstcontinuehandler will stop that search, if exceptionhandler did the same earlier.  It is nosplit for the same reason as exceptionhandler."
      },
      {
        "name": "firstcontinuetramp",
        "desc": ""
      },
      {
        "name": "float64Inf",
        "desc": ""
      },
      {
        "name": "float64NegInf",
        "desc": ""
      },
      {
        "name": "float64bits",
        "desc": "float64bits returns the IEEE 754 binary representation of f."
      },
      {
        "name": "float64frombits",
        "desc": "float64frombits returns the floating point number corresponding the IEEE 754 binary representation b."
      },
      {
        "name": "float64toint64",
        "desc": ""
      },
      {
        "name": "float64touint32",
        "desc": ""
      },
      {
        "name": "float64touint64",
        "desc": ""
      },
      {
        "name": "floor",
        "desc": "floor returns the greatest integer value less than or equal to x.  Special cases are:  \tfloor(±0) = ±0 \tfloor(±Inf) = ±Inf \tfloor(NaN) = NaN  N.B. Portable floor copied from math. math also has optimized arch-specific implementations."
      },
      {
        "name": "flush",
        "desc": ""
      },
      {
        "name": "flushallmcaches",
        "desc": "flushallmcaches flushes the mcaches of all Ps.  The world must be stopped."
      },
      {
        "name": "flushmcache",
        "desc": "flushmcache flushes the mcache of allp[i].  The world must be stopped."
      },
      {
        "name": "fmax",
        "desc": ""
      },
      {
        "name": "fmax32",
        "desc": ""
      },
      {
        "name": "fmax64",
        "desc": ""
      },
      {
        "name": "fmin",
        "desc": ""
      },
      {
        "name": "fmin32",
        "desc": ""
      },
      {
        "name": "fmin64",
        "desc": ""
      },
      {
        "name": "fmtNSAsMS",
        "desc": "fmtNSAsMS nicely formats ns nanoseconds as milliseconds."
      },
      {
        "name": "fmul32",
        "desc": ""
      },
      {
        "name": "fmul64",
        "desc": ""
      },
      {
        "name": "fneg64",
        "desc": ""
      },
      {
        "name": "forEachG",
        "desc": "forEachG calls fn on every G from allgs.  forEachG takes a lock to exclude concurrent addition of new Gs."
      },
      {
        "name": "forEachGRace",
        "desc": "forEachGRace calls fn on every G from allgs.  forEachGRace avoids locking, but does not exclude addition of new Gs during execution, which may be missed."
      },
      {
        "name": "forEachP",
        "desc": "forEachP calls fn(p) for every P p when p reaches a GC safe point. If a P is currently executing code, this will bring the P to a GC safe point and execute fn on that P. If the P is not executing code (it is idle or in a syscall), this will call fn(p) directly while preventing the P from exiting its state. This does not ensure that fn will run on every CPU executing Go code, but it acts as a global memory barrier. GC uses this as a \"ragged barrier.\"  The caller must hold worldsema. fn must not refer to any part of the current goroutine's stack, since the GC may move it."
      },
      {
        "name": "forEachPInternal",
        "desc": "forEachPInternal calls fn(p) for every P p when p reaches a GC safe point. It is the internal implementation of forEachP.  The caller must hold worldsema and either must ensure that a GC is not running (otherwise this may deadlock with the GC trying to preempt this P) or it must leave its goroutine in a preemptible state before it switches to the systemstack. Due to these restrictions, prefer forEachP when possible."
      },
      {
        "name": "forEachSpecial",
        "desc": "forEachSpecial is an iterator over all specials.  Used by debug.checkfinalizers.  The world must be stopped."
      },
      {
        "name": "forbits",
        "desc": ""
      },
      {
        "name": "forcegchelper",
        "desc": ""
      },
      {
        "name": "fpRegAddr",
        "desc": "fpRegAddr returns the address of the ith fp-simd register in sigcontext."
      },
      {
        "name": "fpTracebackPCs",
        "desc": "fpTracebackPCs populates pcBuf with the return addresses for each frame and returns the number of PCs written to pcBuf. The returned PCs correspond to \"physical frames\" rather than \"logical frames\"; that is if A is inlined into B, this will return a PC for only B."
      },
      {
        "name": "fpTracebackPartialExpand",
        "desc": "fpTracebackPartialExpand records a call stack obtained starting from fp. This function will skip the given number of frames, properly accounting for inlining, and save remaining frames as \"physical\" return addresses. The consumer should later use CallersFrames or similar to expand inline frames."
      },
      {
        "name": "fpack32",
        "desc": ""
      },
      {
        "name": "fpack64",
        "desc": ""
      },
      {
        "name": "fpunwindExpand",
        "desc": "fpunwindExpand expands a call stack from pcBuf into dst, returning the number of PCs written to dst. pcBuf and dst should not overlap.  fpunwindExpand checks if pcBuf contains logical frames (which include inlined frames) or physical frames (produced by frame pointer unwinding) using a sentinel value in pcBuf[0]. Logical frames are simply returned without the sentinel. Physical frames are turned into logical frames via inline unwinding and by applying the skip value that's stored in pcBuf[0]."
      },
      {
        "name": "freeSomeWbufs",
        "desc": "freeSomeWbufs frees some workbufs back to the heap and returns true if it should be called again to free more."
      },
      {
        "name": "freeSpecial",
        "desc": "freeSpecial performs any cleanup on special s and deallocates it. s must already be unlinked from the specials list."
      },
      {
        "name": "freeStackSpans",
        "desc": "freeStackSpans frees unused stack spans at the end of GC."
      },
      {
        "name": "freeUserArenaChunk",
        "desc": "freeUserArenaChunk releases the user arena represented by s back to the runtime.  x must be a live pointer within s.  The runtime will set the user arena to fault once it's safe (the GC is no longer running) and then once the user arena is no longer referenced by the application, will allow it to be reused."
      },
      {
        "name": "freemcache",
        "desc": "freemcache releases resources associated with this mcache and puts the object onto a free list.  In some cases there is no way to simply release resources, such as statistics, so donate them to a different mcache (the recipient)."
      },
      {
        "name": "freezetheworld",
        "desc": "Similar to stopTheWorld but best-effort and can be called several times. There is no reverse operation, used during crashing. This function must not lock any mutexes."
      },
      {
        "name": "frombe",
        "desc": ""
      },
      {
        "name": "fsub64",
        "desc": ""
      },
      {
        "name": "fuint64to32",
        "desc": ""
      },
      {
        "name": "fuint64to64",
        "desc": ""
      },
      {
        "name": "full",
        "desc": "full reports whether a send on c would block (that is, the channel is full). It uses a single word-sized read of mutable state, so although the answer is instantaneously true, the correct answer may have changed by the time the calling function receives the return value."
      },
      {
        "name": "funcMaxSPDelta",
        "desc": "funcMaxSPDelta returns the maximum spdelta at any point in f."
      },
      {
        "name": "funcNameForPrint",
        "desc": "funcNameForPrint returns the function name for printing to the user."
      },
      {
        "name": "funcNamePiecesForPrint",
        "desc": "funcNamePiecesForPrint returns the function name for printing to the user. It returns three pieces so it doesn't need an allocation for string concatenation."
      },
      {
        "name": "funcdata",
        "desc": "funcdata returns a pointer to the ith funcdata for f. funcdata should be kept in sync with cmd/link:writeFuncs."
      },
      {
        "name": "funcfile",
        "desc": ""
      },
      {
        "name": "funcline",
        "desc": ""
      },
      {
        "name": "funcline1",
        "desc": "funcline1 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "funcname",
        "desc": ""
      },
      {
        "name": "funcpkgpath",
        "desc": ""
      },
      {
        "name": "funcspdelta",
        "desc": ""
      },
      {
        "name": "funpack32",
        "desc": ""
      },
      {
        "name": "funpack64",
        "desc": ""
      },
      {
        "name": "futex",
        "desc": ""
      },
      {
        "name": "futexsleep",
        "desc": "Atomically,  \tif(*addr == val) sleep  Might be woken up spuriously; that's allowed. Don't sleep longer than ns; ns \u003c 0 means forever."
      },
      {
        "name": "futexsleep1",
        "desc": ""
      },
      {
        "name": "futexwakeup",
        "desc": "If any procs are sleeping on addr, wake up at most cnt."
      },
      {
        "name": "g0_pthread_key_create",
        "desc": ""
      },
      {
        "name": "g0_pthread_setspecific",
        "desc": ""
      },
      {
        "name": "gbit16",
        "desc": "gbit16 reads a 16-bit little-endian binary number from b and returns it with the remaining slice of b."
      },
      {
        "name": "gcAssistAlloc",
        "desc": "gcAssistAlloc performs GC work to make gp's assist debt positive. gp must be the calling user goroutine.  This must be called with preemption enabled."
      },
      {
        "name": "gcAssistAlloc1",
        "desc": "gcAssistAlloc1 is the part of gcAssistAlloc that runs on the system stack. This is a separate function to make it easier to see that we're not capturing anything from the user stack, since the user stack may move while we're in this function.  gcAssistAlloc1 indicates whether this assist completed the mark phase by setting gp.param to non-nil. This can't be communicated on the stack since it may move."
      },
      {
        "name": "gcBgMarkPrepare",
        "desc": "gcBgMarkPrepare sets up state for background marking. Mutator assists must not yet be enabled."
      },
      {
        "name": "gcBgMarkStartWorkers",
        "desc": "gcBgMarkStartWorkers prepares background mark worker goroutines. These goroutines will not run until the mark phase, but they must be started while the work is not stopped and from a regular G stack. The caller must hold worldsema."
      },
      {
        "name": "gcBgMarkWorker",
        "desc": ""
      },
      {
        "name": "gcComputeStartingStackSize",
        "desc": ""
      },
      {
        "name": "gcControllerCommit",
        "desc": "gcControllerCommit is gcController.commit, but passes arguments from live (non-test) data. It also updates any consumers of the GC pacing, such as sweep pacing and the background scavenger.  Calls gcController.commit.  The heap lock must be held, so this must be executed on the system stack."
      },
      {
        "name": "gcDrain",
        "desc": "gcDrain scans roots and objects in work buffers, blackening grey objects until it is unable to get more work. It may return before GC is done; it's the caller's responsibility to balance work from other Ps.  If flags\u0026gcDrainUntilPreempt != 0, gcDrain returns when g.preempt is set.  If flags\u0026gcDrainIdle != 0, gcDrain returns when there is other work to do.  If flags\u0026gcDrainFractional != 0, gcDrain self-preempts when pollFractionalWorkerExit() returns true. This implies gcDrainNoBlock.  If flags\u0026gcDrainFlushBgCredit != 0, gcDrain flushes scan work credit to gcController.bgScanCredit every gcCreditSlack units of scan work.  gcDrain will always return if there is a pending STW or forEachP.  Disabling write barriers is necessary to ensure that after we've confirmed that we've drained gcw, that we don't accidentally end up flipping that condition by immediately adding work in the form of a write barrier buffer flush.  Don't set nowritebarrierrec because it's safe for some callees to have write barriers enabled."
      },
      {
        "name": "gcDrainMarkWorkerDedicated",
        "desc": "gcDrainMarkWorkerDedicated is a wrapper for gcDrain that exists to better account mark time in profiles."
      },
      {
        "name": "gcDrainMarkWorkerFractional",
        "desc": "gcDrainMarkWorkerFractional is a wrapper for gcDrain that exists to better account mark time in profiles."
      },
      {
        "name": "gcDrainMarkWorkerIdle",
        "desc": "gcDrainMarkWorkerIdle is a wrapper for gcDrain that exists to better account mark time in profiles."
      },
      {
        "name": "gcDrainN",
        "desc": "gcDrainN blackens grey objects until it has performed roughly scanWork units of scan work or the G is preempted. This is best-effort, so it may perform less work if it fails to get a work buffer. Otherwise, it will perform at least n units of work, but may perform more because scanning is always done in whole object increments. It returns the amount of scan work performed.  The caller goroutine must be in a preemptible state (e.g., _Gwaiting) to prevent deadlocks during stack scanning. As a consequence, this must be called on the system stack."
      },
      {
        "name": "gcDumpObject",
        "desc": "gcDumpObject dumps the contents of obj for debugging and marks the field at byte offset off in obj."
      },
      {
        "name": "gcFlushBgCredit",
        "desc": "gcFlushBgCredit flushes scanWork units of background scan work credit. This first satisfies blocked assists on the work.assistQueue and then flushes any remaining credit to gcController.bgScanCredit.  Write barriers are disallowed because this is used by gcDrain after it has ensured that all work is drained and this must preserve that condition."
      },
      {
        "name": "gcMark",
        "desc": "gcMark runs the mark (or, for concurrent GC, mark termination) All gcWork caches must be empty. STW is in effect at this point."
      },
      {
        "name": "gcMarkDone",
        "desc": "gcMarkDone transitions the GC from mark to mark termination if all reachable objects have been marked (that is, there are no grey objects and can be no more in the future). Otherwise, it flushes all local work to the global queues where it can be discovered by other workers.  This should be called when all local mark work has been drained and there are no remaining workers. Specifically, when  \twork.nwait == work.nproc \u0026\u0026 !gcMarkWorkAvailable(p)  The calling context must be preemptible.  Flushing local work is important because idle Ps may have local work queued. This is the only way to make that work visible and drive GC to completion.  It is explicitly okay to have write barriers in this function. If it does transition to mark termination, then all reachable objects have been marked, so the write barrier cannot shade any more objects."
      },
      {
        "name": "gcMarkRootCheck",
        "desc": "gcMarkRootCheck checks that all roots have been scanned. It is purely for debugging."
      },
      {
        "name": "gcMarkTermination",
        "desc": "World must be stopped and mark assists and background workers must be disabled."
      },
      {
        "name": "gcMarkTinyAllocs",
        "desc": "gcMarkTinyAllocs greys all active tiny alloc blocks.  The world must be stopped."
      },
      {
        "name": "gcMarkWorkAvailable",
        "desc": "gcMarkWorkAvailable reports whether executing a mark worker on p is potentially useful. p may be nil, in which case it only checks the global sources of work."
      },
      {
        "name": "gcPaceScavenger",
        "desc": "gcPaceScavenger updates the scavenger's pacing, particularly its rate and RSS goal. For this, it requires the current heapGoal, and the heapGoal for the previous GC cycle.  The RSS goal is based on the current heap goal with a small overhead to accommodate non-determinism in the allocator.  The pacing is based on scavengePageRate, which applies to both regular and huge pages. See that constant for more information.  Must be called whenever GC pacing is updated.  mheap_.lock must be held or the world must be stopped."
      },
      {
        "name": "gcPaceSweeper",
        "desc": "gcPaceSweeper updates the sweeper's pacing parameters.  Must be called whenever the GC's pacing is updated.  The world must be stopped, or mheap_.lock must be held."
      },
      {
        "name": "gcParkAssist",
        "desc": "gcParkAssist puts the current goroutine on the assist queue and parks.  gcParkAssist reports whether the assist is now satisfied. If it returns false, the caller must retry the assist."
      },
      {
        "name": "gcPrepareMarkRoots",
        "desc": "gcPrepareMarkRoots queues root scanning jobs (stacks, globals, and some miscellany) and initializes scanning-related state.  The world must be stopped."
      },
      {
        "name": "gcResetMarkState",
        "desc": "gcResetMarkState resets global state prior to marking (concurrent or STW) and resets the stack scan state of all Gs.  This is safe to do without the world stopped because any Gs created during or after this will start out in the reset state.  gcResetMarkState must be called on the system stack because it acquires the heap lock. See mheap for details."
      },
      {
        "name": "gcScanCleanup",
        "desc": "gcScanCleanup scans the relevant parts of a cleanup special as a root."
      },
      {
        "name": "gcScanFinalizer",
        "desc": "gcScanFinalizer scans the relevant parts of a finalizer special as a root."
      },
      {
        "name": "gcStart",
        "desc": "gcStart starts the GC. It transitions from _GCoff to _GCmark (if debug.gcstoptheworld == 0) or performs all of GC (if debug.gcstoptheworld != 0).  This may return without performing this transition in some cases, such as when called on a system stack or with locks held."
      },
      {
        "name": "gcSweep",
        "desc": "gcSweep must be called on the system stack because it acquires the heap lock. See mheap for details.  Returns true if the heap was fully swept by this function.  The world must be stopped."
      },
      {
        "name": "gcTestIsReachable",
        "desc": "gcTestIsReachable performs a GC and returns a bit set where bit i is set if ptrs[i] is reachable."
      },
      {
        "name": "gcTestMoveStackOnNextCall",
        "desc": "gcTestMoveStackOnNextCall causes the stack to be moved on a call immediately following the call to this. It may not work correctly if any other work appears after this call (such as returning). Typically the following call should be marked go:noinline so it performs a stack check.  In rare cases this may not cause the stack to move, specifically if there's a preemption between this call and the next."
      },
      {
        "name": "gcTestPointerClass",
        "desc": "gcTestPointerClass returns the category of what p points to, one of: \"heap\", \"stack\", \"data\", \"bss\", \"other\". This is useful for checking that a test is doing what it's intended to do.  This is nosplit simply to avoid extra pointer shuffling that may complicate a test."
      },
      {
        "name": "gcUsesSpanInlineMarkBits",
        "desc": "gcUsesSpanInlineMarkBits returns true if a span holding objects of a certain size has inline mark bits. size must be the span's elemsize.  nosplit because this is called from gcmarknewobject, which is nosplit."
      },
      {
        "name": "gcWaitOnMark",
        "desc": "gcWaitOnMark blocks until GC finishes the Nth mark phase. If GC has already completed this mark phase, it returns immediately."
      },
      {
        "name": "gcWakeAllAssists",
        "desc": "gcWakeAllAssists wakes all currently blocked assists. This is used at the end of a GC cycle. gcBlackenEnabled must be false to prevent new assists from going to sleep after this point."
      },
      {
        "name": "gcWakeAllStrongFromWeak",
        "desc": "gcWakeAllStrongFromWeak wakes all currently blocked weak-\u003estrong conversions. This is used at the end of a GC cycle.  work.strongFromWeak.block must be false to prevent woken goroutines from immediately going back to sleep."
      },
      {
        "name": "gcWriteBarrier1",
        "desc": "Called from compiled code; declared for vet; do NOT call from Go."
      },
      {
        "name": "gcWriteBarrier2",
        "desc": "gcWriteBarrier2 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "gcWriteBarrier3",
        "desc": ""
      },
      {
        "name": "gcWriteBarrier4",
        "desc": ""
      },
      {
        "name": "gcWriteBarrier5",
        "desc": ""
      },
      {
        "name": "gcWriteBarrier6",
        "desc": ""
      },
      {
        "name": "gcWriteBarrier7",
        "desc": ""
      },
      {
        "name": "gcWriteBarrier8",
        "desc": ""
      },
      {
        "name": "gcWriteBarrierBP",
        "desc": ""
      },
      {
        "name": "gcWriteBarrierBX",
        "desc": ""
      },
      {
        "name": "gcWriteBarrierCX",
        "desc": "Called from compiled code; declared for vet; do NOT call from Go."
      },
      {
        "name": "gcWriteBarrierDX",
        "desc": ""
      },
      {
        "name": "gcWriteBarrierR8",
        "desc": ""
      },
      {
        "name": "gcWriteBarrierR9",
        "desc": ""
      },
      {
        "name": "gcWriteBarrierSI",
        "desc": ""
      },
      {
        "name": "gcallers",
        "desc": ""
      },
      {
        "name": "gcd",
        "desc": ""
      },
      {
        "name": "gcenable",
        "desc": "gcenable is called after the bulk of the runtime initialization, just before we're about to start letting user code run. It kicks off the background sweeper goroutine, the background scavenger goroutine, and enables GC."
      },
      {
        "name": "gcinit",
        "desc": ""
      },
      {
        "name": "gcmarknewobject",
        "desc": "gcmarknewobject marks a newly allocated object black. obj must not contain any non-nil pointers.  This is nosplit so it can manipulate a gcWork without preemption."
      },
      {
        "name": "gcount",
        "desc": ""
      },
      {
        "name": "gcstopm",
        "desc": "Stops the current m for stopTheWorld. Returns when the world is restarted."
      },
      {
        "name": "gdestroy",
        "desc": ""
      },
      {
        "name": "gdirname",
        "desc": "gdirname returns the first filename from a buffer of directory entries, and a slice containing the remaining directory entries. If the buffer doesn't start with a valid directory entry, the returned name is nil."
      },
      {
        "name": "getAuxv",
        "desc": "golang.org/x/sys/cpu and golang.org/x/sys/unix use getAuxv via linkname. Do not remove or change the type signature. See go.dev/issue/57336 and go.dev/issue/67401."
      },
      {
        "name": "getCPUCount",
        "desc": ""
      },
      {
        "name": "getCheckmark",
        "desc": ""
      },
      {
        "name": "getCntxct",
        "desc": ""
      },
      {
        "name": "getExtraM",
        "desc": "Return an M from the extra M list. Returns last == true if the list becomes empty because of this call.  Spins waiting for an extra M, so caller must ensure that the list always contains or will soon contain at least one M."
      },
      {
        "name": "getGCMask",
        "desc": "getGCMask returns the pointer/nonpointer bitmask for type t.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "getGCMaskOnDemand",
        "desc": "nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "getGodebugEarly",
        "desc": "getGodebugEarly extracts the environment variable GODEBUG from the environment on Unix-like operating systems and returns it. This function exists to extract GODEBUG early before much of the runtime is initialized.  Returns nil, false if OS doesn't provide env vars early in the init sequence."
      },
      {
        "name": "getHugePageSize",
        "desc": ""
      },
      {
        "name": "getOSRev",
        "desc": ""
      },
      {
        "name": "getOrAddWeakHandle",
        "desc": "Retrieves or creates a weak pointer handle for the object p."
      },
      {
        "name": "getOrSetBubbleSpecial",
        "desc": "getOrSetBubbleSpecial checks the special record for p's bubble membership.  If add is true and p is not associated with any bubble, it adds a special record for p associating it with bubbleid.  It returns ok==true if p is associated with bubbleid (including if a new association was added), and ok==false if not."
      },
      {
        "name": "getPageSize",
        "desc": ""
      },
      {
        "name": "getRandomData",
        "desc": ""
      },
      {
        "name": "getStaticuint64s",
        "desc": "getStaticuint64s is called by the reflect package to get a pointer to the read-only array."
      },
      {
        "name": "getVal32",
        "desc": ""
      },
      {
        "name": "getVal64",
        "desc": ""
      },
      {
        "name": "getWeakHandle",
        "desc": ""
      },
      {
        "name": "getcallerfp",
        "desc": "getcallerfp returns the frame pointer of the caller of the caller of this function."
      },
      {
        "name": "getcontext",
        "desc": ""
      },
      {
        "name": "getcpucap",
        "desc": "Return the minimum value seen for the zone CPU cap, or 0 if no cap is detected."
      },
      {
        "name": "getegid",
        "desc": ""
      },
      {
        "name": "geteuid",
        "desc": ""
      },
      {
        "name": "getfp",
        "desc": "getfp returns the frame pointer register of its caller or 0 if not implemented. TODO: Make this a compiler intrinsic"
      },
      {
        "name": "getgid",
        "desc": ""
      },
      {
        "name": "getlasterror",
        "desc": "in sys_windows_386.s and sys_windows_amd64.s:"
      },
      {
        "name": "getm",
        "desc": "A helper function for EnsureDropM.  getm should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - fortio.org/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "getpid",
        "desc": ""
      },
      {
        "name": "getrctl",
        "desc": ""
      },
      {
        "name": "getsig",
        "desc": ""
      },
      {
        "name": "getthrid",
        "desc": ""
      },
      {
        "name": "getthrid_trampoline",
        "desc": ""
      },
      {
        "name": "gettid",
        "desc": ""
      },
      {
        "name": "getuid",
        "desc": ""
      },
      {
        "name": "gfpurge",
        "desc": "Purge all cached G's from gfree list to the global list."
      },
      {
        "name": "gfput",
        "desc": "Put on gfree list. If local list is too long, transfer a batch to the global list."
      },
      {
        "name": "globrunqgetbatch",
        "desc": "Try get a batch of G's from the global runnable queue. sched.lock must be held."
      },
      {
        "name": "globrunqput",
        "desc": "Put gp on the global runnable queue. sched.lock must be held. May run during STW, so write barriers are not allowed."
      },
      {
        "name": "globrunqputbatch",
        "desc": "Put a batch of runnable goroutines on the global runnable queue. This clears *batch. sched.lock must be held. May run during STW, so write barriers are not allowed."
      },
      {
        "name": "globrunqputhead",
        "desc": "Put gp at the head of the global runnable queue. sched.lock must be held. May run during STW, so write barriers are not allowed."
      },
      {
        "name": "goPanicExtendIndex",
        "desc": "failures in the comparisons for s[x], 0 \u003c= x \u003c y (y == len(s))"
      },
      {
        "name": "goPanicExtendIndexU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSlice3Acap",
        "desc": ""
      },
      {
        "name": "goPanicExtendSlice3AcapU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSlice3Alen",
        "desc": "failures in the comparisons for s[::x], 0 \u003c= x \u003c= y (y == len(s) or cap(s))"
      },
      {
        "name": "goPanicExtendSlice3AlenU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSlice3B",
        "desc": "failures in the comparisons for s[:x:y], 0 \u003c= x \u003c= y"
      },
      {
        "name": "goPanicExtendSlice3BU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSlice3C",
        "desc": "failures in the comparisons for s[x:y:], 0 \u003c= x \u003c= y"
      },
      {
        "name": "goPanicExtendSlice3CU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSliceAcap",
        "desc": ""
      },
      {
        "name": "goPanicExtendSliceAcapU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSliceAlen",
        "desc": "failures in the comparisons for s[:x], 0 \u003c= x \u003c= y (y == len(s) or cap(s))"
      },
      {
        "name": "goPanicExtendSliceAlenU",
        "desc": ""
      },
      {
        "name": "goPanicExtendSliceB",
        "desc": "failures in the comparisons for s[x:y], 0 \u003c= x \u003c= y"
      },
      {
        "name": "goPanicExtendSliceBU",
        "desc": ""
      },
      {
        "name": "goPanicIndex",
        "desc": "failures in the comparisons for s[x], 0 \u003c= x \u003c y (y == len(s))"
      },
      {
        "name": "goPanicIndexU",
        "desc": ""
      },
      {
        "name": "goPanicSlice3Acap",
        "desc": ""
      },
      {
        "name": "goPanicSlice3AcapU",
        "desc": ""
      },
      {
        "name": "goPanicSlice3Alen",
        "desc": "failures in the comparisons for s[::x], 0 \u003c= x \u003c= y (y == len(s) or cap(s))"
      },
      {
        "name": "goPanicSlice3AlenU",
        "desc": ""
      },
      {
        "name": "goPanicSlice3B",
        "desc": "failures in the comparisons for s[:x:y], 0 \u003c= x \u003c= y"
      },
      {
        "name": "goPanicSlice3BU",
        "desc": ""
      },
      {
        "name": "goPanicSlice3C",
        "desc": "failures in the comparisons for s[x:y:], 0 \u003c= x \u003c= y"
      },
      {
        "name": "goPanicSlice3CU",
        "desc": ""
      },
      {
        "name": "goPanicSliceAcap",
        "desc": ""
      },
      {
        "name": "goPanicSliceAcapU",
        "desc": ""
      },
      {
        "name": "goPanicSliceAlen",
        "desc": "failures in the comparisons for s[:x], 0 \u003c= x \u003c= y (y == len(s) or cap(s))"
      },
      {
        "name": "goPanicSliceAlenU",
        "desc": ""
      },
      {
        "name": "goPanicSliceB",
        "desc": "failures in the comparisons for s[x:y], 0 \u003c= x \u003c= y"
      },
      {
        "name": "goPanicSliceBU",
        "desc": ""
      },
      {
        "name": "goPanicSliceConvert",
        "desc": "failures in the conversion ([x]T)(s) or (*[x]T)(s), 0 \u003c= x \u003c= y, y == len(s)"
      },
      {
        "name": "goStatusToTraceGoStatus",
        "desc": "goStatusToTraceGoStatus translates the internal status to tracGoStatus.  status must not be _Gdead or any status whose name has the suffix \"_unused.\"  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "goargs",
        "desc": ""
      },
      {
        "name": "gobytes",
        "desc": "used by cmd/cgo"
      },
      {
        "name": "godebugNotify",
        "desc": ""
      },
      {
        "name": "godebug_registerMetric",
        "desc": ""
      },
      {
        "name": "godebug_setNewIncNonDefault",
        "desc": ""
      },
      {
        "name": "godebug_setUpdate",
        "desc": ""
      },
      {
        "name": "goenvs",
        "desc": "goenvs caches the Plan 9 environment variables at start of execution into string array envs, to supply the initial contents for os.Environ. Subsequent calls to os.Setenv will change this cache, without writing back to the (possibly shared) Plan 9 environment, so that Setenv and Getenv conform to the same Posix semantics as on other operating systems. For Plan 9 shared environment semantics, instead of Getenv(key) and Setenv(key, value), one can use os.ReadFile(\"/env/\" + key) and os.WriteFile(\"/env/\" + key, value, 0666) respectively."
      },
      {
        "name": "goenvs_unix",
        "desc": ""
      },
      {
        "name": "goexit",
        "desc": "goexit is the return stub at the top of every goroutine call stack. Each goroutine stack is constructed as if goexit called the goroutine's entry point function, so that when the entry point function returns, it will return to goexit, which will call goexit1 to perform the actual exit.  This function must never be called directly. Call goexit1 instead. gentraceback assumes that goexit terminates the stack. A direct call on the stack will cause gentraceback to stop walking the stack prematurely and if there is leftover state it may panic."
      },
      {
        "name": "goexit0",
        "desc": "goexit continuation on g0."
      },
      {
        "name": "goexit1",
        "desc": "Finishes execution of the current goroutine."
      },
      {
        "name": "goexitsall",
        "desc": ""
      },
      {
        "name": "gogetenv",
        "desc": ""
      },
      {
        "name": "gogo",
        "desc": ""
      },
      {
        "name": "gopanic",
        "desc": "The implementation of the predeclared function panic. The compiler emits calls to this function.  gopanic should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - go.undefinedlabs.com/scopeagent   - github.com/goplus/igop  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "gopark",
        "desc": "Puts the current goroutine into a waiting state and calls unlockf on the system stack.  If unlockf returns false, the goroutine is resumed.  unlockf must not access this G's stack, as it may be moved between the call to gopark and the call to unlockf.  Note that because unlockf is called after putting the G into a waiting state, the G may have already been readied by the time unlockf is called unless there is external synchronization preventing the G from being readied. If unlockf returns false, it must guarantee that the G cannot be externally readied.  Reason explains why the goroutine has been parked. It is displayed in stack traces and heap dumps. Reasons should be unique and descriptive. Do not re-use reasons, add new ones.  gopark should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "goparkunlock",
        "desc": "Puts the current goroutine into a waiting state and unlocks the lock. The goroutine can be made runnable again by calling goready(gp)."
      },
      {
        "name": "gopreempt_m",
        "desc": ""
      },
      {
        "name": "goready",
        "desc": "goready should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "gorecover",
        "desc": "The implementation of the predeclared function recover. Cannot split the stack because it needs to reliably find the stack segment of its caller.  TODO(rsc): Once we commit to CopyStackAlways, this doesn't need to be nosplit."
      },
      {
        "name": "goroutineProfileInternal",
        "desc": ""
      },
      {
        "name": "goroutineProfileWithLabels",
        "desc": "labels may be nil. If labels is non-nil, it must have the same length as p."
      },
      {
        "name": "goroutineProfileWithLabelsConcurrent",
        "desc": ""
      },
      {
        "name": "goroutineProfileWithLabelsSync",
        "desc": ""
      },
      {
        "name": "goroutineReady",
        "desc": "Ready the goroutine arg."
      },
      {
        "name": "goroutineheader",
        "desc": ""
      },
      {
        "name": "goschedIfBusy",
        "desc": "goschedIfBusy yields the processor like gosched, but only does so if there are no idle Ps or if we're on the only P and there's nothing in the run queue. In both cases, there is freely available idle time."
      },
      {
        "name": "goschedImpl",
        "desc": ""
      },
      {
        "name": "gosched_m",
        "desc": "Gosched continuation on g0."
      },
      {
        "name": "goschedguarded",
        "desc": "goschedguarded yields the processor like gosched, but also checks for forbidden states and opts out of the yield in those cases."
      },
      {
        "name": "goschedguarded_m",
        "desc": "goschedguarded is a forbidden-states-avoided version of gosched_m."
      },
      {
        "name": "gostartcall",
        "desc": "adjust Gobuf as if it executed a call to fn with context ctxt and then did an immediate Gosave."
      },
      {
        "name": "gostartcallfn",
        "desc": "adjust Gobuf as if it executed a call to fn and then stopped before the first instruction in fn."
      },
      {
        "name": "gostring",
        "desc": "This is exported via linkname to assembly in syscall (for Plan9) and cgo."
      },
      {
        "name": "gostringn",
        "desc": ""
      },
      {
        "name": "gostringnocopy",
        "desc": ""
      },
      {
        "name": "gostringw",
        "desc": ""
      },
      {
        "name": "gotraceback",
        "desc": "gotraceback returns the current traceback settings.  If level is 0, suppress all tracebacks. If level is 1, show tracebacks, but exclude runtime frames. If level is 2, show tracebacks including runtime frames. If all is set, print all goroutine stacks. Otherwise, print just the current goroutine. If crash is set, crash (core dump, etc) after tracebacking."
      },
      {
        "name": "goyield",
        "desc": "goyield is like Gosched, but it: - emits a GoPreempt trace event instead of a GoSched trace event - puts the current G on the runq of the current P instead of the globrunq  goyield should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "goyield_m",
        "desc": ""
      },
      {
        "name": "greyobject",
        "desc": "obj is the start of an object with mark mbits. If it isn't already marked, mark it and enqueue into gcw. base and off are for debugging only and could be removed.  See also wbBufFlush1, which partially duplicates this logic."
      },
      {
        "name": "growMemory",
        "desc": "Implemented in src/runtime/sys_wasm.s"
      },
      {
        "name": "growWork",
        "desc": ""
      },
      {
        "name": "growWork_fast32",
        "desc": ""
      },
      {
        "name": "growWork_fast64",
        "desc": ""
      },
      {
        "name": "growWork_faststr",
        "desc": ""
      },
      {
        "name": "gwrite",
        "desc": "write to goroutine-local buffer if diverting output, or else standard error."
      },
      {
        "name": "handleAsyncEvent",
        "desc": ""
      },
      {
        "name": "handleEvent",
        "desc": "handleEvent gets invoked on a call from JavaScript into Go. It calls the event handler of the syscall/js package and then parks the handler goroutine to allow other goroutines to run before giving execution back to JavaScript. When no other goroutine is awake any more, beforeIdle resumes the handler goroutine. Now that the same goroutine is running as was running when the call came in from JavaScript, execution can be safely passed back to JavaScript."
      },
      {
        "name": "handoffp",
        "desc": "Hands off P from syscall or locked M. Always runs without a P, so write barriers are not allowed."
      },
      {
        "name": "hashGrow",
        "desc": ""
      },
      {
        "name": "heapBitsInSpan",
        "desc": "heapBitsInSpan returns true if the size of an object implies its ptr/scalar data is stored at the end of the span, and is accessible via span.heapBits.  Note: this works for both rounded-up sizes (span.elemsize) and unrounded type sizes because gc.MinSizeForMallocHeader is guaranteed to be at a size class boundary."
      },
      {
        "name": "heapBitsSlice",
        "desc": "Helper for constructing a slice for the span's heap bits."
      },
      {
        "name": "heapBitsSmallForAddrInline",
        "desc": ""
      },
      {
        "name": "heapObjectsCanMove",
        "desc": "heapObjectsCanMove always returns false in the current garbage collector. It exists for go4.org/unsafe/assume-no-moving-gc, which is an unfortunate idea that had an even more unfortunate implementation. Every time a new Go release happened, the package stopped building, and the authors had to add a new file with a new //go:build line, and then the entire ecosystem of packages with that as a dependency had to explicitly update to the new version. Many packages depend on assume-no-moving-gc transitively, through paths like inet.af/netaddr -\u003e go4.org/intern -\u003e assume-no-moving-gc. This was causing a significant amount of friction around each new release, so we added this bool for the package to //go:linkname instead. The bool is still unfortunate, but it's not as bad as breaking the ecosystem on every new release.  If the Go garbage collector ever does move heap objects, we can set this to true to break all the programs using assume-no-moving-gc."
      },
      {
        "name": "heapRetained",
        "desc": "heapRetained returns an estimate of the current heap RSS."
      },
      {
        "name": "heapSetTypeLarge",
        "desc": ""
      },
      {
        "name": "heapSetTypeNoHeader",
        "desc": ""
      },
      {
        "name": "heapSetTypeSmallHeader",
        "desc": ""
      },
      {
        "name": "hexdumpWords",
        "desc": "hexdumpWords prints a word-oriented hex dump of [p, end).  If mark != nil, it will be called with each printed word's address and should return a character mark to appear just before that word's value. It can return 0 to indicate no mark."
      },
      {
        "name": "ifaceHash",
        "desc": ""
      },
      {
        "name": "ifaceeq",
        "desc": ""
      },
      {
        "name": "ignoreSIGSYS",
        "desc": ""
      },
      {
        "name": "ignoredNote",
        "desc": ""
      },
      {
        "name": "inHeapOrStack",
        "desc": "inHeapOrStack is a variant of inheap that returns true for pointers into any allocated heap span."
      },
      {
        "name": "inPersistentAlloc",
        "desc": "inPersistentAlloc reports whether p points to memory allocated by persistentalloc. This must be nosplit because it is called by the cgo checker code, which is called by the write barrier code."
      },
      {
        "name": "inRange",
        "desc": "inRange reports whether v0 or v1 are in the range [r0, r1]."
      },
      {
        "name": "inTinyBlock",
        "desc": "inTinyBlock returns whether ptr is in a tiny alloc block, at one point grouped with other distinct values."
      },
      {
        "name": "inUserArenaChunk",
        "desc": "inUserArenaChunk returns true if p points to a user arena chunk."
      },
      {
        "name": "inVDSOPage",
        "desc": "vdsoMarker reports whether PC is on the VDSO page."
      },
      {
        "name": "incidlelocked",
        "desc": ""
      },
      {
        "name": "indexNoFloat",
        "desc": "indexNoFloat is bytealg.IndexString but safe to use in a note handler."
      },
      {
        "name": "inf2one",
        "desc": "inf2one returns a signed 1 if f is an infinity and a signed 0 otherwise. The sign of the result is the sign of f."
      },
      {
        "name": "inheap",
        "desc": "inheap reports whether b is a pointer into a (potentially dead) heap object. It returns false for pointers into mSpanManual spans. Non-preemptible because it is used by write barriers."
      },
      {
        "name": "init",
        "desc": "start forcegc helper goroutine"
      },
      {
        "name": "initAlgAES",
        "desc": ""
      },
      {
        "name": "initBloc",
        "desc": ""
      },
      {
        "name": "initExceptionHandler",
        "desc": ""
      },
      {
        "name": "initHPETTimecounter",
        "desc": ""
      },
      {
        "name": "initHighResTimer",
        "desc": ""
      },
      {
        "name": "initLegacy",
        "desc": ""
      },
      {
        "name": "initLogd",
        "desc": ""
      },
      {
        "name": "initLongPathSupport",
        "desc": "initLongPathSupport enables long path support."
      },
      {
        "name": "initMetrics",
        "desc": "initMetrics initializes the metrics map if it hasn't been yet.  metricsSema must be held."
      },
      {
        "name": "initSecureMode",
        "desc": ""
      },
      {
        "name": "initSysDirectory",
        "desc": ""
      },
      {
        "name": "initsig",
        "desc": "Initialize signals. Called by libpreinit so runtime may not be initialized."
      },
      {
        "name": "injectglist",
        "desc": "injectglist adds each runnable G on the list to some run queue, and clears glist. If there is no current P, they are added to the global queue, and up to npidle M's are started to run them. Otherwise, for each idle P, this adds a G to the global queue and starts an M. Any remaining G's are added to the current P's local run queue. This may temporarily acquire sched.lock. Can run concurrently with GC."
      },
      {
        "name": "int32Hash",
        "desc": ""
      },
      {
        "name": "int64Hash",
        "desc": ""
      },
      {
        "name": "int64div",
        "desc": ""
      },
      {
        "name": "int64mod",
        "desc": ""
      },
      {
        "name": "int64tofloat32",
        "desc": ""
      },
      {
        "name": "int64tofloat64",
        "desc": ""
      },
      {
        "name": "interequal",
        "desc": ""
      },
      {
        "name": "interfaceSwitch",
        "desc": "interfaceSwitch compares t against the list of cases in s. If t matches case i, interfaceSwitch returns the case index i and an itab for the pair \u003ct, s.Cases[i]\u003e. If there is no match, return N,nil, where N is the number of cases."
      },
      {
        "name": "interhash",
        "desc": ""
      },
      {
        "name": "internal_cpu_getsysctlbyname",
        "desc": ""
      },
      {
        "name": "internal_cpu_getsystemcfg",
        "desc": ""
      },
      {
        "name": "internal_cpu_riscvHWProbe",
        "desc": ""
      },
      {
        "name": "internal_cpu_sysctlUint64",
        "desc": ""
      },
      {
        "name": "internal_sync_fatal",
        "desc": ""
      },
      {
        "name": "internal_sync_nanotime",
        "desc": ""
      },
      {
        "name": "internal_sync_runtime_SemacquireMutex",
        "desc": ""
      },
      {
        "name": "internal_sync_runtime_Semrelease",
        "desc": ""
      },
      {
        "name": "internal_sync_runtime_canSpin",
        "desc": "Active spinning for sync.Mutex."
      },
      {
        "name": "internal_sync_runtime_doSpin",
        "desc": ""
      },
      {
        "name": "internal_sync_throw",
        "desc": ""
      },
      {
        "name": "internal_syscall_gostring",
        "desc": "internal_syscall_gostring is a version of gostring for internal/syscall/unix."
      },
      {
        "name": "internal_weak_runtime_makeStrongFromWeak",
        "desc": ""
      },
      {
        "name": "internal_weak_runtime_registerWeakPointer",
        "desc": ""
      },
      {
        "name": "intstring",
        "desc": ""
      },
      {
        "name": "isAbort",
        "desc": "isAbort returns true, if context r describes exception raised by calling runtime.abort function."
      },
      {
        "name": "isAbortPC",
        "desc": "isAbortPC reports whether pc is the program counter at which runtime.abort raises a signal.  It is nosplit because it's part of the isgoexception implementation."
      },
      {
        "name": "isAsyncSafePoint",
        "desc": "isAsyncSafePoint reports whether gp at instruction PC is an asynchronous safe point. This indicates that:  1. It's safe to suspend gp and conservatively scan its stack and registers. There are no potentially hidden pointer values and it's not in the middle of an atomic sequence like a write barrier.  2. gp has enough stack space to inject the asyncPreempt call.  3. It's generally safe to interact with the runtime, even if we're in a signal handler stopped here. For example, there are no runtime locks held, so acquiring a runtime lock won't self-deadlock.  In some cases the PC is safe for asynchronous preemption but it also needs to adjust the resumption PC. The new PC is returned in the second result."
      },
      {
        "name": "isDirectIface",
        "desc": "isDirectIface reports whether t is stored directly in an interface value."
      },
      {
        "name": "isEmpty",
        "desc": "isEmpty reports whether the given tophash array entry represents an empty bucket entry."
      },
      {
        "name": "isExportedRuntime",
        "desc": "isExportedRuntime reports whether name is an exported runtime function. It is only for runtime functions, so ASCII A-Z is fine."
      },
      {
        "name": "isFinite",
        "desc": "isFinite reports whether f is neither NaN nor an infinity."
      },
      {
        "name": "isGoPointerWithoutSpan",
        "desc": ""
      },
      {
        "name": "isInf",
        "desc": "isInf reports whether f is an infinity."
      },
      {
        "name": "isNaN",
        "desc": "isNaN reports whether f is an IEEE 754 “not-a-number” value."
      },
      {
        "name": "isPinned",
        "desc": "isPinned checks if a Go pointer is pinned. nosplit, because it's called from nosplit code in cgocheck."
      },
      {
        "name": "isPowerOfTwo",
        "desc": ""
      },
      {
        "name": "isSecureMode",
        "desc": ""
      },
      {
        "name": "isShrinkStackSafe",
        "desc": "isShrinkStackSafe returns whether it's safe to attempt to shrink gp's stack. Shrinking the stack is only safe when we have precise pointer maps for all frames on the stack. The caller must hold the _Gscan bit for gp or must be running gp itself."
      },
      {
        "name": "isSweepDone",
        "desc": "isSweepDone reports whether all spans are swept.  Note that this condition may transition from false to true at any time as the sweeper runs. It may transition from true to false if a GC runs; to prevent that the caller must be non-preemptible or must somehow block GC progress."
      },
      {
        "name": "isSystemGoroutine",
        "desc": "isSystemGoroutine reports whether the goroutine g must be omitted in stack dumps and deadlock detector. This is any goroutine that starts at a runtime.* entry point, except for runtime.main, runtime.handleAsyncEvent (wasm only) and sometimes runtime.runFinalizers/runtime.runCleanups.  If fixed is true, any goroutine that can vary between user and system (that is, the finalizer goroutine) is considered a user goroutine."
      },
      {
        "name": "isWakeup",
        "desc": ""
      },
      {
        "name": "isgoexception",
        "desc": "isgoexception reports whether this exception should be translated into a Go panic or throw.  It is nosplit to avoid growing the stack in case we're aborting because of a stack overflow."
      },
      {
        "name": "issetugid",
        "desc": ""
      },
      {
        "name": "issetugid_trampoline",
        "desc": ""
      },
      {
        "name": "isvalidaddr",
        "desc": "checks if the address has shadow (i.e. heap or data/bss)."
      },
      {
        "name": "itabAdd",
        "desc": "itabAdd adds the given itab to the itab hash table. itabLock must be held."
      },
      {
        "name": "itabHashFunc",
        "desc": ""
      },
      {
        "name": "itabInit",
        "desc": "itabInit fills in the m.Fun array with all the code pointers for the m.Inter/m.Type pair. If the type does not implement the interface, it sets m.Fun[0] to 0 and returns the name of an interface function that is missing. If !firstTime, itabInit will not write anything to m.Fun (see issue 65962). It is ok to call this multiple times on the same m, even concurrently (although it will only be called once with firstTime==true)."
      },
      {
        "name": "itab_callback",
        "desc": ""
      },
      {
        "name": "itabsinit",
        "desc": ""
      },
      {
        "name": "iterate_finq",
        "desc": ""
      },
      {
        "name": "iterate_itabs",
        "desc": ""
      },
      {
        "name": "iterate_memprof",
        "desc": ""
      },
      {
        "name": "itoa",
        "desc": "itoa converts val to a decimal representation. The result is written somewhere within buf and the location of the result is returned. buf must be at least 20 bytes."
      },
      {
        "name": "itoaDiv",
        "desc": "itoaDiv formats val/(10**dec) into buf."
      },
      {
        "name": "kevent",
        "desc": ""
      },
      {
        "name": "kevent_trampoline",
        "desc": ""
      },
      {
        "name": "key32",
        "desc": "We use the uintptr mutex.key and note.key as a uint32."
      },
      {
        "name": "key8",
        "desc": ""
      },
      {
        "name": "keys",
        "desc": "keys for implementing maps.keys"
      },
      {
        "name": "kqueue",
        "desc": ""
      },
      {
        "name": "kqueue_trampoline",
        "desc": ""
      },
      {
        "name": "lastcontinuehandler",
        "desc": "lastcontinuehandler is reached, because runtime cannot handle current exception. lastcontinuehandler will print crash info and exit.  It is nosplit for the same reason as exceptionhandler."
      },
      {
        "name": "lastcontinuetramp",
        "desc": ""
      },
      {
        "name": "legacy_fastrand",
        "desc": ""
      },
      {
        "name": "legacy_fastrand64",
        "desc": ""
      },
      {
        "name": "legacy_fastrandn",
        "desc": ""
      },
      {
        "name": "less",
        "desc": "less checks if a \u003c b, considering a \u0026 b running counts that may overflow the 32-bit range, and that their \"unwrapped\" difference is always less than 2^31."
      },
      {
        "name": "lfnodeValidate",
        "desc": "lfnodeValidate panics if node is not a valid address for use with lfstack.push. This only needs to be called when node is allocated."
      },
      {
        "name": "lfstackPack",
        "desc": ""
      },
      {
        "name": "libcCall",
        "desc": "Call fn with arg as its argument. Return what fn returns. fn is the raw pc value of the entry point of the desired function. Switches to the system stack, if not already there. Preserves the calling point as the location where a profiler traceback will begin."
      },
      {
        "name": "libfuzzerCall4",
        "desc": ""
      },
      {
        "name": "libfuzzerCallTraceIntCmp",
        "desc": ""
      },
      {
        "name": "libfuzzerCallWithTwoByteBuffers",
        "desc": ""
      },
      {
        "name": "libfuzzerHookEqualFold",
        "desc": "This function has now the same implementation as libfuzzerHookStrCmp because we lack better checks for case-insensitive string equality in the runtime package."
      },
      {
        "name": "libfuzzerHookStrCmp",
        "desc": "We call libFuzzer's __sanitizer_weak_hook_strcmp function which takes the following four arguments:   1. caller_pc: location of string comparison call site  2. s1: first string used in the comparison  3. s2: second string used in the comparison  4. result: an integer representing the comparison result. 0 indicates     equality (comparison will ignored by libfuzzer), non-zero indicates a     difference (comparison will be taken into consideration)."
      },
      {
        "name": "libfuzzerTraceCmp1",
        "desc": "In libFuzzer mode, the compiler inserts calls to libfuzzerTraceCmpN and libfuzzerTraceConstCmpN (where N can be 1, 2, 4, or 8) for encountered integer comparisons in the code to be instrumented. This may result in these functions having callers that are nosplit. That is why they must be nosplit."
      },
      {
        "name": "libfuzzerTraceCmp2",
        "desc": ""
      },
      {
        "name": "libfuzzerTraceCmp4",
        "desc": ""
      },
      {
        "name": "libfuzzerTraceCmp8",
        "desc": ""
      },
      {
        "name": "libfuzzerTraceConstCmp1",
        "desc": ""
      },
      {
        "name": "libfuzzerTraceConstCmp2",
        "desc": ""
      },
      {
        "name": "libfuzzerTraceConstCmp4",
        "desc": ""
      },
      {
        "name": "libfuzzerTraceConstCmp8",
        "desc": ""
      },
      {
        "name": "libpreinit",
        "desc": "Called to do synchronous initialization of Go code built with -buildmode=c-archive or -buildmode=c-shared. None of the Go runtime is initialized."
      },
      {
        "name": "lineNumber",
        "desc": ""
      },
      {
        "name": "loadOptionalSyscalls",
        "desc": ""
      },
      {
        "name": "loadRegArgs",
        "desc": ""
      },
      {
        "name": "load_g",
        "desc": "Called from assembly only; declared for go vet."
      },
      {
        "name": "lock",
        "desc": ""
      },
      {
        "name": "lock2",
        "desc": ""
      },
      {
        "name": "lockInit",
        "desc": "lockInit(l *mutex, rank int) sets the rank of lock before it is used. If there is no clear place to initialize a lock, then the rank of a lock can be specified during the lock call itself via lockWithRank(l *mutex, rank int)."
      },
      {
        "name": "lockOSThread",
        "desc": ""
      },
      {
        "name": "lockRankMayQueueFinalizer",
        "desc": "lockRankMayQueueFinalizer records the lock ranking effects of a function that may call queuefinalizer."
      },
      {
        "name": "lockRankMayTraceFlush",
        "desc": "lockRankMayTraceFlush records the lock ranking effects of a potential call to traceFlush.  nosplit because traceAcquire is nosplit."
      },
      {
        "name": "lockVerifyMSize",
        "desc": "lockVerifyMSize confirms that we can recreate the low bits of the M pointer."
      },
      {
        "name": "lockWithRank",
        "desc": "lockWithRank is like lock(l), but allows the caller to specify a lock rank when acquiring a non-static lock.  Note that we need to be careful about stack splits:  This function is not nosplit, thus it may split at function entry. This may introduce a new edge in the lock order, but it is no different from any other (nosplit) call before this call (including the call to lock() itself).  However, we switch to the systemstack to record the lock held to ensure that we record an accurate lock ordering. e.g., without systemstack, a stack split on entry to lock2() would record stack split locks as taken after l, even though l is not actually locked yet."
      },
      {
        "name": "lockWithRankMayAcquire",
        "desc": "nosplit because it may be called from nosplit contexts."
      },
      {
        "name": "lockedOSThread",
        "desc": ""
      },
      {
        "name": "lowerASCII",
        "desc": ""
      },
      {
        "name": "lsandoleakcheck",
        "desc": ""
      },
      {
        "name": "lsanregisterrootregion",
        "desc": ""
      },
      {
        "name": "lsanunregisterrootregion",
        "desc": ""
      },
      {
        "name": "lwp_create",
        "desc": ""
      },
      {
        "name": "lwp_gettid",
        "desc": ""
      },
      {
        "name": "lwp_kill",
        "desc": ""
      },
      {
        "name": "lwp_mcontext_init",
        "desc": ""
      },
      {
        "name": "lwp_park",
        "desc": ""
      },
      {
        "name": "lwp_self",
        "desc": ""
      },
      {
        "name": "lwp_start",
        "desc": ""
      },
      {
        "name": "lwp_tramp",
        "desc": ""
      },
      {
        "name": "lwp_unpark",
        "desc": ""
      },
      {
        "name": "mPark",
        "desc": "mPark causes a thread to park itself, returning once woken."
      },
      {
        "name": "mProfStackInit",
        "desc": "mProfStackInit is used to eagerly initialize stack trace buffers for profiling. Lazy allocation would have to deal with reentrancy issues in malloc and runtime locks for mLockProfile. TODO(mknyszek): Implement lazy allocation if this becomes a problem."
      },
      {
        "name": "mProf_Flush",
        "desc": "mProf_Flush flushes the events from the current heap profiling cycle into the active profile. After this it is safe to start a new heap profiling cycle with mProf_NextCycle.  This is called by GC after mark termination starts the world. In contrast with mProf_NextCycle, this is somewhat expensive, but safe to do concurrently."
      },
      {
        "name": "mProf_FlushLocked",
        "desc": "mProf_FlushLocked flushes the events from the heap profiling cycle at index into the active profile. The caller must hold the lock for the active profile (profMemActiveLock) and for the profiling cycle at index (profMemFutureLock[index])."
      },
      {
        "name": "mProf_Free",
        "desc": "Called when freeing a profiled block."
      },
      {
        "name": "mProf_Malloc",
        "desc": "Called by malloc to record a profiled block."
      },
      {
        "name": "mProf_NextCycle",
        "desc": "mProf_NextCycle publishes the next heap profile cycle and creates a fresh heap profile cycle. This operation is fast and can be done during STW. The caller must call mProf_Flush before calling mProf_NextCycle again.  This is called by mark termination during STW so allocations and frees after the world is started again count towards a new heap profiling cycle."
      },
      {
        "name": "mProf_PostSweep",
        "desc": "mProf_PostSweep records that all sweep frees for this GC cycle have completed. This has the effect of publishing the heap profile snapshot as of the last mark termination without advancing the heap profile cycle."
      },
      {
        "name": "mReserveID",
        "desc": "mReserveID returns the next ID to use for a new m. This new m is immediately considered 'running' by checkdead.  sched.lock must be held."
      },
      {
        "name": "mStackIsSystemAllocated",
        "desc": "mStackIsSystemAllocated indicates whether this runtime starts on a system-allocated stack."
      },
      {
        "name": "mach_vm_region",
        "desc": "mach_vm_region is used to obtain virtual memory mappings for use by the profiling system and is only exported to runtime/pprof. It is restricted to obtaining mappings for the current process."
      },
      {
        "name": "mach_vm_region_trampoline",
        "desc": ""
      },
      {
        "name": "madvise",
        "desc": "return value is only set on linux to be used in osinit()."
      },
      {
        "name": "madvise_trampoline",
        "desc": ""
      },
      {
        "name": "main",
        "desc": "The main goroutine."
      },
      {
        "name": "main_main",
        "desc": ""
      },
      {
        "name": "makeProfStack",
        "desc": "makeProfStack returns a buffer large enough to hold a maximum-sized stack trace."
      },
      {
        "name": "makeProfStackFP",
        "desc": "makeProfStackFP creates a buffer large enough to hold a maximum-sized stack trace as well as any additional frames needed for frame pointer unwinding with delayed inline expansion."
      },
      {
        "name": "makemap",
        "desc": "makemap implements Go map creation for make(map[k]v, hint). If the compiler has determined that the map or the first group can be created on the stack, m and optionally m.dirPtr may be non-nil. If m != nil, the map can be created directly in m. If m.dirPtr != nil, it points to a group usable for a small map.  makemap should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "makemap64",
        "desc": ""
      },
      {
        "name": "makemap_small",
        "desc": "makemap_small implements Go map creation for make(map[k]v) and make(map[k]v, hint) when hint is known to be at most abi.SwissMapGroupSlots at compile time and the map needs to be allocated on the heap.  makemap_small should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "makeslice",
        "desc": "makeslice should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "makeslice64",
        "desc": ""
      },
      {
        "name": "makeslicecopy",
        "desc": "makeslicecopy allocates a slice of \"tolen\" elements of type \"et\", then copies \"fromlen\" elements of type \"et\" into that new allocation from \"from\"."
      },
      {
        "name": "malloc",
        "desc": ""
      },
      {
        "name": "mallocgc",
        "desc": "Allocate an object of size bytes. Small objects are allocated from the per-P cache's free lists. Large objects (\u003e 32 kB) are allocated straight from the heap.  mallocgc should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/bytedance/sonic   - github.com/cloudwego/frugal   - github.com/cockroachdb/cockroach   - github.com/cockroachdb/pebble   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mallocgcLarge",
        "desc": ""
      },
      {
        "name": "mallocgcSmallNoscan",
        "desc": ""
      },
      {
        "name": "mallocgcSmallScanHeader",
        "desc": ""
      },
      {
        "name": "mallocgcSmallScanNoHeader",
        "desc": ""
      },
      {
        "name": "mallocgcTiny",
        "desc": ""
      },
      {
        "name": "mallocinit",
        "desc": ""
      },
      {
        "name": "mapIterNext",
        "desc": "mapIterNext performs the next step of iteration. Afterwards, the next key/elem are in it.Key()/it.Elem()."
      },
      {
        "name": "mapIterStart",
        "desc": "mapIterStart initializes the Iter struct used for ranging over maps and performs the first step of iteration. The Iter struct pointed to by 'it' is allocated on the stack by the compilers order pass or on the heap by reflect. Both need to have zeroed it since the struct contains pointers."
      },
      {
        "name": "mapaccess1",
        "desc": "mapaccess1 returns a pointer to h[key].  Never returns nil, instead it will return a reference to the zero object for the elem type if the key is not in the map. NOTE: The returned pointer may keep the whole map live, so don't hold onto it for very long.  mapaccess1 is pushed from internal/runtime/maps. We could just call it, but we want to avoid one layer of call."
      },
      {
        "name": "mapaccess1_fast32",
        "desc": ""
      },
      {
        "name": "mapaccess1_fast64",
        "desc": ""
      },
      {
        "name": "mapaccess1_faststr",
        "desc": ""
      },
      {
        "name": "mapaccess1_fat",
        "desc": ""
      },
      {
        "name": "mapaccess2",
        "desc": "mapaccess2 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapaccess2_fast32",
        "desc": "mapaccess2_fast32 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapaccess2_fast64",
        "desc": "mapaccess2_fast64 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapaccess2_faststr",
        "desc": "mapaccess2_faststr should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapaccess2_fat",
        "desc": ""
      },
      {
        "name": "mapaccessK",
        "desc": "returns both key and elem. Used by map iterator."
      },
      {
        "name": "mapassign",
        "desc": "mapassign is pushed from internal/runtime/maps. We could just call it, but we want to avoid one layer of call.  mapassign should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapassign_fast32",
        "desc": "mapassign_fast32 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapassign_fast32ptr",
        "desc": "mapassign_fast32ptr should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapassign_fast64",
        "desc": "mapassign_fast64 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapassign_fast64ptr",
        "desc": "mapassign_fast64ptr should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapassign_faststr",
        "desc": "mapassign_faststr should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapclear",
        "desc": "mapclear deletes all keys from a map."
      },
      {
        "name": "mapclone",
        "desc": "mapclone for implementing maps.Clone"
      },
      {
        "name": "mapdelete",
        "desc": "mapdelete should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapdelete_fast32",
        "desc": ""
      },
      {
        "name": "mapdelete_fast64",
        "desc": ""
      },
      {
        "name": "mapdelete_faststr",
        "desc": ""
      },
      {
        "name": "mapinitnoop",
        "desc": "mapinitnoop is a no-op function known the Go linker; if a given global map (of the right size) is determined to be dead, the linker will rewrite the relocation (from the package init func) from the outlined map init function to this symbol. Defined in assembly so as to avoid complications with instrumentation (coverage, etc)."
      },
      {
        "name": "mapiterinit",
        "desc": "mapiterinit is a compatibility wrapper for map iterator for users of //go:linkname from before Go 1.24. It is not used by Go itself. New users should use reflect or the maps package.  mapiterinit should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/goccy/go-json   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding   - github.com/ugorji/go/codec   - github.com/wI2L/jettison  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "mapiternext",
        "desc": "mapiternext is a compatibility wrapper for map iterator for users of //go:linkname from before Go 1.24. It is not used by Go itself. New users should use reflect or the maps package.  mapiternext should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding   - github.com/ugorji/go/codec   - gonum.org/v1/gonum  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "maps_fatal",
        "desc": ""
      },
      {
        "name": "maps_newarray",
        "desc": ""
      },
      {
        "name": "maps_newobject",
        "desc": ""
      },
      {
        "name": "maps_rand",
        "desc": ""
      },
      {
        "name": "maps_typeString",
        "desc": ""
      },
      {
        "name": "maps_typedmemclr",
        "desc": ""
      },
      {
        "name": "maps_typedmemmove",
        "desc": ""
      },
      {
        "name": "markroot",
        "desc": "markroot scans the i'th root.  Preemption must be disabled (because this uses a gcWork).  Returns the amount of GC work credit produced by the operation. If flushBgCredit is true, then that credit is also flushed to the background credit pool.  nowritebarrier is only advisory here."
      },
      {
        "name": "markrootBlock",
        "desc": "markrootBlock scans the shard'th shard of the block of memory [b0, b0+n0), with the given pointer mask.  Returns the amount of work done."
      },
      {
        "name": "markrootFreeGStacks",
        "desc": "markrootFreeGStacks frees stacks of dead Gs.  This does not free stacks of dead Gs cached on Ps, but having a few cached stacks around isn't a problem."
      },
      {
        "name": "markrootSpans",
        "desc": "markrootSpans marks roots for one shard of markArenas."
      },
      {
        "name": "maxCleanupGs",
        "desc": ""
      },
      {
        "name": "mayMoreStackMove",
        "desc": "mayMoreStackMove is a maymorestack hook that forces stack movement at every possible point.  See mayMoreStackPreempt."
      },
      {
        "name": "mayMoreStackPreempt",
        "desc": "mayMoreStackPreempt is a maymorestack hook that forces a preemption at every possible cooperative preemption point.  This is valuable to apply to the runtime, which can be sensitive to preemption points. To apply this to all preemption points in the runtime and runtime-like code, use the following in bash or zsh:  \tX=(-{gc,asm}flags={runtime/...,reflect,sync}=-d=maymorestack=runtime.mayMoreStackPreempt) GOFLAGS=${X[@]}  This must be deeply nosplit because it is called from a function prologue before the stack is set up and because the compiler will call it from any splittable prologue (leading to infinite recursion).  Ideally it should also use very little stack because the linker doesn't currently account for this in nosplit stack depth checking.  Ensure mayMoreStackPreempt can be called for all ABIs."
      },
      {
        "name": "mcall",
        "desc": "mcall switches from the g to the g0 stack and invokes fn(g), where g is the goroutine that made the call. mcall saves g's current PC/SP in g-\u003esched so that it can be restored later. It is up to fn to arrange for that later execution, typically by recording g in a data structure, causing something to call ready(g) later. mcall returns to the original goroutine g later, when g has been rescheduled. fn must not return at all; typically it ends by calling schedule, to let the m run other goroutines.  mcall can only be called from g stacks (not g0, not gsignal).  This must NOT be go:noescape: if fn is a stack-allocated closure, fn puts g on a run queue, and g executes before fn returns, the closure will be invalidated while it is still executing."
      },
      {
        "name": "mcommoninit",
        "desc": "Pre-allocated ID may be passed as 'id', or omitted by passing -1."
      },
      {
        "name": "mcount",
        "desc": ""
      },
      {
        "name": "mdestroy",
        "desc": "Called from mexit, but not from dropm, to undo the effect of thread-owned resources in minit, semacreate, or elsewhere. Do not take locks after calling this.  This always runs without a P, so //go:nowritebarrierrec is required."
      },
      {
        "name": "mdump",
        "desc": ""
      },
      {
        "name": "memAlloc",
        "desc": ""
      },
      {
        "name": "memAllocNoGrow",
        "desc": ""
      },
      {
        "name": "memCheck",
        "desc": ""
      },
      {
        "name": "memFree",
        "desc": ""
      },
      {
        "name": "memProfileInternal",
        "desc": "memProfileInternal returns the number of records n in the profile. If there are less than size records, copyFn is invoked for each record, and ok returns true.  The linker set disableMemoryProfiling to true to disable memory profiling if this function is not reachable. Mark it noinline to ensure the symbol exists. (This function is big and normally not inlined anyway.) See also disableMemoryProfiling above and cmd/link/internal/ld/lib.go:linksetup."
      },
      {
        "name": "memRound",
        "desc": ""
      },
      {
        "name": "memclrHasPointers",
        "desc": "memclrHasPointers clears n bytes of typed memory starting at ptr. The caller must ensure that the type of the object at ptr has pointers, usually by checking typ.PtrBytes. However, ptr does not have to point to the start of the allocation.  memclrHasPointers should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "memclrNoHeapPointers",
        "desc": "memclrNoHeapPointers clears n bytes starting at ptr.  Usually you should use typedmemclr. memclrNoHeapPointers should be used only when the caller knows that *ptr contains no heap pointers because either:  *ptr is initialized memory and its type is pointer-free, or  *ptr is uninitialized memory (e.g., memory that's being reused for a new allocation) and hence contains only \"junk\".  memclrNoHeapPointers ensures that if ptr is pointer-aligned, and n is a multiple of the pointer size, then any pointer-aligned, pointer-sized portion is cleared atomically. Despite the function name, this is necessary because this function is the underlying implementation of typedmemclr and memclrHasPointers. See the doc of memmove for more details.  The (CPU-specific) implementations of this function are in memclr_*.s.  memclrNoHeapPointers should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/chenzhuoyu/iasm   - github.com/dgraph-io/ristretto   - github.com/outcaste-io/ristretto  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "memclrNoHeapPointersChunked",
        "desc": "memclrNoHeapPointersChunked repeatedly calls memclrNoHeapPointers on chunks of the buffer to be zeroed, with opportunities for preemption along the way.  memclrNoHeapPointers contains no safepoints and also cannot be preemptively scheduled, so this provides a still-efficient block copy that can also be preempted on a reasonable granularity.  Use this with care; if the data being cleared is tagged to contain pointers, this allows the GC to run before it is all cleared."
      },
      {
        "name": "memequal",
        "desc": "in internal/bytealg/equal_*.s  memequal should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "memequal0",
        "desc": ""
      },
      {
        "name": "memequal128",
        "desc": ""
      },
      {
        "name": "memequal16",
        "desc": ""
      },
      {
        "name": "memequal32",
        "desc": ""
      },
      {
        "name": "memequal64",
        "desc": ""
      },
      {
        "name": "memequal8",
        "desc": ""
      },
      {
        "name": "memequal_varlen",
        "desc": ""
      },
      {
        "name": "memhash",
        "desc": "memhash should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/aacfactory/fns   - github.com/dgraph-io/ristretto   - github.com/minio/simdjson-go   - github.com/nbd-wtf/go-nostr   - github.com/outcaste-io/ristretto   - github.com/puzpuzpuz/xsync/v2   - github.com/puzpuzpuz/xsync/v3   - github.com/authzed/spicedb   - github.com/pingcap/badger  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "memhash0",
        "desc": ""
      },
      {
        "name": "memhash128",
        "desc": ""
      },
      {
        "name": "memhash16",
        "desc": ""
      },
      {
        "name": "memhash32",
        "desc": ""
      },
      {
        "name": "memhash32Fallback",
        "desc": ""
      },
      {
        "name": "memhash64",
        "desc": ""
      },
      {
        "name": "memhash64Fallback",
        "desc": ""
      },
      {
        "name": "memhash8",
        "desc": ""
      },
      {
        "name": "memhashFallback",
        "desc": ""
      },
      {
        "name": "memhash_varlen",
        "desc": ""
      },
      {
        "name": "memmove",
        "desc": "memmove copies n bytes from \"from\" to \"to\".  memmove ensures that any pointer in \"from\" is written to \"to\" with an indivisible write, so that racy reads cannot observe a half-written pointer. This is necessary to prevent the garbage collector from observing invalid pointers, and differs from memmove in unmanaged languages. However, memmove is only required to do this if \"from\" and \"to\" may contain pointers, which can only be the case if \"from\", \"to\", and \"n\" are all be word-aligned.  Implementations are in memmove_*.s.  Outside assembly calls memmove.  memmove should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/cloudwego/dynamicgo   - github.com/ebitengine/purego   - github.com/tetratelabs/wazero   - github.com/ugorji/go/codec   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "metricsLock",
        "desc": ""
      },
      {
        "name": "metricsUnlock",
        "desc": ""
      },
      {
        "name": "mexit",
        "desc": "mexit tears down and exits the current thread.  Don't call this directly to exit the thread, since it must run at the top of the thread stack. Instead, use gogo(\u0026gp.m.g0.sched) to unwind the stack to the point that exits the thread.  It is entered with m.p != nil, so write barriers are allowed. It will release the P before exiting."
      },
      {
        "name": "mincore",
        "desc": ""
      },
      {
        "name": "minit",
        "desc": "Called to initialize a new m (including the bootstrap m). Called on the new thread, cannot allocate memory."
      },
      {
        "name": "minitSignalMask",
        "desc": "minitSignalMask is called when initializing a new m to set the thread's signal mask. When this is called all signals have been blocked for the thread.  This starts with m.sigmask, which was set either from initSigmask for a newly created thread or by calling sigsave if this is a non-Go thread calling a Go function. It removes all essential signals from the mask, thus causing those signals to not be blocked. Then it sets the thread's signal mask. After this is called the thread can receive signals."
      },
      {
        "name": "minitSignalStack",
        "desc": "minitSignalStack is called when initializing a new m to set the alternate signal stack. If the alternate signal stack is not set for the thread (the normal case) then set the alternate signal stack to the gsignal stack. If the alternate signal stack is set for the thread (the case when a non-Go thread sets the alternate signal stack and then calls a Go function) then set the gsignal stack to the alternate signal stack. We also set the alternate signal stack to the gsignal stack if cgo is not used (regardless of whether it is already set). Record which choice was made in newSigstack, so that it can be undone in unminit."
      },
      {
        "name": "minitSignals",
        "desc": "minitSignals is called when initializing a new m to set the thread's alternate signal stack and signal mask."
      },
      {
        "name": "miniterrno",
        "desc": "errno address must be retrieved by calling _Errno libc function. This will return a pointer to errno."
      },
      {
        "name": "mix",
        "desc": ""
      },
      {
        "name": "mix32",
        "desc": ""
      },
      {
        "name": "mlock",
        "desc": ""
      },
      {
        "name": "mlock_trampoline",
        "desc": ""
      },
      {
        "name": "mmap",
        "desc": "mmap calls the mmap system call. It is implemented in assembly. We only pass the lower 32 bits of file offset to the assembly routine; the higher bits (if required), should be provided by the assembly routine as 0. The err result is an OS error code such as ENOMEM."
      },
      {
        "name": "mmap_trampoline",
        "desc": ""
      },
      {
        "name": "modf",
        "desc": "modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.  Special cases are:  \tModf(±Inf) = ±Inf, NaN \tModf(NaN) = NaN, NaN  N.B. Portable modf copied from math. math also has optimized arch-specific implementations."
      },
      {
        "name": "moduledataverify",
        "desc": ""
      },
      {
        "name": "moduledataverify1",
        "desc": "moduledataverify1 should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issues/67401. See go.dev/issues/71672."
      },
      {
        "name": "modulesinit",
        "desc": "modulesinit creates the active modules slice out of all loaded modules.  When a module is first loaded by the dynamic linker, an .init_array function (written by cmd/link) is invoked to call addmoduledata, appending to the module to the linked list that starts with firstmoduledata.  There are two times this can happen in the lifecycle of a Go program. First, if compiled with -linkshared, a number of modules built with -buildmode=shared can be loaded at program initialization. Second, a Go program can load a module while running that was built with -buildmode=plugin.  After loading, this function is called which initializes the moduledata so it is usable by the GC and creates a new activeModules list.  Only one goroutine may call modulesinit at a time."
      },
      {
        "name": "monitorSuspendResume",
        "desc": ""
      },
      {
        "name": "morestack",
        "desc": ""
      },
      {
        "name": "morestack_noctxt",
        "desc": "morestack_noctxt should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic  Do not remove or change the type signature. See go.dev/issues/67401. See go.dev/issues/71672."
      },
      {
        "name": "morestackc",
        "desc": "This is exported as ABI0 via linkname so obj can call it."
      },
      {
        "name": "moveToBmap",
        "desc": "moveToBmap moves a bucket from src to dst. It returns the destination bucket or new destination bucket if it overflows and the pos that the next key/value will be written, if pos == bucketCnt means needs to written in overflow bucket."
      },
      {
        "name": "mpreinit",
        "desc": "Ms related functions"
      },
      {
        "name": "mprotect",
        "desc": ""
      },
      {
        "name": "mput",
        "desc": "Put mp on midle list. sched.lock must be held. May run during STW, so write barriers are not allowed."
      },
      {
        "name": "mrandinit",
        "desc": "mrandinit initializes the random state of an m."
      },
      {
        "name": "msanfree",
        "desc": ""
      },
      {
        "name": "msanmalloc",
        "desc": ""
      },
      {
        "name": "msanmove",
        "desc": ""
      },
      {
        "name": "msanread",
        "desc": "If we are running on the system stack, the C program may have marked part of that stack as uninitialized. We don't instrument the runtime, but operations like a slice copy can call msanread anyhow for values on the stack. Just ignore msanread when running on the system stack. The other msan functions are fine."
      },
      {
        "name": "msanwrite",
        "desc": ""
      },
      {
        "name": "msigrestore",
        "desc": "msigrestore sets the current thread's signal mask to sigmask. This is used to restore the non-Go signal mask when a non-Go thread calls a Go function. This is nosplit and nowritebarrierrec because it is called by dropm after g has been cleared."
      },
      {
        "name": "mspinning",
        "desc": ""
      },
      {
        "name": "mstart",
        "desc": "mstart is the entry-point for new Ms. It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0."
      },
      {
        "name": "mstart0",
        "desc": "mstart0 is the Go entry-point for new Ms. This must not split the stack because we may not even have stack bounds set up yet.  May run during STW (because it doesn't have a P yet), so write barriers are not allowed."
      },
      {
        "name": "mstart1",
        "desc": "The go:noinline is to guarantee the sys.GetCallerPC/sys.GetCallerSP below are safe, so that we can set up g0.sched to return to the call of mstart1 above."
      },
      {
        "name": "mstart_stub",
        "desc": "glue code to call mstart from pthread_create."
      },
      {
        "name": "mstartm0",
        "desc": "mstartm0 implements part of mstart1 that only runs on the m0.  Write barriers are allowed here because we know the GC can't be running yet, so they'll be no-ops."
      },
      {
        "name": "mullu",
        "desc": "64x64 -\u003e 128 multiply. adapted from hacker's delight."
      },
      {
        "name": "munmap",
        "desc": "munmap calls the munmap system call. It is implemented in assembly."
      },
      {
        "name": "munmap_trampoline",
        "desc": ""
      },
      {
        "name": "mutexContended",
        "desc": ""
      },
      {
        "name": "mutexPreferLowLatency",
        "desc": "mutexPreferLowLatency reports if this mutex prefers low latency at the risk of performance collapse. If so, we can allow all waiting threads to spin on the state word rather than go to sleep.  TODO: We could have the waiting Ms each spin on their own private cache line, especially if we can put a bound on the on-CPU time that would consume.  TODO: If there's a small set of mutex values with special requirements, they could make use of a more specialized lock2/unlock2 implementation. Otherwise, we're constrained to what we can fit within a single uintptr with no additional storage on the M for each lock held."
      },
      {
        "name": "mutexProfileInternal",
        "desc": "mutexProfileInternal returns the number of records n in the profile. If there are less than size records, copyFn is invoked for each record, and ok returns true."
      },
      {
        "name": "mutexSampleContention",
        "desc": "mutexSampleContention returns whether the current mutex operation should report any contention it discovers."
      },
      {
        "name": "mutexevent",
        "desc": ""
      },
      {
        "name": "nanotime",
        "desc": "Exported via linkname for use by time and internal/poll.  Many external packages also linkname nanotime for a fast monotonic time. Such code should be updated to use:  \tvar start = time.Now() // at init time  and then replace nanotime() with time.Since(start), which is equally fast.  However, all the code linknaming nanotime is never going to go away. Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "nanotime1",
        "desc": ""
      },
      {
        "name": "nanotime_trampoline",
        "desc": ""
      },
      {
        "name": "needAndBindM",
        "desc": "Acquire an extra m and bind it to the C thread when a pthread key has been created."
      },
      {
        "name": "needm",
        "desc": "needm is called when a cgo callback happens on a thread without an m (a thread not created by Go). In this case, needm is expected to find an m to use and return with m, g initialized correctly. Since m and g are not set now (likely nil, but see below) needm is limited in what routines it can call. In particular it can only call nosplit functions (textflag 7) and cannot do any scheduling that requires an m.  In order to avoid needing heavy lifting here, we adopt the following strategy: there is a stack of available m's that can be stolen. Using compare-and-swap to pop from the stack has ABA races, so we simulate a lock by doing an exchange (via Casuintptr) to steal the stack head and replace the top pointer with MLOCKED (1). This serves as a simple spin lock that we can use even without an m. The thread that locks the stack in this way unlocks the stack by storing a valid stack head pointer.  In order to make sure that there is always an m structure available to be stolen, we maintain the invariant that there is always one more than needed. At the beginning of the program (if cgo is in use) the list is seeded with a single m. If needm finds that it has taken the last m off the list, its job is - once it has installed its own m so that it can do things like allocate memory - to create a spare m and put it on the list.  Each of these extra m's also has a g0 and a curg that are pressed into service as the scheduling stack and current goroutine for the duration of the cgo callback.  It calls dropm to put the m back on the list, 1. when the callback is done with the m in non-pthread platforms, 2. or when the C thread exiting on pthread platforms.  The signal argument indicates whether we're called from a signal handler."
      },
      {
        "name": "netbsdMstart",
        "desc": "mstart is the entry-point for new Ms. It is written in assembly, uses ABI0, is marked TOPFRAME, and calls netbsdMstart0."
      },
      {
        "name": "netbsdMstart0",
        "desc": "netbsdMstart0 is the function call that starts executing a newly created thread. On NetBSD, a new thread inherits the signal stack of the creating thread. That confuses minit, so we remove that signal stack here before calling the regular mstart. It's a bit baroque to remove a signal stack here only to add one in minit, but it's a simple change that keeps NetBSD working like other OS's. At this point all signals are blocked, so there is no race."
      },
      {
        "name": "netpoll",
        "desc": "Polls for ready network connections. Returns a list of goroutines that become runnable, and a delta to add to netpollWaiters. This must never return an empty list with a non-zero delta."
      },
      {
        "name": "netpollAdjustWaiters",
        "desc": "netpollAdjustWaiters adds delta to netpollWaiters."
      },
      {
        "name": "netpollAnyWaiters",
        "desc": "netpollAnyWaiters reports whether any goroutines are waiting for I/O."
      },
      {
        "name": "netpollBreak",
        "desc": "netpollBreak interrupts an epollwait."
      },
      {
        "name": "netpollDeadline",
        "desc": ""
      },
      {
        "name": "netpollGenericInit",
        "desc": ""
      },
      {
        "name": "netpollIsPollDescriptor",
        "desc": ""
      },
      {
        "name": "netpollQueueTimer",
        "desc": "netpollQueueTimer queues a timer to wake up the poller after the given delay. It returns true if the timer expired during this call."
      },
      {
        "name": "netpollReadDeadline",
        "desc": ""
      },
      {
        "name": "netpollWriteDeadline",
        "desc": ""
      },
      {
        "name": "netpollarm",
        "desc": "subscribe the fd to the port such that port_getn will return one event."
      },
      {
        "name": "netpollblock",
        "desc": "returns true if IO is ready, or false if timed out or closed waitio - wait only for completed IO, ignore errors Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc can hold only a single waiting goroutine for each mode."
      },
      {
        "name": "netpollblockcommit",
        "desc": ""
      },
      {
        "name": "netpollcheckerr",
        "desc": ""
      },
      {
        "name": "netpollclose",
        "desc": ""
      },
      {
        "name": "netpolldeadlineimpl",
        "desc": ""
      },
      {
        "name": "netpolldisarm",
        "desc": ""
      },
      {
        "name": "netpollgoready",
        "desc": ""
      },
      {
        "name": "netpollinit",
        "desc": ""
      },
      {
        "name": "netpollinited",
        "desc": ""
      },
      {
        "name": "netpollopen",
        "desc": ""
      },
      {
        "name": "netpollready",
        "desc": "netpollready is called by the platform-specific netpoll function. It declares that the fd associated with pd is ready for I/O. The toRun argument is used to build a list of goroutines to return from netpoll. The mode argument is 'r', 'w', or 'r'+'w' to indicate whether the fd is ready for reading or writing or both.  This returns a delta to apply to netpollWaiters.  This may run while the world is stopped, so write barriers are not allowed."
      },
      {
        "name": "netpollupdate",
        "desc": "Updates the association with a new set of interested events. After this call, port_getn will return one and only one event for that particular descriptor, so this function needs to be called again."
      },
      {
        "name": "netpollwakeup",
        "desc": "netpollwakeup writes on wrwake to wakeup poll before any changes."
      },
      {
        "name": "newInlineUnwinder",
        "desc": "newInlineUnwinder creates an inlineUnwinder initially set to the inner-most inlined frame at PC. PC should be a \"call PC\" (not a \"return PC\").  This unwinder uses non-strict handling of PC because it's assumed this is only ever used for symbolic debugging. If things go really wrong, it'll just fall back to the outermost frame.  newInlineUnwinder should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "newarray",
        "desc": "newarray allocates an array of n elements of type typ.  newarray should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "newextram",
        "desc": "newextram allocates m's and puts them on the extra list. It is called with a working local m, so that it can do things like call schedlock and allocate."
      },
      {
        "name": "newm",
        "desc": "Create a new m. It will start off with a call to fn, or else the scheduler. fn needs to be static and not a heap allocated closure. May run with m.p==nil, so write barriers are not allowed.  id is optional pre-allocated m ID. Omit by passing -1."
      },
      {
        "name": "newm1",
        "desc": ""
      },
      {
        "name": "newobject",
        "desc": "implementation of new builtin compiler (both frontend and SSA backend) knows the signature of this function."
      },
      {
        "name": "newosproc",
        "desc": "May run with m.p==nil, so write barriers are not allowed."
      },
      {
        "name": "newosproc0",
        "desc": "newosproc0 is a version of newosproc that can be called before the runtime is initialized.  This function is not safe to use after initialization as it does not pass an M as fnarg."
      },
      {
        "name": "newproc",
        "desc": "Create a new g running fn. Put it on the queue of g's waiting to run. The compiler turns a go statement into a call to this."
      },
      {
        "name": "newstack",
        "desc": "Called from runtime·morestack when more stack is needed. Allocate larger stack and relocate to new stack. Stack growth is multiplicative, for constant amortized cost.  g-\u003eatomicstatus will be Grunning or Gscanrunning upon entry. If the scheduler is trying to stop this g, then it will set preemptStop.  This must be nowritebarrierrec because it can be called as part of stack growth from other nowritebarrierrec functions, but the compiler doesn't check this."
      },
      {
        "name": "nextMarkBitArenaEpoch",
        "desc": "nextMarkBitArenaEpoch establishes a new epoch for the arenas holding the mark bits. The arenas are named relative to the current GC cycle which is demarcated by the call to finishweep_m.  All current spans have been swept. During that sweep each span allocated room for its gcmarkBits in gcBitsArenas.next block. gcBitsArenas.next becomes the gcBitsArenas.current where the GC will mark objects and after each span is swept these bits will be used to allocate objects. gcBitsArenas.current becomes gcBitsArenas.previous where the span's gcAllocBits live until all the spans have been swept during this GC cycle. The span's sweep extinguishes all the references to gcBitsArenas.previous by pointing gcAllocBits into the gcBitsArenas.current. The gcBitsArenas.previous is released to the gcBitsArenas.free list."
      },
      {
        "name": "nextSample",
        "desc": "nextSample returns the next sampling point for heap profiling. The goal is to sample allocations on average every MemProfileRate bytes, but with a completely random distribution over the allocation timeline; this corresponds to a Poisson process with parameter MemProfileRate. In Poisson processes, the distance between two samples follows the exponential distribution (exp(MemProfileRate)), so the best return value is a random number taken from an exponential distribution whose mean is MemProfileRate."
      },
      {
        "name": "nextslicecap",
        "desc": "nextslicecap computes the next appropriate slice length."
      },
      {
        "name": "nilfunc",
        "desc": ""
      },
      {
        "name": "nilinterequal",
        "desc": ""
      },
      {
        "name": "nilinterhash",
        "desc": "nilinterhash should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/anacrolix/stm   - github.com/aristanetworks/goarista  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "noEscapePtr",
        "desc": "noEscapePtr hides a pointer from escape analysis. See noescape. USE CAREFULLY!"
      },
      {
        "name": "noSignalStack",
        "desc": "This is called when we receive a signal when there is no signal stack. This can only happen if non-Go code calls sigaltstack to disable the signal stack."
      },
      {
        "name": "noescape",
        "desc": "noescape hides a pointer from escape analysis.  noescape is the identity function but escape analysis doesn't think the output depends on the input.  noescape is inlined and currently compiles down to zero instructions. USE CAREFULLY!  noescape should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/ebitengine/purego   - github.com/hamba/avro/v2   - github.com/puzpuzpuz/xsync/v3   - github.com/songzhibin97/gkit  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "nonblockingPipe",
        "desc": ""
      },
      {
        "name": "notInitialized",
        "desc": ""
      },
      {
        "name": "notInitialized1",
        "desc": "Called if a wasmexport function is called before runtime initialization"
      },
      {
        "name": "noteclear",
        "desc": "One-time notifications."
      },
      {
        "name": "noted",
        "desc": ""
      },
      {
        "name": "notesleep",
        "desc": ""
      },
      {
        "name": "notetsleep",
        "desc": ""
      },
      {
        "name": "notetsleep_internal",
        "desc": "May run with m.p==nil if called from notetsleep, so write barriers are not allowed."
      },
      {
        "name": "notetsleepg",
        "desc": "same as runtime·notetsleep, but called on user g (not g0) calls only nosplit functions between entersyscallblock/exitsyscall."
      },
      {
        "name": "notewakeup",
        "desc": ""
      },
      {
        "name": "notify",
        "desc": ""
      },
      {
        "name": "notifyListAdd",
        "desc": "notifyListAdd adds the caller to a notify list such that it can receive notifications. The caller must eventually call notifyListWait to wait for such a notification, passing the returned ticket number."
      },
      {
        "name": "notifyListCheck",
        "desc": ""
      },
      {
        "name": "notifyListNotifyAll",
        "desc": "notifyListNotifyAll notifies all entries in the list."
      },
      {
        "name": "notifyListNotifyOne",
        "desc": "notifyListNotifyOne notifies one entry in the list."
      },
      {
        "name": "notifyListWait",
        "desc": "notifyListWait waits for a notification. If one has been sent since notifyListAdd was called, it returns immediately. Otherwise, it blocks."
      },
      {
        "name": "nsToSec",
        "desc": "nsToSec takes a duration in nanoseconds and converts it to seconds as a float64."
      },
      {
        "name": "nsec",
        "desc": ""
      },
      {
        "name": "offAddrToLevelIndex",
        "desc": "offAddrToLevelIndex converts an address in the offset address space to the index into summary[level] containing addr."
      },
      {
        "name": "oneNewExtraM",
        "desc": "oneNewExtraM allocates an m and puts it on the extra list."
      },
      {
        "name": "open",
        "desc": "Stubs so tests can link correctly. These should never be called."
      },
      {
        "name": "open_trampoline",
        "desc": ""
      },
      {
        "name": "osArchInit",
        "desc": ""
      },
      {
        "name": "osPreemptExtEnter",
        "desc": "osPreemptExtEnter is called before entering external code that may call ExitProcess.  This must be nosplit because it may be called from a syscall with untyped stack slots, so the stack must not be grown or scanned."
      },
      {
        "name": "osPreemptExtExit",
        "desc": "osPreemptExtExit is called after returning from external code that may call ExitProcess.  See osPreemptExtEnter for why this is nosplit."
      },
      {
        "name": "osRelax",
        "desc": "osRelax is called by the scheduler when transitioning to and from all Ps being idle.  Some versions of Windows have high resolution timer. For those versions osRelax is noop. For Windows versions without high resolution timer, osRelax adjusts the system-wide timer resolution. Go needs a high resolution timer while running and there's little extra cost if we're already using the CPU, but if all Ps are idle there's no need to consume extra power to drive the high-res timer."
      },
      {
        "name": "osSetupTLS",
        "desc": "osSetupTLS is called by needm to set up TLS for non-Go threads.  Defined in assembly."
      },
      {
        "name": "osStackAlloc",
        "desc": "osStackAlloc performs OS-specific initialization before s is used as stack memory."
      },
      {
        "name": "osStackFree",
        "desc": "osStackFree undoes the effect of osStackAlloc before s is returned to the heap."
      },
      {
        "name": "osStackRemap",
        "desc": ""
      },
      {
        "name": "os_beforeExit",
        "desc": "os_beforeExit is called from os.Exit(0)."
      },
      {
        "name": "os_runtime_args",
        "desc": ""
      },
      {
        "name": "os_sigpipe",
        "desc": "Do nothing on WASM platform, always return EPIPE to caller."
      },
      {
        "name": "osinit",
        "desc": "BSD interface for threading."
      },
      {
        "name": "osinit_hack",
        "desc": "osinit_hack is a clumsy hack to work around Apple libc bugs causing fork+exec to hang in the child process intermittently. See go.dev/issue/33565 and go.dev/issue/56784 for a few reports.  The stacks obtained from the hung child processes are in libSystem_atfork_child, which is supposed to reinitialize various parts of the C library in the new process.  One common stack dies in _notify_fork_child calling _notify_globals (inlined) calling _os_alloc_once, because _os_alloc_once detects that the once lock is held by the parent process and then calls _os_once_gate_corruption_abort. The allocation is setting up the globals for the notification subsystem. See the source code at [1]. To work around this, we can allocate the globals earlier in the Go program's lifetime, before any execs are involved, by calling any notify routine that is exported, calls _notify_globals, and doesn't do anything too expensive otherwise. notify_is_valid_token(0) fits the bill.  The other common stack dies in xpc_atfork_child calling _objc_msgSend_uncached which ends up in WAITING_FOR_ANOTHER_THREAD_TO_FINISH_CALLING_+initialize. Of course, whatever thread the child is waiting for is in the parent process and is not going to finish anything in the child process. There is no public source code for these routines, so it is unclear exactly what the problem is. An Apple engineer suggests using xpc_date_create_from_current, which empirically does fix the problem.  So osinit_hack_trampoline (in sys_darwin_$GOARCH.s) calls notify_is_valid_token(0) and xpc_date_create_from_current(), which makes the fork+exec hangs stop happening. If Apple fixes the libc bug in some future version of macOS, then we can remove this awful code."
      },
      {
        "name": "osinit_hack_trampoline",
        "desc": ""
      },
      {
        "name": "osyield",
        "desc": ""
      },
      {
        "name": "osyield1",
        "desc": ""
      },
      {
        "name": "osyield_no_g",
        "desc": ""
      },
      {
        "name": "overLoadFactor",
        "desc": "overLoadFactor reports whether count items placed in 1\u003c\u003cB buckets is over loadFactor."
      },
      {
        "name": "packNetpollKey",
        "desc": "packNetpollKey creates a key from a source and a tag. Bits that don't fit in the result are discarded."
      },
      {
        "name": "pageIndexOf",
        "desc": "pageIndexOf returns the arena, page index, and page mask for pointer p. The caller must ensure p is in the heap."
      },
      {
        "name": "panicCheck1",
        "desc": "Check to make sure we can really generate a panic. If the panic was generated from the runtime, or from inside malloc, then convert to a throw of msg. pc should be the program counter of the compiler-generated code that triggered this panic."
      },
      {
        "name": "panicCheck2",
        "desc": "Same as above, but calling from the runtime is allowed.  Using this function is necessary for any panic that may be generated by runtime.sigpanic, since those are always called by the runtime."
      },
      {
        "name": "panicExtendIndex",
        "desc": "Implemented in assembly, as they take arguments in registers. Declared here to mark them as ABIInternal."
      },
      {
        "name": "panicExtendIndexU",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3Acap",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3AcapU",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3Alen",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3AlenU",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3B",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3BU",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3C",
        "desc": ""
      },
      {
        "name": "panicExtendSlice3CU",
        "desc": ""
      },
      {
        "name": "panicExtendSliceAcap",
        "desc": ""
      },
      {
        "name": "panicExtendSliceAcapU",
        "desc": ""
      },
      {
        "name": "panicExtendSliceAlen",
        "desc": ""
      },
      {
        "name": "panicExtendSliceAlenU",
        "desc": ""
      },
      {
        "name": "panicExtendSliceB",
        "desc": ""
      },
      {
        "name": "panicExtendSliceBU",
        "desc": ""
      },
      {
        "name": "panicIndex",
        "desc": "Implemented in assembly, as they take arguments in registers. Declared here to mark them as ABIInternal."
      },
      {
        "name": "panicIndexU",
        "desc": ""
      },
      {
        "name": "panicSlice3Acap",
        "desc": ""
      },
      {
        "name": "panicSlice3AcapU",
        "desc": ""
      },
      {
        "name": "panicSlice3Alen",
        "desc": ""
      },
      {
        "name": "panicSlice3AlenU",
        "desc": ""
      },
      {
        "name": "panicSlice3B",
        "desc": ""
      },
      {
        "name": "panicSlice3BU",
        "desc": ""
      },
      {
        "name": "panicSlice3C",
        "desc": ""
      },
      {
        "name": "panicSlice3CU",
        "desc": ""
      },
      {
        "name": "panicSliceAcap",
        "desc": ""
      },
      {
        "name": "panicSliceAcapU",
        "desc": ""
      },
      {
        "name": "panicSliceAlen",
        "desc": ""
      },
      {
        "name": "panicSliceAlenU",
        "desc": ""
      },
      {
        "name": "panicSliceB",
        "desc": ""
      },
      {
        "name": "panicSliceBU",
        "desc": ""
      },
      {
        "name": "panicSliceConvert",
        "desc": ""
      },
      {
        "name": "panicdivide",
        "desc": ""
      },
      {
        "name": "panicdottypeE",
        "desc": "panicdottypeE is called when doing an e.(T) conversion and the conversion fails. have = the dynamic type we have. want = the static type we're trying to convert to. iface = the static type we're converting from."
      },
      {
        "name": "panicdottypeI",
        "desc": "panicdottypeI is called when doing an i.(T) conversion and the conversion fails. Same args as panicdottypeE, but \"have\" is the dynamic itab we have."
      },
      {
        "name": "panicfloat",
        "desc": ""
      },
      {
        "name": "panicmakeslicecap",
        "desc": ""
      },
      {
        "name": "panicmakeslicelen",
        "desc": ""
      },
      {
        "name": "panicmem",
        "desc": ""
      },
      {
        "name": "panicmemAddr",
        "desc": ""
      },
      {
        "name": "panicnildottype",
        "desc": "panicnildottype is called when doing an i.(T) conversion and the interface i is nil. want = the static type we're trying to convert to."
      },
      {
        "name": "panicoverflow",
        "desc": ""
      },
      {
        "name": "panicrangestate",
        "desc": ""
      },
      {
        "name": "panicshift",
        "desc": ""
      },
      {
        "name": "panicunsafeslicelen",
        "desc": ""
      },
      {
        "name": "panicunsafeslicelen1",
        "desc": ""
      },
      {
        "name": "panicunsafeslicenilptr",
        "desc": ""
      },
      {
        "name": "panicunsafeslicenilptr1",
        "desc": ""
      },
      {
        "name": "panicunsafestringlen",
        "desc": ""
      },
      {
        "name": "panicunsafestringnilptr",
        "desc": ""
      },
      {
        "name": "panicwrap",
        "desc": "panicwrap generates a panic for a call to a wrapped value method with a nil pointer receiver.  It is called from the generated wrapper code."
      },
      {
        "name": "park_m",
        "desc": "park continuation on g0."
      },
      {
        "name": "parkunlock_c",
        "desc": ""
      },
      {
        "name": "parseByteCount",
        "desc": "parseByteCount parses a string that represents a count of bytes.  s must match the following regular expression:  \t^[0-9]+(([KMGT]i)?B)?$  In other words, an integer byte count with an optional unit suffix. Acceptable suffixes include one of - KiB, MiB, GiB, TiB which represent binary IEC/ISO 80000 units, or - B, which just represents bytes.  Returns an int64 because that's what its callers want and receive, but the result is always non-negative."
      },
      {
        "name": "parseRuntimeDebugVars",
        "desc": ""
      },
      {
        "name": "parsegodebug",
        "desc": "parsegodebug parses the godebug string, updating variables listed in dbgvars. If seen == nil, this is startup time and we process the string left to right overwriting older settings with newer ones. If seen != nil, $GODEBUG has changed and we are doing an incremental update. To avoid flapping in the case where a value is set multiple times (perhaps in the default and the environment, or perhaps twice in the environment), we process the string right-to-left and only change values not already seen. After doing this for both the environment and the default settings, the caller must also call cleargodebug(seen) to reset any now-unset values back to their defaults."
      },
      {
        "name": "pause",
        "desc": "pause is only used on wasm."
      },
      {
        "name": "pcdatastart",
        "desc": ""
      },
      {
        "name": "pcdatavalue",
        "desc": ""
      },
      {
        "name": "pcdatavalue1",
        "desc": ""
      },
      {
        "name": "pcdatavalue2",
        "desc": "Like pcdatavalue, but also return the start PC of this PCData value."
      },
      {
        "name": "pcvalue",
        "desc": "Returns the PCData value, and the PC where this value starts."
      },
      {
        "name": "pcvalueCacheKey",
        "desc": "pcvalueCacheKey returns the outermost index in a pcvalueCache to use for targetpc. It must be very cheap to calculate. For now, align to goarch.PtrSize and reduce mod the number of entries. In practice, this appears to be fairly randomly and evenly distributed."
      },
      {
        "name": "persistentalloc",
        "desc": "Wrapper around sysAlloc that can allocate small chunks. There is no associated free operation. Intended for things like function/type/debug-related persistent data. If align is 0, uses default align (currently 8). The returned memory will be zeroed. sysStat must be non-nil.  Consider marking persistentalloc'd types not in heap by embedding internal/runtime/sys.NotInHeap.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "pidleget",
        "desc": "pidleget tries to get a p from the _Pidle list, acquiring ownership.  sched.lock must be held.  May run during STW, so write barriers are not allowed."
      },
      {
        "name": "pidlegetSpinning",
        "desc": "pidlegetSpinning tries to get a p from the _Pidle list, acquiring ownership. This is called by spinning Ms (or callers than need a spinning M) that have found work. If no P is available, this must synchronized with non-spinning Ms that may be preparing to drop their P without discovering this work.  sched.lock must be held.  May run during STW, so write barriers are not allowed."
      },
      {
        "name": "pidleput",
        "desc": "pidleput puts p on the _Pidle list. now must be a relatively recent call to nanotime or zero. Returns now or the current time if now was zero.  This releases ownership of p. Once sched.lock is released it is no longer safe to use p.  sched.lock must be held.  May run during STW, so write barriers are not allowed."
      },
      {
        "name": "pinnerGetPinCounter",
        "desc": "only for tests"
      },
      {
        "name": "pinnerGetPtr",
        "desc": ""
      },
      {
        "name": "pipe",
        "desc": ""
      },
      {
        "name": "pipe2",
        "desc": ""
      },
      {
        "name": "pipe2_trampoline",
        "desc": ""
      },
      {
        "name": "pipe_trampoline",
        "desc": ""
      },
      {
        "name": "pkgPath",
        "desc": ""
      },
      {
        "name": "plan9_semacquire",
        "desc": ""
      },
      {
        "name": "plan9_semrelease",
        "desc": ""
      },
      {
        "name": "plan9_tsemacquire",
        "desc": ""
      },
      {
        "name": "plugin_lastmoduleinit",
        "desc": ""
      },
      {
        "name": "pluginftabverify",
        "desc": ""
      },
      {
        "name": "pointerMask",
        "desc": "Returns GC type info for the pointer stored in ep for testing. If ep points to the stack, only static live information will be returned (i.e. not for objects which are only dynamically live stack objects)."
      },
      {
        "name": "poll",
        "desc": ""
      },
      {
        "name": "pollFractionalWorkerExit",
        "desc": "pollFractionalWorkerExit reports whether a fractional mark worker should self-preempt. It assumes it is called from the fractional worker."
      },
      {
        "name": "pollWork",
        "desc": "pollWork reports whether there is non-background work this P could be doing. This is a fairly lightweight check to be used for background work loops, like idle GC. It checks a subset of the conditions checked by the actual scheduler."
      },
      {
        "name": "poll_runtime_Semacquire",
        "desc": ""
      },
      {
        "name": "poll_runtime_Semrelease",
        "desc": ""
      },
      {
        "name": "poll_runtime_isPollServerDescriptor",
        "desc": "poll_runtime_isPollServerDescriptor reports whether fd is a descriptor being used by netpoll."
      },
      {
        "name": "poll_runtime_pollClose",
        "desc": ""
      },
      {
        "name": "poll_runtime_pollOpen",
        "desc": ""
      },
      {
        "name": "poll_runtime_pollReset",
        "desc": "poll_runtime_pollReset, which is internal/poll.runtime_pollReset, prepares a descriptor for polling in mode, which is 'r' or 'w'. This returns an error code; the codes are defined above."
      },
      {
        "name": "poll_runtime_pollServerInit",
        "desc": ""
      },
      {
        "name": "poll_runtime_pollSetDeadline",
        "desc": ""
      },
      {
        "name": "poll_runtime_pollUnblock",
        "desc": ""
      },
      {
        "name": "poll_runtime_pollWait",
        "desc": "poll_runtime_pollWait, which is internal/poll.runtime_pollWait, waits for a descriptor to be ready for reading or writing, according to mode, which is 'r' or 'w'. This returns an error code; the codes are defined above."
      },
      {
        "name": "poll_runtime_pollWaitCanceled",
        "desc": ""
      },
      {
        "name": "popDefer",
        "desc": "popDefer pops the head of gp's defer list and frees it."
      },
      {
        "name": "port_alert",
        "desc": ""
      },
      {
        "name": "port_associate",
        "desc": ""
      },
      {
        "name": "port_create",
        "desc": ""
      },
      {
        "name": "port_dissociate",
        "desc": ""
      },
      {
        "name": "port_getn",
        "desc": ""
      },
      {
        "name": "postMallocgcDebug",
        "desc": ""
      },
      {
        "name": "postnote",
        "desc": ""
      },
      {
        "name": "pprof_blockProfileInternal",
        "desc": ""
      },
      {
        "name": "pprof_cyclesPerSecond",
        "desc": "runtime/pprof.runtime_cyclesPerSecond should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/grafana/pyroscope-go/godeltaprof   - github.com/pyroscope-io/godeltaprof  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "pprof_fpunwindExpand",
        "desc": ""
      },
      {
        "name": "pprof_goroutineProfileWithLabels",
        "desc": ""
      },
      {
        "name": "pprof_makeProfStack",
        "desc": ""
      },
      {
        "name": "pprof_memProfileInternal",
        "desc": ""
      },
      {
        "name": "pprof_mutexProfileInternal",
        "desc": ""
      },
      {
        "name": "pprof_threadCreateInternal",
        "desc": ""
      },
      {
        "name": "preMallocgcDebug",
        "desc": ""
      },
      {
        "name": "pread",
        "desc": ""
      },
      {
        "name": "preemptM",
        "desc": "preemptM sends a preemption request to mp. This request may be handled asynchronously and may be coalesced with other requests to the M. When the request is received, if the running G or P are marked for preemption and the goroutine is at an asynchronous safe-point, it will preempt the goroutine. It always atomically increments mp.preemptGen after handling a preemption request."
      },
      {
        "name": "preemptPark",
        "desc": "preemptPark parks gp and puts it in _Gpreempted."
      },
      {
        "name": "preemptall",
        "desc": "Tell all goroutines that they have been preempted and they should stop. This function is purely best-effort. It can fail to inform a goroutine if a processor just started running it. No locks need to be held. Returns true if preemption request was issued to at least one goroutine."
      },
      {
        "name": "preemptone",
        "desc": "Tell the goroutine running on processor P to stop. This function is purely best-effort. It can incorrectly fail to inform the goroutine. It can inform the wrong goroutine. Even if it informs the correct goroutine, that goroutine might ignore the request if it is simultaneously executing newstack. No lock needs to be held. Returns true if preemption request was issued. The actual preemption will happen at some point in the future and will be indicated by the gp-\u003estatus no longer being Grunning"
      },
      {
        "name": "prepGoExitFrame",
        "desc": ""
      },
      {
        "name": "prepareContextForSigResume",
        "desc": ""
      },
      {
        "name": "prepareFreeWorkbufs",
        "desc": "prepareFreeWorkbufs moves busy workbuf spans to free list so they can be freed to the heap. This must only be called when all workbufs are on the empty list."
      },
      {
        "name": "preprintpanics",
        "desc": "Call all Error and String methods before freezing the world. Used when crashing with panicking."
      },
      {
        "name": "preventErrorDialogs",
        "desc": ""
      },
      {
        "name": "printAncestorTraceback",
        "desc": "printAncestorTraceback prints the traceback of the given ancestor. TODO: Unify this with gentraceback and CallersFrames."
      },
      {
        "name": "printAncestorTracebackFuncInfo",
        "desc": "printAncestorTracebackFuncInfo prints the given function info at a given pc within an ancestor traceback. The precision of this info is reduced due to only have access to the pcs at the time of the caller goroutine being created."
      },
      {
        "name": "printArgs",
        "desc": "printArgs prints function arguments in traceback."
      },
      {
        "name": "printCgoTraceback",
        "desc": "printCgoTraceback prints a traceback of callers."
      },
      {
        "name": "printDebugLog",
        "desc": "printDebugLog prints the debug log."
      },
      {
        "name": "printDebugLogImpl",
        "desc": ""
      },
      {
        "name": "printDebugLogPC",
        "desc": "printDebugLogPC prints a single symbolized PC. If returnPC is true, pc is a return PC that must first be converted to a call PC."
      },
      {
        "name": "printFuncName",
        "desc": "printFuncName prints a function name. name is the function name in the binary's func data table."
      },
      {
        "name": "printHeldLocks",
        "desc": "nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "printOneCgoTraceback",
        "desc": "printOneCgoTraceback prints the traceback of a single cgo caller. This can print more than one line because of inlining. It returns the \"stop\" result of commitFrame."
      },
      {
        "name": "printScavTrace",
        "desc": "printScavTrace prints a scavenge trace line to standard error.  released should be the amount of memory released since the last time this was called, and forced indicates whether the scavenge was forced by the application.  scavenger.lock must be held."
      },
      {
        "name": "printanycustomtype",
        "desc": "Invariant: each newline in the string representation is followed by a tab."
      },
      {
        "name": "printbool",
        "desc": ""
      },
      {
        "name": "printcomplex",
        "desc": ""
      },
      {
        "name": "printcreatedby",
        "desc": ""
      },
      {
        "name": "printcreatedby1",
        "desc": ""
      },
      {
        "name": "printeface",
        "desc": ""
      },
      {
        "name": "printfloat",
        "desc": ""
      },
      {
        "name": "printhex",
        "desc": ""
      },
      {
        "name": "printiface",
        "desc": ""
      },
      {
        "name": "printindented",
        "desc": "printindented prints s, replacing \"\\n\" with \"\\n\\t\"."
      },
      {
        "name": "printint",
        "desc": ""
      },
      {
        "name": "printlock",
        "desc": ""
      },
      {
        "name": "printnl",
        "desc": ""
      },
      {
        "name": "printpanics",
        "desc": "Print all currently active panics. Used when crashing. Should only be called after preprintpanics."
      },
      {
        "name": "printpanicval",
        "desc": "printpanicval prints an argument passed to panic. If panic is called with a value that has a String or Error method, it has already been converted into a string by preprintpanics.  To ensure that the traceback can be unambiguously parsed even when the panic value contains \"\\ngoroutine\" and other stack-like strings, newlines in the string representation of v are replaced by \"\\n\\t\"."
      },
      {
        "name": "printpointer",
        "desc": ""
      },
      {
        "name": "printslice",
        "desc": ""
      },
      {
        "name": "printsp",
        "desc": ""
      },
      {
        "name": "printstring",
        "desc": ""
      },
      {
        "name": "printuint",
        "desc": ""
      },
      {
        "name": "printuintptr",
        "desc": ""
      },
      {
        "name": "printunlock",
        "desc": ""
      },
      {
        "name": "procPin",
        "desc": "procPin should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/choleraehyq/pid   - github.com/songzhibin97/gkit  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "procUnpin",
        "desc": "procUnpin should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/choleraehyq/pid   - github.com/songzhibin97/gkit  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "proc_regionfilename",
        "desc": ""
      },
      {
        "name": "proc_regionfilename_trampoline",
        "desc": ""
      },
      {
        "name": "processWakeupEvent",
        "desc": ""
      },
      {
        "name": "procyield",
        "desc": "procyield should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/sagernet/sing-tun   - github.com/slackhq/nebula   - golang.zx2c4.com/wireguard  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "profileLoop",
        "desc": ""
      },
      {
        "name": "profilealloc",
        "desc": "profilealloc resets the current mcache's nextSample counter and records a memory profile sample.  The caller must be non-preemptible and have a P."
      },
      {
        "name": "profilem",
        "desc": ""
      },
      {
        "name": "pthread_attr_destroy",
        "desc": ""
      },
      {
        "name": "pthread_attr_destroy_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_attr_getstack",
        "desc": ""
      },
      {
        "name": "pthread_attr_getstacksize",
        "desc": ""
      },
      {
        "name": "pthread_attr_getstacksize_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_attr_init",
        "desc": ""
      },
      {
        "name": "pthread_attr_init1",
        "desc": ""
      },
      {
        "name": "pthread_attr_init_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_attr_setdetachstate",
        "desc": ""
      },
      {
        "name": "pthread_attr_setdetachstate1",
        "desc": ""
      },
      {
        "name": "pthread_attr_setdetachstate_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_attr_setstack",
        "desc": ""
      },
      {
        "name": "pthread_attr_setstackaddr",
        "desc": ""
      },
      {
        "name": "pthread_attr_setstacksize",
        "desc": ""
      },
      {
        "name": "pthread_attr_setstacksize1",
        "desc": ""
      },
      {
        "name": "pthread_cond_init",
        "desc": ""
      },
      {
        "name": "pthread_cond_init_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_cond_signal",
        "desc": ""
      },
      {
        "name": "pthread_cond_signal_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_cond_timedwait_relative_np",
        "desc": ""
      },
      {
        "name": "pthread_cond_timedwait_relative_np_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_cond_wait",
        "desc": ""
      },
      {
        "name": "pthread_cond_wait_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_create",
        "desc": ""
      },
      {
        "name": "pthread_create1",
        "desc": ""
      },
      {
        "name": "pthread_create_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_key_create_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_kill",
        "desc": ""
      },
      {
        "name": "pthread_kill_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_mutex_init",
        "desc": ""
      },
      {
        "name": "pthread_mutex_init_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_mutex_lock",
        "desc": ""
      },
      {
        "name": "pthread_mutex_lock_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_mutex_unlock",
        "desc": ""
      },
      {
        "name": "pthread_mutex_unlock_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_self_trampoline",
        "desc": ""
      },
      {
        "name": "pthread_setspecific_trampoline",
        "desc": ""
      },
      {
        "name": "publicationBarrier",
        "desc": "publicationBarrier performs a store/store barrier (a \"publication\" or \"export\" barrier). Some form of synchronization is required between initializing an object and making that object accessible to another processor. Without synchronization, the initialization writes and the \"publication\" write may be reordered, allowing the other processor to follow the pointer and observe an uninitialized object. In general, higher-level synchronization should be used, such as locking or an atomic pointer write. publicationBarrier is for when those aren't an option, such as in the implementation of the memory manager.  There's no corresponding barrier for the read side because the read side naturally has a data dependency order. All architectures that Go supports or seems likely to ever support automatically enforce data dependency ordering."
      },
      {
        "name": "putCachedDlogger",
        "desc": "putCachedDlogger attempts to return l to the local cache. It returns false if this fails."
      },
      {
        "name": "putExtraM",
        "desc": "Returns an extra M back to the list. mp must be from getExtraM. Newly allocated M's should use addExtraM."
      },
      {
        "name": "putempty",
        "desc": "putempty puts a workbuf onto the work.empty list. Upon entry this goroutine owns b. The lfstack.push relinquishes ownership."
      },
      {
        "name": "putfull",
        "desc": "putfull puts the workbuf on the work.full list for the GC. putfull accepts partially full buffers so the GC can avoid competing with the mutators for ownership of partially full buffers."
      },
      {
        "name": "pwrite",
        "desc": ""
      },
      {
        "name": "queuefinalizer",
        "desc": ""
      },
      {
        "name": "r4",
        "desc": ""
      },
      {
        "name": "r8",
        "desc": ""
      },
      {
        "name": "raceEnterNewCtx",
        "desc": "raceEnterNewCtx creates a new racectx and switches the current goroutine to it. Returns the old racectx.  Must be running on a user goroutine. nosplit to match other race instrumentation."
      },
      {
        "name": "raceReadObjectPC",
        "desc": "For all functions accepting callerpc and pc, callerpc is a return PC of the function that calls this function, pc is start PC of the function that calls this function."
      },
      {
        "name": "raceRestoreCtx",
        "desc": "raceRestoreCtx restores ctx on the goroutine. It is the inverse of raceenternewctx and must be called with its result.  Must be running on a user goroutine. nosplit to match other race instrumentation."
      },
      {
        "name": "raceSymbolizeCode",
        "desc": "raceSymbolizeCode reads ctx.pc and populates the rest of *ctx with information about the code at that pc.  The race detector has already subtracted 1 from pcs, so they point to the last byte of call instructions (including calls to runtime.racewrite and friends).  If the incoming pc is part of an inlined function, *ctx is populated with information about the inlined function, and on return ctx.pc is set to a pc in the logically containing function. (The race detector should call this function again with that pc.)  If the incoming pc is not part of an inlined function, the return pc is unchanged."
      },
      {
        "name": "raceSymbolizeData",
        "desc": ""
      },
      {
        "name": "raceWriteObjectPC",
        "desc": ""
      },
      {
        "name": "race_Acquire",
        "desc": ""
      },
      {
        "name": "race_Disable",
        "desc": ""
      },
      {
        "name": "race_Enable",
        "desc": ""
      },
      {
        "name": "race_Errors",
        "desc": ""
      },
      {
        "name": "race_Read",
        "desc": ""
      },
      {
        "name": "race_ReadObjectPC",
        "desc": ""
      },
      {
        "name": "race_ReadPC",
        "desc": ""
      },
      {
        "name": "race_ReadRange",
        "desc": ""
      },
      {
        "name": "race_Release",
        "desc": ""
      },
      {
        "name": "race_ReleaseMerge",
        "desc": ""
      },
      {
        "name": "race_Write",
        "desc": ""
      },
      {
        "name": "race_WriteObjectPC",
        "desc": ""
      },
      {
        "name": "race_WritePC",
        "desc": ""
      },
      {
        "name": "race_WriteRange",
        "desc": ""
      },
      {
        "name": "raceacquire",
        "desc": ""
      },
      {
        "name": "raceacquirectx",
        "desc": ""
      },
      {
        "name": "raceacquireg",
        "desc": ""
      },
      {
        "name": "racecall",
        "desc": "racecall allows calling an arbitrary function fn from C race runtime with up to 4 uintptr arguments."
      },
      {
        "name": "racecallback",
        "desc": "Callback from C into Go, runs on g0."
      },
      {
        "name": "racecallbackthunk",
        "desc": ""
      },
      {
        "name": "racectxend",
        "desc": ""
      },
      {
        "name": "racectxstart",
        "desc": ""
      },
      {
        "name": "racefingo",
        "desc": ""
      },
      {
        "name": "racefini",
        "desc": ""
      },
      {
        "name": "racefree",
        "desc": ""
      },
      {
        "name": "racefuncenter",
        "desc": ""
      },
      {
        "name": "racefuncenterfp",
        "desc": ""
      },
      {
        "name": "racefuncexit",
        "desc": ""
      },
      {
        "name": "racegoend",
        "desc": ""
      },
      {
        "name": "racegostart",
        "desc": ""
      },
      {
        "name": "raceinit",
        "desc": ""
      },
      {
        "name": "racemalloc",
        "desc": ""
      },
      {
        "name": "racemapshadow",
        "desc": ""
      },
      {
        "name": "racenotify",
        "desc": "Notify the race detector of a send or receive involving buffer entry idx and a channel c or its communicating partner sg. This function handles the special case of c.elemsize==0."
      },
      {
        "name": "raceproccreate",
        "desc": ""
      },
      {
        "name": "raceprocdestroy",
        "desc": ""
      },
      {
        "name": "raceread",
        "desc": ""
      },
      {
        "name": "racereadpc",
        "desc": ""
      },
      {
        "name": "racereadrange",
        "desc": ""
      },
      {
        "name": "racereadrangepc",
        "desc": ""
      },
      {
        "name": "racereadrangepc1",
        "desc": ""
      },
      {
        "name": "racerelease",
        "desc": ""
      },
      {
        "name": "racereleaseacquire",
        "desc": ""
      },
      {
        "name": "racereleaseacquireg",
        "desc": ""
      },
      {
        "name": "racereleaseg",
        "desc": ""
      },
      {
        "name": "racereleasemerge",
        "desc": ""
      },
      {
        "name": "racereleasemergeg",
        "desc": ""
      },
      {
        "name": "racesync",
        "desc": ""
      },
      {
        "name": "racewrite",
        "desc": ""
      },
      {
        "name": "racewritepc",
        "desc": ""
      },
      {
        "name": "racewriterange",
        "desc": ""
      },
      {
        "name": "racewriterangepc",
        "desc": ""
      },
      {
        "name": "racewriterangepc1",
        "desc": ""
      },
      {
        "name": "raise",
        "desc": "raise sends a signal to the calling thread.  It must be nosplit because it is used by the signal handler before it definitely has a Go stack."
      },
      {
        "name": "raise_trampoline",
        "desc": ""
      },
      {
        "name": "raisebadsignal",
        "desc": "raisebadsignal is called when a signal is received on a non-Go thread, and the Go program does not want to handle it (that is, the program has not called os/signal.Notify for the signal)."
      },
      {
        "name": "raiseproc",
        "desc": ""
      },
      {
        "name": "raiseproc_trampoline",
        "desc": ""
      },
      {
        "name": "rand",
        "desc": "rand returns a random uint64 from the per-m chacha8 state. This is called from compiler-generated code.  Do not change signature: used via linkname from other packages."
      },
      {
        "name": "rand32",
        "desc": "rand32 is uint32(rand()), called from compiler-generated code."
      },
      {
        "name": "rand_fatal",
        "desc": ""
      },
      {
        "name": "randinit",
        "desc": "randinit initializes the global random state. It must be called before any use of grand."
      },
      {
        "name": "randn",
        "desc": "randn is like rand() % n but faster. Do not change signature: used via linkname from other packages."
      },
      {
        "name": "rawbyteslice",
        "desc": "rawbyteslice allocates a new byte slice. The byte slice is not zeroed."
      },
      {
        "name": "rawruneslice",
        "desc": "rawruneslice allocates a new rune slice. The rune slice is not zeroed."
      },
      {
        "name": "rawstring",
        "desc": "rawstring allocates storage for a new string. The returned string and byte slice both refer to the same storage. The storage is not zeroed. Callers should use b to set the string contents and then drop b."
      },
      {
        "name": "rawstringtmp",
        "desc": ""
      },
      {
        "name": "rctlblk_get_local_action",
        "desc": ""
      },
      {
        "name": "rctlblk_get_local_flags",
        "desc": ""
      },
      {
        "name": "rctlblk_get_value",
        "desc": ""
      },
      {
        "name": "rctlblk_size",
        "desc": ""
      },
      {
        "name": "read",
        "desc": "read calls the read system call. It returns a non-negative number of bytes written or a negative errno value."
      },
      {
        "name": "readGCStats",
        "desc": ""
      },
      {
        "name": "readGCStats_m",
        "desc": "readGCStats_m must be called on the system stack because it acquires the heap lock. See mheap for details."
      },
      {
        "name": "readGOGC",
        "desc": ""
      },
      {
        "name": "readGOMEMLIMIT",
        "desc": ""
      },
      {
        "name": "readMetricNames",
        "desc": "readMetricNames is the implementation of runtime/metrics.readMetricNames, used by the runtime/metrics test and otherwise unreferenced."
      },
      {
        "name": "readMetrics",
        "desc": "readMetrics is the implementation of runtime/metrics.Read."
      },
      {
        "name": "readMetricsLocked",
        "desc": "readMetricsLocked is the internal, locked portion of readMetrics.  Broken out for more robust testing. metricsLock must be held and initMetrics must have been called already."
      },
      {
        "name": "readRandom",
        "desc": "Don't read from /dev/random, since this device can only return a few hundred bits a second and would slow creation of Go processes down significantly."
      },
      {
        "name": "readTimeRandom",
        "desc": "readTimeRandom stretches any entropy in the current time into entropy the length of r and XORs it into r. This is a fallback for when readRandom does not read the full requested amount. Whatever entropy r already contained is preserved."
      },
      {
        "name": "readTrace",
        "desc": "readTrace is the implementation of ReadTrace, except with an additional in-band signal as to when the buffer is for a new generation."
      },
      {
        "name": "readTrace0",
        "desc": "readTrace0 is ReadTrace's continuation on g0. This must run on the system stack because it acquires trace.lock."
      },
      {
        "name": "readUintptr",
        "desc": "Read the bytes starting at the aligned pointer p into a uintptr. Read is little-endian."
      },
      {
        "name": "readUnaligned32",
        "desc": "Note: These routines perform the read with a native endianness."
      },
      {
        "name": "readUnaligned64",
        "desc": ""
      },
      {
        "name": "read_tls_fallback",
        "desc": ""
      },
      {
        "name": "read_trampoline",
        "desc": ""
      },
      {
        "name": "readgstatus",
        "desc": "All reads and writes of g's status go through readgstatus, casgstatus castogscanstatus, casfrom_Gscanstatus."
      },
      {
        "name": "readmemstats_m",
        "desc": "readmemstats_m populates stats for internal runtime values.  The world must be stopped."
      },
      {
        "name": "readtime",
        "desc": ""
      },
      {
        "name": "readvarint",
        "desc": "readvarint reads a varint from p."
      },
      {
        "name": "readvarintUnsafe",
        "desc": "readvarintUnsafe reads the uint32 in varint format starting at fd, and returns the uint32 and a pointer to the byte following the varint.  The implementation is the same with runtime.readvarint, except that this function uses unsafe.Pointer for speed."
      },
      {
        "name": "ready",
        "desc": "Mark gp ready to run."
      },
      {
        "name": "readyWithTime",
        "desc": ""
      },
      {
        "name": "recordForPanic",
        "desc": "recordForPanic maintains a circular buffer of messages written by the runtime leading up to a process crash, allowing the messages to be extracted from a core dump.  The text written during a process crash (following \"panic\" or \"fatal error\") is not saved, since the goroutine stacks will generally be readable from the runtime data structures in the core file."
      },
      {
        "name": "recordspan",
        "desc": "recordspan adds a newly allocated span to h.allspans.  This only happens the first time a span is allocated from mheap.spanalloc (it is not called when a span is reused).  Write barriers are disallowed here because it can be called from gcWork when allocating new workbufs. However, because it's an indirect call from the fixalloc initializer, the compiler can't see this.  The heap lock must be held."
      },
      {
        "name": "recovery",
        "desc": "Unwind the stack after a deferred function calls recover after a panic. Then arrange to continue running as though the caller of the deferred function returned normally.  However, if unwinding the stack would skip over a Goexit call, we return into the Goexit loop instead, so it can continue processing defers instead."
      },
      {
        "name": "recv",
        "desc": "recv processes a receive operation on a full channel c. There are 2 parts:  1. The value sent by the sender sg is put into the channel     and the sender is woken up to go on its merry way.  2. The value received by the receiver (the current G) is     written to ep.  For synchronous channels, both values are the same. For asynchronous channels, the receiver gets its data from the channel buffer and the sender's data is put in the channel buffer. Channel c must be full and locked. recv unlocks c with unlockf. sg must already be dequeued from c. A non-nil ep must point to the heap or the caller's stack."
      },
      {
        "name": "recvDirect",
        "desc": ""
      },
      {
        "name": "redZoneSize",
        "desc": "redZoneSize computes the size of the redzone for a given allocation. Refer to the implementation of the compiler-rt."
      },
      {
        "name": "reentersyscall",
        "desc": "The goroutine g is about to enter a system call. Record that it's not using the cpu anymore. This is called only from the go syscall library and cgocall, not from the low-level system calls used by the runtime.  Entersyscall cannot split the stack: the save must make g-\u003esched refer to the caller's stack segment, because entersyscall is going to return immediately after.  Nothing entersyscall calls can split the stack either. We cannot safely move the stack during an active call to syscall, because we do not know which of the uintptr arguments are really pointers (back into the stack). In practice, this means that we make the fast path run through entersyscall doing no-split things, and the slow path has to use systemstack to run bigger things on the system stack.  reentersyscall is the entry point used by cgo callbacks, where explicitly saved SP and PC are restored. This is needed when exitsyscall will be called from a function further up in the call stack than the parent, as g-\u003esyscallsp must always point to a valid stack frame. entersyscall below is the normal entry point for syscalls, which obtains the SP and PC from the caller."
      },
      {
        "name": "reflectOffsLock",
        "desc": ""
      },
      {
        "name": "reflectOffsUnlock",
        "desc": ""
      },
      {
        "name": "reflect_addReflectOff",
        "desc": "reflect_addReflectOff adds a pointer to the reflection offset lookup map."
      },
      {
        "name": "reflect_chancap",
        "desc": ""
      },
      {
        "name": "reflect_chanclose",
        "desc": ""
      },
      {
        "name": "reflect_chanlen",
        "desc": ""
      },
      {
        "name": "reflect_chanrecv",
        "desc": ""
      },
      {
        "name": "reflect_chansend",
        "desc": ""
      },
      {
        "name": "reflect_gcbits",
        "desc": "reflect_gcbits returns the GC type info for x, for testing. The result is the bitmap entries (0 or 1), one entry per byte."
      },
      {
        "name": "reflect_ifaceE2I",
        "desc": "reflect_ifaceE2I is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/modern-go/reflect2   - github.com/v2pro/plz  Do not remove or change the type signature."
      },
      {
        "name": "reflect_makemap",
        "desc": "reflect_makemap is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/modern-go/reflect2   - github.com/goccy/go-json   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_mapaccess",
        "desc": "reflect_mapaccess is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/modern-go/reflect2   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_mapaccess_faststr",
        "desc": ""
      },
      {
        "name": "reflect_mapassign",
        "desc": "reflect_mapassign is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/v2pro/plz  Do not remove or change the type signature."
      },
      {
        "name": "reflect_mapassign_faststr",
        "desc": ""
      },
      {
        "name": "reflect_mapclear",
        "desc": ""
      },
      {
        "name": "reflect_mapdelete",
        "desc": ""
      },
      {
        "name": "reflect_mapdelete_faststr",
        "desc": ""
      },
      {
        "name": "reflect_mapiterelem",
        "desc": "reflect_mapiterelem is a compatibility wrapper for map iterator for users of //go:linkname from before Go 1.24. It is not used by Go itself. New users should use reflect or the maps package.  reflect_mapiterelem should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/goccy/go-json   - gonum.org/v1/gonum  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_mapiterinit",
        "desc": "reflect_mapiterinit is a compatibility wrapper for map iterator for users of //go:linkname from before Go 1.24. It is not used by Go itself. New users should use reflect or the maps package.  reflect_mapiterinit should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/modern-go/reflect2   - gitee.com/quant1x/gox   - github.com/v2pro/plz   - github.com/wI2L/jettison  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_mapiterkey",
        "desc": "reflect_mapiterkey is a compatibility wrapper for map iterator for users of //go:linkname from before Go 1.24. It is not used by Go itself. New users should use reflect or the maps package.  reflect_mapiterkey should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/goccy/go-json   - gonum.org/v1/gonum  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_mapiternext",
        "desc": "reflect_mapiternext is a compatibility wrapper for map iterator for users of //go:linkname from before Go 1.24. It is not used by Go itself. New users should use reflect or the maps package.  reflect_mapiternext is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/modern-go/reflect2   - github.com/goccy/go-json   - github.com/v2pro/plz   - github.com/wI2L/jettison  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_maplen",
        "desc": "reflect_maplen is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/goccy/go-json   - github.com/wI2L/jettison  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_memclrNoHeapPointers",
        "desc": ""
      },
      {
        "name": "reflect_memmove",
        "desc": ""
      },
      {
        "name": "reflect_resolveNameOff",
        "desc": "reflect_resolveNameOff resolves a name offset from a base pointer.  reflect_resolveNameOff is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/agiledragon/gomonkey/v2  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_resolveTextOff",
        "desc": "reflect_resolveTextOff resolves a function pointer offset from a base type.  reflect_resolveTextOff is for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/agiledragon/gomonkey/v2  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_resolveTypeOff",
        "desc": "reflect_resolveTypeOff resolves an *rtype offset from a base type.  reflect_resolveTypeOff is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/modern-go/reflect2   - github.com/v2pro/plz   - github.com/timandy/routine  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_rselect",
        "desc": ""
      },
      {
        "name": "reflect_typedarrayclear",
        "desc": ""
      },
      {
        "name": "reflect_typedmemclr",
        "desc": "reflect_typedmemclr is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/ugorji/go/codec  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_typedmemclrpartial",
        "desc": ""
      },
      {
        "name": "reflect_typedmemmove",
        "desc": "reflect_typedmemmove is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/goccy/json   - github.com/modern-go/reflect2   - github.com/ugorji/go/codec   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_typedslicecopy",
        "desc": "reflect_typedslicecopy is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/modern-go/reflect2   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_typehash",
        "desc": ""
      },
      {
        "name": "reflect_typelinks",
        "desc": "reflect_typelinks is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/goccy/json   - github.com/modern-go/reflect2   - github.com/vmware/govmomi   - github.com/pinpoint-apm/pinpoint-go-agent   - github.com/timandy/routine   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_unsafe_New",
        "desc": "reflect_unsafe_New is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/goccy/json   - github.com/modern-go/reflect2   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_unsafe_NewArray",
        "desc": "reflect_unsafe_NewArray is meant for package reflect, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/bytedance/sonic   - github.com/goccy/json   - github.com/modern-go/reflect2   - github.com/segmentio/encoding   - github.com/segmentio/kafka-go   - github.com/v2pro/plz  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "reflect_unsafeslice",
        "desc": ""
      },
      {
        "name": "reflect_verifyNotInHeapPtr",
        "desc": "reflect_verifyNotInHeapPtr reports whether converting the not-in-heap pointer into a unsafe.Pointer is ok."
      },
      {
        "name": "reflectcall",
        "desc": "reflectcall calls fn with arguments described by stackArgs, stackArgsSize, frameSize, and regArgs.  Arguments passed on the stack and space for return values passed on the stack must be laid out at the space pointed to by stackArgs (with total length stackArgsSize) according to the ABI.  stackRetOffset must be some value \u003c= stackArgsSize that indicates the offset within stackArgs where the return value space begins.  frameSize is the total size of the argument frame at stackArgs and must therefore be \u003e= stackArgsSize. It must include additional space for spilling register arguments for stack growth and preemption.  TODO(mknyszek): Once we don't need the additional spill space, remove frameSize, since frameSize will be redundant with stackArgsSize.  Arguments passed in registers must be laid out in regArgs according to the ABI. regArgs will hold any return values passed in registers after the call.  reflectcall copies stack arguments from stackArgs to the goroutine stack, and then copies back stackArgsSize-stackRetOffset bytes back to the return space in stackArgs once fn has completed. It also \"unspills\" argument registers from regArgs before calling fn, and spills them back into regArgs immediately following the call to fn. If there are results being returned on the stack, the caller should pass the argument frame type as stackArgsType so that reflectcall can execute appropriate write barriers during the copy.  reflectcall expects regArgs.ReturnIsPtr to be populated indicating which registers on the return path will contain Go pointers. It will then store these pointers in regArgs.Ptrs such that they are visible to the GC.  Package reflect passes a frame type. In package runtime, there is only one call that copies results back, in callbackWrap in syscall_windows.go, and it does NOT pass a frame type, meaning there are no write barriers invoked. See that call site for justification.  Package reflect accesses this symbol through a linkname.  Arguments passed through to reflectcall do not escape. The type is used only in a very limited callee of reflectcall, the stackArgs are copied, and regArgs is only used in the reflectcall frame."
      },
      {
        "name": "reflectcallmove",
        "desc": "reflectcallmove is invoked by reflectcall to copy the return values out of the stack and into the heap, invoking the necessary write barriers. dst, src, and size describe the return value area to copy. typ describes the entire frame (not just the return values). typ may be nil, which indicates write barriers are not needed.  It must be nosplit and must only call nosplit functions because the stack map of reflectcall is wrong."
      },
      {
        "name": "reflectlite_chanlen",
        "desc": ""
      },
      {
        "name": "reflectlite_ifaceE2I",
        "desc": ""
      },
      {
        "name": "reflectlite_maplen",
        "desc": ""
      },
      {
        "name": "reflectlite_resolveNameOff",
        "desc": "reflectlite_resolveNameOff resolves a name offset from a base pointer."
      },
      {
        "name": "reflectlite_resolveTypeOff",
        "desc": "reflectlite_resolveTypeOff resolves an *rtype offset from a base type."
      },
      {
        "name": "reflectlite_typedmemmove",
        "desc": ""
      },
      {
        "name": "reflectlite_unsafe_New",
        "desc": ""
      },
      {
        "name": "reginit",
        "desc": ""
      },
      {
        "name": "releaseLockRankAndM",
        "desc": "releaseLockRankAndM releases a rank which is not associated with a mutex lock. To maintain the invariant that an M with m.locks==0 does not hold any lock-like resources, it also releases the M.  This function may be called in nosplit context and thus must be nosplit."
      },
      {
        "name": "releaseSudog",
        "desc": ""
      },
      {
        "name": "releasem",
        "desc": ""
      },
      {
        "name": "removefinalizer",
        "desc": "Removes the finalizer (if any) from the object p."
      },
      {
        "name": "removesub",
        "desc": ""
      },
      {
        "name": "reparsedebugvars",
        "desc": "reparsedebugvars reparses the runtime's debug variables because the environment variable has been changed to env."
      },
      {
        "name": "resetForSleep",
        "desc": "resetForSleep is called after the goroutine is parked for timeSleep. We can't call timer.reset in timeSleep itself because if this is a short sleep and there are many goroutines then the P can wind up running the timer function, goroutineReady, before the goroutine has been parked."
      },
      {
        "name": "resetMemoryDataView",
        "desc": "resetMemoryDataView signals the JS front-end that WebAssembly's memory.grow instruction has been used. This allows the front-end to replace the old DataView object with a new one."
      },
      {
        "name": "resetTimer",
        "desc": "resetTimer resets an inactive timer, adding it to the timer heap.  Reports whether the timer was modified before it was run."
      },
      {
        "name": "resetspinning",
        "desc": ""
      },
      {
        "name": "restoreGsignalStack",
        "desc": "restoreGsignalStack restores the gsignal stack to the value it had before entering the signal handler."
      },
      {
        "name": "restoreSIGSYS",
        "desc": ""
      },
      {
        "name": "resumeG",
        "desc": "resumeG undoes the effects of suspendG, allowing the suspended goroutine to continue from its current safe-point."
      },
      {
        "name": "retake",
        "desc": ""
      },
      {
        "name": "retpolineAX",
        "desc": "Retpolines, used by -spectre=ret flag in cmd/asm, cmd/compile."
      },
      {
        "name": "retpolineBP",
        "desc": ""
      },
      {
        "name": "retpolineBX",
        "desc": ""
      },
      {
        "name": "retpolineCX",
        "desc": ""
      },
      {
        "name": "retpolineDI",
        "desc": ""
      },
      {
        "name": "retpolineDX",
        "desc": ""
      },
      {
        "name": "retpolineR10",
        "desc": ""
      },
      {
        "name": "retpolineR11",
        "desc": ""
      },
      {
        "name": "retpolineR12",
        "desc": ""
      },
      {
        "name": "retpolineR13",
        "desc": ""
      },
      {
        "name": "retpolineR14",
        "desc": ""
      },
      {
        "name": "retpolineR15",
        "desc": ""
      },
      {
        "name": "retpolineR8",
        "desc": ""
      },
      {
        "name": "retpolineR9",
        "desc": ""
      },
      {
        "name": "retpolineSI",
        "desc": ""
      },
      {
        "name": "retryOnEAGAIN",
        "desc": "retryOnEAGAIN retries a function until it does not return EAGAIN. It will use an increasing delay between calls, and retry up to 20 times. The function argument is expected to return an errno value, and retryOnEAGAIN will return any errno value other than EAGAIN. If all retries return EAGAIN, then retryOnEAGAIN will return EAGAIN."
      },
      {
        "name": "rfork",
        "desc": ""
      },
      {
        "name": "round2",
        "desc": "round x up to a power of 2."
      },
      {
        "name": "roundupsize",
        "desc": "Returns size of the memory block that mallocgc will allocate if you ask for the size, minus any inline space for metadata."
      },
      {
        "name": "rt0_go",
        "desc": ""
      },
      {
        "name": "rt_sigaction",
        "desc": "rt_sigaction is implemented in assembly."
      },
      {
        "name": "rtsigprocmask",
        "desc": ""
      },
      {
        "name": "runCheckmark",
        "desc": "runCheckmark runs a full non-parallel, stop-the-world mark using checkmark bits, to check that we didn't forget to mark anything during the concurrent mark process.  The world must be stopped to call runCheckmark."
      },
      {
        "name": "runCleanups",
        "desc": "runCleanups is the entrypoint for all cleanup-running goroutines."
      },
      {
        "name": "runExitHooks",
        "desc": ""
      },
      {
        "name": "runFinalizers",
        "desc": "This is the goroutine that runs all of the finalizers."
      },
      {
        "name": "runGCProg",
        "desc": "runGCProg returns the number of 1-bit entries written to memory."
      },
      {
        "name": "runPerThreadSyscall",
        "desc": "runPerThreadSyscall runs perThreadSyscall for this M if required.  This function throws if the system call returns with anything other than the expected values."
      },
      {
        "name": "runSafePointFn",
        "desc": "runSafePointFn runs the safe point function, if any, for this P. This should be called like  \tif getg().m.p.runSafePointFn != 0 { \t    runSafePointFn() \t}  runSafePointFn must be checked on any transition in to _Pidle or _Psyscall to avoid a race where forEachP sees that the P is running just before the P goes into _Pidle/_Psyscall and neither forEachP nor the P run the safe-point function."
      },
      {
        "name": "runqempty",
        "desc": "runqempty reports whether pp has no Gs on its local run queue. It never returns true spuriously."
      },
      {
        "name": "runqget",
        "desc": "Get g from local runnable queue. If inheritTime is true, gp should inherit the remaining time in the current time slice. Otherwise, it should start a new time slice. Executed only by the owner P."
      },
      {
        "name": "runqgrab",
        "desc": "Grabs a batch of goroutines from pp's runnable queue into batch. Batch is a ring buffer starting at batchHead. Returns number of grabbed goroutines. Can be executed by any P."
      },
      {
        "name": "runqput",
        "desc": "runqput tries to put g on the local runnable queue. If next is false, runqput adds g to the tail of the runnable queue. If next is true, runqput puts g in the pp.runnext slot. If the run queue is full, runnext puts g on the global queue. Executed only by the owner P."
      },
      {
        "name": "runqputbatch",
        "desc": "runqputbatch tries to put all the G's on q on the local runnable queue. If the local runq is full the input queue still contains unqueued Gs. Executed only by the owner P."
      },
      {
        "name": "runqputslow",
        "desc": "Put g and a batch of work from local runnable queue on global queue. Executed only by the owner P."
      },
      {
        "name": "runtime_FrameStartLine",
        "desc": "runtime_FrameStartLine returns the start line of the function in a Frame.  runtime_FrameStartLine should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/grafana/pyroscope-go/godeltaprof  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "runtime_FrameSymbolName",
        "desc": "runtime_FrameSymbolName returns the full symbol name of the function in a Frame. For generic functions this differs from f.Function in that this doesn't replace the shape name to \"...\".  runtime_FrameSymbolName should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/grafana/pyroscope-go/godeltaprof  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "runtime_debug_WriteHeapDump",
        "desc": ""
      },
      {
        "name": "runtime_debug_freeOSMemory",
        "desc": ""
      },
      {
        "name": "runtime_expandFinalInlineFrame",
        "desc": "runtime_expandFinalInlineFrame expands the final pc in stk to include all \"callers\" if pc is inline.  runtime_expandFinalInlineFrame should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/grafana/pyroscope-go/godeltaprof   - github.com/pyroscope-io/godeltaprof  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "runtime_getProfLabel",
        "desc": "runtime_getProfLabel should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/cloudwego/localsession  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "runtime_ignoreHangup",
        "desc": ""
      },
      {
        "name": "runtime_pprof_readProfile",
        "desc": "readProfile, provided to runtime/pprof, returns the next chunk of binary CPU profiling stack trace data, blocking until data is available. If profiling is turned off and all the profile data accumulated while it was on has been returned, readProfile returns eof=true. The caller must save the returned data and tags before calling readProfile again. The returned data contains a whole number of records, and tags contains exactly one entry per record.  runtime_pprof_readProfile should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/pyroscope-io/pyroscope  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "runtime_setProfLabel",
        "desc": "runtime_setProfLabel should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/cloudwego/localsession  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "runtime_unignoreHangup",
        "desc": ""
      },
      {
        "name": "sameSizeGrowForIssue69110Test",
        "desc": ""
      },
      {
        "name": "save",
        "desc": "save updates getg().sched to refer to pc and sp so that a following gogo will restore pc and sp.  save must not have write barriers because invoking a write barrier can clobber getg().sched."
      },
      {
        "name": "saveAncestors",
        "desc": "saveAncestors copies previous ancestors of the given caller g and includes info for the current caller into a new set of tracebacks for a g being created."
      },
      {
        "name": "saveBlockEventStack",
        "desc": ""
      },
      {
        "name": "save_g",
        "desc": ""
      },
      {
        "name": "saveblockevent",
        "desc": "saveblockevent records a profile event of the type specified by which. cycles is the quantity associated with this event and rate is the sampling rate, used to adjust the cycles value in the manner determined by the profile type. skip is the number of frames to omit from the traceback associated with the event. The traceback will be recorded from the stack of the goroutine associated with the current m. skip should be positive if this event is recorded from the current stack (e.g. when this is not called from a system stack)"
      },
      {
        "name": "saveg",
        "desc": ""
      },
      {
        "name": "sbrk",
        "desc": ""
      },
      {
        "name": "sbrk0",
        "desc": "sbrk0 returns the current process brk, or 0 if not implemented."
      },
      {
        "name": "scanConservative",
        "desc": "scanConservative scans block [b, b+n) conservatively, treating any pointer-like value in the block as a pointer.  If ptrmask != nil, only words that are marked in ptrmask are considered as potential pointers.  If state != nil, it's assumed that [b, b+n) is a block in the stack and may contain pointers to stack objects."
      },
      {
        "name": "scanObjectSmall",
        "desc": ""
      },
      {
        "name": "scanObjectsSmall",
        "desc": ""
      },
      {
        "name": "scanSpan",
        "desc": "scanSpan scans objects indicated marks\u0026^scans and then scans those objects, queuing the resulting pointers into gcw."
      },
      {
        "name": "scanblock",
        "desc": "scanblock scans b as scanobject would, but using an explicit pointer bitmap instead of the heap bitmap.  This is used to scan non-heap roots, so it does not update gcw.bytesMarked or gcw.heapScanWork.  If stk != nil, possible stack pointers are also reported to stk.putPtr."
      },
      {
        "name": "scanframeworker",
        "desc": "Scan a stack frame: local variables and function arguments/results."
      },
      {
        "name": "scanobject",
        "desc": "scanobject scans the object starting at b, adding pointers to gcw. b must point to the beginning of a heap object or an oblet. scanobject consults the GC bitmap for the pointer mask and the spans for the size of the object."
      },
      {
        "name": "scanstack",
        "desc": "scanstack scans gp's stack, greying all pointers found on the stack.  Returns the amount of scan work performed, but doesn't update gcController.stackScanWork or flush any credit. Any background credit produced by this function should be flushed by its caller. scanstack itself can't safely flush because it may result in trying to wake up a goroutine that was just scanned, resulting in a self-deadlock.  scanstack will also shrink the stack if it is safe to do so. If it is not, it schedules a stack shrink for the next synchronous safe point.  scanstack is marked go:systemstack because it must not be preempted while using a workbuf."
      },
      {
        "name": "schedEnableUser",
        "desc": "schedEnableUser enables or disables the scheduling of user goroutines.  This does not stop already running user goroutines, so the caller should first stop the world when disabling user goroutines."
      },
      {
        "name": "schedEnabled",
        "desc": "schedEnabled reports whether gp should be scheduled. It returns false is scheduling of gp is disabled.  sched.lock must be held."
      },
      {
        "name": "sched_getaffinity",
        "desc": ""
      },
      {
        "name": "sched_yield_trampoline",
        "desc": ""
      },
      {
        "name": "schedinit",
        "desc": "The bootstrap sequence is:  \tcall osinit \tcall schedinit \tmake \u0026 queue new G \tcall runtime·mstart  The new G calls runtime·main."
      },
      {
        "name": "schedtrace",
        "desc": ""
      },
      {
        "name": "schedule",
        "desc": "One round of scheduler: find a runnable goroutine and execute it. Never returns."
      },
      {
        "name": "scheduleTimeoutEvent",
        "desc": "scheduleTimeoutEvent tells the WebAssembly environment to trigger an event after ms milliseconds. It returns a timer id that can be used with clearTimeoutEvent."
      },
      {
        "name": "secure",
        "desc": ""
      },
      {
        "name": "secureEnv",
        "desc": ""
      },
      {
        "name": "seek",
        "desc": ""
      },
      {
        "name": "sehhandler",
        "desc": "sehhandler is reached as part of the SEH chain.  It is nosplit for the same reason as exceptionhandler."
      },
      {
        "name": "sehtramp",
        "desc": ""
      },
      {
        "name": "selectgo",
        "desc": "selectgo implements the select statement.  cas0 points to an array of type [ncases]scase, and order0 points to an array of type [2*ncases]uint16 where ncases must be \u003c= 65536. Both reside on the goroutine's stack (regardless of any escaping in selectgo).  For race detector builds, pc0 points to an array of type [ncases]uintptr (also on the stack); for other builds, it's set to nil.  selectgo returns the index of the chosen scase, which matches the ordinal position of its respective select{recv,send,default} call. Also, if the chosen scase was a receive operation, it reports whether a value was received."
      },
      {
        "name": "selectnbrecv",
        "desc": "compiler implements  \tselect { \tcase v, ok = \u003c-c: \t\t... foo \tdefault: \t\t... bar \t}  as  \tif selected, ok = selectnbrecv(\u0026v, c); selected { \t\t... foo \t} else { \t\t... bar \t}"
      },
      {
        "name": "selectnbsend",
        "desc": "compiler implements  \tselect { \tcase c \u003c- v: \t\t... foo \tdefault: \t\t... bar \t}  as  \tif selectnbsend(c, v) { \t\t... foo \t} else { \t\t... bar \t}"
      },
      {
        "name": "selectsetpc",
        "desc": ""
      },
      {
        "name": "sellock",
        "desc": ""
      },
      {
        "name": "selparkcommit",
        "desc": ""
      },
      {
        "name": "selunlock",
        "desc": ""
      },
      {
        "name": "sem_init",
        "desc": ""
      },
      {
        "name": "sem_post",
        "desc": ""
      },
      {
        "name": "sem_reltimedwait_np",
        "desc": ""
      },
      {
        "name": "sem_timedwait",
        "desc": ""
      },
      {
        "name": "sem_wait",
        "desc": ""
      },
      {
        "name": "semacquire",
        "desc": "Called from runtime."
      },
      {
        "name": "semacquire1",
        "desc": ""
      },
      {
        "name": "semacreate",
        "desc": ""
      },
      {
        "name": "semasleep",
        "desc": ""
      },
      {
        "name": "semawakeup",
        "desc": ""
      },
      {
        "name": "semrelease",
        "desc": ""
      },
      {
        "name": "semrelease1",
        "desc": ""
      },
      {
        "name": "send",
        "desc": "send processes a send operation on an empty channel c. The value ep sent by the sender is copied to the receiver sg. The receiver is then woken up to go on its merry way. Channel c must be empty and locked.  send unlocks c with unlockf. sg must already be dequeued from c. ep must be non-nil and point to the heap or the caller's stack."
      },
      {
        "name": "sendDirect",
        "desc": ""
      },
      {
        "name": "sendNote",
        "desc": "Called from sighandler to send a signal back out of the signal handling thread. Reports whether the signal was sent. If not, the caller typically crashes the program."
      },
      {
        "name": "setCheckmark",
        "desc": "setCheckmark throws if marking object is a checkmarks violation, and otherwise sets obj's checkmark. It returns true if obj was already checkmarked."
      },
      {
        "name": "setCleanupContext",
        "desc": "setCleanupContext adds a specialCheckFinalizer to ptr. ptr must already have a finalizer or cleanup special attached. Pass 0 for the cleanupID to indicate a finalizer."
      },
      {
        "name": "setCrashFD",
        "desc": ""
      },
      {
        "name": "setEventHandler",
        "desc": ""
      },
      {
        "name": "setFinalizerContext",
        "desc": "setFinalizerContext adds a specialCheckFinalizer to ptr. ptr must already have a finalizer special attached."
      },
      {
        "name": "setGCPercent",
        "desc": ""
      },
      {
        "name": "setGCPhase",
        "desc": ""
      },
      {
        "name": "setGNoWB",
        "desc": "setGNoWB performs *gp = new without a write barrier. For times when it's impractical to use a guintptr."
      },
      {
        "name": "setGsignalStack",
        "desc": "setGsignalStack sets the gsignal stack of the current m to an alternate signal stack returned from the sigaltstack system call. It saves the old values in *old for use by restoreGsignalStack. This is used when handling a signal if non-Go code has set the alternate signal stack."
      },
      {
        "name": "setMNoWB",
        "desc": "setMNoWB performs *mp = new without a write barrier. For times when it's impractical to use an muintptr."
      },
      {
        "name": "setMaxStack",
        "desc": ""
      },
      {
        "name": "setMaxThreads",
        "desc": ""
      },
      {
        "name": "setMemoryLimit",
        "desc": ""
      },
      {
        "name": "setNonblock",
        "desc": ""
      },
      {
        "name": "setPanicOnFault",
        "desc": ""
      },
      {
        "name": "setPinned",
        "desc": "setPinned marks or unmarks a Go pointer as pinned, when the ptr is a Go pointer. It will be ignored while try to pin a non-Go pointer, and it will be panic while try to unpin a non-Go pointer, which should not happen in normal usage."
      },
      {
        "name": "setProcessCPUProfiler",
        "desc": ""
      },
      {
        "name": "setProcessCPUProfilerTimer",
        "desc": "setProcessCPUProfilerTimer is called when the profiling timer changes. It is called with prof.signalLock held. hz is the new timer, and is 0 if profiling is being disabled. Enable or disable the signal as required for -buildmode=c-archive."
      },
      {
        "name": "setSignalstackSP",
        "desc": "setSignalstackSP sets the ss_sp field of a stackt."
      },
      {
        "name": "setThreadCPUProfiler",
        "desc": ""
      },
      {
        "name": "setThreadCPUProfilerHz",
        "desc": "setThreadCPUProfilerHz makes any thread-specific changes required to implement profiling at a rate of hz. No changes required on Unix systems when using setitimer."
      },
      {
        "name": "setTinyBlockContext",
        "desc": "setTinyBlockContext marks an allocation as a tiny block to diagnostics like checkfinalizer.  A tiny block is only marked if it actually contains more than one distinct value, since we're using this for debugging."
      },
      {
        "name": "setTraceback",
        "desc": ""
      },
      {
        "name": "setVMAName",
        "desc": "setVMAName isn’t implemented"
      },
      {
        "name": "setVMANameSupported",
        "desc": ""
      },
      {
        "name": "setVal64",
        "desc": ""
      },
      {
        "name": "setcpuprofilerate",
        "desc": "setcpuprofilerate sets the CPU profiling rate to hz times per second. If hz \u003c= 0, setcpuprofilerate turns off CPU profiling."
      },
      {
        "name": "setenv_c",
        "desc": "Update the C environment if cgo is loaded."
      },
      {
        "name": "setfpmasks",
        "desc": ""
      },
      {
        "name": "setg",
        "desc": ""
      },
      {
        "name": "setitimer",
        "desc": ""
      },
      {
        "name": "setitimer_trampoline",
        "desc": ""
      },
      {
        "name": "setldt",
        "desc": "Called from assembly only; declared for go vet."
      },
      {
        "name": "setprofilebucket",
        "desc": "Set the heap profile bucket associated with addr to b."
      },
      {
        "name": "setsig",
        "desc": ""
      },
      {
        "name": "setsigsegv",
        "desc": "setsigsegv is used on darwin/arm64 to fake a segmentation fault.  This is exported via linkname to assembly in runtime/cgo."
      },
      {
        "name": "setsigstack",
        "desc": ""
      },
      {
        "name": "settls",
        "desc": "Called from assembly only; declared for go vet."
      },
      {
        "name": "shade",
        "desc": "Shade the object if it isn't already. The object is not nil and known to be in the heap. Preemption must be disabled."
      },
      {
        "name": "shouldPushSigpanic",
        "desc": "shouldPushSigpanic reports whether pc should be used as sigpanic's return PC (pushing a frame for the call). Otherwise, it should be left alone so that LR is used as sigpanic's return PC, effectively replacing the top-most frame with sigpanic. This is used by preparePanic."
      },
      {
        "name": "showframe",
        "desc": "showframe reports whether the frame with the given characteristics should be printed during a traceback."
      },
      {
        "name": "showfuncinfo",
        "desc": "showfuncinfo reports whether a function with the given characteristics should be printed during a traceback."
      },
      {
        "name": "shrinkstack",
        "desc": "Maybe shrink the stack being used by gp.  gp must be stopped and we must own its stack. It may be in _Grunning, but only if this is our own user G."
      },
      {
        "name": "sigInitIgnored",
        "desc": "sigInitIgnored marks the signal as already ignored. This is called at program start by initsig. In a shared library initsig is called by libpreinit, so the runtime may not be initialized yet."
      },
      {
        "name": "sigInstallGoHandler",
        "desc": ""
      },
      {
        "name": "sigNotOnStack",
        "desc": "This is called if we receive a signal when there is a signal stack but we are not on it. This can only happen if non-Go code called sigaction without setting the SS_ONSTACK flag."
      },
      {
        "name": "sigNoteSetup",
        "desc": "sigNoteSetup initializes a single, there-can-only-be-one, async-signal-safe note.  The current implementation of notes on Darwin is not async-signal-safe, because the functions pthread_mutex_lock, pthread_cond_signal, and pthread_mutex_unlock, called by semawakeup, are not async-signal-safe. There is only one case where we need to wake up a note from a signal handler: the sigsend function. The signal handler code does not require all the features of notes: it does not need to do a timed wait. This is a separate implementation of notes, based on a pipe, that does not support timed waits but is async-signal-safe."
      },
      {
        "name": "sigNoteSleep",
        "desc": "sigNoteSleep waits for a note created by sigNoteSetup to be woken."
      },
      {
        "name": "sigNoteWakeup",
        "desc": "sigNoteWakeup wakes up a thread sleeping on a note created by sigNoteSetup."
      },
      {
        "name": "sigaction",
        "desc": ""
      },
      {
        "name": "sigaction1",
        "desc": ""
      },
      {
        "name": "sigaction_trampoline",
        "desc": ""
      },
      {
        "name": "sigaddset",
        "desc": ""
      },
      {
        "name": "sigaltstack",
        "desc": ""
      },
      {
        "name": "sigaltstack_trampoline",
        "desc": ""
      },
      {
        "name": "sigblock",
        "desc": "sigblock blocks signals in the current thread's signal mask. This is used to block signals while setting up and tearing down g when a non-Go thread calls a Go function. When a thread is exiting we use the sigsetAllExiting value, otherwise the OS specific definition of sigset_all is used. This is nosplit and nowritebarrierrec because it is called by needm which may be called on a non-Go thread with no g available."
      },
      {
        "name": "sigctxtAtTrapInstruction",
        "desc": ""
      },
      {
        "name": "sigctxtSetContextRegister",
        "desc": ""
      },
      {
        "name": "sigctxtStatus",
        "desc": ""
      },
      {
        "name": "sigdelset",
        "desc": ""
      },
      {
        "name": "sigdisable",
        "desc": "sigdisable disables the Go signal handler for the signal sig. It is only called while holding the os/signal.handlers lock, via os/signal.disableSignal and signal_disable."
      },
      {
        "name": "sigenable",
        "desc": "sigenable enables the Go signal handler to catch the signal sig. It is only called while holding the os/signal.handlers lock, via os/signal.enableSignal and signal_enable."
      },
      {
        "name": "sigfillset",
        "desc": ""
      },
      {
        "name": "sigfwd",
        "desc": ""
      },
      {
        "name": "sigfwdgo",
        "desc": "Determines if the signal should be handled by Go and if not, forwards the signal to the handler that was installed before Go's. Returns whether the signal was forwarded. This is called by the signal handler, and the world may be stopped."
      },
      {
        "name": "sighandler",
        "desc": "May run during STW, so write barriers are not allowed."
      },
      {
        "name": "sigignore",
        "desc": "sigignore ignores the signal sig. It is only called while holding the os/signal.handlers lock, via os/signal.ignoreSignal and signal_ignore."
      },
      {
        "name": "sigismember",
        "desc": ""
      },
      {
        "name": "signalDuringFork",
        "desc": "signalDuringFork is called if we receive a signal while doing a fork. We do not want signals at that time, as a signal sent to the process group may be delivered to the child process, causing confusion. This should never be called, because we block signals across the fork; this function is just a safety check. See issue 18600 for background."
      },
      {
        "name": "signalM",
        "desc": "signalM sends a signal to mp."
      },
      {
        "name": "signalWaitUntilIdle",
        "desc": "signalWaitUntilIdle waits until the signal delivery mechanism is idle. This is used to ensure that we do not drop a signal notification due to a race between disabling a signal and receiving a signal. This assumes that signal delivery has already been disabled for the signal(s) in question, and here we are just waiting to make sure that all the signals have been delivered to the user channels by the os/signal package."
      },
      {
        "name": "signal_disable",
        "desc": "Must only be called from a single goroutine at a time."
      },
      {
        "name": "signal_enable",
        "desc": "Must only be called from a single goroutine at a time."
      },
      {
        "name": "signal_ignore",
        "desc": "Must only be called from a single goroutine at a time."
      },
      {
        "name": "signal_ignored",
        "desc": "Checked by signal handlers."
      },
      {
        "name": "signal_recv",
        "desc": "Called to receive the next queued signal. Must only be called from a single goroutine at a time."
      },
      {
        "name": "signalstack",
        "desc": "signalstack sets the current thread's alternate signal stack to s."
      },
      {
        "name": "signame",
        "desc": ""
      },
      {
        "name": "sigpanic",
        "desc": "sigpanic turns a synchronous signal into a run-time panic. If the signal handler sees a synchronous panic, it arranges the stack to look like the function where the signal occurred called sigpanic, sets the signal's PC value to sigpanic, and returns from the signal handler. The effect is that the program will act as though the function that got the signal simply called sigpanic instead.  This must NOT be nosplit because the linker doesn't know where sigpanic calls can be injected.  The signal handler must not inject a call to sigpanic if getg().throwsplit, since sigpanic may need to grow the stack.  This is exported via linkname to assembly in runtime/cgo."
      },
      {
        "name": "sigpanic0",
        "desc": "Injected by the signal handler for panicking signals. Initializes any registers that have fixed meaning at calls but are scratch in bodies and calls sigpanic. On many platforms it just jumps to sigpanic."
      },
      {
        "name": "sigpanictramp",
        "desc": ""
      },
      {
        "name": "sigpipe",
        "desc": ""
      },
      {
        "name": "sigprocmask",
        "desc": ""
      },
      {
        "name": "sigprocmask1",
        "desc": "On multi-thread program, sigprocmask must not be called. It's replaced by sigthreadmask."
      },
      {
        "name": "sigprocmask_trampoline",
        "desc": ""
      },
      {
        "name": "sigprof",
        "desc": "Called if we receive a SIGPROF signal. Called by the signal handler, may run during STW."
      },
      {
        "name": "sigprofNonGo",
        "desc": "sigprofNonGo is called if we receive a SIGPROF signal on a non-Go thread, and the signal handler collected a stack trace in sigprofCallers. When this is called, sigprofCallersUse will be non-zero. g is nil, and what we can do is very limited.  It is called from the signal handling functions written in assembly code that are active for cgo programs, cgoSigtramp and sigprofNonGoWrapper, which have not verified that the SIGPROF delivery corresponds to the best available profiling source for this thread."
      },
      {
        "name": "sigprofNonGoPC",
        "desc": "sigprofNonGoPC is called when a profiling signal arrived on a non-Go thread and we have a single PC value, not a stack trace. g is nil, and what we can do is very limited."
      },
      {
        "name": "sigresume",
        "desc": ""
      },
      {
        "name": "sigreturn__sigaction",
        "desc": ""
      },
      {
        "name": "sigsave",
        "desc": "sigsave saves the current thread's signal mask into *p. This is used to preserve the non-Go signal mask when a non-Go thread calls a Go function. This is nosplit and nowritebarrierrec because it is called by needm which may be called on a non-Go thread with no g available."
      },
      {
        "name": "sigsend",
        "desc": "sigsend delivers a signal from sighandler to the internal signal delivery queue. It reports whether the signal was sent. If not, the caller typically crashes the program. It runs from the signal handler, so it's limited in what it can do."
      },
      {
        "name": "sigtramp",
        "desc": "sigtramp is the callback from libc when a signal is received. It is called with the C calling convention."
      },
      {
        "name": "sigtrampgo",
        "desc": "sigtrampgo is called from the exception handler function, sigtramp, written in assembly code. Return EXCEPTION_CONTINUE_EXECUTION if the exception is handled, else return EXCEPTION_CONTINUE_SEARCH.  It is nosplit for the same reason as exceptionhandler."
      },
      {
        "name": "sleep",
        "desc": ""
      },
      {
        "name": "slicebytetostring",
        "desc": "slicebytetostring converts a byte slice to a string. It is inserted by the compiler into generated code. ptr is a pointer to the first element of the slice; n is the length of the slice. Buf is a fixed-size buffer for the result, it is not nil if the result does not escape."
      },
      {
        "name": "slicebytetostringtmp",
        "desc": "slicebytetostringtmp returns a \"string\" referring to the actual []byte bytes.  Callers need to ensure that the returned string will not be used after the calling goroutine modifies the original slice or synchronizes with another goroutine.  The function is only called when instrumenting and otherwise intrinsified by the compiler.  Some internal compiler optimizations use this function.   - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)]     where k is []byte, T1 to Tn is a nesting of struct and array literals.   - Used for \"\u003c\"+string(b)+\"\u003e\" concatenation where b is []byte.   - Used for string(b)==\"foo\" comparison where b is []byte."
      },
      {
        "name": "slicecopy",
        "desc": "slicecopy is used to copy from a string or slice of pointerless elements into a slice."
      },
      {
        "name": "slicerunetostring",
        "desc": ""
      },
      {
        "name": "slowdodiv",
        "desc": ""
      },
      {
        "name": "socket",
        "desc": ""
      },
      {
        "name": "spanHasNoSpecials",
        "desc": "spanHasNoSpecials marks a span as having no specials in the arena bitmap."
      },
      {
        "name": "spanHasSpecials",
        "desc": "spanHasSpecials marks a span as having specials in the arena bitmap."
      },
      {
        "name": "spanHeapBitsRange",
        "desc": ""
      },
      {
        "name": "spanSetScans",
        "desc": "spanSetScans sets any unset mark bits that have their mark bits set in the inline mark bits.  toScan is populated with bits indicating whether a particular mark bit was set.  Returns the number of objects marked, which could be zero."
      },
      {
        "name": "spillArgs",
        "desc": "Spills/loads arguments in registers to/from an internal/abi.RegArgs respectively. Does not follow the Go ABI."
      },
      {
        "name": "stackOverflow",
        "desc": ""
      },
      {
        "name": "stackcache_clear",
        "desc": ""
      },
      {
        "name": "stackcacherefill",
        "desc": "stackcacherefill/stackcacherelease implement a global pool of stack segments. The pool is required to prevent unlimited growth of per-thread caches."
      },
      {
        "name": "stackcacherelease",
        "desc": ""
      },
      {
        "name": "stackcheck",
        "desc": "stackcheck checks that SP is in range [g-\u003estack.lo, g-\u003estack.hi)."
      },
      {
        "name": "stackfree",
        "desc": "stackfree frees an n byte stack allocation at stk.  stackfree must run on the system stack because it uses per-P resources and must not split the stack."
      },
      {
        "name": "stackinit",
        "desc": ""
      },
      {
        "name": "stacklog2",
        "desc": "stacklog2 returns ⌊log_2(n)⌋."
      },
      {
        "name": "stackpoolfree",
        "desc": "Adds stack x to the free pool. Must be called with stackpool[order].item.mu held."
      },
      {
        "name": "startCheckmarks",
        "desc": "startCheckmarks prepares for the checkmarks phase.  The world must be stopped."
      },
      {
        "name": "startPCForTrace",
        "desc": "startPCForTrace returns the start PC of a goroutine for tracing purposes. If pc is a wrapper, it returns the PC of the wrapped function. Otherwise it returns pc."
      },
      {
        "name": "startTemplateThread",
        "desc": "startTemplateThread starts the template thread if it is not already running.  The calling thread must itself be in a known-good state."
      },
      {
        "name": "startTheWorld",
        "desc": "startTheWorld undoes the effects of stopTheWorld.  w must be the worldStop returned by stopTheWorld."
      },
      {
        "name": "startTheWorldGC",
        "desc": "startTheWorldGC undoes the effects of stopTheWorldGC.  w must be the worldStop returned by stopTheWorld."
      },
      {
        "name": "startTheWorldWithSema",
        "desc": "reason is the same STW reason passed to stopTheWorld. start is the start time returned by stopTheWorld.  now is the current time; prefer to pass 0 to capture a fresh timestamp.  stattTheWorldWithSema returns now."
      },
      {
        "name": "startlockedm",
        "desc": "Schedules the locked m to run the locked gp. May run during STW, so write barriers are not allowed."
      },
      {
        "name": "startm",
        "desc": "Schedules some M to run the p (creates an M if necessary). If p==nil, tries to get an idle P, if no idle P's does nothing. May run with m.p==nil, so write barriers are not allowed. If spinning is set, the caller has incremented nmspinning and must provide a P. startm will set m.spinning in the newly started M.  Callers passing a non-nil P must call from a non-preemptible context. See comment on acquirem below.  Argument lockheld indicates whether the caller already acquired the scheduler lock. Callers holding the lock when making the call must pass true. The lock might be temporarily dropped, but will be reacquired before returning.  Must not have write barriers because this may be called without a P."
      },
      {
        "name": "startpanic_m",
        "desc": "startpanic_m prepares for an unrecoverable panic.  It returns true if panic messages should be printed, or false if the runtime is in bad shape and should just print stacks.  It must not have write barriers even though the write barrier explicitly ignores writes once dying \u003e 0. Write barriers still assume that g.m.p != nil, and this function may not have P in some contexts (e.g. a panic in a signal handler for a signal sent to an M with no P)."
      },
      {
        "name": "stdcall",
        "desc": "Calling stdcall on os stack. May run during STW, so write barriers are not allowed."
      },
      {
        "name": "stdcall0",
        "desc": ""
      },
      {
        "name": "stdcall1",
        "desc": ""
      },
      {
        "name": "stdcall2",
        "desc": ""
      },
      {
        "name": "stdcall3",
        "desc": ""
      },
      {
        "name": "stdcall4",
        "desc": ""
      },
      {
        "name": "stdcall5",
        "desc": ""
      },
      {
        "name": "stdcall6",
        "desc": ""
      },
      {
        "name": "stdcall7",
        "desc": ""
      },
      {
        "name": "stdcall8",
        "desc": ""
      },
      {
        "name": "stdcall_no_g",
        "desc": "stdcall_no_g calls asmstdcall on os stack without using g."
      },
      {
        "name": "stealWork",
        "desc": "stealWork attempts to steal a runnable goroutine or timer from any P.  If newWork is true, new work may have been readied.  If now is not 0 it is the current time. stealWork returns the passed time or the current time if now was passed as 0."
      },
      {
        "name": "step",
        "desc": "step advances to the next pc, value pair in the encoded table."
      },
      {
        "name": "stkobjinit",
        "desc": ""
      },
      {
        "name": "stopTimer",
        "desc": "stopTimer stops a timer. It reports whether t was stopped before being run."
      },
      {
        "name": "stoplockedm",
        "desc": "Stops execution of the current m that is locked to a g until the g is runnable again. Returns with acquired P."
      },
      {
        "name": "stopm",
        "desc": "Stops execution of the current m until new work is available. Returns with acquired P."
      },
      {
        "name": "storeRegArgs",
        "desc": "storeRegArgs sets up argument registers in the signal context state from an abi.RegArgs.  Both src and dst must be non-nil."
      },
      {
        "name": "strequal",
        "desc": ""
      },
      {
        "name": "strhash",
        "desc": "strhash should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/aristanetworks/goarista   - github.com/bytedance/sonic   - github.com/bytedance/go-tagexpr/v2   - github.com/cloudwego/dynamicgo   - github.com/v2fly/v2ray-core/v5  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "strhashFallback",
        "desc": ""
      },
      {
        "name": "stringDataOnStack",
        "desc": "stringDataOnStack reports whether the string's data is stored on the current goroutine's stack."
      },
      {
        "name": "stringHash",
        "desc": "Testing adapters for hash quality tests (see hash_test.go)  stringHash should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/k14s/starlark-go  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "stringtoslicebyte",
        "desc": ""
      },
      {
        "name": "stringtoslicerune",
        "desc": ""
      },
      {
        "name": "strmax",
        "desc": ""
      },
      {
        "name": "strmin",
        "desc": ""
      },
      {
        "name": "subtract1",
        "desc": "subtract1 returns the byte pointer p-1.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "subtractb",
        "desc": "subtractb returns the byte pointer p-n."
      },
      {
        "name": "swapsub",
        "desc": ""
      },
      {
        "name": "sweepone",
        "desc": "sweepone sweeps some unswept heap span and returns the number of pages returned to the heap, or ^uintptr(0) if there was nothing to sweep."
      },
      {
        "name": "switchToCrashStack",
        "desc": "Switch to crashstack and call fn, with special handling of concurrent and recursive cases.  Nosplit as it is called in a bad stack condition (we know morestack would fail)."
      },
      {
        "name": "switchToCrashStack0",
        "desc": ""
      },
      {
        "name": "sync_atomic_CompareAndSwapPointer",
        "desc": ""
      },
      {
        "name": "sync_atomic_CompareAndSwapUintptr",
        "desc": ""
      },
      {
        "name": "sync_atomic_StorePointer",
        "desc": ""
      },
      {
        "name": "sync_atomic_StoreUintptr",
        "desc": ""
      },
      {
        "name": "sync_atomic_SwapPointer",
        "desc": ""
      },
      {
        "name": "sync_atomic_SwapUintptr",
        "desc": ""
      },
      {
        "name": "sync_atomic_runtime_procPin",
        "desc": ""
      },
      {
        "name": "sync_atomic_runtime_procUnpin",
        "desc": ""
      },
      {
        "name": "sync_fatal",
        "desc": ""
      },
      {
        "name": "sync_runtime_Semacquire",
        "desc": "sync_runtime_Semacquire should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "sync_runtime_SemacquireRWMutex",
        "desc": ""
      },
      {
        "name": "sync_runtime_SemacquireRWMutexR",
        "desc": ""
      },
      {
        "name": "sync_runtime_SemacquireWaitGroup",
        "desc": ""
      },
      {
        "name": "sync_runtime_Semrelease",
        "desc": "sync_runtime_Semrelease should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "sync_runtime_canSpin",
        "desc": "Active spinning for sync.Mutex.  sync_runtime_canSpin should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/livekit/protocol   - github.com/sagernet/gvisor   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "sync_runtime_doSpin",
        "desc": "sync_runtime_doSpin should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/livekit/protocol   - github.com/sagernet/gvisor   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "sync_runtime_procPin",
        "desc": ""
      },
      {
        "name": "sync_runtime_procUnpin",
        "desc": ""
      },
      {
        "name": "sync_runtime_registerPoolCleanup",
        "desc": "sync_runtime_registerPoolCleanup should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/songzhibin97/gkit  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "sync_test_runtime_blockUntilEmptyCleanupQueue",
        "desc": ""
      },
      {
        "name": "sync_throw",
        "desc": ""
      },
      {
        "name": "syncadjustsudogs",
        "desc": "syncadjustsudogs adjusts gp's sudogs and copies the part of gp's stack they refer to while synchronizing with concurrent channel operations. It returns the number of bytes of stack copied."
      },
      {
        "name": "synctestRun",
        "desc": ""
      },
      {
        "name": "synctestWait",
        "desc": ""
      },
      {
        "name": "synctest_acquire",
        "desc": ""
      },
      {
        "name": "synctest_associate",
        "desc": "synctest_associate associates p with the current bubble. It returns false if p is already associated with a different bubble."
      },
      {
        "name": "synctest_disassociate",
        "desc": "synctest_disassociate disassociates p from its bubble."
      },
      {
        "name": "synctest_inBubble",
        "desc": ""
      },
      {
        "name": "synctest_isAssociated",
        "desc": "synctest_isAssociated reports whether p is associated with the current bubble."
      },
      {
        "name": "synctest_isInBubble",
        "desc": ""
      },
      {
        "name": "synctest_release",
        "desc": ""
      },
      {
        "name": "synctestidle_c",
        "desc": ""
      },
      {
        "name": "synctestwait_c",
        "desc": ""
      },
      {
        "name": "sysAlloc",
        "desc": "sysAlloc transitions an OS-chosen region of memory from None to Ready. More specifically, it obtains a large chunk of zeroed memory from the operating system, typically on the order of a hundred kilobytes or a megabyte. This memory is always immediately available for use.  sysStat must be non-nil.  Don't split the stack as this function may be invoked without a valid G, which prevents us from allocating more stack."
      },
      {
        "name": "sysAllocOS",
        "desc": "Don't split the stack as this function may be invoked without a valid G, which prevents us from allocating more stack."
      },
      {
        "name": "sysFault",
        "desc": "sysFault transitions a memory region from Ready to Reserved. It marks a region such that it will always fault if accessed. Used only for debugging the runtime.  TODO(mknyszek): Currently it's true that all uses of sysFault transition memory from Ready to Reserved, but this may not be true in the future since on every platform the operation is much more general than that. If a transition from Prepared is ever introduced, create a new function that elides the Ready state accounting."
      },
      {
        "name": "sysFaultOS",
        "desc": ""
      },
      {
        "name": "sysFree",
        "desc": "sysFree transitions a memory region from any state to None. Therefore, it returns memory unconditionally. It is used if an out-of-memory error has been detected midway through an allocation or to carve out an aligned section of the address space. It is okay if sysFree is a no-op only if sysReserve always returns a memory region aligned to the heap allocator's alignment restrictions.  sysStat must be non-nil.  Don't split the stack as this function may be invoked without a valid G, which prevents us from allocating more stack."
      },
      {
        "name": "sysFreeOS",
        "desc": "Don't split the stack as this function may be invoked without a valid G, which prevents us from allocating more stack."
      },
      {
        "name": "sysHugePage",
        "desc": "sysHugePage does not transition memory regions, but instead provides a hint to the OS that it would be more efficient to back this memory region with pages of a larger size transparently."
      },
      {
        "name": "sysHugePageCollapse",
        "desc": "sysHugePageCollapse attempts to immediately back the provided memory region with huge pages. It is best-effort and may fail silently."
      },
      {
        "name": "sysHugePageCollapseOS",
        "desc": ""
      },
      {
        "name": "sysHugePageOS",
        "desc": ""
      },
      {
        "name": "sysMap",
        "desc": "sysMap transitions a memory region from Reserved to Prepared. It ensures the memory region can be efficiently transitioned to Ready.  sysStat must be non-nil."
      },
      {
        "name": "sysMapOS",
        "desc": ""
      },
      {
        "name": "sysMmap",
        "desc": "sysMmap calls the mmap system call. It is implemented in assembly."
      },
      {
        "name": "sysMunmap",
        "desc": "sysMunmap calls the munmap system call. It is implemented in assembly."
      },
      {
        "name": "sysNoHugePage",
        "desc": "sysNoHugePage does not transition memory regions, but instead provides a hint to the OS that it would be less efficient to back this memory region with pages of a larger size transparently."
      },
      {
        "name": "sysNoHugePageOS",
        "desc": ""
      },
      {
        "name": "sysReserve",
        "desc": "sysReserve transitions a memory region from None to Reserved. It reserves address space in such a way that it would cause a fatal fault upon access (either via permissions or not committing the memory). Such a reservation is thus never backed by physical memory.  If the pointer passed to it is non-nil, the caller wants the reservation there, but sysReserve can still choose another location if that one is unavailable.  NOTE: sysReserve returns OS-aligned memory, but the heap allocator may use larger alignment, so the caller must be careful to realign the memory obtained by sysReserve."
      },
      {
        "name": "sysReserveAligned",
        "desc": "sysReserveAligned is like sysReserve, but the returned pointer is aligned to align bytes. It may reserve either n or n+align bytes, so it returns the size that was reserved."
      },
      {
        "name": "sysReserveAlignedSbrk",
        "desc": ""
      },
      {
        "name": "sysReserveOS",
        "desc": ""
      },
      {
        "name": "sysSigaction",
        "desc": "sysSigaction calls the rt_sigaction system call."
      },
      {
        "name": "sysUnused",
        "desc": "sysUnused transitions a memory region from Ready to Prepared. It notifies the operating system that the physical pages backing this memory region are no longer needed and can be reused for other purposes. The contents of a sysUnused memory region are considered forfeit and the region must not be accessed again until sysUsed is called."
      },
      {
        "name": "sysUnusedOS",
        "desc": ""
      },
      {
        "name": "sysUsed",
        "desc": "sysUsed transitions a memory region from Prepared to Ready. It notifies the operating system that the memory region is needed and ensures that the region may be safely accessed. This is typically a no-op on systems that don't have an explicit commit step and hard over-commit limits, but is critical on Windows, for example.  This operation is idempotent for memory already in the Prepared state, so it is safe to refer, with v and n, to a range of memory that includes both Prepared and Ready memory. However, the caller must provide the exact amount of Prepared memory for accounting purposes."
      },
      {
        "name": "sysUsedOS",
        "desc": ""
      },
      {
        "name": "sys_umtx_op",
        "desc": ""
      },
      {
        "name": "sys_umtx_sleep",
        "desc": ""
      },
      {
        "name": "sys_umtx_wakeup",
        "desc": ""
      },
      {
        "name": "sysargs",
        "desc": ""
      },
      {
        "name": "sysauxv",
        "desc": ""
      },
      {
        "name": "syscall",
        "desc": ""
      },
      {
        "name": "syscall0",
        "desc": ""
      },
      {
        "name": "syscall1",
        "desc": ""
      },
      {
        "name": "syscall10",
        "desc": ""
      },
      {
        "name": "syscall10X",
        "desc": ""
      },
      {
        "name": "syscall2",
        "desc": ""
      },
      {
        "name": "syscall3",
        "desc": ""
      },
      {
        "name": "syscall4",
        "desc": ""
      },
      {
        "name": "syscall5",
        "desc": ""
      },
      {
        "name": "syscall6",
        "desc": ""
      },
      {
        "name": "syscall6X",
        "desc": ""
      },
      {
        "name": "syscall9",
        "desc": ""
      },
      {
        "name": "syscallPtr",
        "desc": ""
      },
      {
        "name": "syscallX",
        "desc": ""
      },
      {
        "name": "syscall_Exit",
        "desc": ""
      },
      {
        "name": "syscall_Getpagesize",
        "desc": ""
      },
      {
        "name": "syscall_RawSyscall",
        "desc": "This is syscall.RawSyscall, it exists to satisfy some build dependency, but it doesn't work.  This is exported via linkname to assembly in the syscall package."
      },
      {
        "name": "syscall_Syscall",
        "desc": "Syscall is needed because some packages (like net) need it too. The best way is to return EINVAL and let Golang handles its failure If the syscall can't fail, this function can redirect it to a real syscall.  This is exported via linkname to assembly in the syscall package."
      },
      {
        "name": "syscall_Syscall12",
        "desc": ""
      },
      {
        "name": "syscall_Syscall15",
        "desc": ""
      },
      {
        "name": "syscall_Syscall18",
        "desc": ""
      },
      {
        "name": "syscall_Syscall6",
        "desc": ""
      },
      {
        "name": "syscall_Syscall9",
        "desc": ""
      },
      {
        "name": "syscall_SyscallN",
        "desc": ""
      },
      {
        "name": "syscall_cgocaller",
        "desc": "wrapper for syscall package to call cgocall for libc (cgo) calls."
      },
      {
        "name": "syscall_chdir",
        "desc": ""
      },
      {
        "name": "syscall_chroot",
        "desc": ""
      },
      {
        "name": "syscall_chroot1",
        "desc": ""
      },
      {
        "name": "syscall_close",
        "desc": "like close, but must not split stack, for forkx."
      },
      {
        "name": "syscall_closeFD",
        "desc": "like close, but must not split stack, for fork."
      },
      {
        "name": "syscall_dup2",
        "desc": ""
      },
      {
        "name": "syscall_dup2child",
        "desc": ""
      },
      {
        "name": "syscall_execve",
        "desc": ""
      },
      {
        "name": "syscall_exit",
        "desc": "like exit, but must not split stack, for fork."
      },
      {
        "name": "syscall_fcntl",
        "desc": ""
      },
      {
        "name": "syscall_fcntl1",
        "desc": ""
      },
      {
        "name": "syscall_forkx",
        "desc": ""
      },
      {
        "name": "syscall_gethostname",
        "desc": ""
      },
      {
        "name": "syscall_getpid",
        "desc": ""
      },
      {
        "name": "syscall_getprocaddress",
        "desc": "golang.org/x/sys linknames syscall.getprocaddress (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_ioctl",
        "desc": ""
      },
      {
        "name": "syscall_loadlibrary",
        "desc": "golang.org/x/sys linknames syscall.loadlibrary (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_loadsystemlibrary",
        "desc": ""
      },
      {
        "name": "syscall_now",
        "desc": ""
      },
      {
        "name": "syscall_rawSyscall",
        "desc": "golang.org/x/sys linknames syscall_rawSyscall (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_rawSyscall10X",
        "desc": ""
      },
      {
        "name": "syscall_rawSyscall6",
        "desc": "golang.org/x/sys linknames syscall_rawSyscall6 (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_rawSyscall6X",
        "desc": ""
      },
      {
        "name": "syscall_rawsyscall",
        "desc": "This is syscall.RawSyscall, it exists to satisfy some build dependency, but it doesn't work."
      },
      {
        "name": "syscall_rawsyscall6",
        "desc": "This is syscall.RawSyscall6, it exists to avoid a linker error because syscall.RawSyscall6 is already declared. See golang.org/issue/24357"
      },
      {
        "name": "syscall_rawsysvicall6",
        "desc": ""
      },
      {
        "name": "syscall_runtimeSetenv",
        "desc": ""
      },
      {
        "name": "syscall_runtimeUnsetenv",
        "desc": ""
      },
      {
        "name": "syscall_runtime_AfterExec",
        "desc": "Called from syscall package after Exec."
      },
      {
        "name": "syscall_runtime_AfterFork",
        "desc": "Called from syscall package after fork in parent.  syscall_runtime_AfterFork is for package syscall, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "syscall_runtime_AfterForkInChild",
        "desc": "Called from syscall package after fork in child. It resets non-sigignored signals to the default handler, and restores the signal mask in preparation for the exec.  Because this might be called during a vfork, and therefore may be temporarily sharing address space with the parent process, this must not change any global variables or calling into C code that may do so.  syscall_runtime_AfterForkInChild is for package syscall, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "syscall_runtime_BeforeExec",
        "desc": "Called from syscall package before Exec."
      },
      {
        "name": "syscall_runtime_BeforeFork",
        "desc": "Called from syscall package before fork.  syscall_runtime_BeforeFork is for package syscall, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "syscall_runtime_doAllThreadsSyscall",
        "desc": "syscall_runtime_doAllThreadsSyscall and executes a specified system call on all Ms.  The system call is expected to succeed and return the same value on every thread. If any threads do not match, the runtime throws."
      },
      {
        "name": "syscall_runtime_envs",
        "desc": ""
      },
      {
        "name": "syscall_setgid",
        "desc": ""
      },
      {
        "name": "syscall_setgroups",
        "desc": ""
      },
      {
        "name": "syscall_setgroups1",
        "desc": ""
      },
      {
        "name": "syscall_setpgid",
        "desc": ""
      },
      {
        "name": "syscall_setrlimit",
        "desc": ""
      },
      {
        "name": "syscall_setrlimit1",
        "desc": ""
      },
      {
        "name": "syscall_setsid",
        "desc": ""
      },
      {
        "name": "syscall_setuid",
        "desc": ""
      },
      {
        "name": "syscall_syscall",
        "desc": "golang.org/x/sys linknames syscall_syscall (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_syscall10",
        "desc": "golang.org/x/sys linknames syscall.syscall10 (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_syscall10X",
        "desc": ""
      },
      {
        "name": "syscall_syscall6",
        "desc": "golang.org/x/sys linknames syscall.syscall6 (in addition to standard package syscall). Do not remove or change the type signature.  syscall.syscall6 is meant for package syscall (and x/sys), but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/tetratelabs/wazero  See go.dev/issue/67401."
      },
      {
        "name": "syscall_syscall6X",
        "desc": ""
      },
      {
        "name": "syscall_syscall9",
        "desc": "golang.org/x/sys linknames syscall.syscall9 (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_syscallPtr",
        "desc": "golang.org/x/sys linknames syscall.syscallPtr (in addition to standard package syscall). Do not remove or change the type signature."
      },
      {
        "name": "syscall_syscallX",
        "desc": ""
      },
      {
        "name": "syscall_syscalln",
        "desc": ""
      },
      {
        "name": "syscall_sysvicall6",
        "desc": ""
      },
      {
        "name": "syscall_wait4",
        "desc": ""
      },
      {
        "name": "syscall_write",
        "desc": ""
      },
      {
        "name": "syscall_write1",
        "desc": ""
      },
      {
        "name": "syscall_x509",
        "desc": ""
      },
      {
        "name": "sysconf",
        "desc": ""
      },
      {
        "name": "sysctl",
        "desc": ""
      },
      {
        "name": "sysctlInt",
        "desc": ""
      },
      {
        "name": "sysctlUint64",
        "desc": ""
      },
      {
        "name": "sysctl_trampoline",
        "desc": ""
      },
      {
        "name": "sysctlbyname",
        "desc": ""
      },
      {
        "name": "sysctlbynameInt32",
        "desc": ""
      },
      {
        "name": "sysctlbyname_trampoline",
        "desc": ""
      },
      {
        "name": "sysctlnametomib",
        "desc": "sysctlnametomib fill mib with dynamically assigned sysctl entries of name, return count of effected mib slots, return 0 on error."
      },
      {
        "name": "sysmon",
        "desc": "Always runs without a P, so write barriers are not allowed."
      },
      {
        "name": "sysmonUpdateGOMAXPROCS",
        "desc": ""
      },
      {
        "name": "sysrand_fatal",
        "desc": ""
      },
      {
        "name": "systemstack",
        "desc": "systemstack runs fn on a system stack. If systemstack is called from the per-OS-thread (g0) stack, or if systemstack is called from the signal handling (gsignal) stack, systemstack calls fn directly and returns. Otherwise, systemstack is being called from the limited stack of an ordinary goroutine. In this case, systemstack switches to the per-OS-thread stack, calls fn, and switches back. It is common to use a func literal as the argument, in order to share inputs and outputs with the code around the call to system stack:  \t... set up y ... \tsystemstack(func() { \t\tx = bigcall(y) \t}) \t... use x ..."
      },
      {
        "name": "systemstack_switch",
        "desc": ""
      },
      {
        "name": "sysvicall0",
        "desc": ""
      },
      {
        "name": "sysvicall1",
        "desc": ""
      },
      {
        "name": "sysvicall1Err",
        "desc": "sysvicall1Err returns both the system call result and the errno value. This is used by sysvicall1 and pipe."
      },
      {
        "name": "sysvicall2",
        "desc": ""
      },
      {
        "name": "sysvicall2Err",
        "desc": "sysvicall2Err returns both the system call result and the errno value. This is used by sysvicall2 and pipe2."
      },
      {
        "name": "sysvicall3",
        "desc": ""
      },
      {
        "name": "sysvicall3Err",
        "desc": "sysvicall3Err returns both the system call result and the errno value. This is used by sysvicall3 and write1."
      },
      {
        "name": "sysvicall4",
        "desc": ""
      },
      {
        "name": "sysvicall5",
        "desc": ""
      },
      {
        "name": "sysvicall6",
        "desc": ""
      },
      {
        "name": "templateThread",
        "desc": "templateThread is a thread in a known-good state that exists solely to start new threads in known-good states when the calling thread may not be in a good state.  Many programs never need this, so templateThread is started lazily when we first enter a state that might lead to running on a thread in an unknown state.  templateThread runs on an M without a P, so it must not have write barriers."
      },
      {
        "name": "testAtomic64",
        "desc": ""
      },
      {
        "name": "testSPWrite",
        "desc": ""
      },
      {
        "name": "tfork",
        "desc": ""
      },
      {
        "name": "tgkill",
        "desc": ""
      },
      {
        "name": "thr_kill",
        "desc": ""
      },
      {
        "name": "thr_new",
        "desc": ""
      },
      {
        "name": "thr_start",
        "desc": ""
      },
      {
        "name": "threadCreateProfileInternal",
        "desc": "threadCreateProfileInternal returns the number of records n in the profile. If there are less than size records, copyFn is invoked for each record, and ok returns true."
      },
      {
        "name": "thrkill",
        "desc": ""
      },
      {
        "name": "thrkill_trampoline",
        "desc": ""
      },
      {
        "name": "throw",
        "desc": "throw triggers a fatal error that dumps a stack trace and exits.  throw should be used for runtime-internal fatal errors where Go itself, rather than user code, may be at fault for the failure.  throw should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/sonic   - github.com/cockroachdb/pebble   - github.com/dgraph-io/ristretto   - github.com/outcaste-io/ristretto   - github.com/pingcap/br   - gvisor.dev/gvisor   - github.com/sagernet/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "thrsleep",
        "desc": ""
      },
      {
        "name": "thrsleep_trampoline",
        "desc": ""
      },
      {
        "name": "thrwakeup",
        "desc": ""
      },
      {
        "name": "thrwakeup_trampoline",
        "desc": ""
      },
      {
        "name": "ticksPerSecond",
        "desc": "ticksPerSecond returns a conversion rate between the cputicks clock and the nanotime clock.  Note: Clocks are hard. Using this as an actual conversion rate for timestamps is ill-advised and should be avoided when possible. Use only for durations, where a tiny error term isn't going to make a meaningful difference in even a 1ms duration. If an accurate timestamp is needed, use nanotime instead. (The entire Windows platform is a broad exception to this rule, where nanotime produces timestamps on such a coarse granularity that the error from this conversion is actually preferable.)  The strategy for computing the conversion rate is to write down nanotime and cputicks as early in process startup as possible. From then, we just need to wait until we get values from nanotime that we can use (some platforms have a really coarse system time granularity). We require some amount of time to pass to ensure that the conversion rate is fairly accurate in aggregate. But because we compute this rate lazily, there's a pretty good chance a decent amount of time has passed by the time we get here.  Must be called from a normal goroutine context (running regular goroutine with a P).  Called by runtime/pprof in addition to runtime code.  TODO(mknyszek): This doesn't account for things like CPU frequency scaling. Consider a more sophisticated and general approach in the future."
      },
      {
        "name": "timeHistogramMetricsBuckets",
        "desc": "timeHistogramMetricsBuckets generates a slice of boundaries for the timeHistogram. These boundaries are represented in seconds, not nanoseconds like the timeHistogram represents durations."
      },
      {
        "name": "timeSleep",
        "desc": "timeSleep puts the current goroutine to sleep for at least ns nanoseconds."
      },
      {
        "name": "timeSleepUntil",
        "desc": "timeSleepUntil returns the time when the next timer should fire. Returns maxWhen if there are no timers. This is only called by sysmon and checkdead."
      },
      {
        "name": "time_now",
        "desc": "Do not remove or change the type signature. See comment in timestub.go."
      },
      {
        "name": "time_runtimeIsBubbled",
        "desc": ""
      },
      {
        "name": "time_runtimeNano",
        "desc": ""
      },
      {
        "name": "time_runtimeNow",
        "desc": ""
      },
      {
        "name": "timediv",
        "desc": "Poor mans 64-bit division. This is a very special function, do not use it if you are not sure what you are doing. int64 division is lowered into _divv() call on 386, which does not fit into nosplit functions. Handles overflow in a time-specific manner. This keeps us within no-split stack limits on 32-bit processors."
      },
      {
        "name": "timer_create",
        "desc": ""
      },
      {
        "name": "timer_delete",
        "desc": ""
      },
      {
        "name": "timer_settime",
        "desc": ""
      },
      {
        "name": "timerchandrain",
        "desc": "timerchandrain removes all elements in channel c's buffer. It reports whether any elements were removed. Because it is only intended for timers, it does not handle waiting senders at all (all timer channels use non-blocking sends to fill the buffer)."
      },
      {
        "name": "timesplit",
        "desc": "timesplit returns u/1e9, u%1e9"
      },
      {
        "name": "tiuInlined1",
        "desc": ""
      },
      {
        "name": "tiuInlined2",
        "desc": ""
      },
      {
        "name": "tiuTest",
        "desc": ""
      },
      {
        "name": "tlsinit",
        "desc": "tlsinit allocates a thread-local storage slot for g.  It finds the first available slot using pthread_key_create and uses it as the offset value for runtime.tlsg.  This runs at startup on g0 stack, but before g is set, so it must not split stack (transitively). g is expected to be nil, so things (e.g. asmcgocall) will skip saving or reading g."
      },
      {
        "name": "tooManyOverflowBuckets",
        "desc": "tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1\u003c\u003cB buckets. Note that most of these overflow buckets must be in sparse use; if use was dense, then we'd have already triggered regular map growth."
      },
      {
        "name": "tophash",
        "desc": "tophash calculates the tophash value for hash."
      },
      {
        "name": "totalMutexWaitTimeNanos",
        "desc": ""
      },
      {
        "name": "traceAdvance",
        "desc": "traceAdvance moves tracing to the next generation, and cleans up the current generation, ensuring that it's flushed out before returning. If stopTrace is true, it disables tracing altogether instead of advancing to the next generation.  traceAdvanceSema must not be held.  traceAdvance is called by runtime/trace and golang.org/x/exp/trace using linkname."
      },
      {
        "name": "traceAllocFreeEnabled",
        "desc": "traceAllocFreeEnabled returns true if the trace is currently enabled and alloc/free events are also enabled."
      },
      {
        "name": "traceBufFlush",
        "desc": "traceBufFlush flushes a trace buffer.  Must run on the system stack because trace.lock must be held."
      },
      {
        "name": "traceCPUFlush",
        "desc": "traceCPUFlush flushes trace.cpuBuf[gen%2]. The caller must be certain that gen has completed and that there are no more writers to it."
      },
      {
        "name": "traceCPUSample",
        "desc": "traceCPUSample writes a CPU profile sample stack to the execution tracer's profiling buffer. It is called from a signal handler, so is limited in what it can do. mp must be the thread that is currently stopped in a signal."
      },
      {
        "name": "traceClockUnitsPerSecond",
        "desc": "traceClockUnitsPerSecond estimates the number of trace clock units per second that elapse."
      },
      {
        "name": "traceEnabled",
        "desc": "traceEnabled returns true if the trace is currently enabled."
      },
      {
        "name": "traceExitedSyscall",
        "desc": "traceExitedSyscall marks a goroutine as having exited the syscall slow path."
      },
      {
        "name": "traceExitingSyscall",
        "desc": "traceExitingSyscall marks a goroutine as exiting the syscall slow path.  Must be paired with a traceExitedSyscall call."
      },
      {
        "name": "traceInitReadCPU",
        "desc": "traceInitReadCPU initializes CPU profile -\u003e tracer state for tracing.  Returns a profBuf for reading from."
      },
      {
        "name": "traceLockInit",
        "desc": "traceLockInit initializes global trace locks."
      },
      {
        "name": "traceNextGen",
        "desc": ""
      },
      {
        "name": "traceReadCPU",
        "desc": "traceReadCPU attempts to read from the provided profBuf[gen%2] and write into the trace. Returns true if there might be more to read or false if the profBuf is closed or the caller should otherwise stop reading.  The caller is responsible for ensuring that gen does not change. Either the caller must be in a traceAcquire/traceRelease block, or must be calling with traceAdvanceSema held.  No more than one goroutine may be in traceReadCPU for the same profBuf at a time.  Must not run on the system stack because profBuf.read performs race operations."
      },
      {
        "name": "traceRegisterLabelsAndReasons",
        "desc": "traceRegisterLabelsAndReasons re-registers mark worker labels and goroutine stop/block reasons in the string table for the provided generation. Note: the provided generation must not have started yet."
      },
      {
        "name": "traceRelease",
        "desc": "traceRelease indicates that this M is done writing trace events.  nosplit because it's called on the syscall path when stack movement is forbidden."
      },
      {
        "name": "traceShuttingDown",
        "desc": "traceShuttingDown returns true if the trace is currently shutting down."
      },
      {
        "name": "traceSnapshotMemory",
        "desc": "traceSnapshotMemory takes a snapshot of all runtime memory that there are events for (heap spans, heap objects, goroutine stacks, etc.) and writes out events for them.  The world must be stopped and tracing must be enabled when this function is called."
      },
      {
        "name": "traceStack",
        "desc": "traceStack captures a stack trace from a goroutine and registers it in the trace stack table. It then returns its unique ID. If gp == nil, then traceStack will attempt to use the current execution context.  skip controls the number of leaf frames to omit in order to hide tracer internals from stack traces, see CL 5523.  Avoid calling this function directly. Prefer traceEventWriter.stack."
      },
      {
        "name": "traceStartReadCPU",
        "desc": "traceStartReadCPU creates a goroutine to start reading CPU profile data into an active trace.  traceAdvanceSema must be held."
      },
      {
        "name": "traceStopReadCPU",
        "desc": "traceStopReadCPU blocks until the trace CPU reading goroutine exits.  traceAdvanceSema must be held, and tracing must be disabled."
      },
      {
        "name": "traceSyncBatch",
        "desc": ""
      },
      {
        "name": "traceThreadDestroy",
        "desc": "traceThreadDestroy is called when a thread is removed from sched.freem.  mp must not be able to emit trace events anymore.  sched.lock must be held to synchronize with traceAdvance."
      },
      {
        "name": "trace_userLog",
        "desc": "trace_userLog emits a UserRegionBegin or UserRegionEnd event."
      },
      {
        "name": "trace_userRegion",
        "desc": "trace_userRegion emits a UserRegionBegin or UserRegionEnd event, depending on mode (0 == Begin, 1 == End).  TODO(mknyszek): Just make this two functions."
      },
      {
        "name": "trace_userTaskCreate",
        "desc": "trace_userTaskCreate emits a UserTaskCreate event."
      },
      {
        "name": "trace_userTaskEnd",
        "desc": "trace_userTaskEnd emits a UserTaskEnd event."
      },
      {
        "name": "traceback",
        "desc": ""
      },
      {
        "name": "traceback1",
        "desc": ""
      },
      {
        "name": "traceback2",
        "desc": "traceback2 prints a stack trace starting at u. It skips the first \"skip\" logical frames, after which it prints at most \"max\" logical frames. It returns n, which is the number of logical frames skipped and printed, and lastN, which is the number of logical frames skipped or printed just in the physical frame that u references."
      },
      {
        "name": "tracebackHexdump",
        "desc": "tracebackHexdump hexdumps part of stk around frame.sp and frame.fp for debugging purposes. If the address bad is included in the hexdumped range, it will mark it as well."
      },
      {
        "name": "tracebackPCs",
        "desc": "tracebackPCs populates pcBuf with the return addresses for each frame from u and returns the number of PCs written to pcBuf. The returned PCs correspond to \"logical frames\" rather than \"physical frames\"; that is if A is inlined into B, this will still return a PCs for both A and B. This also includes PCs generated by the cgo unwinder, if one is registered.  If skip != 0, this skips this many logical frames.  Callers should set the unwindSilentErrors flag on u."
      },
      {
        "name": "tracebackothers",
        "desc": ""
      },
      {
        "name": "tracebacksomeothers",
        "desc": ""
      },
      {
        "name": "tracebacktrap",
        "desc": "tracebacktrap is like traceback but expects that the PC and SP were obtained from a trap, not from gp-\u003esched or gp-\u003esyscallpc/gp-\u003esyscallsp or GetCallerPC/GetCallerSP. Because they are from a trap instead of from a saved pair, the initial PC must not be rewound to the previous instruction. (All the saved pairs record a PC that is a return address, so we rewind it into the CALL instruction.) If gp.m.libcall{g,pc,sp} information is available, it uses that information in preference to the pc/sp/lr passed in."
      },
      {
        "name": "tracefpunwindoff",
        "desc": "tracefpunwindoff returns true if frame pointer unwinding for the tracer is disabled via GODEBUG or not supported by the architecture."
      },
      {
        "name": "tryDeferToSpanScan",
        "desc": "tryQueueOnSpan tries to queue p on the span it points to, if it points to a small object span (gcUsesSpanQueue size)."
      },
      {
        "name": "tryRecordGoroutineProfile",
        "desc": "tryRecordGoroutineProfile ensures that gp1 has the appropriate representation in the current goroutine profile: either that it should not be profiled, or that a snapshot of its call stack and labels are now in the profile."
      },
      {
        "name": "tryRecordGoroutineProfileWB",
        "desc": "tryRecordGoroutineProfileWB asserts that write barriers are allowed and calls tryRecordGoroutineProfile."
      },
      {
        "name": "tstart_plan9",
        "desc": ""
      },
      {
        "name": "tstart_stdcall",
        "desc": "Function to be called by windows CreateThread to start new os thread."
      },
      {
        "name": "tstart_sysvicall",
        "desc": ""
      },
      {
        "name": "typeBitsBulkBarrier",
        "desc": "typeBitsBulkBarrier executes a write barrier for every pointer that would be copied from [src, src+size) to [dst, dst+size) by a memmove using the type bitmap to locate those pointer slots.  The type typ must correspond exactly to [src, src+size) and [dst, dst+size). dst, src, and size must be pointer-aligned.  Must not be preempted because it typically runs right before memmove, and the GC must observe them as an atomic action.  Callers must perform cgo checks if goexperiment.CgoCheck2."
      },
      {
        "name": "typedmemclr",
        "desc": "typedmemclr clears the typed memory at ptr with type typ. The memory at ptr must already be initialized (and hence in type-safe state). If the memory is being initialized for the first time, see memclrNoHeapPointers.  If the caller knows that typ has pointers, it can alternatively call memclrHasPointers.  TODO: A \"go:nosplitrec\" annotation would be perfect for this."
      },
      {
        "name": "typedmemmove",
        "desc": "typedmemmove copies a value of type typ to dst from src. Must be nosplit, see #16026.  TODO: Perfect for go:nosplitrec since we can't have a safe point anywhere in the bulk barrier or memmove.  typedmemmove should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/RomiChan/protobuf   - github.com/segmentio/encoding  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "typedslicecopy",
        "desc": "typedslicecopy should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/segmentio/encoding  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "typehash",
        "desc": "typehash computes the hash of the object of type t at address p. h is the seed. This function is seldom used. Most maps use for hashing either fixed functions (e.g. f32hash) or compiler-generated functions (e.g. for a type like struct { x, y string }). This implementation is slower but more general and is used for hashing interface types (called from interhash or nilinterhash, above) or for hashing in maps generated by reflect.MapOf (reflect_typehash, below). Note: this function must match the compiler generated functions exactly. See issue 37716.  typehash should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/puzpuzpuz/xsync/v2   - github.com/puzpuzpuz/xsync/v3  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "typelinksinit",
        "desc": "typelinksinit scans the types from extra modules and builds the moduledata typemap used to de-duplicate type pointers."
      },
      {
        "name": "typesEqual",
        "desc": "typesEqual reports whether two types are equal.  Everywhere in the runtime and reflect packages, it is assumed that there is exactly one *_type per Go type, so that pointer equality can be used to test if types are equal. There is one place that breaks this assumption: buildmode=shared. In this case a type can appear as two different pieces of memory. This is hidden from the runtime and reflect package by the per-module typemap built in typelinksinit. It uses typesEqual to map types from later modules back into earlier ones.  Only typelinksinit needs this function."
      },
      {
        "name": "udiv",
        "desc": "Called from compiler-generated code; declared for go vet."
      },
      {
        "name": "uint32tofloat64",
        "desc": ""
      },
      {
        "name": "uint64div",
        "desc": ""
      },
      {
        "name": "uint64mod",
        "desc": ""
      },
      {
        "name": "uint64tofloat32",
        "desc": ""
      },
      {
        "name": "uint64tofloat64",
        "desc": ""
      },
      {
        "name": "unblockTimerChan",
        "desc": "unblockTimerChan is called when a channel op that was blocked on c is no longer blocked. Every call to blockTimerChan must be paired with a call to unblockTimerChan. The caller holds the channel lock for c and possibly other channels. unblockTimerChan removes c from the timer heap when nothing is blocked on it anymore."
      },
      {
        "name": "unblocksig",
        "desc": "unblocksig removes sig from the current thread's signal mask. This is nosplit and nowritebarrierrec because it is called from dieFromSignal, which can be called by sigfwdgo while running in the signal handler, on the signal stack, with no g available."
      },
      {
        "name": "unexportedPanicForTesting",
        "desc": ""
      },
      {
        "name": "unimplemented",
        "desc": ""
      },
      {
        "name": "unique_runtime_blockUntilEmptyCleanupQueue",
        "desc": ""
      },
      {
        "name": "unlock",
        "desc": ""
      },
      {
        "name": "unlock2",
        "desc": "We might not be holding a p in this code."
      },
      {
        "name": "unlock2Wake",
        "desc": "unlock2Wake updates the list of Ms waiting on l, waking an M if necessary."
      },
      {
        "name": "unlockOSThread",
        "desc": ""
      },
      {
        "name": "unlockWithRank",
        "desc": "See comment on lockWithRank regarding stack splitting."
      },
      {
        "name": "unlockextra",
        "desc": ""
      },
      {
        "name": "unminit",
        "desc": "Called from dropm to undo the effect of an minit."
      },
      {
        "name": "unminitSignals",
        "desc": "unminitSignals is called from dropm, via unminit, to undo the effect of calling minit on a non-Go thread."
      },
      {
        "name": "unpackNetpollSource",
        "desc": "unpackNetpollSource returns the source packed key."
      },
      {
        "name": "unreachableMethod",
        "desc": "The linker redirects a reference of a method that it determined unreachable to a reference to this function, so it will throw if ever called."
      },
      {
        "name": "unsafeslice",
        "desc": "Keep this code in sync with cmd/compile/internal/walk/builtin.go:walkUnsafeSlice"
      },
      {
        "name": "unsafeslice64",
        "desc": "Keep this code in sync with cmd/compile/internal/walk/builtin.go:walkUnsafeSlice"
      },
      {
        "name": "unsafeslicecheckptr",
        "desc": ""
      },
      {
        "name": "unsafestring",
        "desc": ""
      },
      {
        "name": "unsafestring64",
        "desc": "Keep this code in sync with cmd/compile/internal/walk/builtin.go:walkUnsafeString"
      },
      {
        "name": "unsafestringcheckptr",
        "desc": ""
      },
      {
        "name": "unsetenv_c",
        "desc": "Update the C environment if cgo is loaded."
      },
      {
        "name": "unspillArgs",
        "desc": ""
      },
      {
        "name": "unwindm",
        "desc": ""
      },
      {
        "name": "updateMaxProcsGoroutine",
        "desc": ""
      },
      {
        "name": "userArenaChunkReserveBytes",
        "desc": "userArenaChunkReserveBytes returns the amount of additional bytes to reserve for heap metadata."
      },
      {
        "name": "userArenaHeapBitsSetSliceType",
        "desc": "userArenaHeapBitsSetSliceType is the equivalent of heapBitsSetType but for Go slice backing store values allocated in a user arena chunk. It sets up the heap bitmap for n consecutive values with type typ allocated at address ptr."
      },
      {
        "name": "userArenaHeapBitsSetType",
        "desc": "userArenaHeapBitsSetType is the equivalent of heapSetType but for non-slice-backing-store Go values allocated in a user arena chunk. It sets up the type metadata for the value with type typ allocated at address ptr. base is the base address of the arena chunk."
      },
      {
        "name": "usesLibcall",
        "desc": "usesLibcall indicates whether this runtime performs system calls via libcall."
      },
      {
        "name": "usleep",
        "desc": ""
      },
      {
        "name": "usleep1",
        "desc": ""
      },
      {
        "name": "usleep_no_g",
        "desc": ""
      },
      {
        "name": "usleep_trampoline",
        "desc": ""
      },
      {
        "name": "usplit",
        "desc": "for testing"
      },
      {
        "name": "usplitR0",
        "desc": "Called from assembly only; declared for go vet."
      },
      {
        "name": "valgrindChangeStack",
        "desc": ""
      },
      {
        "name": "valgrindClientRequest",
        "desc": ""
      },
      {
        "name": "valgrindCreateMempool",
        "desc": ""
      },
      {
        "name": "valgrindDeregisterStack",
        "desc": ""
      },
      {
        "name": "valgrindFree",
        "desc": ""
      },
      {
        "name": "valgrindMakeMemDefined",
        "desc": ""
      },
      {
        "name": "valgrindMakeMemNoAccess",
        "desc": ""
      },
      {
        "name": "valgrindMakeMemUndefined",
        "desc": ""
      },
      {
        "name": "valgrindMalloc",
        "desc": ""
      },
      {
        "name": "valgrindMempoolFree",
        "desc": ""
      },
      {
        "name": "valgrindMempoolMalloc",
        "desc": ""
      },
      {
        "name": "valgrindRegisterStack",
        "desc": ""
      },
      {
        "name": "validSIGPROF",
        "desc": "validSIGPROF compares this signal delivery's code against the signal sources that the profiler uses, returning whether the delivery should be processed. To be processed, a signal delivery from a known profiling mechanism should correspond to the best profiling mechanism available to this thread. Signals from other sources are always considered valid."
      },
      {
        "name": "values",
        "desc": "values for implementing maps.values"
      },
      {
        "name": "vdsoCall",
        "desc": ""
      },
      {
        "name": "vdsoFindVersion",
        "desc": ""
      },
      {
        "name": "vdsoInitFromSysinfoEhdr",
        "desc": ""
      },
      {
        "name": "vdsoParseSymbols",
        "desc": ""
      },
      {
        "name": "vdsoauxv",
        "desc": ""
      },
      {
        "name": "vgetrandom",
        "desc": "This is exported for use in internal/syscall/unix as well as x/sys/unix."
      },
      {
        "name": "vgetrandom1",
        "desc": ""
      },
      {
        "name": "vgetrandomDestroy",
        "desc": "Free vgetrandom state from the M (if any) prior to destroying the M.  This may allocate, so it must have a P."
      },
      {
        "name": "vgetrandomGetState",
        "desc": ""
      },
      {
        "name": "vgetrandomInit",
        "desc": ""
      },
      {
        "name": "waitForSigusr1Callback",
        "desc": "waitForSigusr1Callback is called from the signal handler during WaitForSigusr1. It must not have write barriers because there may not be a P."
      },
      {
        "name": "wakeNetPoller",
        "desc": "wakeNetPoller wakes up the thread sleeping in the network poller if it isn't going to wake up before the when argument; or it wakes an idle P to service timers and the network poller if there isn't one already."
      },
      {
        "name": "wakeNetpoll",
        "desc": ""
      },
      {
        "name": "wakep",
        "desc": "Tries to add one more P to execute G's. Called when a G is made runnable (newproc, ready). Must be called with a P.  wakep should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gvisor.dev/gvisor  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "walltime",
        "desc": "walltime should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "walltime1",
        "desc": ""
      },
      {
        "name": "walltime_trampoline",
        "desc": ""
      },
      {
        "name": "wantAsyncPreempt",
        "desc": "wantAsyncPreempt returns whether an asynchronous preemption is queued for gp."
      },
      {
        "name": "wasmDiv",
        "desc": ""
      },
      {
        "name": "wasmExit",
        "desc": ""
      },
      {
        "name": "wasmTruncS",
        "desc": ""
      },
      {
        "name": "wasmTruncU",
        "desc": ""
      },
      {
        "name": "wasmWrite",
        "desc": ""
      },
      {
        "name": "wbBufFlush",
        "desc": "wbBufFlush flushes the current P's write barrier buffer to the GC workbufs.  This must not have write barriers because it is part of the write barrier implementation.  This and everything it calls must be nosplit because 1) the stack contains untyped slots from gcWriteBarrier and 2) there must not be a GC safe point between the write barrier test in the caller and flushing the buffer.  TODO: A \"go:nosplitrec\" annotation would be perfect for this."
      },
      {
        "name": "wbBufFlush1",
        "desc": "wbBufFlush1 flushes p's write barrier buffer to the GC work queue.  This must not have write barriers because it is part of the write barrier implementation, so this may lead to infinite loops or buffer corruption.  This must be non-preemptible because it uses the P's workbuf."
      },
      {
        "name": "wbMove",
        "desc": "wbMove performs the write barrier operations necessary before copying a region of memory from src to dst of type typ. Does not actually do the copying."
      },
      {
        "name": "wbZero",
        "desc": "wbZero performs the write barrier operations necessary before zeroing a region of memory at address dst of type typ. Does not actually do the zeroing."
      },
      {
        "name": "windowsLoadSystemLib",
        "desc": ""
      },
      {
        "name": "windows_GetSystemDirectory",
        "desc": ""
      },
      {
        "name": "windows_QueryPerformanceCounter",
        "desc": ""
      },
      {
        "name": "windows_QueryPerformanceFrequency",
        "desc": ""
      },
      {
        "name": "winthrow",
        "desc": "Always called on g0. gp is the G where the exception occurred."
      },
      {
        "name": "wintls",
        "desc": "Init-time helper"
      },
      {
        "name": "wirep",
        "desc": "wirep is the first step of acquirep, which actually associates the current M to pp. This is broken out so we can disallow write barriers for this part, since we don't yet have a P."
      },
      {
        "name": "worldStarted",
        "desc": "worldStarted that the world is starting.  Caller must hold worldsema.  nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "worldStopped",
        "desc": "worldStopped notes that the world is stopped.  Caller must hold worldsema.  nosplit to ensure it can be called in as many contexts as possible."
      },
      {
        "name": "write",
        "desc": "write must be nosplit on Windows (see write1)"
      },
      {
        "name": "write1",
        "desc": "write1 calls the write system call. It returns a non-negative number of bytes written or a negative errno value."
      },
      {
        "name": "write2",
        "desc": ""
      },
      {
        "name": "writeConsole",
        "desc": "writeConsole writes bufLen bytes from buf to the console File. It returns the number of bytes written."
      },
      {
        "name": "writeConsoleUTF16",
        "desc": "writeConsoleUTF16 is the dedicated windows calls that correctly prints to the console regardless of the current code page. Input is utf-16 code points. The handle must be a console handle."
      },
      {
        "name": "writeErr",
        "desc": ""
      },
      {
        "name": "writeErrData",
        "desc": "writeErrData is the common parts of writeErr{,Str}."
      },
      {
        "name": "writeErrStr",
        "desc": "writeErrStr writes a string to descriptor 2. If SetCrashOutput(f) was called, it also writes to f."
      },
      {
        "name": "writeLogdHeader",
        "desc": "writeLogdHeader populates the header and returns the length of the payload."
      },
      {
        "name": "write_trampoline",
        "desc": ""
      },
      {
        "name": "writeheapdump_m",
        "desc": ""
      },
      {
        "name": "Base",
        "desc": "Base returns the virtual base address of the address range."
      },
      {
        "name": "Equals",
        "desc": "Equals returns true if the two address ranges are exactly equal."
      },
      {
        "name": "Limit",
        "desc": "Base returns the virtual address of the limit of the address range."
      },
      {
        "name": "Size",
        "desc": "Size returns the size in bytes of the address range."
      },
      {
        "name": "contains",
        "desc": "contains returns whether or not the range contains a given address."
      },
      {
        "name": "removeGreaterEqual",
        "desc": "removeGreaterEqual removes all addresses in a greater than or equal to addr and returns the new range."
      },
      {
        "name": "size",
        "desc": "size returns the size of the range represented in bytes."
      },
      {
        "name": "subtract",
        "desc": "subtract takes the addrRange toPrune and cuts out any overlap with from, then returns the new range. subtract assumes that a and b either don't overlap at all, only overlap on one side, or are equal. If b is strictly contained in a, thus forcing a split, it will throw."
      },
      {
        "name": "takeFromBack",
        "desc": "takeFromBack takes len bytes from the end of the address range, aligning the limit to align after subtracting len. On success, returns the aligned start of the region taken and true."
      },
      {
        "name": "takeFromFront",
        "desc": "takeFromFront takes len bytes from the front of the address range, aligning the base to align first. On success, returns the aligned start of the region taken and true."
      },
      {
        "name": "Add",
        "desc": "Add adds a new AddrRange to the AddrRanges.  The AddrRange must be mutable (i.e. created by NewAddrRanges), otherwise this method will throw."
      },
      {
        "name": "FindSucc",
        "desc": "FindSucc returns the successor to base. See addrRanges.findSucc for more details."
      },
      {
        "name": "Ranges",
        "desc": "Ranges returns a copy of the ranges described by the addrRanges."
      },
      {
        "name": "TotalBytes",
        "desc": "TotalBytes returns the totalBytes field of the addrRanges."
      },
      {
        "name": "add",
        "desc": "add inserts a new address range to a.  r must not overlap with any address range in a and r.size() must be \u003e 0."
      },
      {
        "name": "cloneInto",
        "desc": "cloneInto makes a deep clone of a's state into b, re-using b's ranges if able."
      },
      {
        "name": "contains",
        "desc": "contains returns true if a covers the address addr."
      },
      {
        "name": "findAddrGreaterEqual",
        "desc": "findAddrGreaterEqual returns the smallest address represented by a that is \u003e= addr. Thus, if the address is represented by a, then it returns addr. The second return value indicates whether such an address exists for addr in a. That is, if addr is larger than any address known to a, the second return value will be false."
      },
      {
        "name": "findSucc",
        "desc": "findSucc returns the first index in a such that addr is less than the base of the addrRange at that index."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "removeGreaterEqual",
        "desc": "removeGreaterEqual removes the ranges of a which are above addr, and additionally splits any range containing addr."
      },
      {
        "name": "removeLast",
        "desc": "removeLast removes and returns the highest-addressed contiguous range of a, or the last nBytes of that range, whichever is smaller. If a is empty, it returns an empty range."
      },
      {
        "name": "Offset",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Stop",
        "desc": "Stop cancels the cleanup call. Stop will have no effect if the cleanup call has already been queued for execution (because ptr became unreachable). To guarantee that Stop removes the cleanup function, the caller must ensure that the pointer that was passed to AddCleanup is reachable across the call to Stop."
      },
      {
        "name": "GetPC",
        "desc": ""
      },
      {
        "name": "ip",
        "desc": ""
      },
      {
        "name": "lr",
        "desc": "386 does not have link register, so this returns 0."
      },
      {
        "name": "pushCall",
        "desc": ""
      },
      {
        "name": "set_fp",
        "desc": "386 does not have frame pointer register."
      },
      {
        "name": "set_ip",
        "desc": ""
      },
      {
        "name": "set_lr",
        "desc": ""
      },
      {
        "name": "set_sp",
        "desc": ""
      },
      {
        "name": "sp",
        "desc": ""
      },
      {
        "name": "Next",
        "desc": "Next returns a [Frame] representing the next call frame in the slice of PC values. If it has already returned all call frames, Next returns a zero [Frame].  The more result indicates whether the next call to Next will return a valid [Frame]. It does not necessarily indicate whether this call returned one.  See the [Frames] example for idiomatic usage."
      },
      {
        "name": "Entry",
        "desc": "Entry returns the entry address of the function."
      },
      {
        "name": "FileLine",
        "desc": "FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the function."
      },
      {
        "name": "funcInfo",
        "desc": ""
      },
      {
        "name": "raw",
        "desc": ""
      },
      {
        "name": "startLine",
        "desc": "startLine returns the starting line number of the function. i.e., the line number of the func keyword."
      },
      {
        "name": "AddAssistTime",
        "desc": ""
      },
      {
        "name": "Capacity",
        "desc": ""
      },
      {
        "name": "Fill",
        "desc": ""
      },
      {
        "name": "FinishGCTransition",
        "desc": ""
      },
      {
        "name": "Limiting",
        "desc": ""
      },
      {
        "name": "NeedUpdate",
        "desc": ""
      },
      {
        "name": "Overflow",
        "desc": ""
      },
      {
        "name": "ResetCapacity",
        "desc": ""
      },
      {
        "name": "StartGCTransition",
        "desc": ""
      },
      {
        "name": "Update",
        "desc": ""
      },
      {
        "name": "AddIdleMarkWorker",
        "desc": ""
      },
      {
        "name": "AssistWorkPerByte",
        "desc": ""
      },
      {
        "name": "EndCycle",
        "desc": ""
      },
      {
        "name": "HeapGoal",
        "desc": ""
      },
      {
        "name": "HeapLive",
        "desc": ""
      },
      {
        "name": "HeapMarked",
        "desc": ""
      },
      {
        "name": "NeedIdleMarkWorker",
        "desc": ""
      },
      {
        "name": "RemoveIdleMarkWorker",
        "desc": ""
      },
      {
        "name": "Revise",
        "desc": ""
      },
      {
        "name": "SetMaxIdleMarkWorkers",
        "desc": ""
      },
      {
        "name": "StartCycle",
        "desc": ""
      },
      {
        "name": "Triggered",
        "desc": ""
      },
      {
        "name": "addGlobals",
        "desc": ""
      },
      {
        "name": "addIdleMarkWorker",
        "desc": "addIdleMarkWorker attempts to add a new idle mark worker.  If this returns true, the caller must become an idle mark worker unless there's no background mark worker goroutines in the pool. This case is harmless because there are already background mark workers running. If this returns false, the caller must NOT become an idle mark worker.  nosplit because it may be called without a P."
      },
      {
        "name": "addScannableStack",
        "desc": ""
      },
      {
        "name": "commit",
        "desc": "commit recomputes all pacing parameters needed to derive the trigger and the heap goal. Namely, the gcPercent-based heap goal, and the amount of runway we want to give the GC this cycle.  This can be called any time. If GC is the in the middle of a concurrent phase, it will adjust the pacing of that phase.  isSweepDone should be the result of calling isSweepDone(), unless we're testing or we know we're executing during a GC cycle.  This depends on gcPercent, gcController.heapMarked, and gcController.heapLive. These must be up to date.  Callers must call gcControllerState.revise after calling this function if the GC is enabled.  mheap_.lock must be held or the world must be stopped."
      },
      {
        "name": "endCycle",
        "desc": "endCycle computes the consMark estimate for the next cycle. userForced indicates whether the current GC cycle was forced by the application."
      },
      {
        "name": "enlistWorker",
        "desc": "enlistWorker encourages another dedicated mark worker to start on another P if there are spare worker slots. It is used by putfull when more work is made available.  If goexperiment.GreenTeaGC, the caller must not hold a G's scan bit, otherwise this could cause a deadlock. This is already enforced by the static lock ranking."
      },
      {
        "name": "findRunnableGCWorker",
        "desc": "findRunnableGCWorker returns a background mark worker for pp if it should be run. This must only be called when gcBlackenEnabled != 0."
      },
      {
        "name": "heapGoal",
        "desc": "heapGoal returns the current heap goal."
      },
      {
        "name": "heapGoalInternal",
        "desc": "heapGoalInternal is the implementation of heapGoal which returns additional information that is necessary for computing the trigger.  The returned minTrigger is always \u003c= goal."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "markWorkerStop",
        "desc": "markWorkerStop must be called whenever a mark worker stops executing.  It updates mark work accounting in the controller by a duration of work in nanoseconds and other bookkeeping.  Safe to execute at any time."
      },
      {
        "name": "memoryLimitHeapGoal",
        "desc": "memoryLimitHeapGoal returns a heap goal derived from memoryLimit."
      },
      {
        "name": "needIdleMarkWorker",
        "desc": "needIdleMarkWorker is a hint as to whether another idle mark worker is needed.  The caller must still call addIdleMarkWorker to become one. This is mainly useful for a quick check before an expensive operation.  nosplit because it may be called without a P."
      },
      {
        "name": "removeIdleMarkWorker",
        "desc": "removeIdleMarkWorker must be called when a new idle mark worker stops executing."
      },
      {
        "name": "resetLive",
        "desc": "resetLive sets up the controller state for the next mark phase after the end of the previous one. Must be called after endCycle and before commit, before the world is started.  The world must be stopped."
      },
      {
        "name": "revise",
        "desc": "revise updates the assist ratio during the GC cycle to account for improved estimates. This should be called whenever gcController.heapScan, gcController.heapLive, or if any inputs to gcController.heapGoal are updated. It is safe to call concurrently, but it may race with other calls to revise.  The result of this race is that the two assist ratio values may not line up or may be stale. In practice this is OK because the assist ratio moves slowly throughout a GC cycle, and the assist ratio is a best-effort heuristic anyway. Furthermore, no part of the heuristic depends on the two assist ratio values being exact reciprocals of one another, since the two values are used to convert values from different sources.  The worst case result of this raciness is that we may miss a larger shift in the ratio (say, if we decide to pace more aggressively against the hard heap goal) but even this \"hard goal\" is best-effort (see #40460). The dedicated GC should ensure we don't exceed the hard goal by too much in the rare case we do exceed it.  It should only be called when gcBlackenEnabled != 0 (because this is when assists are enabled and the necessary statistics are available)."
      },
      {
        "name": "setGCPercent",
        "desc": "setGCPercent updates gcPercent. commit must be called after. Returns the old value of gcPercent.  The world must be stopped, or mheap_.lock must be held."
      },
      {
        "name": "setMaxIdleMarkWorkers",
        "desc": "setMaxIdleMarkWorkers sets the maximum number of idle mark workers allowed.  This method is optimistic in that it does not wait for the number of idle mark workers to reduce to max before returning; it assumes the workers will deschedule themselves."
      },
      {
        "name": "setMemoryLimit",
        "desc": "setMemoryLimit updates memoryLimit. commit must be called after Returns the old value of memoryLimit.  The world must be stopped, or mheap_.lock must be held."
      },
      {
        "name": "startCycle",
        "desc": "startCycle resets the GC controller's state and computes estimates for a new GC cycle. The caller must hold worldsema and the world must be stopped."
      },
      {
        "name": "trigger",
        "desc": "trigger returns the current point at which a GC should trigger along with the heap goal.  The returned value may be compared against heapLive to determine whether the GC should trigger. Thus, the GC trigger condition should be (but may not be, in the case of small movements for efficiency) checked whenever the heap goal may change."
      },
      {
        "name": "update",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Pop",
        "desc": ""
      },
      {
        "name": "PopN",
        "desc": ""
      },
      {
        "name": "Push",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "TakeAll",
        "desc": ""
      },
      {
        "name": "InUseBytes",
        "desc": "InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes)."
      },
      {
        "name": "InUseObjects",
        "desc": "InUseObjects returns the number of objects in use (AllocObjects - FreeObjects)."
      },
      {
        "name": "Stack",
        "desc": "Stack returns the stack trace associated with the record, a prefix of r.Stack0."
      },
      {
        "name": "Next",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "next provides a new sample to the controller.  input is the sample, setpoint is the desired point, and period is how much time (in whatever unit makes the most sense) has passed since the last sample.  Returns a new value for the variable it's controlling, and whether the operation completed successfully. One reason this might fail is if error has been growing in an unbounded manner, to the point of overflow.  In the specific case of an error overflow occurs, the errOverflow field will be set and the rest of the controller's internal state will be fully reset."
      },
      {
        "name": "reset",
        "desc": "reset resets the controller state, except for controller error flags."
      },
      {
        "name": "Alloc",
        "desc": ""
      },
      {
        "name": "AllocToCache",
        "desc": ""
      },
      {
        "name": "Bounds",
        "desc": ""
      },
      {
        "name": "Free",
        "desc": ""
      },
      {
        "name": "InUse",
        "desc": ""
      },
      {
        "name": "PallocData",
        "desc": "Returns nil if the PallocData's L2 is missing."
      },
      {
        "name": "Scavenge",
        "desc": ""
      },
      {
        "name": "Alloc",
        "desc": ""
      },
      {
        "name": "Base",
        "desc": ""
      },
      {
        "name": "Cache",
        "desc": ""
      },
      {
        "name": "Empty",
        "desc": ""
      },
      {
        "name": "Flush",
        "desc": ""
      },
      {
        "name": "Scav",
        "desc": ""
      },
      {
        "name": "AllocRange",
        "desc": ""
      },
      {
        "name": "Find",
        "desc": ""
      },
      {
        "name": "Free",
        "desc": ""
      },
      {
        "name": "PopcntRange",
        "desc": ""
      },
      {
        "name": "Summarize",
        "desc": ""
      },
      {
        "name": "AllocRange",
        "desc": ""
      },
      {
        "name": "FindScavengeCandidate",
        "desc": ""
      },
      {
        "name": "PallocBits",
        "desc": ""
      },
      {
        "name": "Scavenged",
        "desc": ""
      },
      {
        "name": "ScavengedSetRange",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Max",
        "desc": ""
      },
      {
        "name": "Start",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      },
      {
        "name": "Pin",
        "desc": "Pin pins a Go object, preventing it from being moved or freed by the garbage collector until the [Pinner.Unpin] method has been called.  A pointer to a pinned object can be directly stored in C memory or can be contained in Go memory passed to C functions. If the pinned object itself contains pointers to Go objects, these objects must be pinned separately if they are going to be accessed from C code.  The argument must be a pointer of any type or an [unsafe.Pointer]. It's safe to call Pin on non-Go pointers, in which case Pin will do nothing."
      },
      {
        "name": "Unpin",
        "desc": "Unpin unpins all pinned objects of the [Pinner]."
      },
      {
        "name": "unpin",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Init",
        "desc": ""
      },
      {
        "name": "Lock",
        "desc": ""
      },
      {
        "name": "RLock",
        "desc": ""
      },
      {
        "name": "RUnlock",
        "desc": ""
      },
      {
        "name": "Unlock",
        "desc": ""
      },
      {
        "name": "AllocRange",
        "desc": ""
      },
      {
        "name": "Find",
        "desc": ""
      },
      {
        "name": "FreeRange",
        "desc": ""
      },
      {
        "name": "NextGen",
        "desc": ""
      },
      {
        "name": "ResetSearchAddrs",
        "desc": ""
      },
      {
        "name": "SetEmpty",
        "desc": ""
      },
      {
        "name": "BlockUntilParked",
        "desc": "BlockUntilParked blocks until the scavenger parks, or until timeout is exceeded. Returns true if the scavenger parked.  Note that in testing, parked means something slightly different. In anger, the scavenger parks to sleep, too, but in testing, it only parks when it actually has no work to do."
      },
      {
        "name": "Released",
        "desc": "Released returns how many bytes the scavenger released."
      },
      {
        "name": "Start",
        "desc": ""
      },
      {
        "name": "Stop",
        "desc": "Stop cleans up the scavenger's resources. The scavenger must be parked for this to work."
      },
      {
        "name": "Wake",
        "desc": "Wake wakes up a parked scavenger to keep running."
      },
      {
        "name": "Dequeue",
        "desc": "Dequeue simulates dequeuing a waiter for a semaphore (or lock) at addr.  Returns true if there actually was a waiter to be dequeued."
      },
      {
        "name": "Enqueue",
        "desc": "Enqueue simulates enqueuing a waiter for a semaphore (or lock) at addr."
      },
      {
        "name": "rootFor",
        "desc": ""
      },
      {
        "name": "Stack",
        "desc": "Stack returns the stack trace associated with the record, a prefix of r.Stack0."
      },
      {
        "name": "Count",
        "desc": "Count returns the counts for the given bucket, subBucket indices. Returns true if the bucket was valid, otherwise returns the counts for the overflow bucket if bucket \u003e 0 or the underflow bucket if bucket \u003c 0, and false."
      },
      {
        "name": "Record",
        "desc": ""
      },
      {
        "name": "PutString",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "newTraceMapNode",
        "desc": ""
      },
      {
        "name": "put",
        "desc": "put inserts the data into the table.  It's always safe for callers to noescape data because put copies its bytes.  Returns a unique ID for the data and whether this is the first time the data has been added to the map."
      },
      {
        "name": "reset",
        "desc": "reset drops all allocated memory from the table and resets it.  The caller must ensure that there are no put operations executing concurrently with this function."
      },
      {
        "name": "stealID",
        "desc": "stealID steals an ID from the table, ensuring that it will not appear in the table anymore."
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      },
      {
        "name": "Free",
        "desc": ""
      },
      {
        "name": "New",
        "desc": ""
      },
      {
        "name": "Slice",
        "desc": ""
      },
      {
        "name": "ctx",
        "desc": ""
      },
      {
        "name": "funcInfo",
        "desc": ""
      },
      {
        "name": "isInlined",
        "desc": "isInlined reports whether f should be re-interpreted as a *funcinl."
      },
      {
        "name": "initOpenCodedDefers",
        "desc": ""
      },
      {
        "name": "nextDefer",
        "desc": "nextDefer returns the next deferred function to invoke, if any.  Note: The \"ok bool\" result is necessary to correctly handle when the deferred function itself was nil (e.g., \"defer (func())(nil)\")."
      },
      {
        "name": "nextFrame",
        "desc": "nextFrame finds the next frame that contains deferred calls, if any."
      },
      {
        "name": "start",
        "desc": "start initializes a panic to start unwinding the stack.  If p.goexit is true, then start may return multiple times."
      },
      {
        "name": "assignArg",
        "desc": ""
      },
      {
        "name": "assignReg",
        "desc": "assignReg attempts to assign a single register for an argument with the given size, at the given offset into the value in the C ABI space.  Returns whether the assignment was successful."
      },
      {
        "name": "tryRegAssignArg",
        "desc": "tryRegAssignArg tries to register-assign a value of type t. If this type is nested in an aggregate type, then offset is the offset of this type within its parent type. Assumes t.size \u003c= goarch.PtrSize and t.size != 0.  Returns whether the assignment succeeded."
      },
      {
        "name": "tryMerge",
        "desc": ""
      },
      {
        "name": "begin",
        "desc": "begin registers a new sweeper. Returns a sweepLocker for acquiring spans for sweeping. Any outstanding sweeper blocks sweep termination.  If the sweepLocker is invalid, the caller can be sure that all outstanding sweep work has been drained, so there is nothing left to sweep. Note that there may be sweepers currently running, so this does not indicate that all sweeping has completed.  Even if the sweepLocker is invalid, its sweepGen is always valid."
      },
      {
        "name": "end",
        "desc": "end deregisters a sweeper. Must be called once for each time begin is called if the sweepLocker is valid."
      },
      {
        "name": "isDone",
        "desc": "isDone returns true if all sweep work has been drained and no more outstanding sweepers exist. That is, when the sweep phase is completely done."
      },
      {
        "name": "markDrained",
        "desc": "markDrained marks the active sweep cycle as having drained all remaining work. This is safe to be called concurrently with all other methods of activeSweep, though may race.  Returns true if this call was the one that actually performed the mark."
      },
      {
        "name": "reset",
        "desc": "reset sets up the activeSweep for the next sweep cycle.  The world must be stopped."
      },
      {
        "name": "sweepers",
        "desc": "sweepers returns the current number of active sweepers."
      },
      {
        "name": "contains",
        "desc": "contains returns whether or not the range contains a given address."
      },
      {
        "name": "removeGreaterEqual",
        "desc": "removeGreaterEqual removes all addresses in a greater than or equal to addr and returns the new range."
      },
      {
        "name": "size",
        "desc": "size returns the size of the range represented in bytes."
      },
      {
        "name": "subtract",
        "desc": "subtract takes the addrRange toPrune and cuts out any overlap with from, then returns the new range. subtract assumes that a and b either don't overlap at all, only overlap on one side, or are equal. If b is strictly contained in a, thus forcing a split, it will throw."
      },
      {
        "name": "takeFromBack",
        "desc": "takeFromBack takes len bytes from the end of the address range, aligning the limit to align after subtracting len. On success, returns the aligned start of the region taken and true."
      },
      {
        "name": "takeFromFront",
        "desc": "takeFromFront takes len bytes from the front of the address range, aligning the base to align first. On success, returns the aligned start of the region taken and true."
      },
      {
        "name": "add",
        "desc": "add inserts a new address range to a.  r must not overlap with any address range in a and r.size() must be \u003e 0."
      },
      {
        "name": "cloneInto",
        "desc": "cloneInto makes a deep clone of a's state into b, re-using b's ranges if able."
      },
      {
        "name": "contains",
        "desc": "contains returns true if a covers the address addr."
      },
      {
        "name": "findAddrGreaterEqual",
        "desc": "findAddrGreaterEqual returns the smallest address represented by a that is \u003e= addr. Thus, if the address is represented by a, then it returns addr. The second return value indicates whether such an address exists for addr in a. That is, if addr is larger than any address known to a, the second return value will be false."
      },
      {
        "name": "findSucc",
        "desc": "findSucc returns the first index in a such that addr is less than the base of the addrRange at that index."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "removeGreaterEqual",
        "desc": "removeGreaterEqual removes the ranges of a which are above addr, and additionally splits any range containing addr."
      },
      {
        "name": "removeLast",
        "desc": "removeLast removes and returns the highest-addressed contiguous range of a, or the last nBytes of that range, whichever is smaller. If a is empty, it returns an empty range."
      },
      {
        "name": "l1",
        "desc": "l1 returns the \"l1\" portion of an arenaIdx.  Marked nosplit because it's called by spanOf and other nosplit functions."
      },
      {
        "name": "l2",
        "desc": "l2 returns the \"l2\" portion of an arenaIdx.  Marked nosplit because it's called by spanOf and other nosplit funcs. functions."
      },
      {
        "name": "cas",
        "desc": "cas atomically compares-and-swaps a headTailIndex value."
      },
      {
        "name": "decHead",
        "desc": "decHead atomically decrements the head of a headTailIndex."
      },
      {
        "name": "incHead",
        "desc": "incHead atomically increments the head of a headTailIndex."
      },
      {
        "name": "incTail",
        "desc": "incTail atomically increments the tail of a headTailIndex."
      },
      {
        "name": "load",
        "desc": "load atomically reads a headTailIndex value."
      },
      {
        "name": "reset",
        "desc": "reset clears the headTailIndex to (0, 0)."
      },
      {
        "name": "Load",
        "desc": "Load returns the *mspan."
      },
      {
        "name": "StoreNoWB",
        "desc": "Store stores an *mspan."
      },
      {
        "name": "Clear",
        "desc": "Clear attempts to store minOffAddr in atomicOffAddr. It may fail if a marked value is placed in the box in the meanwhile."
      },
      {
        "name": "Load",
        "desc": "Load returns the address in the box as a virtual address. It also returns if the value was marked or not."
      },
      {
        "name": "StoreMarked",
        "desc": "StoreMarked stores addr but first converted to the offset address space and then negated."
      },
      {
        "name": "StoreMin",
        "desc": "StoreMin stores addr if it's less than the current value in the offset address space if the current value is not marked."
      },
      {
        "name": "StoreUnmark",
        "desc": "StoreUnmark attempts to unmark the value in atomicOffAddr and replace it with newAddr. markedAddr must be a marked address returned by Load. This function will not store newAddr if the box no longer contains markedAddr."
      },
      {
        "name": "load",
        "desc": "load loads and unpacks a scavChunkData."
      },
      {
        "name": "store",
        "desc": "store packs and writes a new scavChunkData. store must be serialized with other calls to store."
      },
      {
        "name": "Load",
        "desc": "Loads the spanSetSpinePointer and returns it.  It has the same semantics as atomic.UnsafePointer."
      },
      {
        "name": "StoreNoWB",
        "desc": "Stores the spanSetSpinePointer.  It has the same semantics as [atomic.UnsafePointer]."
      },
      {
        "name": "Add",
        "desc": ""
      },
      {
        "name": "AddX",
        "desc": ""
      },
      {
        "name": "offset",
        "desc": ""
      },
      {
        "name": "write",
        "desc": "Write to b cnt bits starting at bit 0 of data. Requires cnt\u003e0."
      },
      {
        "name": "ptrbit",
        "desc": "ptrbit returns the i'th bit in bv. ptrbit is less efficient than iterating directly over bitvector bits, and should only be used in non-performance-critical code. See adjustpointers for an example of a high-efficiency walk of a bitvector."
      },
      {
        "name": "keys",
        "desc": ""
      },
      {
        "name": "overflow",
        "desc": ""
      },
      {
        "name": "setoverflow",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      },
      {
        "name": "bp",
        "desc": "bp returns the blockRecord associated with the blockProfile bucket b."
      },
      {
        "name": "mp",
        "desc": "mp returns the memRecord associated with the memProfile bucket b."
      },
      {
        "name": "stk",
        "desc": "stk returns the slice in b holding the stack. The caller can assume that the backing array is immutable."
      },
      {
        "name": "l1",
        "desc": "l1 returns the index into the first level of (*pageAlloc).chunks."
      },
      {
        "name": "l2",
        "desc": "l2 returns the index into the second level of (*pageAlloc).chunks."
      },
      {
        "name": "empty",
        "desc": "empty returns true if the cleanup block is empty."
      },
      {
        "name": "enqueue",
        "desc": "enqueue pushes a single cleanup function into the block.  Returns if this enqueue call filled the block. This is odd, but we want to flush full blocks eagerly to get cleanups running as soon as possible.  Must only be called if the GC is in the sweep phase (gcphase == _GCoff), because it does not synchronize with the garbage collector."
      },
      {
        "name": "full",
        "desc": "full returns true if the cleanup block is full."
      },
      {
        "name": "take",
        "desc": "take moves as many cleanups as possible from b into a."
      },
      {
        "name": "addWork",
        "desc": "addWork indicates that n units of parallelizable work have been added to the queue."
      },
      {
        "name": "beginRunningCleanups",
        "desc": ""
      },
      {
        "name": "blockUntilEmpty",
        "desc": "blockUntilEmpty blocks until either the cleanup queue is emptied and the cleanups have been executed, or the timeout is reached. Returns true if the cleanup queue was emptied. This is used by the sync and unique tests."
      },
      {
        "name": "createGs",
        "desc": ""
      },
      {
        "name": "dequeue",
        "desc": "dequeue pops a block of cleanups from the queue. Blocks until one is available and never returns nil."
      },
      {
        "name": "endRunningCleanups",
        "desc": ""
      },
      {
        "name": "enqueue",
        "desc": "enqueue queues a single cleanup for execution.  Called by the sweeper, and only the sweeper."
      },
      {
        "name": "flush",
        "desc": "flush pushes all active cleanup blocks to the full list and wakes up cleanup goroutines to handle them.  Must only be called at a point when we can guarantee that no more cleanups are being queued, such as after the final sweeper for the cycle is done but before the next mark phase."
      },
      {
        "name": "needG",
        "desc": ""
      },
      {
        "name": "needsWake",
        "desc": "needsWake returns true if cleanup goroutines may need to be awoken or created to handle cleanup load."
      },
      {
        "name": "readQueueStats",
        "desc": ""
      },
      {
        "name": "tryTakeWork",
        "desc": "tryTakeWork is an attempt to dequeue some work by a cleanup goroutine. This might fail if there's no work to do."
      },
      {
        "name": "wake",
        "desc": "wake wakes up one or more goroutines to process the cleanup queue. If there aren't enough sleeping goroutines to handle the demand, wake will arrange for new goroutines to be created."
      },
      {
        "name": "acquire",
        "desc": "acquire returns a heapStatsDelta to be updated. In effect, it acquires the shard for writing. release must be called as soon as the relevant deltas are updated.  The returned heapStatsDelta must be updated atomically.  The caller's P must not change between acquire and release. This also means that the caller should not acquire a P or release its P in between. A P also must not acquire a given consistentHeapStats if it hasn't yet released it.  nosplit because a stack growth in this function could lead to a stack allocation that could reenter the function."
      },
      {
        "name": "read",
        "desc": "read takes a globally consistent snapshot of m and puts the aggregated value in out. Even though out is a heapStatsDelta, the resulting values should be complete and valid statistic values.  Not safe to call concurrently. The world must be stopped or metricsSema must be held."
      },
      {
        "name": "release",
        "desc": "release indicates that the writer is done modifying the delta. The value returned by the corresponding acquire must no longer be accessed or modified after release is called.  The caller's P must not change between acquire and release. This also means that the caller should not acquire a P or release its P in between.  nosplit because a stack growth in this function could lead to a stack allocation that causes another acquire before this operation has completed."
      },
      {
        "name": "unsafeClear",
        "desc": "unsafeClear clears the shard.  Unsafe because the world must be stopped and values should be donated elsewhere before clearing."
      },
      {
        "name": "unsafeRead",
        "desc": "unsafeRead aggregates the delta for this shard into out.  Unsafe because it does so without any synchronization. The world must be stopped."
      },
      {
        "name": "ip",
        "desc": ""
      },
      {
        "name": "lr",
        "desc": "386 does not have link register, so this returns 0."
      },
      {
        "name": "pushCall",
        "desc": ""
      },
      {
        "name": "set_fp",
        "desc": "386 does not have frame pointer register."
      },
      {
        "name": "set_ip",
        "desc": ""
      },
      {
        "name": "set_lr",
        "desc": ""
      },
      {
        "name": "set_sp",
        "desc": ""
      },
      {
        "name": "sp",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "add adds the stack trace to the profile. It is called from signal handlers and other limited environments and cannot allocate memory or acquire locks that might be held at the time of the signal, nor can it use substantial amounts of stack."
      },
      {
        "name": "addExtra",
        "desc": "addExtra adds the \"extra\" profiling events, queued by addNonGo, to the profile log. addExtra is called either from a signal handler on a Go thread or from an ordinary goroutine; either way it can use stack and has a g. The world may be stopped, though."
      },
      {
        "name": "addNonGo",
        "desc": "addNonGo adds the non-Go stack trace to the profile. It is called from a non-Go thread, so we cannot use much stack at all, nor do anything that needs a g or an m. In particular, we can't call cpuprof.log.write. Instead, we copy the stack into cpuprof.extra, which will be drained the next time a Go thread gets the signal handling event."
      },
      {
        "name": "accumulate",
        "desc": "accumulate takes a cpuStats and adds in the current state of all GC CPU counters.  gcMarkPhase indicates that we're in the mark phase and that certain counter values should be used."
      },
      {
        "name": "accumulateGCPauseTime",
        "desc": "accumulateGCPauseTime add dt*stwProcs to the GC CPU pause time stats. dt should be the actual time spent paused, for orthogonality. maxProcs should be GOMAXPROCS, not work.stwprocs, since this number must be comparable to a total time computed from GOMAXPROCS."
      },
      {
        "name": "accumulate",
        "desc": "accumulate takes a cpuStats and adds in the current state of all GC CPU counters.  gcMarkPhase indicates that we're in the mark phase and that certain counter values should be used."
      },
      {
        "name": "accumulateGCPauseTime",
        "desc": "accumulateGCPauseTime add dt*stwProcs to the GC CPU pause time stats. dt should be the actual time spent paused, for orthogonality. maxProcs should be GOMAXPROCS, not work.stwprocs, since this number must be comparable to a total time computed from GOMAXPROCS."
      },
      {
        "name": "compute",
        "desc": "compute populates the cpuStatsAggregate with values from the runtime."
      },
      {
        "name": "debugCallPanicOut",
        "desc": "case 2"
      },
      {
        "name": "debugCallReturn",
        "desc": "case 1"
      },
      {
        "name": "debugCallRun",
        "desc": "case 0"
      },
      {
        "name": "debugCallUnsafe",
        "desc": "case 8"
      },
      {
        "name": "handle",
        "desc": ""
      },
      {
        "name": "inject",
        "desc": ""
      },
      {
        "name": "restoreSigContext",
        "desc": "case 16"
      },
      {
        "name": "saveSigContext",
        "desc": ""
      },
      {
        "name": "header",
        "desc": ""
      },
      {
        "name": "peek",
        "desc": ""
      },
      {
        "name": "printVal",
        "desc": ""
      },
      {
        "name": "readUint16LEAt",
        "desc": ""
      },
      {
        "name": "readUint64LEAt",
        "desc": ""
      },
      {
        "name": "skip",
        "desc": ""
      },
      {
        "name": "uvarint",
        "desc": ""
      },
      {
        "name": "varint",
        "desc": ""
      },
      {
        "name": "byte",
        "desc": ""
      },
      {
        "name": "bytes",
        "desc": ""
      },
      {
        "name": "ensure",
        "desc": ""
      },
      {
        "name": "uvarint",
        "desc": ""
      },
      {
        "name": "varint",
        "desc": ""
      },
      {
        "name": "writeFrameAt",
        "desc": ""
      },
      {
        "name": "writeSync",
        "desc": ""
      },
      {
        "name": "writeUint64LE",
        "desc": ""
      },
      {
        "name": "b",
        "desc": ""
      },
      {
        "name": "end",
        "desc": ""
      },
      {
        "name": "hex",
        "desc": ""
      },
      {
        "name": "i",
        "desc": ""
      },
      {
        "name": "i16",
        "desc": ""
      },
      {
        "name": "i32",
        "desc": ""
      },
      {
        "name": "i64",
        "desc": ""
      },
      {
        "name": "i8",
        "desc": ""
      },
      {
        "name": "p",
        "desc": ""
      },
      {
        "name": "pc",
        "desc": ""
      },
      {
        "name": "s",
        "desc": ""
      },
      {
        "name": "traceback",
        "desc": ""
      },
      {
        "name": "u",
        "desc": ""
      },
      {
        "name": "u16",
        "desc": ""
      },
      {
        "name": "u32",
        "desc": ""
      },
      {
        "name": "u64",
        "desc": ""
      },
      {
        "name": "u8",
        "desc": ""
      },
      {
        "name": "uptr",
        "desc": ""
      },
      {
        "name": "B",
        "desc": ""
      },
      {
        "name": "End",
        "desc": ""
      },
      {
        "name": "Hex",
        "desc": ""
      },
      {
        "name": "I",
        "desc": ""
      },
      {
        "name": "I16",
        "desc": ""
      },
      {
        "name": "P",
        "desc": ""
      },
      {
        "name": "PC",
        "desc": ""
      },
      {
        "name": "S",
        "desc": ""
      },
      {
        "name": "U64",
        "desc": ""
      },
      {
        "name": "b",
        "desc": ""
      },
      {
        "name": "end",
        "desc": ""
      },
      {
        "name": "hex",
        "desc": ""
      },
      {
        "name": "i",
        "desc": ""
      },
      {
        "name": "i16",
        "desc": ""
      },
      {
        "name": "i32",
        "desc": ""
      },
      {
        "name": "i64",
        "desc": ""
      },
      {
        "name": "i8",
        "desc": ""
      },
      {
        "name": "p",
        "desc": ""
      },
      {
        "name": "pc",
        "desc": ""
      },
      {
        "name": "s",
        "desc": ""
      },
      {
        "name": "traceback",
        "desc": ""
      },
      {
        "name": "u",
        "desc": ""
      },
      {
        "name": "u16",
        "desc": ""
      },
      {
        "name": "u32",
        "desc": ""
      },
      {
        "name": "u64",
        "desc": ""
      },
      {
        "name": "u8",
        "desc": ""
      },
      {
        "name": "uptr",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": "Addr returns the memory address where a fault occurred. The address provided is best-effort. The veracity of the result may depend on the platform. Errors providing this method will only be returned as a result of using [runtime/debug.SetPanicOnFault]."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      },
      {
        "name": "alloc",
        "desc": ""
      },
      {
        "name": "free",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "Initialize f to allocate objects of the given size, using the allocator to obtain chunks of memory."
      },
      {
        "name": "_Func",
        "desc": ""
      },
      {
        "name": "entry",
        "desc": "entry returns the entry PC for f.  entry should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "funcInfo",
        "desc": ""
      },
      {
        "name": "isInlined",
        "desc": "isInlined reports whether f should be re-interpreted as a *funcinl."
      },
      {
        "name": "srcFunc",
        "desc": ""
      },
      {
        "name": "valid",
        "desc": ""
      },
      {
        "name": "guintptr",
        "desc": ""
      },
      {
        "name": "empty",
        "desc": "empty reports whether l is empty."
      },
      {
        "name": "pop",
        "desc": "pop removes and returns the head of l. If l is empty, it returns nil."
      },
      {
        "name": "push",
        "desc": "push adds gp to the head of l."
      },
      {
        "name": "pushAll",
        "desc": "pushAll prepends all Gs in q to l. After this q must not be used."
      },
      {
        "name": "empty",
        "desc": "empty reports whether q is empty."
      },
      {
        "name": "pop",
        "desc": "pop removes and returns the head of queue q. It returns nil if q is empty."
      },
      {
        "name": "popList",
        "desc": "popList takes all Gs in q and returns them as a gList."
      },
      {
        "name": "push",
        "desc": "push adds gp to the head of q."
      },
      {
        "name": "pushBack",
        "desc": "pushBack adds gp to the tail of q."
      },
      {
        "name": "pushBackAll",
        "desc": "pushBackAll adds all Gs in q2 to the tail of q. After this q2 must not be used."
      },
      {
        "name": "acquireStatus",
        "desc": "acquireStatus acquires the right to emit a Status event for the scheduling resource.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "nextSeq",
        "desc": "nextSeq returns the next sequence number for the resource."
      },
      {
        "name": "readyNextGen",
        "desc": "readyNextGen readies r for the generation following gen."
      },
      {
        "name": "reset",
        "desc": "reset resets the gTraceState for a new goroutine."
      },
      {
        "name": "setStatusTraced",
        "desc": "setStatusTraced indicates that the resource's status was already traced, for example when a goroutine is created."
      },
      {
        "name": "statusWasTraced",
        "desc": "statusWasTraced returns true if the sched resource's status was already acquired for tracing."
      },
      {
        "name": "bitp",
        "desc": "bitp returns a pointer to the byte containing bit n and a mask for selecting that bit from *bytep."
      },
      {
        "name": "bytep",
        "desc": "bytep returns a pointer to the n'th byte of b."
      },
      {
        "name": "tryAlloc",
        "desc": "tryAlloc allocates from b or returns nil if b does not have enough room. This is safe to call concurrently."
      },
      {
        "name": "accumulate",
        "desc": "accumulate adds time to the bucket and signals whether the limiter is enabled.  This is an internal function that deals just with the bucket. Prefer update. l.lock must be held."
      },
      {
        "name": "addAssistTime",
        "desc": "addAssistTime notifies the limiter of additional assist time. It will be included in the next update."
      },
      {
        "name": "addIdleTime",
        "desc": "addIdleTime notifies the limiter of additional time a P spent on the idle list. It will be subtracted from the total CPU time in the next update."
      },
      {
        "name": "finishGCTransition",
        "desc": "finishGCTransition notifies the limiter that the GC transition is complete and releases ownership of it. It also accumulates STW time in the bucket. now must be the timestamp from the end of the STW pause."
      },
      {
        "name": "limiting",
        "desc": "limiting returns true if the CPU limiter is currently enabled, meaning the Go GC should take action to limit CPU utilization.  It is safe to call concurrently with other operations."
      },
      {
        "name": "needUpdate",
        "desc": "needUpdate returns true if the limiter's maximum update period has been exceeded, and so would benefit from an update."
      },
      {
        "name": "resetCapacity",
        "desc": "resetCapacity updates the capacity based on GOMAXPROCS. Must not be called while the GC is enabled.  It is safe to call concurrently with other operations."
      },
      {
        "name": "startGCTransition",
        "desc": "startGCTransition notifies the limiter of a GC transition.  This call takes ownership of the limiter and disables all other means of updating the limiter. Release ownership by calling finishGCTransition.  It is safe to call concurrently with other operations."
      },
      {
        "name": "tryLock",
        "desc": "tryLock attempts to lock l. Returns true on success."
      },
      {
        "name": "unlock",
        "desc": "unlock releases the lock on l. Must be called if tryLock returns true."
      },
      {
        "name": "update",
        "desc": "update updates the bucket given runtime-specific information. now is the current monotonic time in nanoseconds.  This is safe to call concurrently with other operations, except *GCTransition."
      },
      {
        "name": "updateLocked",
        "desc": "updateLocked is the implementation of update. l.lock must be held."
      },
      {
        "name": "addGlobals",
        "desc": ""
      },
      {
        "name": "addIdleMarkWorker",
        "desc": "addIdleMarkWorker attempts to add a new idle mark worker.  If this returns true, the caller must become an idle mark worker unless there's no background mark worker goroutines in the pool. This case is harmless because there are already background mark workers running. If this returns false, the caller must NOT become an idle mark worker.  nosplit because it may be called without a P."
      },
      {
        "name": "addScannableStack",
        "desc": ""
      },
      {
        "name": "commit",
        "desc": "commit recomputes all pacing parameters needed to derive the trigger and the heap goal. Namely, the gcPercent-based heap goal, and the amount of runway we want to give the GC this cycle.  This can be called any time. If GC is the in the middle of a concurrent phase, it will adjust the pacing of that phase.  isSweepDone should be the result of calling isSweepDone(), unless we're testing or we know we're executing during a GC cycle.  This depends on gcPercent, gcController.heapMarked, and gcController.heapLive. These must be up to date.  Callers must call gcControllerState.revise after calling this function if the GC is enabled.  mheap_.lock must be held or the world must be stopped."
      },
      {
        "name": "endCycle",
        "desc": "endCycle computes the consMark estimate for the next cycle. userForced indicates whether the current GC cycle was forced by the application."
      },
      {
        "name": "enlistWorker",
        "desc": "enlistWorker encourages another dedicated mark worker to start on another P if there are spare worker slots. It is used by putfull when more work is made available.  If goexperiment.GreenTeaGC, the caller must not hold a G's scan bit, otherwise this could cause a deadlock. This is already enforced by the static lock ranking."
      },
      {
        "name": "findRunnableGCWorker",
        "desc": "findRunnableGCWorker returns a background mark worker for pp if it should be run. This must only be called when gcBlackenEnabled != 0."
      },
      {
        "name": "heapGoal",
        "desc": "heapGoal returns the current heap goal."
      },
      {
        "name": "heapGoalInternal",
        "desc": "heapGoalInternal is the implementation of heapGoal which returns additional information that is necessary for computing the trigger.  The returned minTrigger is always \u003c= goal."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "markWorkerStop",
        "desc": "markWorkerStop must be called whenever a mark worker stops executing.  It updates mark work accounting in the controller by a duration of work in nanoseconds and other bookkeeping.  Safe to execute at any time."
      },
      {
        "name": "memoryLimitHeapGoal",
        "desc": "memoryLimitHeapGoal returns a heap goal derived from memoryLimit."
      },
      {
        "name": "needIdleMarkWorker",
        "desc": "needIdleMarkWorker is a hint as to whether another idle mark worker is needed.  The caller must still call addIdleMarkWorker to become one. This is mainly useful for a quick check before an expensive operation.  nosplit because it may be called without a P."
      },
      {
        "name": "removeIdleMarkWorker",
        "desc": "removeIdleMarkWorker must be called when a new idle mark worker stops executing."
      },
      {
        "name": "resetLive",
        "desc": "resetLive sets up the controller state for the next mark phase after the end of the previous one. Must be called after endCycle and before commit, before the world is started.  The world must be stopped."
      },
      {
        "name": "revise",
        "desc": "revise updates the assist ratio during the GC cycle to account for improved estimates. This should be called whenever gcController.heapScan, gcController.heapLive, or if any inputs to gcController.heapGoal are updated. It is safe to call concurrently, but it may race with other calls to revise.  The result of this race is that the two assist ratio values may not line up or may be stale. In practice this is OK because the assist ratio moves slowly throughout a GC cycle, and the assist ratio is a best-effort heuristic anyway. Furthermore, no part of the heuristic depends on the two assist ratio values being exact reciprocals of one another, since the two values are used to convert values from different sources.  The worst case result of this raciness is that we may miss a larger shift in the ratio (say, if we decide to pace more aggressively against the hard heap goal) but even this \"hard goal\" is best-effort (see #40460). The dedicated GC should ensure we don't exceed the hard goal by too much in the rare case we do exceed it.  It should only be called when gcBlackenEnabled != 0 (because this is when assists are enabled and the necessary statistics are available)."
      },
      {
        "name": "setGCPercent",
        "desc": "setGCPercent updates gcPercent. commit must be called after. Returns the old value of gcPercent.  The world must be stopped, or mheap_.lock must be held."
      },
      {
        "name": "setMaxIdleMarkWorkers",
        "desc": "setMaxIdleMarkWorkers sets the maximum number of idle mark workers allowed.  This method is optimistic in that it does not wait for the number of idle mark workers to reduce to max before returning; it assumes the workers will deschedule themselves."
      },
      {
        "name": "setMemoryLimit",
        "desc": "setMemoryLimit updates memoryLimit. commit must be called after Returns the old value of memoryLimit.  The world must be stopped, or mheap_.lock must be held."
      },
      {
        "name": "startCycle",
        "desc": "startCycle resets the GC controller's state and computes estimates for a new GC cycle. The caller must hold worldsema and the world must be stopped."
      },
      {
        "name": "trigger",
        "desc": "trigger returns the current point at which a GC should trigger along with the heap goal.  The returned value may be compared against heapLive to determine whether the GC should trigger. Thus, the GC trigger condition should be (but may not be, in the case of small movements for efficiency) checked whenever the heap goal may change."
      },
      {
        "name": "update",
        "desc": ""
      },
      {
        "name": "compute",
        "desc": "compute populates the gcStatsAggregate with values from the runtime."
      },
      {
        "name": "test",
        "desc": "test reports whether the trigger condition is satisfied, meaning that the exit condition for the _GCoff phase has been met. The exit condition should be tested when allocating."
      },
      {
        "name": "balance",
        "desc": "balance moves some work that's cached in this gcWork back on the global queue."
      },
      {
        "name": "dispose",
        "desc": "dispose returns any cached pointers to the global queue. The buffers are being put on the full queue so that the write barriers will not simply reacquire them before the GC can inspect them. This helps reduce the mutator's ability to hide pointers during the concurrent mark phase."
      },
      {
        "name": "empty",
        "desc": "empty reports whether w has no mark work available."
      },
      {
        "name": "flushScanStats",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "putObj",
        "desc": "putObj enqueues a pointer for the garbage collector to trace. obj must point to the beginning of a heap object or an oblet."
      },
      {
        "name": "putObjBatch",
        "desc": "putObjBatch performs a put on every pointer in obj. See put for constraints on these pointers."
      },
      {
        "name": "putObjFast",
        "desc": "putObjFast does a put and reports whether it can be done quickly otherwise it returns false and the caller needs to call put."
      },
      {
        "name": "tryGetObj",
        "desc": "tryGetObj dequeues a pointer for the garbage collector to trace.  If there are no pointers remaining in this gcWork or in the global queue, tryGet returns 0.  Note that there may still be pointers in other gcWork instances or other caches."
      },
      {
        "name": "tryGetObjFast",
        "desc": "tryGetObjFast dequeues a pointer for the garbage collector to trace if one is readily available. Otherwise it returns 0 and the caller is expected to call tryGet()."
      },
      {
        "name": "tryGetSpan",
        "desc": "tryGetSpan attempts to get an entire span to scan."
      },
      {
        "name": "ptr",
        "desc": "ptr returns the *gclink form of p. The result should be used for accessing fields, not stored in other data structures."
      },
      {
        "name": "IncNonDefault",
        "desc": ""
      },
      {
        "name": "CompareAndSwap",
        "desc": ""
      },
      {
        "name": "Load",
        "desc": ""
      },
      {
        "name": "Store",
        "desc": ""
      },
      {
        "name": "cas",
        "desc": ""
      },
      {
        "name": "ptr",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "raceaddr",
        "desc": ""
      },
      {
        "name": "sortkey",
        "desc": ""
      },
      {
        "name": "head",
        "desc": "head returns the head of a headTailIndex value."
      },
      {
        "name": "split",
        "desc": "split splits the headTailIndex value into its parts."
      },
      {
        "name": "tail",
        "desc": "tail returns the tail of a headTailIndex value."
      },
      {
        "name": "compute",
        "desc": "compute populates the heapStatsAggregate with values from the runtime."
      },
      {
        "name": "merge",
        "desc": "merge adds in the deltas from b into a."
      },
      {
        "name": "merge",
        "desc": "merge adds in the deltas from b into a."
      },
      {
        "name": "createOverflow",
        "desc": ""
      },
      {
        "name": "growing",
        "desc": "growing reports whether h is growing. The growth may be to the same size or bigger."
      },
      {
        "name": "incrnoverflow",
        "desc": "incrnoverflow increments h.noverflow. noverflow counts the number of overflow buckets. This is used to trigger same-size map growth. See also tooManyOverflowBuckets. To keep hmap small, noverflow is a uint16. When there are few buckets, noverflow is an exact count. When there are many buckets, noverflow is an approximate count."
      },
      {
        "name": "newoverflow",
        "desc": ""
      },
      {
        "name": "noldbuckets",
        "desc": "noldbuckets calculates the number of buckets prior to the current map growth."
      },
      {
        "name": "oldbucketmask",
        "desc": "oldbucketmask provides a mask that can be applied to calculate n % noldbuckets()."
      },
      {
        "name": "sameSizeGrow",
        "desc": "sameSizeGrow reports whether the current growth is to a map of the same size."
      },
      {
        "name": "handle",
        "desc": "handle returns a canonical weak handle."
      },
      {
        "name": "getOrAdd",
        "desc": "getOrAdd introduces p, which must be a pointer to immortal memory (for example, a linker-allocated object) and returns a weak handle. The weak handle will never become nil."
      },
      {
        "name": "valid",
        "desc": ""
      },
      {
        "name": "fileLine",
        "desc": "fileLine returns the file name and line number of the call within the given frame. As a convenience, for the innermost frame, it returns the file and line of the PC this unwinder was started at (often this is a call to another physical function).  It returns \"?\", 0 if something goes wrong."
      },
      {
        "name": "isInlined",
        "desc": "isInlined returns whether uf is an inlined frame."
      },
      {
        "name": "next",
        "desc": "next returns the frame representing uf's logical caller."
      },
      {
        "name": "resolveInternal",
        "desc": ""
      },
      {
        "name": "srcFunc",
        "desc": "srcFunc returns the srcFunc representing the given frame.  srcFunc should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401.  The go:linkname is below."
      },
      {
        "name": "add",
        "desc": "add adds the given itab to itab table t. itabLock must be held."
      },
      {
        "name": "find",
        "desc": "find finds the given interface/type pair in t. Returns nil if the given interface/type pair isn't present."
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": ""
      },
      {
        "name": "push",
        "desc": ""
      },
      {
        "name": "consume",
        "desc": "consume acquires the partial event CPU time from any in-flight event. It achieves this by storing the current time as the new event time.  Returns the type of the in-flight event, as well as how long it's currently been executing for. Returns limiterEventNone if no event is active."
      },
      {
        "name": "start",
        "desc": "start begins tracking a new limiter event of the current type. If an event is already in flight, then a new event cannot begin because the current time is already being attributed to that event. In this case, this function returns false. Otherwise, it returns true.  The caller must be non-preemptible until at least stop is called or this function returns false. Because this is trying to measure \"on-CPU\" time of some event, getting scheduled away during it can mean that whatever we're measuring isn't a reflection of \"on-CPU\" time. The OS could deschedule us at any time, but we want to maintain as close of an approximation as we can."
      },
      {
        "name": "stop",
        "desc": "stop stops the active limiter event. Throws if the  The caller must be non-preemptible across the event. See start as to why."
      },
      {
        "name": "duration",
        "desc": "duration computes the difference between now and the start time stored in the stamp.  Returns 0 if the difference is negative, which may happen if now is stale or if the before and after timestamps cross a 2^(64-limiterEventBits) boundary."
      },
      {
        "name": "typ",
        "desc": "type extracts the event type from the stamp."
      },
      {
        "name": "alloc",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "allocBitsForIndex",
        "desc": ""
      },
      {
        "name": "base",
        "desc": ""
      },
      {
        "name": "countAlloc",
        "desc": "countAlloc returns the number of objects allocated in span s by scanning the mark bitmap."
      },
      {
        "name": "decPinCounter",
        "desc": "decPinCounter decreases the counter. If the counter reaches 0, the counter special is deleted and false is returned. Otherwise true is returned."
      },
      {
        "name": "divideByElemSize",
        "desc": "divideByElemSize returns n/s.elemsize. n must be within [0, s.npages*_PageSize), or may be exactly s.npages*_PageSize if s.elemsize is from sizeclasses.go.  nosplit, because it is called by objIndex, which is nosplit"
      },
      {
        "name": "ensureSwept",
        "desc": "Returns only when span s has been swept."
      },
      {
        "name": "getPinnerBits",
        "desc": "nosplit, because it's called by isPinned, which is nosplit"
      },
      {
        "name": "heapBits",
        "desc": "heapBits returns the heap ptr/scalar bits stored at the end of the span for small object spans and heap arena spans.  Note that the uintptr of each element means something different for small object spans and for heap arena spans. Small object spans are easy: they're never interpreted as anything but uintptr, so they're immune to differences in endianness. However, the heapBits for user arena spans is exposed through a dummy type descriptor, so the byte ordering needs to match the same byte ordering the compiler would emit. The compiler always emits the bitmap data in little endian byte ordering, so on big endian platforms these uintptrs will have their byte orders swapped from what they normally would be.  heapBitsInSpan(span.elemsize) or span.isUserArenaChunk must be true."
      },
      {
        "name": "heapBitsSmallForAddr",
        "desc": "heapBitsSmallForAddr loads the heap bits for the object stored at addr from span.heapBits.  addr must be the base pointer of an object in the span. heapBitsInSpan(span.elemsize) must be true."
      },
      {
        "name": "inList",
        "desc": ""
      },
      {
        "name": "incPinCounter",
        "desc": "incPinCounter is only called for multiple pins of the same object and records the _additional_ pins."
      },
      {
        "name": "init",
        "desc": "Initialize a new span with the given start and npages."
      },
      {
        "name": "initHeapBits",
        "desc": "initHeapBits initializes the heap bitmap for a span."
      },
      {
        "name": "initInlineMarkBits",
        "desc": "initInlineMarkBits initializes the inlineMarkBits stored at the end of the span."
      },
      {
        "name": "inlineMarkBits",
        "desc": "inlineMarkBits returns the inline mark bits for the span.  gcUsesSpanInlineMarkBits(s.elemsize) must be true."
      },
      {
        "name": "isFree",
        "desc": "isFree reports whether the index'th object in s is unallocated.  The caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change).  Callers must ensure that the index passed here must not have been produced from a pointer that came from 'thin air', as might happen with conservative scanning."
      },
      {
        "name": "isFreeOrNewlyAllocated",
        "desc": "isFreeOrNewlyAllocated reports whether the index'th object in s is either unallocated or has been allocated since the beginning of the last mark phase.  The caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change).  Callers must ensure that the index passed here must not have been produced from a pointer that came from 'thin air', as might happen with conservative scanning, unless the GC is currently in the mark phase. If the GC is currently in the mark phase, this function is safe to call for out-of-thin-air pointers."
      },
      {
        "name": "isUnusedUserArenaChunk",
        "desc": "isUnusedUserArenaChunk indicates that the arena chunk has been set to fault and doesn't contain any scannable memory anymore. However, it might still be mSpanInUse as it sits on the quarantine list, since it needs to be swept.  This is not safe to execute unless the caller has ownership of the mspan or the world is stopped (preemption is prevented while the relevant state changes).  This is really only meant to be used by accounting tests in the runtime to distinguish when a span shouldn't be counted (since mSpanInUse might not be enough)."
      },
      {
        "name": "layout",
        "desc": ""
      },
      {
        "name": "markBitsForBase",
        "desc": ""
      },
      {
        "name": "markBitsForIndex",
        "desc": ""
      },
      {
        "name": "moveInlineMarks",
        "desc": "moveInlineMarks merges the span's inline mark bits into dst and clears them.  gcUsesSpanInlineMarkBits(s.elemsize) must be true."
      },
      {
        "name": "newPinnerBits",
        "desc": "newPinnerBits returns a pointer to 8 byte aligned bytes to be used for this span's pinner bits. newPinnerBits is used to mark objects that are pinned. They are copied when the span is swept."
      },
      {
        "name": "nextFreeIndex",
        "desc": "nextFreeIndex returns the index of the next free object in s at or after s.freeindex. There are hardware instructions that can be used to make this faster if profiling warrants it."
      },
      {
        "name": "objBase",
        "desc": "objBase returns the base pointer for the object containing addr in span.  Assumes that addr points into a valid part of span (span.base() \u003c= addr \u003c span.limit)."
      },
      {
        "name": "objIndex",
        "desc": "nosplit, because it is called by other nosplit code like findObject"
      },
      {
        "name": "pinnerBitSize",
        "desc": ""
      },
      {
        "name": "refillAllocCache",
        "desc": "refillAllocCache takes 8 bytes s.allocBits starting at whichByte and negates them so that ctz (count trailing zeros) instructions can be used. It then places these 8 bytes into the cached 64 bit s.allocCache."
      },
      {
        "name": "refreshPinnerBits",
        "desc": "refreshPinnerBits replaces pinnerBits with a fresh copy in the arenas for the next GC cycle. If it does not contain any pinned objects, pinnerBits of the span is set to nil."
      },
      {
        "name": "reportZombies",
        "desc": "reportZombies reports any marked but free objects in s and throws.  This generally means one of the following:  1. User code converted a pointer to a uintptr and then back unsafely, and a GC ran while the uintptr was the only reference to an object.  2. User code (or a compiler bug) constructed a bad pointer that points to a free slot, often a past-the-end pointer.  3. The GC two cycles ago missed a pointer and freed a live object, but it was still live in the last cycle, so this GC cycle found a pointer to that object and marked it."
      },
      {
        "name": "scannedBitsForIndex",
        "desc": "scannedBitsForIndex returns a markBits representing the scanned bit for objIndex in the inline mark bits."
      },
      {
        "name": "setPinnerBits",
        "desc": ""
      },
      {
        "name": "setUserArenaChunkToFault",
        "desc": "setUserArenaChunkToFault sets the address space for the user arena chunk to fault and releases any underlying memory resources.  Must be in a non-preemptible state to ensure the consistency of statistics exported to MemStats."
      },
      {
        "name": "specialFindSplicePoint",
        "desc": "Find a splice point in the sorted list and check for an already existing record. Returns a pointer to the next-reference in the list predecessor. Returns true, if the referenced item is an exact match."
      },
      {
        "name": "typePointersOf",
        "desc": "typePointersOf returns an iterator over all heap pointers in the range [addr, addr+size).  addr and addr+size must be in the range [span.base(), span.limit).  Note: addr+size must be passed as the limit argument to the iterator's next method on each iteration. This slightly awkward API is to allow typePointers to be destructured by the compiler.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "typePointersOfType",
        "desc": "typePointersOfType is like typePointersOf, but assumes addr points to one or more contiguous instances of the provided type. The provided type must not be nil.  It returns an iterator that tiles typ's gcmask starting from addr. It's the caller's responsibility to limit iteration.  nosplit because its callers are nosplit and require all their callees to be nosplit."
      },
      {
        "name": "typePointersOfUnchecked",
        "desc": "typePointersOfUnchecked is like typePointersOf, but assumes addr is the base of an allocation slot in a span (the start of the object if no header, the header otherwise). It returns an iterator that generates all pointers in the range [addr, addr+span.elemsize).  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "userArenaNextFree",
        "desc": "userArenaNextFree reserves space in the user arena for an item of the specified type. If cap is not -1, this is for an array of cap elements of type t."
      },
      {
        "name": "writeHeapBitsSmall",
        "desc": "writeHeapBitsSmall writes the heap bits for small objects whose ptr/scalar data is stored as a bitmap at the end of the span.  Assumes dataSize is \u003c= ptrBits*goarch.PtrSize. x must be a pointer into the span. heapBitsInSpan(dataSize) must be true. dataSize must be \u003e= typ.Size_."
      },
      {
        "name": "writeUserArenaHeapBits",
        "desc": ""
      },
      {
        "name": "drain",
        "desc": "drain moves all spans in the queue to the global queue.  Returns true if anything was moved."
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "get",
        "desc": "get attempts to take a span off the queue. Might fail if the queue is empty. May be called by multiple threads, but callers are better off using stealFrom to amortize the cost of stealing. This method is intended for use by the owner of this queue."
      },
      {
        "name": "put",
        "desc": "put adds s to the queue. Returns true if put flushed to the global queue because it was full."
      },
      {
        "name": "putSlow",
        "desc": "putSlow is a helper for put to move spans to the global queue. Returns true on success, false on failure (nothing moved)."
      },
      {
        "name": "stealFrom",
        "desc": "stealFrom takes spans from q2 and puts them into q1. One span is removed from the stolen spans and returned on success. Failure to steal returns a zero objptr."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "becomeSpinning",
        "desc": ""
      },
      {
        "name": "clearAllpSnapshot",
        "desc": "Clear the saved allp snapshot. Should be called as soon as the snapshot is no longer required.  Must be called after reacquiring a P, as it requires a write barrier."
      },
      {
        "name": "hasCgoOnStack",
        "desc": ""
      },
      {
        "name": "snapshotAllp",
        "desc": "Take a snapshot of allp, for use after dropping the P.  Must be called with a P, but the returned slice may be used after dropping the P. The M holds a reference on the snapshot to keep the backing array alive."
      },
      {
        "name": "captureStack",
        "desc": ""
      },
      {
        "name": "end",
        "desc": ""
      },
      {
        "name": "recordUnlock",
        "desc": "recordUnlock prepares data for later addition to the mutex contention profile. The M may hold arbitrary locks during this call.  From unlock2, we might not be holding a p in this code."
      },
      {
        "name": "start",
        "desc": ""
      },
      {
        "name": "store",
        "desc": "store adds the M's local record to the mutex contention profile.  From unlock2, we might not be holding a p in this code."
      },
      {
        "name": "storeSlow",
        "desc": ""
      },
      {
        "name": "becomeSpinning",
        "desc": ""
      },
      {
        "name": "clearAllpSnapshot",
        "desc": "Clear the saved allp snapshot. Should be called as soon as the snapshot is no longer required.  Must be called after reacquiring a P, as it requires a write barrier."
      },
      {
        "name": "hasCgoOnStack",
        "desc": ""
      },
      {
        "name": "snapshotAllp",
        "desc": "Take a snapshot of allp, for use after dropping the P.  Must be called with a P, but the returned slice may be used after dropping the P. The M holds a reference on the snapshot to keep the backing array alive."
      },
      {
        "name": "increment",
        "desc": "increment increases the cycle count by one, wrapping the value at mProfCycleWrap. It clears the flushed flag."
      },
      {
        "name": "read",
        "desc": "read returns the current cycle count."
      },
      {
        "name": "setFlushed",
        "desc": "setFlushed sets the flushed flag. It returns the current cycle count and the previous value of the flushed flag."
      },
      {
        "name": "init",
        "desc": "Initialize an empty doubly-linked list."
      },
      {
        "name": "insert",
        "desc": ""
      },
      {
        "name": "insertBack",
        "desc": ""
      },
      {
        "name": "isEmpty",
        "desc": ""
      },
      {
        "name": "remove",
        "desc": ""
      },
      {
        "name": "takeAll",
        "desc": "takeAll removes all spans from other and inserts them at the front of list."
      },
      {
        "name": "pop",
        "desc": "pop removes a span from the head of the queue, if any."
      },
      {
        "name": "popN",
        "desc": "popN removes n spans from the head of the queue and returns them as a new queue."
      },
      {
        "name": "push",
        "desc": "push adds s to the end of the queue."
      },
      {
        "name": "takeAll",
        "desc": "takeAll removes all the spans from q2 and adds them to the end of q1, in order."
      },
      {
        "name": "get",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "advance",
        "desc": "advance advances the markBits to the next object in the span."
      },
      {
        "name": "clearMarked",
        "desc": "clearMarked clears the marked bit in the markbits, atomically."
      },
      {
        "name": "isMarked",
        "desc": "isMarked reports whether mark bit m is set."
      },
      {
        "name": "setMarked",
        "desc": "setMarked sets the marked bit in the markbits, atomically."
      },
      {
        "name": "setMarkedNonAtomic",
        "desc": "setMarkedNonAtomic sets the marked bit in the markbits, non-atomically."
      },
      {
        "name": "allocLarge",
        "desc": "allocLarge allocates a span for a large object."
      },
      {
        "name": "nextFree",
        "desc": "nextFree returns the next free object from the cached span if one is available. Otherwise it refills the cache with a span with an available object and returns that object along with a flag indicating that this was a heavy weight allocation. If it is a heavy weight allocation the caller must determine whether a new GC cycle needs to be started or if the GC is active whether this goroutine needs to assist the GC.  Must run in a non-preemptible context since otherwise the owner of c could change."
      },
      {
        "name": "prepareForSweep",
        "desc": "prepareForSweep flushes c if the system has entered a new sweep phase since c was populated. This must happen between the sweep phase starting and the first allocation from c."
      },
      {
        "name": "refill",
        "desc": "refill acquires a new span of span class spc for c. This span will have at least one free object. The current span in c must be full.  Must run in a non-preemptible context since otherwise the owner of c could change."
      },
      {
        "name": "releaseAll",
        "desc": ""
      },
      {
        "name": "cacheSpan",
        "desc": "Allocate a span to use in an mcache."
      },
      {
        "name": "fullSwept",
        "desc": "fullSwept returns the spanSet which holds swept spans without any free slots for this sweepgen."
      },
      {
        "name": "fullUnswept",
        "desc": "fullUnswept returns the spanSet which holds unswept spans without any free slots for this sweepgen."
      },
      {
        "name": "grow",
        "desc": "grow allocates a new empty span from the heap and initializes it for c's size class."
      },
      {
        "name": "init",
        "desc": "Initialize a single central free list."
      },
      {
        "name": "partialSwept",
        "desc": "partialSwept returns the spanSet which holds partially-filled swept spans for this sweepgen."
      },
      {
        "name": "partialUnswept",
        "desc": "partialUnswept returns the spanSet which holds partially-filled unswept spans for this sweepgen."
      },
      {
        "name": "uncacheSpan",
        "desc": "Return span from an mcache.  s must have a span class corresponding to this mcentral and it must not be empty."
      },
      {
        "name": "ptr",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "add accumulates b into a. It does not zero b."
      },
      {
        "name": "compute",
        "desc": ""
      },
      {
        "name": "float64HistOrInit",
        "desc": "float64HistOrInit tries to pull out an existing float64Histogram from the value, but if none exists, then it allocates one with the given buckets."
      },
      {
        "name": "alloc",
        "desc": "alloc allocates a new span of npage pages from the GC'd heap.  spanclass indicates the span's size class and scannability.  Returns a span that has been fully initialized. span.needzero indicates whether the span has been zeroed. Note that it may not be."
      },
      {
        "name": "allocMSpanLocked",
        "desc": "allocMSpanLocked allocates an mspan object.  h.lock must be held.  allocMSpanLocked must be called on the system stack because its caller holds the heap lock. See mheap for details. Running on the system stack also ensures that we won't switch Ps during this function. See tryAllocMSpan for details."
      },
      {
        "name": "allocManual",
        "desc": "allocManual allocates a manually-managed span of npage pages. allocManual returns nil if allocation fails.  allocManual adds the bytes used to *stat, which should be a memstats in-use field. Unlike allocations in the GC'd heap, the allocation does *not* count toward heapInUse.  The memory backing the returned span may not be zeroed if span.needzero is set.  allocManual must be called on the system stack because it may acquire the heap lock via allocSpan. See mheap for details.  If new code is written to call allocManual, do NOT use an existing spanAllocType value and instead declare a new one."
      },
      {
        "name": "allocNeedsZero",
        "desc": "allocNeedsZero checks if the region of address space [base, base+npage*pageSize), assumed to be allocated, needs to be zeroed, updating heap arena metadata for future allocations.  This must be called each time pages are allocated from the heap, even if the page allocator can otherwise prove the memory it's allocating is already zero because they're fresh from the operating system. It updates heapArena metadata that is critical for future page allocations.  There are no locking constraints on this method."
      },
      {
        "name": "allocSpan",
        "desc": "allocSpan allocates an mspan which owns npages worth of memory.  If typ.manual() == false, allocSpan allocates a heap span of class spanclass and updates heap accounting. If manual == true, allocSpan allocates a manually-managed span (spanclass is ignored), and the caller is responsible for any accounting related to its use of the span. Either way, allocSpan will atomically add the bytes in the newly allocated span to *sysStat.  The returned span is fully initialized.  h.lock must not be held.  allocSpan must be called on the system stack both because it acquires the heap lock and because it must block GC transitions."
      },
      {
        "name": "allocUserArenaChunk",
        "desc": "allocUserArenaChunk attempts to reuse a free user arena chunk represented as a span.  Must be in a non-preemptible state to ensure the consistency of statistics exported to MemStats.  Acquires the heap lock. Must run on the system stack for that reason."
      },
      {
        "name": "enableMetadataHugePages",
        "desc": "enableMetadataHugePages enables huge pages for various sources of heap metadata.  A note on latency: for sufficiently small heaps (\u003c10s of GiB) this function will take constant time, but may take time proportional to the size of the mapped heap beyond that.  This function is idempotent.  The heap lock must not be held over this operation, since it will briefly acquire the heap lock.  Must be called on the system stack because it acquires the heap lock."
      },
      {
        "name": "freeMSpanLocked",
        "desc": "freeMSpanLocked free an mspan object.  h.lock must be held.  freeMSpanLocked must be called on the system stack because its caller holds the heap lock. See mheap for details. Running on the system stack also ensures that we won't switch Ps during this function. See tryAllocMSpan for details."
      },
      {
        "name": "freeManual",
        "desc": "freeManual frees a manually-managed span returned by allocManual. typ must be the same as the spanAllocType passed to the allocManual that allocated s.  This must only be called when gcphase == _GCoff. See mSpanState for an explanation.  freeManual must be called on the system stack because it acquires the heap lock. See mheap for details."
      },
      {
        "name": "freeSpan",
        "desc": "Free the span back into the heap."
      },
      {
        "name": "freeSpanLocked",
        "desc": ""
      },
      {
        "name": "grow",
        "desc": "Try to add at least npage pages of memory to the heap, returning how much the heap grew by and whether it worked.  h.lock must be held."
      },
      {
        "name": "init",
        "desc": "Initialize the heap."
      },
      {
        "name": "initSpan",
        "desc": "initSpan initializes a blank span s which will represent the range [base, base+npages*pageSize). typ is the type of span being allocated."
      },
      {
        "name": "nextSpanForSweep",
        "desc": "nextSpanForSweep finds and pops the next span for sweeping from the central sweep buffers. It returns ownership of the span to the caller. Returns nil if no such span exists."
      },
      {
        "name": "reclaim",
        "desc": "reclaim sweeps and reclaims at least npage pages into the heap. It is called before allocating npage pages to keep growth in check.  reclaim implements the page-reclaimer half of the sweeper.  h.lock must NOT be held."
      },
      {
        "name": "reclaimChunk",
        "desc": "reclaimChunk sweeps unmarked spans that start at page indexes [pageIdx, pageIdx+n). It returns the number of pages returned to the heap.  h.lock must be held and the caller must be non-preemptible. Note: h.lock may be temporarily unlocked and re-locked in order to do sweeping or if tracing is enabled."
      },
      {
        "name": "scavengeAll",
        "desc": "scavengeAll acquires the heap lock (blocking any additional manipulation of the page allocator) and iterates over the whole heap, scavenging every free page available.  Must run on the system stack because it acquires the heap lock."
      },
      {
        "name": "setSpans",
        "desc": "setSpans modifies the span map so [spanOf(base), spanOf(base+npage*pageSize)) is s."
      },
      {
        "name": "sysAlloc",
        "desc": "sysAlloc allocates heap arena space for at least n bytes. The returned pointer is always heapArenaBytes-aligned and backed by h.arenas metadata. The returned size is always a multiple of heapArenaBytes. sysAlloc returns nil on failure. There is no corresponding free function.  hintList is a list of hint addresses for where to allocate new heap arenas. It must be non-nil.  sysAlloc returns a memory region in the Reserved state. This region must be transitioned to Prepared and then Ready before use.  arenaList is the list the arena should be added to.  h must be locked."
      },
      {
        "name": "tryAllocMSpan",
        "desc": "tryAllocMSpan attempts to allocate an mspan object from the P-local cache, but may fail.  h.lock need not be held.  This caller must ensure that its P won't change underneath it during this function. Currently to ensure that we enforce that the function is run on the system stack, because that's the only place it is used now. In the future, this requirement may be relaxed if its use is necessary elsewhere."
      },
      {
        "name": "funcName",
        "desc": "funcName returns the string at nameOff in the function name table."
      },
      {
        "name": "textAddr",
        "desc": "textAddr returns md.text + off, with special handling for multiple text sections. off is a (virtual) offset computed at internal linking time, before the external linker adjusts the sections' base addresses.  The text, or instruction stream is generated as one large buffer. The off (offset) for a function is its offset within this buffer. If the total text size gets too large, there can be issues on platforms like ppc64 if the target of calls are too far for the call instruction. To resolve the large text issue, the text is split into multiple text sections to allow the linker to generate long calls when necessary. When this happens, the vaddr for each text section is set to its offset within the text. Each function's offset is compared against the section vaddrs and ends to determine the containing section. Then the section relative offset is added to the section's relocated baseaddr to compute the function address.  It is nosplit because it is part of the findfunc implementation."
      },
      {
        "name": "textOff",
        "desc": "textOff is the opposite of textAddr. It converts a PC to a (virtual) offset to md.text, and returns if the PC is in any Go text section.  It is nosplit because it is part of the findfunc implementation."
      },
      {
        "name": "allocBitsForIndex",
        "desc": ""
      },
      {
        "name": "base",
        "desc": ""
      },
      {
        "name": "countAlloc",
        "desc": "countAlloc returns the number of objects allocated in span s by scanning the mark bitmap."
      },
      {
        "name": "decPinCounter",
        "desc": "decPinCounter decreases the counter. If the counter reaches 0, the counter special is deleted and false is returned. Otherwise true is returned."
      },
      {
        "name": "divideByElemSize",
        "desc": "divideByElemSize returns n/s.elemsize. n must be within [0, s.npages*_PageSize), or may be exactly s.npages*_PageSize if s.elemsize is from sizeclasses.go.  nosplit, because it is called by objIndex, which is nosplit"
      },
      {
        "name": "ensureSwept",
        "desc": "Returns only when span s has been swept."
      },
      {
        "name": "getPinnerBits",
        "desc": "nosplit, because it's called by isPinned, which is nosplit"
      },
      {
        "name": "heapBits",
        "desc": "heapBits returns the heap ptr/scalar bits stored at the end of the span for small object spans and heap arena spans.  Note that the uintptr of each element means something different for small object spans and for heap arena spans. Small object spans are easy: they're never interpreted as anything but uintptr, so they're immune to differences in endianness. However, the heapBits for user arena spans is exposed through a dummy type descriptor, so the byte ordering needs to match the same byte ordering the compiler would emit. The compiler always emits the bitmap data in little endian byte ordering, so on big endian platforms these uintptrs will have their byte orders swapped from what they normally would be.  heapBitsInSpan(span.elemsize) or span.isUserArenaChunk must be true."
      },
      {
        "name": "heapBitsSmallForAddr",
        "desc": "heapBitsSmallForAddr loads the heap bits for the object stored at addr from span.heapBits.  addr must be the base pointer of an object in the span. heapBitsInSpan(span.elemsize) must be true."
      },
      {
        "name": "inList",
        "desc": ""
      },
      {
        "name": "incPinCounter",
        "desc": "incPinCounter is only called for multiple pins of the same object and records the _additional_ pins."
      },
      {
        "name": "init",
        "desc": "Initialize a new span with the given start and npages."
      },
      {
        "name": "initHeapBits",
        "desc": "initHeapBits initializes the heap bitmap for a span."
      },
      {
        "name": "initInlineMarkBits",
        "desc": "initInlineMarkBits initializes the inlineMarkBits stored at the end of the span."
      },
      {
        "name": "inlineMarkBits",
        "desc": "inlineMarkBits returns the inline mark bits for the span.  gcUsesSpanInlineMarkBits(s.elemsize) must be true."
      },
      {
        "name": "isFree",
        "desc": "isFree reports whether the index'th object in s is unallocated.  The caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change).  Callers must ensure that the index passed here must not have been produced from a pointer that came from 'thin air', as might happen with conservative scanning."
      },
      {
        "name": "isFreeOrNewlyAllocated",
        "desc": "isFreeOrNewlyAllocated reports whether the index'th object in s is either unallocated or has been allocated since the beginning of the last mark phase.  The caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change).  Callers must ensure that the index passed here must not have been produced from a pointer that came from 'thin air', as might happen with conservative scanning, unless the GC is currently in the mark phase. If the GC is currently in the mark phase, this function is safe to call for out-of-thin-air pointers."
      },
      {
        "name": "isUnusedUserArenaChunk",
        "desc": "isUnusedUserArenaChunk indicates that the arena chunk has been set to fault and doesn't contain any scannable memory anymore. However, it might still be mSpanInUse as it sits on the quarantine list, since it needs to be swept.  This is not safe to execute unless the caller has ownership of the mspan or the world is stopped (preemption is prevented while the relevant state changes).  This is really only meant to be used by accounting tests in the runtime to distinguish when a span shouldn't be counted (since mSpanInUse might not be enough)."
      },
      {
        "name": "layout",
        "desc": ""
      },
      {
        "name": "markBitsForBase",
        "desc": ""
      },
      {
        "name": "markBitsForIndex",
        "desc": ""
      },
      {
        "name": "moveInlineMarks",
        "desc": "moveInlineMarks merges the span's inline mark bits into dst and clears them.  gcUsesSpanInlineMarkBits(s.elemsize) must be true."
      },
      {
        "name": "newPinnerBits",
        "desc": "newPinnerBits returns a pointer to 8 byte aligned bytes to be used for this span's pinner bits. newPinnerBits is used to mark objects that are pinned. They are copied when the span is swept."
      },
      {
        "name": "nextFreeIndex",
        "desc": "nextFreeIndex returns the index of the next free object in s at or after s.freeindex. There are hardware instructions that can be used to make this faster if profiling warrants it."
      },
      {
        "name": "objBase",
        "desc": "objBase returns the base pointer for the object containing addr in span.  Assumes that addr points into a valid part of span (span.base() \u003c= addr \u003c span.limit)."
      },
      {
        "name": "objIndex",
        "desc": "nosplit, because it is called by other nosplit code like findObject"
      },
      {
        "name": "pinnerBitSize",
        "desc": ""
      },
      {
        "name": "refillAllocCache",
        "desc": "refillAllocCache takes 8 bytes s.allocBits starting at whichByte and negates them so that ctz (count trailing zeros) instructions can be used. It then places these 8 bytes into the cached 64 bit s.allocCache."
      },
      {
        "name": "refreshPinnerBits",
        "desc": "refreshPinnerBits replaces pinnerBits with a fresh copy in the arenas for the next GC cycle. If it does not contain any pinned objects, pinnerBits of the span is set to nil."
      },
      {
        "name": "reportZombies",
        "desc": "reportZombies reports any marked but free objects in s and throws.  This generally means one of the following:  1. User code converted a pointer to a uintptr and then back unsafely, and a GC ran while the uintptr was the only reference to an object.  2. User code (or a compiler bug) constructed a bad pointer that points to a free slot, often a past-the-end pointer.  3. The GC two cycles ago missed a pointer and freed a live object, but it was still live in the last cycle, so this GC cycle found a pointer to that object and marked it."
      },
      {
        "name": "scannedBitsForIndex",
        "desc": "scannedBitsForIndex returns a markBits representing the scanned bit for objIndex in the inline mark bits."
      },
      {
        "name": "setPinnerBits",
        "desc": ""
      },
      {
        "name": "setUserArenaChunkToFault",
        "desc": "setUserArenaChunkToFault sets the address space for the user arena chunk to fault and releases any underlying memory resources.  Must be in a non-preemptible state to ensure the consistency of statistics exported to MemStats."
      },
      {
        "name": "specialFindSplicePoint",
        "desc": "Find a splice point in the sorted list and check for an already existing record. Returns a pointer to the next-reference in the list predecessor. Returns true, if the referenced item is an exact match."
      },
      {
        "name": "typePointersOf",
        "desc": "typePointersOf returns an iterator over all heap pointers in the range [addr, addr+size).  addr and addr+size must be in the range [span.base(), span.limit).  Note: addr+size must be passed as the limit argument to the iterator's next method on each iteration. This slightly awkward API is to allow typePointers to be destructured by the compiler.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "typePointersOfType",
        "desc": "typePointersOfType is like typePointersOf, but assumes addr points to one or more contiguous instances of the provided type. The provided type must not be nil.  It returns an iterator that tiles typ's gcmask starting from addr. It's the caller's responsibility to limit iteration.  nosplit because its callers are nosplit and require all their callees to be nosplit."
      },
      {
        "name": "typePointersOfUnchecked",
        "desc": "typePointersOfUnchecked is like typePointersOf, but assumes addr is the base of an allocation slot in a span (the start of the object if no header, the header otherwise). It returns an iterator that generates all pointers in the range [addr, addr+span.elemsize).  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "userArenaNextFree",
        "desc": "userArenaNextFree reserves space in the user arena for an item of the specified type. If cap is not -1, this is for an array of cap elements of type t."
      },
      {
        "name": "writeHeapBitsSmall",
        "desc": "writeHeapBitsSmall writes the heap bits for small objects whose ptr/scalar data is stored as a bitmap at the end of the span.  Assumes dataSize is \u003c= ptrBits*goarch.PtrSize. x must be a pointer into the span. heapBitsInSpan(dataSize) must be true. dataSize must be \u003e= typ.Size_."
      },
      {
        "name": "writeUserArenaHeapBits",
        "desc": ""
      },
      {
        "name": "ptr",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": ""
      },
      {
        "name": "push",
        "desc": "It is not allowed to allocate memory in the signal handler."
      },
      {
        "name": "objIndex",
        "desc": ""
      },
      {
        "name": "spanBase",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "add adds a uintptr offset to the offAddr."
      },
      {
        "name": "addr",
        "desc": "addr returns the virtual address for this offset address."
      },
      {
        "name": "diff",
        "desc": "diff returns the amount of bytes in between the two offAddrs."
      },
      {
        "name": "equal",
        "desc": "equal returns true if the two offAddr values are equal."
      },
      {
        "name": "lessEqual",
        "desc": "lessEqual returns true if l1 is less than or equal to l2 in the offset address space."
      },
      {
        "name": "lessThan",
        "desc": "lessThan returns true if l1 is less than l2 in the offset address space."
      },
      {
        "name": "sub",
        "desc": "sub subtracts a uintptr offset from the offAddr."
      },
      {
        "name": "destroy",
        "desc": "destroy releases all of the resources associated with pp and transitions it to status _Pdead.  sched.lock must be held and the world must be stopped."
      },
      {
        "name": "init",
        "desc": "init initializes pp, which may be a freshly allocated p or a previously destroyed p, and transitions it to status _Pgcstop."
      },
      {
        "name": "clear",
        "desc": "clear clears P id's bit."
      },
      {
        "name": "read",
        "desc": "read returns true if P id's bit is set."
      },
      {
        "name": "set",
        "desc": "set sets P id's bit."
      },
      {
        "name": "acquireStatus",
        "desc": "acquireStatus acquires the right to emit a Status event for the scheduling resource.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "nextSeq",
        "desc": "nextSeq returns the next sequence number for the resource."
      },
      {
        "name": "readyNextGen",
        "desc": "readyNextGen readies r for the generation following gen."
      },
      {
        "name": "setStatusTraced",
        "desc": "setStatusTraced indicates that the resource's status was already traced, for example when a goroutine is created."
      },
      {
        "name": "statusWasTraced",
        "desc": "statusWasTraced returns true if the sched resource's status was already acquired for tracing."
      },
      {
        "name": "alloc",
        "desc": "alloc allocates npages worth of memory from the page heap, returning the base address for the allocation and the amount of scavenged memory in bytes contained in the region [base address, base address + npages*pageSize).  Returns a 0 base address on failure, in which case other returned values should be ignored.  p.mheapLock must be held.  Must run on the system stack because p.mheapLock must be held."
      },
      {
        "name": "allocRange",
        "desc": "allocRange marks the range of memory [base, base+npages*pageSize) as allocated. It also updates the summaries to reflect the newly-updated bitmap.  Returns the amount of scavenged memory in bytes present in the allocated range.  p.mheapLock must be held."
      },
      {
        "name": "allocToCache",
        "desc": "allocToCache acquires a pageCachePages-aligned chunk of free pages which may not be contiguous, and returns a pageCache structure which owns the chunk.  p.mheapLock must be held.  Must run on the system stack because p.mheapLock must be held."
      },
      {
        "name": "chunkOf",
        "desc": "chunkOf returns the chunk at the given chunk index.  The chunk index must be valid or this method may throw."
      },
      {
        "name": "enableChunkHugePages",
        "desc": "enableChunkHugePages enables huge pages for the chunk bitmap mappings (disabled by default).  This function is idempotent.  A note on latency: for sufficiently small heaps (\u003c10s of GiB) this function will take constant time, but may take time proportional to the size of the mapped heap beyond that.  The heap lock must not be held over this operation, since it will briefly acquire the heap lock.  Must be called on the system stack because it acquires the heap lock."
      },
      {
        "name": "find",
        "desc": "find searches for the first (address-ordered) contiguous free region of npages in size and returns a base address for that region.  It uses p.searchAddr to prune its search and assumes that no palloc chunks below chunkIndex(p.searchAddr) contain any free memory at all.  find also computes and returns a candidate p.searchAddr, which may or may not prune more of the address space than p.searchAddr already does. This candidate is always a valid p.searchAddr.  find represents the slow path and the full radix tree search.  Returns a base address of 0 on failure, in which case the candidate searchAddr returned is invalid and must be ignored.  p.mheapLock must be held."
      },
      {
        "name": "findMappedAddr",
        "desc": "findMappedAddr returns the smallest mapped offAddr that is \u003e= addr. That is, if addr refers to mapped memory, then it is returned. If addr is higher than any mapped region, then it returns maxOffAddr.  p.mheapLock must be held."
      },
      {
        "name": "free",
        "desc": "free returns npages worth of memory starting at base back to the page heap.  p.mheapLock must be held.  Must run on the system stack because p.mheapLock must be held."
      },
      {
        "name": "grow",
        "desc": "grow sets up the metadata for the address range [base, base+size). It may allocate metadata, in which case *p.sysStat will be updated.  p.mheapLock must be held."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "scavenge",
        "desc": "scavenge scavenges nbytes worth of free pages, starting with the highest address first. Successive calls continue from where it left off until the heap is exhausted. force makes all memory available to scavenge, ignoring huge page heuristics.  Returns the amount of memory scavenged in bytes.  scavenge always tries to scavenge nbytes worth of memory, and will only fail to do so if the heap is exhausted for now."
      },
      {
        "name": "scavengeOne",
        "desc": "scavengeOne walks over the chunk at chunk index ci and searches for a contiguous run of pages to scavenge. It will try to scavenge at most max bytes at once, but may scavenge more to avoid breaking huge pages. Once it scavenges some memory it returns how much it scavenged in bytes.  searchIdx is the page index to start searching from in ci.  Returns the number of bytes scavenged.  Must run on the systemstack because it acquires p.mheapLock."
      },
      {
        "name": "sysGrow",
        "desc": "sysGrow performs architecture-dependent operations on heap growth for the page allocator, such as mapping in new memory for summaries. It also updates the length of the slices in p.summary.  base is the base of the newly-added heap memory and limit is the first address past the end of the newly-added heap memory. Both must be aligned to pallocChunkBytes.  The caller must update p.start and p.end after calling sysGrow."
      },
      {
        "name": "sysInit",
        "desc": "sysInit performs architecture-dependent initialization of fields in pageAlloc. pageAlloc should be uninitialized except for sysStat if any runtime statistic should be updated."
      },
      {
        "name": "tryChunkOf",
        "desc": "tryChunkOf returns the bitmap data for the given chunk.  Returns nil if the chunk data has not been mapped."
      },
      {
        "name": "update",
        "desc": "update updates heap metadata. It must be called each time the bitmap is updated.  If contig is true, update does some optimizations assuming that there was a contiguous allocation or free between addr and addr+npages. alloc indicates whether the operation performed was an allocation or a free.  p.mheapLock must be held."
      },
      {
        "name": "block64",
        "desc": "block64 returns the 64-bit aligned block of bits containing the i'th bit."
      },
      {
        "name": "clear",
        "desc": "clear clears bit i of pageBits."
      },
      {
        "name": "clearAll",
        "desc": "clearAll frees all the bits of b."
      },
      {
        "name": "clearBlock64",
        "desc": "clearBlock64 clears the 64-bit aligned block of bits containing the i'th bit that are set in v."
      },
      {
        "name": "clearRange",
        "desc": "clearRange clears bits in the range [i, i+n)."
      },
      {
        "name": "get",
        "desc": "get returns the value of the i'th bit in the bitmap."
      },
      {
        "name": "popcntRange",
        "desc": "popcntRange counts the number of set bits in the range [i, i+n)."
      },
      {
        "name": "set",
        "desc": "set sets bit i of pageBits."
      },
      {
        "name": "setAll",
        "desc": "setAll sets all the bits of b."
      },
      {
        "name": "setBlock64",
        "desc": "setBlock64 sets the 64-bit aligned block of bits containing the i'th bit that are set in v."
      },
      {
        "name": "setRange",
        "desc": "setRange sets bits in the range [i, i+n)."
      },
      {
        "name": "alloc",
        "desc": "alloc allocates npages from the page cache and is the main entry point for allocation.  Returns a base address and the amount of scavenged memory in the allocated region in bytes.  Returns a base address of zero on failure, in which case the amount of scavenged memory should be ignored."
      },
      {
        "name": "allocN",
        "desc": "allocN is a helper which attempts to allocate npages worth of pages from the cache. It represents the general case for allocating from the page cache.  Returns a base address and the amount of scavenged memory in the allocated region in bytes."
      },
      {
        "name": "empty",
        "desc": "empty reports whether the page cache has no free pages."
      },
      {
        "name": "flush",
        "desc": "flush empties out unallocated free pages in the given cache into s. Then, it clears the cache, such that empty returns true.  p.mheapLock must be held.  Must run on the system stack because p.mheapLock must be held."
      },
      {
        "name": "allocAll",
        "desc": "allocAll allocates all the bits of b."
      },
      {
        "name": "allocPages64",
        "desc": "allocPages64 allocates a 64-bit block of 64 pages aligned to 64 pages according to the bits set in alloc. The block set is the one containing the i'th page."
      },
      {
        "name": "allocRange",
        "desc": "allocRange allocates the range [i, i+n)."
      },
      {
        "name": "find",
        "desc": "find searches for npages contiguous free pages in pallocBits and returns the index where that run starts, as well as the index of the first free page it found in the search. searchIdx represents the first known free page and where to begin the next search from.  If find fails to find any free space, it returns an index of ^uint(0) and the new searchIdx should be ignored.  Note that if npages == 1, the two returned values will always be identical."
      },
      {
        "name": "find1",
        "desc": "find1 is a helper for find which searches for a single free page in the pallocBits and returns the index.  See find for an explanation of the searchIdx parameter."
      },
      {
        "name": "findLargeN",
        "desc": "findLargeN is a helper for find which searches for npages contiguous free pages in this pallocBits and returns the index where that run starts, as well as the index of the first free page it found it its search.  See alloc for an explanation of the searchIdx parameter.  Returns a ^uint(0) index on failure and the new searchIdx should be ignored.  findLargeN assumes npages \u003e 64, where any such run of free pages crosses at least one aligned 64-bit boundary in the bits."
      },
      {
        "name": "findSmallN",
        "desc": "findSmallN is a helper for find which searches for npages contiguous free pages in this pallocBits and returns the index where that run of contiguous pages starts as well as the index of the first free page it finds in its search.  See find for an explanation of the searchIdx parameter.  Returns a ^uint(0) index on failure and the new searchIdx should be ignored.  findSmallN assumes npages \u003c= 64, where any such contiguous run of pages crosses at most one aligned 64-bit boundary in the bits."
      },
      {
        "name": "free",
        "desc": "free frees the range [i, i+n) of pages in the pallocBits."
      },
      {
        "name": "free1",
        "desc": "free1 frees a single page in the pallocBits at i."
      },
      {
        "name": "freeAll",
        "desc": "freeAll frees all the bits of b."
      },
      {
        "name": "pages64",
        "desc": "pages64 returns a 64-bit bitmap representing a block of 64 pages aligned to 64 pages. The returned block of pages is the one containing the i'th page in this pallocBits. Each bit represents whether the page is in-use."
      },
      {
        "name": "summarize",
        "desc": "summarize returns a packed summary of the bitmap in pallocBits."
      },
      {
        "name": "allocAll",
        "desc": "allocAll sets every bit in the bitmap to 1 and updates the scavenged bits appropriately."
      },
      {
        "name": "allocPages64",
        "desc": "allocPages64 allocates a 64-bit block of 64 pages aligned to 64 pages according to the bits set in alloc. The block set is the one containing the i'th page."
      },
      {
        "name": "allocRange",
        "desc": "allocRange sets bits [i, i+n) in the bitmap to 1 and updates the scavenged bits appropriately."
      },
      {
        "name": "find",
        "desc": "find searches for npages contiguous free pages in pallocBits and returns the index where that run starts, as well as the index of the first free page it found in the search. searchIdx represents the first known free page and where to begin the next search from.  If find fails to find any free space, it returns an index of ^uint(0) and the new searchIdx should be ignored.  Note that if npages == 1, the two returned values will always be identical."
      },
      {
        "name": "find1",
        "desc": "find1 is a helper for find which searches for a single free page in the pallocBits and returns the index.  See find for an explanation of the searchIdx parameter."
      },
      {
        "name": "findLargeN",
        "desc": "findLargeN is a helper for find which searches for npages contiguous free pages in this pallocBits and returns the index where that run starts, as well as the index of the first free page it found it its search.  See alloc for an explanation of the searchIdx parameter.  Returns a ^uint(0) index on failure and the new searchIdx should be ignored.  findLargeN assumes npages \u003e 64, where any such run of free pages crosses at least one aligned 64-bit boundary in the bits."
      },
      {
        "name": "findScavengeCandidate",
        "desc": "findScavengeCandidate returns a start index and a size for this pallocData segment which represents a contiguous region of free and unscavenged memory.  searchIdx indicates the page index within this chunk to start the search, but note that findScavengeCandidate searches backwards through the pallocData. As a result, it will return the highest scavenge candidate in address order.  min indicates a hard minimum size and alignment for runs of pages. That is, findScavengeCandidate will not return a region smaller than min pages in size, or that is min pages or greater in size but not aligned to min. min must be a non-zero power of 2 \u003c= maxPagesPerPhysPage.  max is a hint for how big of a region is desired. If max \u003e= pallocChunkPages, then findScavengeCandidate effectively returns entire free and unscavenged regions. If max \u003c pallocChunkPages, it may truncate the returned region such that size is max. However, findScavengeCandidate may still return a larger region if, for example, it chooses to preserve huge pages, or if max is not aligned to min (it will round up). That is, even if max is small, the returned size is not guaranteed to be equal to max. max is allowed to be less than min, in which case it is as if max == min."
      },
      {
        "name": "findSmallN",
        "desc": "findSmallN is a helper for find which searches for npages contiguous free pages in this pallocBits and returns the index where that run of contiguous pages starts as well as the index of the first free page it finds in its search.  See find for an explanation of the searchIdx parameter.  Returns a ^uint(0) index on failure and the new searchIdx should be ignored.  findSmallN assumes npages \u003c= 64, where any such contiguous run of pages crosses at most one aligned 64-bit boundary in the bits."
      },
      {
        "name": "free",
        "desc": "free frees the range [i, i+n) of pages in the pallocBits."
      },
      {
        "name": "free1",
        "desc": "free1 frees a single page in the pallocBits at i."
      },
      {
        "name": "freeAll",
        "desc": "freeAll frees all the bits of b."
      },
      {
        "name": "pages64",
        "desc": "pages64 returns a 64-bit bitmap representing a block of 64 pages aligned to 64 pages. The returned block of pages is the one containing the i'th page in this pallocBits. Each bit represents whether the page is in-use."
      },
      {
        "name": "summarize",
        "desc": "summarize returns a packed summary of the bitmap in pallocBits."
      },
      {
        "name": "end",
        "desc": "end extracts the end value from a packed sum."
      },
      {
        "name": "max",
        "desc": "max extracts the max value from a packed sum."
      },
      {
        "name": "start",
        "desc": "start extracts the start value from a packed sum."
      },
      {
        "name": "unpack",
        "desc": "unpack unpacks all three values from the summary."
      },
      {
        "name": "next",
        "desc": "next provides a new sample to the controller.  input is the sample, setpoint is the desired point, and period is how much time (in whatever unit makes the most sense) has passed since the last sample.  Returns a new value for the variable it's controlling, and whether the operation completed successfully. One reason this might fail is if error has been growing in an unbounded manner, to the point of overflow.  In the specific case of an error overflow occurs, the errOverflow field will be set and the rest of the controller's internal state will be fully reset."
      },
      {
        "name": "reset",
        "desc": "reset resets the controller state, except for controller error flags."
      },
      {
        "name": "isMultiPinned",
        "desc": ""
      },
      {
        "name": "isPinned",
        "desc": "nosplit, because it's called by isPinned, which is nosplit"
      },
      {
        "name": "set",
        "desc": "set sets the pin bit of the pinState to val. If multipin is true, it sets/unsets the multipin bit instead."
      },
      {
        "name": "setMultiPinned",
        "desc": ""
      },
      {
        "name": "setPinned",
        "desc": ""
      },
      {
        "name": "unpin",
        "desc": ""
      },
      {
        "name": "ofObject",
        "desc": "ofObject returns the pinState of the n'th object. nosplit, because it's called by isPinned, which is nosplit"
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "RuntimeError",
        "desc": ""
      },
      {
        "name": "alloc",
        "desc": ""
      },
      {
        "name": "free",
        "desc": ""
      },
      {
        "name": "info",
        "desc": "info returns the pollInfo corresponding to pd."
      },
      {
        "name": "makeArg",
        "desc": "makeArg converts pd to an interface{}. makeArg does not do any allocation. Normally, such a conversion requires an allocation because pointers to types which embed internal/runtime/sys.NotInHeap (which pollDesc is) must be stored in interfaces indirectly. See issue 42076."
      },
      {
        "name": "publishInfo",
        "desc": "publishInfo updates pd.atomicInfo (returned by pd.info) using the other values in pd. It must be called while holding pd.lock, and it must be called after changing anything that might affect the info bits. In practice this means after changing closing or changing rd or wd from \u003c 0 to \u003e= 0."
      },
      {
        "name": "setEventErr",
        "desc": "setEventErr sets the result of pd.info().eventErr() to b. We only change the error bit if seq == 0 or if seq matches pollFDSeq (issue #59545)."
      },
      {
        "name": "closing",
        "desc": ""
      },
      {
        "name": "eventErr",
        "desc": ""
      },
      {
        "name": "expiredReadDeadline",
        "desc": ""
      },
      {
        "name": "expiredWriteDeadline",
        "desc": ""
      },
      {
        "name": "cas",
        "desc": ""
      },
      {
        "name": "load",
        "desc": ""
      },
      {
        "name": "store",
        "desc": ""
      },
      {
        "name": "canWriteRecord",
        "desc": "canWriteRecord reports whether the buffer has room for a single contiguous record with a stack of length nstk."
      },
      {
        "name": "canWriteTwoRecords",
        "desc": "canWriteTwoRecords reports whether the buffer has room for two records with stack lengths nstk1, nstk2, in that order. Each record must be contiguous on its own, but the two records need not be contiguous (one can be at the end of the buffer and the other can wrap around and start at the beginning of the buffer)."
      },
      {
        "name": "close",
        "desc": "close signals that there will be no more writes on the buffer. Once all the data has been read from the buffer, reads will return eof=true."
      },
      {
        "name": "hasOverflow",
        "desc": "hasOverflow reports whether b has any overflow records pending."
      },
      {
        "name": "incrementOverflow",
        "desc": "incrementOverflow records a single overflow at time now. It is racing against a possible takeOverflow in the reader."
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "takeOverflow",
        "desc": "takeOverflow consumes the pending overflow records, returning the overflow count and the time of the first overflow. When called by the reader, it is racing against incrementOverflow."
      },
      {
        "name": "wakeupExtra",
        "desc": "wakeupExtra must be called after setting one of the \"extra\" atomic fields b.overflow or b.eof. It records the change in b.w and wakes up the reader if needed."
      },
      {
        "name": "write",
        "desc": "write writes an entry to the profiling buffer b. The entry begins with a fixed hdr, which must have length b.hdrsize, followed by a variable-sized stack and a single tag pointer *tagPtr (or nil if tagPtr is nil). No write barriers allowed because this might be called from a signal handler."
      },
      {
        "name": "addCountsAndClearFlags",
        "desc": "addCountsAndClearFlags returns the packed form of \"x + (data, tag) - all flags\"."
      },
      {
        "name": "dataCount",
        "desc": ""
      },
      {
        "name": "tagCount",
        "desc": ""
      },
      {
        "name": "ptr",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "done",
        "desc": ""
      },
      {
        "name": "next",
        "desc": ""
      },
      {
        "name": "position",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "start",
        "desc": ""
      },
      {
        "name": "name",
        "desc": ""
      },
      {
        "name": "nameOff",
        "desc": ""
      },
      {
        "name": "pkgpath",
        "desc": "pkgpath returns the path of the package where t was defined, if available. This is not the same as the reflect package's PkgPath method, in that it returns the package path for struct and interface types, not just named types."
      },
      {
        "name": "string",
        "desc": ""
      },
      {
        "name": "textOff",
        "desc": ""
      },
      {
        "name": "typeOff",
        "desc": ""
      },
      {
        "name": "uncommon",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "Lock ranking an rwmutex has two aspects:  Semantic ranking: this rwmutex represents some higher level lock that protects some resource (e.g., allocmLock protects creation of new Ms). The read and write locks of that resource need to be represented in the lock rank.  Internal ranking: as an implementation detail, rwmutex uses two mutexes: rLock and wLock. These have lock order requirements: wLock must be locked before rLock. This also needs to be represented in the lock rank.  Semantic ranking is represented by acquiring readRank during read lock and writeRank during write lock.  wLock is held for the duration of a write lock, so it uses writeRank directly, both for semantic and internal ranking. rLock is only held temporarily inside the rlock/lock methods, so it uses readRankInternal to represent internal ranking. Semantic ranking is represented by a separate acquire of readRank for the duration of a read lock.  The lock ranking must document this ordering:   - readRankInternal is a leaf lock.   - readRank is taken before readRankInternal.   - writeRank is taken before readRankInternal.   - readRank is placed in the lock order wherever a read lock of this rwmutex     belongs.   - writeRank is placed in the lock order wherever a write lock of this     rwmutex belongs."
      },
      {
        "name": "lock",
        "desc": "lock locks rw for writing."
      },
      {
        "name": "rlock",
        "desc": "rlock locks rw for reading."
      },
      {
        "name": "runlock",
        "desc": "runlock undoes a single rlock call on rw."
      },
      {
        "name": "unlock",
        "desc": "unlock unlocks rw for writing."
      },
      {
        "name": "alloc",
        "desc": "alloc updates sc given that npages were allocated in the corresponding chunk."
      },
      {
        "name": "free",
        "desc": "free updates sc given that npages was freed in the corresponding chunk."
      },
      {
        "name": "isEmpty",
        "desc": "isEmpty returns true if the hasFree flag is unset."
      },
      {
        "name": "pack",
        "desc": "pack returns sc packed into a uint64."
      },
      {
        "name": "setEmpty",
        "desc": "setEmpty clears the hasFree flag."
      },
      {
        "name": "setNonEmpty",
        "desc": "setNonEmpty sets the hasFree flag."
      },
      {
        "name": "shouldScavenge",
        "desc": "shouldScavenge returns true if the corresponding chunk should be interrogated by the scavenger."
      },
      {
        "name": "isEmpty",
        "desc": "isEmpty returns true if the hasFree flag is unset."
      },
      {
        "name": "setEmpty",
        "desc": "setEmpty clears the hasFree flag."
      },
      {
        "name": "setNonEmpty",
        "desc": "setNonEmpty sets the hasFree flag."
      },
      {
        "name": "alloc",
        "desc": "alloc updates metadata for chunk at index ci with the fact that an allocation of npages occurred. It also eagerly attempts to collapse the chunk's memory into hugepage if the chunk has become sufficiently dense and we're not allocating the whole chunk at once (which suggests the allocation is part of a bigger one and it's probably not worth eagerly collapsing).  alloc may only run concurrently with find."
      },
      {
        "name": "find",
        "desc": "find returns the highest chunk index that may contain pages available to scavenge. It also returns an offset to start searching in the highest chunk."
      },
      {
        "name": "free",
        "desc": "free updates metadata for chunk at index ci with the fact that a free of npages occurred.  free may only run concurrently with find."
      },
      {
        "name": "grow",
        "desc": "sysGrow updates the index's backing store in response to a heap growth.  Returns the amount of memory added to sysStat."
      },
      {
        "name": "init",
        "desc": "init initializes the scavengeIndex.  Returns the amount added to sysStat."
      },
      {
        "name": "nextGen",
        "desc": "nextGen moves the scavenger forward one generation. Must be called once per GC cycle, but may be called more often to force more memory to be released.  nextGen may only run concurrently with find."
      },
      {
        "name": "setEmpty",
        "desc": "setEmpty marks that the scavenger has finished looking at ci for now to prevent the scavenger from getting stuck looking at the same chunk.  setEmpty may only run concurrently with find."
      },
      {
        "name": "sysGrow",
        "desc": "sysGrow increases the index's backing store in response to a heap growth.  Returns the amount of memory added to sysStat."
      },
      {
        "name": "sysInit",
        "desc": "sysInit initializes the scavengeIndex' chunks array.  Returns the amount of memory added to sysStat."
      },
      {
        "name": "controllerFailed",
        "desc": "controllerFailed indicates that the scavenger's scheduling controller failed."
      },
      {
        "name": "init",
        "desc": "init initializes a scavenger state and wires to the current G.  Must be called from a regular goroutine that can allocate."
      },
      {
        "name": "park",
        "desc": "park parks the scavenger goroutine."
      },
      {
        "name": "ready",
        "desc": "ready signals to sysmon that the scavenger should be awoken."
      },
      {
        "name": "run",
        "desc": "run is the body of the main scavenging loop.  Returns the number of bytes released and the estimated time spent releasing those bytes.  Must be run on the scavenger goroutine."
      },
      {
        "name": "sleep",
        "desc": "sleep puts the scavenger to sleep based on the amount of time that it worked in nanoseconds.  Note that this function should only be called by the scavenger.  The scavenger may be woken up earlier by a pacing change, and it may not go to sleep at all if there's a pending pacing change."
      },
      {
        "name": "wake",
        "desc": "wake immediately unparks the scavenger if necessary.  Safe to run without a P."
      },
      {
        "name": "rootFor",
        "desc": ""
      },
      {
        "name": "dequeue",
        "desc": "dequeue searches for and finds the first goroutine in semaRoot blocked on addr. If the sudog was being profiled, dequeue returns the time at which it was woken up as now. Otherwise now is 0. If there are additional entries in the wait list, dequeue returns tailtime set to the last entry's acquiretime. Otherwise tailtime is found.acquiretime."
      },
      {
        "name": "queue",
        "desc": "queue adds s to the blocked goroutines in semaRoot."
      },
      {
        "name": "rotateLeft",
        "desc": "rotateLeft rotates the tree rooted at node x. turning (x a (y b c)) into (y (x a b) c)."
      },
      {
        "name": "rotateRight",
        "desc": "rotateRight rotates the tree rooted at node y. turning (y (x a b) c) into (x a (y b c))."
      },
      {
        "name": "a0",
        "desc": ""
      },
      {
        "name": "a1",
        "desc": ""
      },
      {
        "name": "a2",
        "desc": ""
      },
      {
        "name": "a3",
        "desc": ""
      },
      {
        "name": "a4",
        "desc": ""
      },
      {
        "name": "a5",
        "desc": ""
      },
      {
        "name": "a6",
        "desc": ""
      },
      {
        "name": "a7",
        "desc": ""
      },
      {
        "name": "ccr",
        "desc": ""
      },
      {
        "name": "cpsr",
        "desc": ""
      },
      {
        "name": "cregs",
        "desc": ""
      },
      {
        "name": "cs",
        "desc": ""
      },
      {
        "name": "ctr",
        "desc": ""
      },
      {
        "name": "eax",
        "desc": ""
      },
      {
        "name": "ebp",
        "desc": ""
      },
      {
        "name": "ebx",
        "desc": ""
      },
      {
        "name": "ecx",
        "desc": ""
      },
      {
        "name": "edi",
        "desc": ""
      },
      {
        "name": "edx",
        "desc": ""
      },
      {
        "name": "eflags",
        "desc": ""
      },
      {
        "name": "eip",
        "desc": ""
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "esi",
        "desc": ""
      },
      {
        "name": "esp",
        "desc": ""
      },
      {
        "name": "fault",
        "desc": ""
      },
      {
        "name": "fixsigcode",
        "desc": ""
      },
      {
        "name": "fp",
        "desc": ""
      },
      {
        "name": "fpscr",
        "desc": ""
      },
      {
        "name": "fpscrx",
        "desc": ""
      },
      {
        "name": "fs",
        "desc": ""
      },
      {
        "name": "gp",
        "desc": ""
      },
      {
        "name": "gs",
        "desc": ""
      },
      {
        "name": "hi",
        "desc": ""
      },
      {
        "name": "ip",
        "desc": ""
      },
      {
        "name": "link",
        "desc": ""
      },
      {
        "name": "lo",
        "desc": ""
      },
      {
        "name": "lr",
        "desc": ""
      },
      {
        "name": "oldmask",
        "desc": ""
      },
      {
        "name": "pc",
        "desc": ""
      },
      {
        "name": "preparePanic",
        "desc": "preparePanic sets up the stack to look like a call to sigpanic."
      },
      {
        "name": "pstate",
        "desc": ""
      },
      {
        "name": "pushCall",
        "desc": ""
      },
      {
        "name": "r0",
        "desc": ""
      },
      {
        "name": "r1",
        "desc": ""
      },
      {
        "name": "r10",
        "desc": ""
      },
      {
        "name": "r11",
        "desc": ""
      },
      {
        "name": "r12",
        "desc": ""
      },
      {
        "name": "r13",
        "desc": ""
      },
      {
        "name": "r14",
        "desc": ""
      },
      {
        "name": "r15",
        "desc": ""
      },
      {
        "name": "r16",
        "desc": ""
      },
      {
        "name": "r17",
        "desc": ""
      },
      {
        "name": "r18",
        "desc": ""
      },
      {
        "name": "r19",
        "desc": ""
      },
      {
        "name": "r2",
        "desc": ""
      },
      {
        "name": "r20",
        "desc": ""
      },
      {
        "name": "r21",
        "desc": ""
      },
      {
        "name": "r22",
        "desc": ""
      },
      {
        "name": "r23",
        "desc": ""
      },
      {
        "name": "r24",
        "desc": ""
      },
      {
        "name": "r25",
        "desc": ""
      },
      {
        "name": "r26",
        "desc": ""
      },
      {
        "name": "r27",
        "desc": ""
      },
      {
        "name": "r28",
        "desc": ""
      },
      {
        "name": "r29",
        "desc": ""
      },
      {
        "name": "r3",
        "desc": ""
      },
      {
        "name": "r30",
        "desc": ""
      },
      {
        "name": "r31",
        "desc": ""
      },
      {
        "name": "r4",
        "desc": ""
      },
      {
        "name": "r5",
        "desc": ""
      },
      {
        "name": "r6",
        "desc": ""
      },
      {
        "name": "r7",
        "desc": ""
      },
      {
        "name": "r8",
        "desc": ""
      },
      {
        "name": "r9",
        "desc": ""
      },
      {
        "name": "ra",
        "desc": ""
      },
      {
        "name": "rax",
        "desc": ""
      },
      {
        "name": "rbp",
        "desc": ""
      },
      {
        "name": "rbx",
        "desc": ""
      },
      {
        "name": "rcx",
        "desc": ""
      },
      {
        "name": "rdi",
        "desc": ""
      },
      {
        "name": "rdx",
        "desc": ""
      },
      {
        "name": "regs",
        "desc": ""
      },
      {
        "name": "rflags",
        "desc": ""
      },
      {
        "name": "rip",
        "desc": ""
      },
      {
        "name": "rsi",
        "desc": ""
      },
      {
        "name": "rsp",
        "desc": ""
      },
      {
        "name": "s0",
        "desc": ""
      },
      {
        "name": "s1",
        "desc": ""
      },
      {
        "name": "s10",
        "desc": ""
      },
      {
        "name": "s11",
        "desc": ""
      },
      {
        "name": "s2",
        "desc": ""
      },
      {
        "name": "s3",
        "desc": ""
      },
      {
        "name": "s4",
        "desc": ""
      },
      {
        "name": "s5",
        "desc": ""
      },
      {
        "name": "s6",
        "desc": ""
      },
      {
        "name": "s7",
        "desc": ""
      },
      {
        "name": "s8",
        "desc": ""
      },
      {
        "name": "s9",
        "desc": ""
      },
      {
        "name": "savelr",
        "desc": ""
      },
      {
        "name": "set_eip",
        "desc": ""
      },
      {
        "name": "set_esp",
        "desc": ""
      },
      {
        "name": "set_gp",
        "desc": ""
      },
      {
        "name": "set_link",
        "desc": ""
      },
      {
        "name": "set_lr",
        "desc": ""
      },
      {
        "name": "set_pc",
        "desc": ""
      },
      {
        "name": "set_r0",
        "desc": ""
      },
      {
        "name": "set_r10",
        "desc": ""
      },
      {
        "name": "set_r12",
        "desc": ""
      },
      {
        "name": "set_r13",
        "desc": ""
      },
      {
        "name": "set_r22",
        "desc": ""
      },
      {
        "name": "set_r28",
        "desc": ""
      },
      {
        "name": "set_r30",
        "desc": ""
      },
      {
        "name": "set_r31",
        "desc": ""
      },
      {
        "name": "set_ra",
        "desc": ""
      },
      {
        "name": "set_rip",
        "desc": ""
      },
      {
        "name": "set_rsp",
        "desc": ""
      },
      {
        "name": "set_sigaddr",
        "desc": ""
      },
      {
        "name": "set_sigcode",
        "desc": ""
      },
      {
        "name": "set_sp",
        "desc": ""
      },
      {
        "name": "setlr",
        "desc": ""
      },
      {
        "name": "setpc",
        "desc": ""
      },
      {
        "name": "setsigpc",
        "desc": ""
      },
      {
        "name": "setsp",
        "desc": ""
      },
      {
        "name": "sigFromSeccomp",
        "desc": "sigFromSeccomp reports whether the signal was sent from seccomp."
      },
      {
        "name": "sigFromUser",
        "desc": "sigFromUser reports whether the signal was sent because of a call to kill or tgkill."
      },
      {
        "name": "sigaddr",
        "desc": ""
      },
      {
        "name": "sigcode",
        "desc": ""
      },
      {
        "name": "siglr",
        "desc": ""
      },
      {
        "name": "sigpc",
        "desc": ""
      },
      {
        "name": "sigsp",
        "desc": ""
      },
      {
        "name": "sp",
        "desc": ""
      },
      {
        "name": "t0",
        "desc": ""
      },
      {
        "name": "t1",
        "desc": ""
      },
      {
        "name": "t2",
        "desc": ""
      },
      {
        "name": "t3",
        "desc": ""
      },
      {
        "name": "t4",
        "desc": ""
      },
      {
        "name": "t5",
        "desc": ""
      },
      {
        "name": "t6",
        "desc": ""
      },
      {
        "name": "tp",
        "desc": ""
      },
      {
        "name": "trap",
        "desc": "TODO(aix): find trap equivalent"
      },
      {
        "name": "xer",
        "desc": ""
      },
      {
        "name": "manual",
        "desc": "manual returns true if the span allocation is manually managed."
      },
      {
        "name": "noscan",
        "desc": ""
      },
      {
        "name": "sizeclass",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "release",
        "desc": "release releases the span for scanning, allowing another thread to queue the span.  Returns an upper bound on the number of mark bits set since the span was queued. The upper bound is described as \"one\" (spanScanOneMark) or \"many\" (spanScanManyMark, with or without spanScanOneMark). If the return value indicates only one mark bit was set, the caller can be certain that it was the same mark bit that caused the span to get queued. Take note of the fact that this is *only* an upper-bound. In particular, it may still turn out that only one mark bit was set, even if the return value indicates \"many\"."
      },
      {
        "name": "tryAcquire",
        "desc": "tryAcquire attempts to acquire the span for scanning. On success, the caller must queue the span for scanning or scan the span immediately."
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "get",
        "desc": "get tries to take a span off the queue.  Returns a non-zero objptr on success. Also, moves additional spans to gcw's local span queue."
      },
      {
        "name": "putBatch",
        "desc": "putBatch adds a whole batch of spans to the queue."
      },
      {
        "name": "size",
        "desc": ""
      },
      {
        "name": "load",
        "desc": "load atomically loads from a pointer to a spanScanOwnership."
      },
      {
        "name": "or",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": "pop removes and returns a span from buffer b, or nil if b is empty. pop is safe to call concurrently with other pop and push operations."
      },
      {
        "name": "push",
        "desc": "push adds span s to buffer b. push is safe to call concurrently with other push and pop operations."
      },
      {
        "name": "reset",
        "desc": "reset resets a spanSet which is empty. It will also clean up any left over blocks.  Throws if the buf is not empty.  reset may not be called concurrently with any other operations on the span set."
      },
      {
        "name": "alloc",
        "desc": "alloc tries to grab a spanSetBlock out of the pool, and if it fails persistentallocs a new one and returns it."
      },
      {
        "name": "free",
        "desc": "free returns a spanSetBlock back to the pool."
      },
      {
        "name": "lookup",
        "desc": "lookup returns \u0026s[idx]."
      },
      {
        "name": "next",
        "desc": ""
      },
      {
        "name": "unlinkAndNext",
        "desc": "unlinkAndNext removes the current special from the list and moves the iterator to the next special. It returns the unlinked special."
      },
      {
        "name": "valid",
        "desc": ""
      },
      {
        "name": "name",
        "desc": "name should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/phuslu/log  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "setRecord",
        "desc": "obj.r = r, but with no write barrier."
      },
      {
        "name": "gcdata",
        "desc": "gcdata returns the number of bytes that contain pointers, and a ptr/nonptr bitmask covering those bytes. Note that this bitmask might be larger than internal/abi.MaxPtrmaskBytes."
      },
      {
        "name": "addObject",
        "desc": "addObject adds a stack object at addr of type typ to the set of stack objects."
      },
      {
        "name": "buildIndex",
        "desc": "buildIndex initializes s.root to a binary search tree. It should be called after all addObject calls but before any call of findObject."
      },
      {
        "name": "findObject",
        "desc": "findObject returns the stack object containing address a, if any. Must have called buildIndex previously."
      },
      {
        "name": "getPtr",
        "desc": "Remove and return a potential pointer to a stack object. Returns 0 if there are no more pointers available.  This prefers non-conservative pointers so we scan stack objects precisely if there are any non-conservative pointers to them."
      },
      {
        "name": "putPtr",
        "desc": "Add p as a potential pointer to a stack object. p must be a stack address."
      },
      {
        "name": "ensure",
        "desc": "ensure populates statistics aggregates determined by deps if they haven't yet been populated."
      },
      {
        "name": "difference",
        "desc": "difference returns set difference of s from b as a new set."
      },
      {
        "name": "empty",
        "desc": "empty returns true if there are no dependencies in the set."
      },
      {
        "name": "has",
        "desc": "has returns true if the set contains a given statDep."
      },
      {
        "name": "union",
        "desc": "union returns the union of the two sets as a new set."
      },
      {
        "name": "argBytes",
        "desc": "argBytes returns the argument frame size for a call to frame.fn."
      },
      {
        "name": "argMapInternal",
        "desc": "argMapInternal is used internally by stkframe to fetch special argument maps.  argMap.n is always populated with the size of the argument map.  argMap.bytedata is only populated for dynamic argument maps (used by reflect). If the caller requires the argument map, it should use this if non-nil, and otherwise fetch the argument map using the current PC.  hasReflectStackObj indicates that this frame also has a reflect function stack object, which the caller must synthesize."
      },
      {
        "name": "getStackMap",
        "desc": "getStackMap returns the locals and arguments live pointer maps, and stack object list for frame."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isGC",
        "desc": ""
      },
      {
        "name": "eventtype",
        "desc": ""
      },
      {
        "name": "subscriptionClock",
        "desc": ""
      },
      {
        "name": "subscriptionFdReadwrite",
        "desc": ""
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "load",
        "desc": ""
      },
      {
        "name": "split",
        "desc": "split returns the underlying span class as well as whether we're interested in the full or partial unswept lists for that class, indicated as a boolean (true means \"full\")."
      },
      {
        "name": "update",
        "desc": ""
      },
      {
        "name": "allocBitsForIndex",
        "desc": ""
      },
      {
        "name": "base",
        "desc": ""
      },
      {
        "name": "countAlloc",
        "desc": "countAlloc returns the number of objects allocated in span s by scanning the mark bitmap."
      },
      {
        "name": "decPinCounter",
        "desc": "decPinCounter decreases the counter. If the counter reaches 0, the counter special is deleted and false is returned. Otherwise true is returned."
      },
      {
        "name": "divideByElemSize",
        "desc": "divideByElemSize returns n/s.elemsize. n must be within [0, s.npages*_PageSize), or may be exactly s.npages*_PageSize if s.elemsize is from sizeclasses.go.  nosplit, because it is called by objIndex, which is nosplit"
      },
      {
        "name": "ensureSwept",
        "desc": "Returns only when span s has been swept."
      },
      {
        "name": "getPinnerBits",
        "desc": "nosplit, because it's called by isPinned, which is nosplit"
      },
      {
        "name": "heapBits",
        "desc": "heapBits returns the heap ptr/scalar bits stored at the end of the span for small object spans and heap arena spans.  Note that the uintptr of each element means something different for small object spans and for heap arena spans. Small object spans are easy: they're never interpreted as anything but uintptr, so they're immune to differences in endianness. However, the heapBits for user arena spans is exposed through a dummy type descriptor, so the byte ordering needs to match the same byte ordering the compiler would emit. The compiler always emits the bitmap data in little endian byte ordering, so on big endian platforms these uintptrs will have their byte orders swapped from what they normally would be.  heapBitsInSpan(span.elemsize) or span.isUserArenaChunk must be true."
      },
      {
        "name": "heapBitsSmallForAddr",
        "desc": "heapBitsSmallForAddr loads the heap bits for the object stored at addr from span.heapBits.  addr must be the base pointer of an object in the span. heapBitsInSpan(span.elemsize) must be true."
      },
      {
        "name": "inList",
        "desc": ""
      },
      {
        "name": "incPinCounter",
        "desc": "incPinCounter is only called for multiple pins of the same object and records the _additional_ pins."
      },
      {
        "name": "init",
        "desc": "Initialize a new span with the given start and npages."
      },
      {
        "name": "initHeapBits",
        "desc": "initHeapBits initializes the heap bitmap for a span."
      },
      {
        "name": "initInlineMarkBits",
        "desc": "initInlineMarkBits initializes the inlineMarkBits stored at the end of the span."
      },
      {
        "name": "inlineMarkBits",
        "desc": "inlineMarkBits returns the inline mark bits for the span.  gcUsesSpanInlineMarkBits(s.elemsize) must be true."
      },
      {
        "name": "isFree",
        "desc": "isFree reports whether the index'th object in s is unallocated.  The caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change).  Callers must ensure that the index passed here must not have been produced from a pointer that came from 'thin air', as might happen with conservative scanning."
      },
      {
        "name": "isFreeOrNewlyAllocated",
        "desc": "isFreeOrNewlyAllocated reports whether the index'th object in s is either unallocated or has been allocated since the beginning of the last mark phase.  The caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change).  Callers must ensure that the index passed here must not have been produced from a pointer that came from 'thin air', as might happen with conservative scanning, unless the GC is currently in the mark phase. If the GC is currently in the mark phase, this function is safe to call for out-of-thin-air pointers."
      },
      {
        "name": "isUnusedUserArenaChunk",
        "desc": "isUnusedUserArenaChunk indicates that the arena chunk has been set to fault and doesn't contain any scannable memory anymore. However, it might still be mSpanInUse as it sits on the quarantine list, since it needs to be swept.  This is not safe to execute unless the caller has ownership of the mspan or the world is stopped (preemption is prevented while the relevant state changes).  This is really only meant to be used by accounting tests in the runtime to distinguish when a span shouldn't be counted (since mSpanInUse might not be enough)."
      },
      {
        "name": "layout",
        "desc": ""
      },
      {
        "name": "markBitsForBase",
        "desc": ""
      },
      {
        "name": "markBitsForIndex",
        "desc": ""
      },
      {
        "name": "moveInlineMarks",
        "desc": "moveInlineMarks merges the span's inline mark bits into dst and clears them.  gcUsesSpanInlineMarkBits(s.elemsize) must be true."
      },
      {
        "name": "newPinnerBits",
        "desc": "newPinnerBits returns a pointer to 8 byte aligned bytes to be used for this span's pinner bits. newPinnerBits is used to mark objects that are pinned. They are copied when the span is swept."
      },
      {
        "name": "nextFreeIndex",
        "desc": "nextFreeIndex returns the index of the next free object in s at or after s.freeindex. There are hardware instructions that can be used to make this faster if profiling warrants it."
      },
      {
        "name": "objBase",
        "desc": "objBase returns the base pointer for the object containing addr in span.  Assumes that addr points into a valid part of span (span.base() \u003c= addr \u003c span.limit)."
      },
      {
        "name": "objIndex",
        "desc": "nosplit, because it is called by other nosplit code like findObject"
      },
      {
        "name": "pinnerBitSize",
        "desc": ""
      },
      {
        "name": "refillAllocCache",
        "desc": "refillAllocCache takes 8 bytes s.allocBits starting at whichByte and negates them so that ctz (count trailing zeros) instructions can be used. It then places these 8 bytes into the cached 64 bit s.allocCache."
      },
      {
        "name": "refreshPinnerBits",
        "desc": "refreshPinnerBits replaces pinnerBits with a fresh copy in the arenas for the next GC cycle. If it does not contain any pinned objects, pinnerBits of the span is set to nil."
      },
      {
        "name": "reportZombies",
        "desc": "reportZombies reports any marked but free objects in s and throws.  This generally means one of the following:  1. User code converted a pointer to a uintptr and then back unsafely, and a GC ran while the uintptr was the only reference to an object.  2. User code (or a compiler bug) constructed a bad pointer that points to a free slot, often a past-the-end pointer.  3. The GC two cycles ago missed a pointer and freed a live object, but it was still live in the last cycle, so this GC cycle found a pointer to that object and marked it."
      },
      {
        "name": "scannedBitsForIndex",
        "desc": "scannedBitsForIndex returns a markBits representing the scanned bit for objIndex in the inline mark bits."
      },
      {
        "name": "setPinnerBits",
        "desc": ""
      },
      {
        "name": "setUserArenaChunkToFault",
        "desc": "setUserArenaChunkToFault sets the address space for the user arena chunk to fault and releases any underlying memory resources.  Must be in a non-preemptible state to ensure the consistency of statistics exported to MemStats."
      },
      {
        "name": "specialFindSplicePoint",
        "desc": "Find a splice point in the sorted list and check for an already existing record. Returns a pointer to the next-reference in the list predecessor. Returns true, if the referenced item is an exact match."
      },
      {
        "name": "sweep",
        "desc": "sweep frees or collects finalizers for blocks not marked in the mark phase. It clears the mark bits in preparation for the next GC round. Returns true if the span was returned to heap. If preserve=true, don't return it to heap nor relink in mcentral lists; caller takes care of it."
      },
      {
        "name": "typePointersOf",
        "desc": "typePointersOf returns an iterator over all heap pointers in the range [addr, addr+size).  addr and addr+size must be in the range [span.base(), span.limit).  Note: addr+size must be passed as the limit argument to the iterator's next method on each iteration. This slightly awkward API is to allow typePointers to be destructured by the compiler.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "typePointersOfType",
        "desc": "typePointersOfType is like typePointersOf, but assumes addr points to one or more contiguous instances of the provided type. The provided type must not be nil.  It returns an iterator that tiles typ's gcmask starting from addr. It's the caller's responsibility to limit iteration.  nosplit because its callers are nosplit and require all their callees to be nosplit."
      },
      {
        "name": "typePointersOfUnchecked",
        "desc": "typePointersOfUnchecked is like typePointersOf, but assumes addr is the base of an allocation slot in a span (the start of the object if no header, the header otherwise). It returns an iterator that generates all pointers in the range [addr, addr+span.elemsize).  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "userArenaNextFree",
        "desc": "userArenaNextFree reserves space in the user arena for an item of the specified type. If cap is not -1, this is for an array of cap elements of type t."
      },
      {
        "name": "writeHeapBitsSmall",
        "desc": "writeHeapBitsSmall writes the heap bits for small objects whose ptr/scalar data is stored as a bitmap at the end of the span.  Assumes dataSize is \u003c= ptrBits*goarch.PtrSize. x must be a pointer into the span. heapBitsInSpan(dataSize) must be true. dataSize must be \u003e= typ.Size_."
      },
      {
        "name": "writeUserArenaHeapBits",
        "desc": ""
      },
      {
        "name": "tryAcquire",
        "desc": "tryAcquire attempts to acquire sweep ownership of span s. If it successfully acquires ownership, it blocks sweep completion."
      },
      {
        "name": "changegstatus",
        "desc": "changegstatus is called when the non-lock status of a g changes. It is never called with a Gscanstatus."
      },
      {
        "name": "decActive",
        "desc": "decActive decrements the active-count for the bubble."
      },
      {
        "name": "incActive",
        "desc": "incActive increments the active-count for the bubble. A bubble does not become durably blocked while the active-count is non-zero."
      },
      {
        "name": "maybeWakeLocked",
        "desc": "maybeWakeLocked returns a g to wake if the bubble is durably blocked."
      },
      {
        "name": "raceaddr",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "add",
        "desc": "add atomically adds the sysMemStat by n.  Must be nosplit as it is called in runtime initialization, e.g. newosproc0."
      },
      {
        "name": "load",
        "desc": "load atomically reads the value of the stat.  Must be nosplit as it is called in runtime initialization, e.g. newosproc0."
      },
      {
        "name": "compute",
        "desc": "compute populates the sysStatsAggregate with values from the runtime."
      },
      {
        "name": "pointer",
        "desc": "Pointer returns the pointer from a taggedPointer."
      },
      {
        "name": "tag",
        "desc": "Tag returns the tag from a taggedPointer."
      },
      {
        "name": "init",
        "desc": "init initializes ticks to maximize the chance that we have a good ticksPerSecond reference.  Must not run concurrently with ticksPerSecond."
      },
      {
        "name": "record",
        "desc": "record adds the given duration to the distribution.  Disallow preemptions and stack growths because this function may run in sensitive locations."
      },
      {
        "name": "write",
        "desc": "write dumps the histogram to the passed metricValue as a float64 histogram."
      },
      {
        "name": "hchan",
        "desc": "hchan returns the channel in t.arg. t must be a timer with a channel."
      },
      {
        "name": "init",
        "desc": "init initializes a newly allocated timer t. Any code that allocates a timer must call t.init before using it. The arg and f can be set during init, or they can be nil in init and set by a future call to t.modify."
      },
      {
        "name": "lock",
        "desc": "lock locks the timer, allowing reading or writing any of the timer fields."
      },
      {
        "name": "maybeAdd",
        "desc": "maybeAdd adds t to the local timers heap if it needs to be in a heap. The caller must not hold t's lock nor any timers heap lock. The caller probably just unlocked t, but that lock must be dropped in order to acquire a ts.lock, to avoid lock inversions. (timers.adjust holds ts.lock while acquiring each t's lock, so we cannot hold any t's lock while acquiring ts.lock).  Strictly speaking it *might* be okay to hold t.lock and acquire ts.lock at the same time, because we know that t is not in any ts.heap, so nothing holding a ts.lock would be acquiring the t.lock at the same time, meaning there isn't a possible deadlock. But it is easier and safer not to be too clever and respect the static ordering. (If we don't, we have to change the static lock checking of t and ts.)  Concurrent calls to time.Timer.Reset or blockTimerChan may result in concurrent calls to t.maybeAdd, so we cannot assume that t is not in a heap on entry to t.maybeAdd."
      },
      {
        "name": "maybeRunAsync",
        "desc": "maybeRunAsync checks whether t needs to be triggered and runs it if so. The caller is responsible for locking the timer and for checking that we are running timers in async mode. If the timer needs to be run, maybeRunAsync will unlock and re-lock it. The timer is always locked on return."
      },
      {
        "name": "maybeRunChan",
        "desc": "maybeRunChan checks whether the timer needs to run to send a value to its associated channel. If so, it does. The timer must not be locked."
      },
      {
        "name": "modify",
        "desc": "modify modifies an existing timer. This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset. Reports whether the timer was modified before it was run. If f == nil, then t.f, t.arg, and t.seq are not modified."
      },
      {
        "name": "needsAdd",
        "desc": "needsAdd reports whether t needs to be added to a timers heap. t must be locked."
      },
      {
        "name": "reset",
        "desc": "reset resets the time when a timer should fire. If used for an inactive timer, the timer will become active. Reports whether the timer was active and was stopped."
      },
      {
        "name": "stop",
        "desc": "stop stops the timer t. It may be on some other P, so we can't actually remove it from the timers heap. We can only mark it as stopped. It will be removed in due course by the P whose heap it is on. Reports whether the timer was stopped before it was run."
      },
      {
        "name": "trace",
        "desc": ""
      },
      {
        "name": "trace1",
        "desc": ""
      },
      {
        "name": "unlock",
        "desc": "unlock updates t.astate and unlocks the timer."
      },
      {
        "name": "unlockAndRun",
        "desc": "unlockAndRun unlocks and runs the timer t (which must be locked). If t is in a timer set (t.ts != nil), the caller must also have locked the timer set, and this call will temporarily unlock the timer set while running the timer function. unlockAndRun returns with t unlocked and t.ts (re-)locked."
      },
      {
        "name": "updateHeap",
        "desc": "updateHeap updates t as directed by t.state, updating t.state and returning a bool indicating whether the state (and ts.heap[0].when) changed. The caller must hold t's lock, or the world can be stopped instead. The timer set t.ts must be non-nil and locked, t must be t.ts.heap[0], and updateHeap takes care of moving t within the timers heap to preserve the heap invariants. If ts == nil, then t must not be in a heap (or is in a heap that is temporarily not maintaining its invariant, such as during timers.adjust)."
      },
      {
        "name": "clear",
        "desc": "clear cancels this timeout event."
      },
      {
        "name": "diff",
        "desc": "diff calculates the difference of the event's trigger time and x."
      },
      {
        "name": "hchan",
        "desc": "hchan returns the channel in t.arg. t must be a timer with a channel."
      },
      {
        "name": "init",
        "desc": "init initializes a newly allocated timer t. Any code that allocates a timer must call t.init before using it. The arg and f can be set during init, or they can be nil in init and set by a future call to t.modify."
      },
      {
        "name": "lock",
        "desc": "lock locks the timer, allowing reading or writing any of the timer fields."
      },
      {
        "name": "maybeAdd",
        "desc": "maybeAdd adds t to the local timers heap if it needs to be in a heap. The caller must not hold t's lock nor any timers heap lock. The caller probably just unlocked t, but that lock must be dropped in order to acquire a ts.lock, to avoid lock inversions. (timers.adjust holds ts.lock while acquiring each t's lock, so we cannot hold any t's lock while acquiring ts.lock).  Strictly speaking it *might* be okay to hold t.lock and acquire ts.lock at the same time, because we know that t is not in any ts.heap, so nothing holding a ts.lock would be acquiring the t.lock at the same time, meaning there isn't a possible deadlock. But it is easier and safer not to be too clever and respect the static ordering. (If we don't, we have to change the static lock checking of t and ts.)  Concurrent calls to time.Timer.Reset or blockTimerChan may result in concurrent calls to t.maybeAdd, so we cannot assume that t is not in a heap on entry to t.maybeAdd."
      },
      {
        "name": "maybeRunAsync",
        "desc": "maybeRunAsync checks whether t needs to be triggered and runs it if so. The caller is responsible for locking the timer and for checking that we are running timers in async mode. If the timer needs to be run, maybeRunAsync will unlock and re-lock it. The timer is always locked on return."
      },
      {
        "name": "maybeRunChan",
        "desc": "maybeRunChan checks whether the timer needs to run to send a value to its associated channel. If so, it does. The timer must not be locked."
      },
      {
        "name": "modify",
        "desc": "modify modifies an existing timer. This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset. Reports whether the timer was modified before it was run. If f == nil, then t.f, t.arg, and t.seq are not modified."
      },
      {
        "name": "needsAdd",
        "desc": "needsAdd reports whether t needs to be added to a timers heap. t must be locked."
      },
      {
        "name": "reset",
        "desc": "reset resets the time when a timer should fire. If used for an inactive timer, the timer will become active. Reports whether the timer was active and was stopped."
      },
      {
        "name": "stop",
        "desc": "stop stops the timer t. It may be on some other P, so we can't actually remove it from the timers heap. We can only mark it as stopped. It will be removed in due course by the P whose heap it is on. Reports whether the timer was stopped before it was run."
      },
      {
        "name": "trace",
        "desc": ""
      },
      {
        "name": "trace1",
        "desc": ""
      },
      {
        "name": "unlock",
        "desc": "unlock updates t.astate and unlocks the timer."
      },
      {
        "name": "unlockAndRun",
        "desc": "unlockAndRun unlocks and runs the timer t (which must be locked). If t is in a timer set (t.ts != nil), the caller must also have locked the timer set, and this call will temporarily unlock the timer set while running the timer function. unlockAndRun returns with t unlocked and t.ts (re-)locked."
      },
      {
        "name": "updateHeap",
        "desc": "updateHeap updates t as directed by t.state, updating t.state and returning a bool indicating whether the state (and ts.heap[0].when) changed. The caller must hold t's lock, or the world can be stopped instead. The timer set t.ts must be non-nil and locked, t must be t.ts.heap[0], and updateHeap takes care of moving t within the timers heap to preserve the heap invariants. If ts == nil, then t must not be in a heap (or is in a heap that is temporarily not maintaining its invariant, such as during timers.adjust)."
      },
      {
        "name": "less",
        "desc": "less reports whether tw is less than other."
      },
      {
        "name": "addHeap",
        "desc": "addHeap adds t to the timers heap. The caller must hold ts.lock or the world must be stopped. The caller must also have checked that t belongs in the heap. Callers that are not sure can call t.maybeAdd instead, but note that maybeAdd has different locking requirements."
      },
      {
        "name": "adjust",
        "desc": "adjust looks through the timers in ts.heap for any timers that have been modified to run earlier, and puts them in the correct place in the heap. While looking for those timers, it also moves timers that have been modified to run later, and removes deleted timers. The caller must have locked ts."
      },
      {
        "name": "check",
        "desc": "check runs any timers in ts that are ready. If now is not 0 it is the current time. It returns the passed time or the current time if now was passed as 0. and the time when the next timer should run or 0 if there is no next timer, and reports whether it ran any timers. If the time when the next timer should run is not 0, it is always larger than the returned time. We pass now in and out to avoid extra calls of nanotime."
      },
      {
        "name": "cleanHead",
        "desc": "cleanHead cleans up the head of the timer queue. This speeds up programs that create and delete timers; leaving them in the heap slows down heap operations. The caller must have locked ts."
      },
      {
        "name": "deleteMin",
        "desc": "deleteMin removes timer 0 from ts. ts must be locked."
      },
      {
        "name": "initHeap",
        "desc": "initHeap reestablishes the heap order in the slice ts.heap. It takes O(n) time for n=len(ts.heap), not the O(n log n) of n repeated add operations."
      },
      {
        "name": "lock",
        "desc": ""
      },
      {
        "name": "run",
        "desc": "run examines the first timer in ts. If it is ready based on now, it runs the timer and removes or updates it. Returns 0 if it ran a timer, -1 if there are no more timers, or the time when the first timer should run. The caller must have locked ts. If a timer is run, this will temporarily unlock ts."
      },
      {
        "name": "siftDown",
        "desc": "siftDown puts the timer at position i in the right place in the heap by moving it down toward the bottom of the heap."
      },
      {
        "name": "siftUp",
        "desc": "siftUp puts the timer at position i in the right place in the heap by moving it up toward the top of the heap."
      },
      {
        "name": "take",
        "desc": "take moves any timers from src into ts and then clears the timer state from src, because src is being destroyed. The caller must not have locked either timers. For now this is only called when the world is stopped."
      },
      {
        "name": "trace",
        "desc": ""
      },
      {
        "name": "unlock",
        "desc": ""
      },
      {
        "name": "updateMinWhenHeap",
        "desc": "updateMinWhenHeap sets ts.minWhenHeap to ts.heap[0].when. The caller must have locked ts or the world must be stopped."
      },
      {
        "name": "updateMinWhenModified",
        "desc": "updateMinWhenModified updates ts.minWhenModified to be \u003c= when. ts need not be (and usually is not) locked."
      },
      {
        "name": "verify",
        "desc": "verifyTimerHeap verifies that the timers is in a valid state. This is only for debugging, and is only called if verifyTimers is true. The caller must have locked ts."
      },
      {
        "name": "wakeTime",
        "desc": "wakeTime looks at ts's timers and returns the time when we should wake up the netpoller. It returns 0 if there are no timers. This function is invoked when dropping a P, so it must run without any write barriers."
      },
      {
        "name": "setNsec",
        "desc": ""
      },
      {
        "name": "set_usec",
        "desc": ""
      },
      {
        "name": "start",
        "desc": "start starts a new traceAdvancer."
      },
      {
        "name": "stop",
        "desc": "stop stops a traceAdvancer and blocks until it exits."
      },
      {
        "name": "available",
        "desc": "nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "byte",
        "desc": "byte appends v to buf.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "stringData",
        "desc": "stringData appends s's data directly to buf.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "varint",
        "desc": "varint appends v to buf in little-endian-base-128 encoding.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "varintAt",
        "desc": "varintAt writes varint v at byte position pos in buf. This always consumes traceBytesPerNumber bytes. This is intended for when the caller needs to reserve space for a varint but can't populate it until later. Use varintReserve to reserve this space.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "varintReserve",
        "desc": "varintReserve reserves enough space in buf to hold any varint.  Space reserved this way can be filled in with the varintAt method.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": "pop dequeues from the queue of buffers."
      },
      {
        "name": "push",
        "desc": "push queues buf into queue of buffers."
      },
      {
        "name": "event",
        "desc": "event writes out a trace event."
      },
      {
        "name": "GCActive",
        "desc": "GCActive traces a GCActive event.  Must be emitted by an actively running goroutine on an active P. This restriction can be changed easily and only depends on where it's currently called."
      },
      {
        "name": "GCDone",
        "desc": "GCDone traces a GCEnd event.  Must be emitted by an actively running goroutine on an active P. This restriction can be changed easily and only depends on where it's currently called."
      },
      {
        "name": "GCMarkAssistDone",
        "desc": "GCMarkAssistDone emits a MarkAssistEnd event."
      },
      {
        "name": "GCMarkAssistStart",
        "desc": "GCMarkAssistStart emits a MarkAssistBegin event."
      },
      {
        "name": "GCStart",
        "desc": "GCStart traces a GCBegin event.  Must be emitted by an actively running goroutine on an active P. This restriction can be changed easily and only depends on where it's currently called."
      },
      {
        "name": "GCSweepDone",
        "desc": "GCSweepDone finishes tracing a sweep loop. If any memory was swept (i.e. traceGCSweepSpan emitted an event) then this will emit a GCSweepEnd event.  Must be called with a valid P."
      },
      {
        "name": "GCSweepSpan",
        "desc": "GCSweepSpan traces the sweep of a single span. If this is the first span swept since traceGCSweepStart was called, this will emit a GCSweepBegin event.  This may be called outside a traceGCSweepStart/traceGCSweepDone pair; however, it will not emit any trace events in this case.  Must be called with a valid P."
      },
      {
        "name": "GCSweepStart",
        "desc": "GCSweepStart prepares to trace a sweep loop. This does not emit any events until traceGCSweepSpan is called.  GCSweepStart must be paired with traceGCSweepDone and there must be no preemption points between these two calls.  Must be called with a valid P."
      },
      {
        "name": "GoCreate",
        "desc": "GoCreate emits a GoCreate event."
      },
      {
        "name": "GoCreateSyscall",
        "desc": "GoCreateSyscall indicates that a goroutine has transitioned from dead to GoSyscall.  Unlike GoCreate, the caller must be running on gp.  This occurs when C code calls into Go. On pthread platforms it occurs only when a C thread calls into Go code for the first time."
      },
      {
        "name": "GoDestroySyscall",
        "desc": "GoDestroySyscall indicates that a goroutine has transitioned from GoSyscall to dead.  Must not have a P.  This occurs when Go code returns back to C. On pthread platforms it occurs only when the C thread is destroyed."
      },
      {
        "name": "GoEnd",
        "desc": "GoEnd emits a GoDestroy event.  TODO(mknyszek): Rename this to GoDestroy."
      },
      {
        "name": "GoPark",
        "desc": "GoPark emits a GoBlock event with the provided reason.  TODO(mknyszek): Replace traceBlockReason with waitReason. It's silly that we have both, and waitReason is way more descriptive."
      },
      {
        "name": "GoPreempt",
        "desc": "GoPreempt emits a GoStop event with a GoPreempted reason."
      },
      {
        "name": "GoSched",
        "desc": "GoSched emits a GoStop event with a GoSched reason."
      },
      {
        "name": "GoStart",
        "desc": "GoStart emits a GoStart event.  Must be called with a valid P."
      },
      {
        "name": "GoStop",
        "desc": "GoStop emits a GoStop event with the provided reason."
      },
      {
        "name": "GoSwitch",
        "desc": "GoSwitch emits a GoSwitch event. If destroy is true, the calling goroutine is simultaneously being destroyed."
      },
      {
        "name": "GoSysCall",
        "desc": "GoSysCall emits a GoSyscallBegin event.  Must be called with a valid P."
      },
      {
        "name": "GoSysExit",
        "desc": "GoSysExit emits a GoSyscallEnd event, possibly along with a GoSyscallBlocked event if lostP is true.  lostP must be true in all cases that a goroutine loses its P during a syscall. This means it's not sufficient to check if it has no P. In particular, it needs to be true in the following cases: - The goroutine lost its P, it ran some other code, and then got it back. It's now running with that P. - The goroutine lost its P and was unable to reacquire it, and is now running without a P. - The goroutine lost its P and acquired a different one, and is now running with that P."
      },
      {
        "name": "GoUnpark",
        "desc": "GoUnpark emits a GoUnblock event."
      },
      {
        "name": "Gomaxprocs",
        "desc": "Gomaxprocs emits a ProcsChange event."
      },
      {
        "name": "GoroutineStackAlloc",
        "desc": "GoroutineStackAlloc records that a goroutine stack was newly allocated at address base with the provided size.."
      },
      {
        "name": "GoroutineStackExists",
        "desc": "GoroutineStackExists records that a goroutine stack already exists at address base with the provided size."
      },
      {
        "name": "GoroutineStackFree",
        "desc": "GoroutineStackFree records that a goroutine stack at address base is about to be freed."
      },
      {
        "name": "HeapAlloc",
        "desc": "HeapAlloc emits a HeapAlloc event."
      },
      {
        "name": "HeapGoal",
        "desc": "HeapGoal reads the current heap goal and emits a HeapGoal event."
      },
      {
        "name": "HeapObjectAlloc",
        "desc": "HeapObjectAlloc records that an object was newly allocated at addr with the provided type. The type is optional, and the size of the slot occupied the object is inferred from the span containing it."
      },
      {
        "name": "HeapObjectExists",
        "desc": "HeapObjectExists records that an object already exists at addr with the provided type. The type is optional, and the size of the slot occupied the object is inferred from the span containing it."
      },
      {
        "name": "HeapObjectFree",
        "desc": "HeapObjectFree records that an object at addr is about to be freed."
      },
      {
        "name": "ProcStart",
        "desc": "ProcStart traces a ProcStart event.  Must be called with a valid P."
      },
      {
        "name": "ProcSteal",
        "desc": "ProcSteal indicates that our current M stole a P from another M.  inSyscall indicates that we're stealing the P from a syscall context.  The caller must have ownership of pp."
      },
      {
        "name": "ProcStop",
        "desc": "ProcStop traces a ProcStop event."
      },
      {
        "name": "STWDone",
        "desc": "STWDone traces a STWEnd event."
      },
      {
        "name": "STWStart",
        "desc": "STWStart traces a STWBegin event."
      },
      {
        "name": "SpanAlloc",
        "desc": "SpanAlloc records an event indicating that the span has just been allocated."
      },
      {
        "name": "SpanExists",
        "desc": "SpanExists records an event indicating that the span exists."
      },
      {
        "name": "SpanFree",
        "desc": "SpanFree records an event indicating that the span is about to be freed."
      },
      {
        "name": "emitUnblockStatus",
        "desc": "emitUnblockStatus emits a GoStatus GoWaiting event for a goroutine about to be unblocked to the trace writer."
      },
      {
        "name": "eventWriter",
        "desc": "eventWriter creates a new traceEventWriter. It is the main entrypoint for writing trace events.  Before creating the event writer, this method will emit a status for the current goroutine or proc if it exists, and if it hasn't had its status emitted yet. goStatus and procStatus indicate what the status of goroutine or P should be immediately *before* the events that are about to be written using the eventWriter (if they exist). No status will be written if there's no active goroutine or P.  Callers can elect to pass a constant value here if the status is clear (e.g. a goroutine must have been Runnable before a GoStart). Otherwise, callers can query the status of either the goroutine or P and pass the appropriate status.  In this case, the default status should be tracev2.GoBad or tracev2.ProcBad to help identify bugs sooner."
      },
      {
        "name": "expWriter",
        "desc": "expWriter returns a traceWriter that writes into the current M's stream for the given experiment."
      },
      {
        "name": "ok",
        "desc": "ok returns true if the traceLocker is valid (i.e. tracing is enabled).  nosplit because it's called on the syscall path when stack movement is forbidden."
      },
      {
        "name": "rtype",
        "desc": "rtype returns a traceArg representing typ which may be passed to write."
      },
      {
        "name": "stack",
        "desc": "stack takes a stack trace skipping the provided number of frames. It then returns a traceArg representing that stack which may be passed to write."
      },
      {
        "name": "startPC",
        "desc": "startPC takes a start PC for a goroutine and produces a unique stack ID for it.  It then returns a traceArg representing that stack which may be passed to write."
      },
      {
        "name": "string",
        "desc": "string returns a traceArg representing s which may be passed to write. The string is assumed to be relatively short and popular, so it may be stored for a while in the string dictionary."
      },
      {
        "name": "uniqueString",
        "desc": "uniqueString returns a traceArg representing s which may be passed to write. The string is assumed to be unique or long, so it will be written out to the trace eagerly."
      },
      {
        "name": "writer",
        "desc": "writer returns an a traceWriter that writes into the current M's stream.  Once this is called, the caller must guard against stack growth until end is called on it. Therefore, it's highly recommended to use this API in a \"fluent\" style, for example tl.writer().event(...).end(). Better yet, callers just looking to write events should use eventWriter when possible, which is a much safer wrapper around this function.  nosplit to allow for safe reentrant tracing from stack growth paths."
      },
      {
        "name": "newTraceMapNode",
        "desc": ""
      },
      {
        "name": "put",
        "desc": "put inserts the data into the table.  It's always safe for callers to noescape data because put copies its bytes.  Returns a unique ID for the data and whether this is the first time the data has been added to the map."
      },
      {
        "name": "reset",
        "desc": "reset drops all allocated memory from the table and resets it.  The caller must ensure that there are no put operations executing concurrently with this function."
      },
      {
        "name": "stealID",
        "desc": "stealID steals an ID from the table, ensuring that it will not appear in the table anymore."
      },
      {
        "name": "alloc",
        "desc": "alloc allocates n-byte block. The block is always aligned to 8 bytes, regardless of platform."
      },
      {
        "name": "drop",
        "desc": "drop frees all previously allocated memory and resets the allocator.  drop is not safe to call concurrently with other calls to drop or with calls to alloc. The caller must ensure that it is not possible for anything else to be using the same structure."
      },
      {
        "name": "acquireStatus",
        "desc": "acquireStatus acquires the right to emit a Status event for the scheduling resource.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "nextSeq",
        "desc": "nextSeq returns the next sequence number for the resource."
      },
      {
        "name": "readyNextGen",
        "desc": "readyNextGen readies r for the generation following gen."
      },
      {
        "name": "setStatusTraced",
        "desc": "setStatusTraced indicates that the resource's status was already traced, for example when a goroutine is created."
      },
      {
        "name": "statusWasTraced",
        "desc": "statusWasTraced returns true if the sched resource's status was already acquired for tracing."
      },
      {
        "name": "dump",
        "desc": "dump writes all previously cached stacks to trace buffers, releases all memory and resets state. It must only be called once the caller can guarantee that there are no more writers to the table."
      },
      {
        "name": "put",
        "desc": "put returns a unique id for the stack trace pcs and caches it in the table, if it sees the trace for the first time."
      },
      {
        "name": "emit",
        "desc": "emit emits a string and creates an ID for it, but doesn't add it to the table. Returns the ID."
      },
      {
        "name": "put",
        "desc": "put adds a string to the table, emits it, and returns a unique ID for it."
      },
      {
        "name": "reset",
        "desc": "reset clears the string table and flushes any buffers it has.  Must be called only once the caller is certain nothing else will be added to this table."
      },
      {
        "name": "writeString",
        "desc": "writeString writes the string to t.buf.  Must run on the systemstack because it acquires t.lock."
      },
      {
        "name": "dump",
        "desc": "dump writes all previously cached types to trace buffers and releases all memory and resets state. It must only be called once the caller can guarantee that there are no more writers to the table."
      },
      {
        "name": "put",
        "desc": "put returns a unique id for the type typ and caches it in the table, if it's seeing it for the first time.  N.B. typ must be kept alive forever for this to work correctly."
      },
      {
        "name": "GCActive",
        "desc": "GCActive traces a GCActive event.  Must be emitted by an actively running goroutine on an active P. This restriction can be changed easily and only depends on where it's currently called."
      },
      {
        "name": "GCDone",
        "desc": "GCDone traces a GCEnd event.  Must be emitted by an actively running goroutine on an active P. This restriction can be changed easily and only depends on where it's currently called."
      },
      {
        "name": "GCMarkAssistDone",
        "desc": "GCMarkAssistDone emits a MarkAssistEnd event."
      },
      {
        "name": "GCMarkAssistStart",
        "desc": "GCMarkAssistStart emits a MarkAssistBegin event."
      },
      {
        "name": "GCStart",
        "desc": "GCStart traces a GCBegin event.  Must be emitted by an actively running goroutine on an active P. This restriction can be changed easily and only depends on where it's currently called."
      },
      {
        "name": "GCSweepDone",
        "desc": "GCSweepDone finishes tracing a sweep loop. If any memory was swept (i.e. traceGCSweepSpan emitted an event) then this will emit a GCSweepEnd event.  Must be called with a valid P."
      },
      {
        "name": "GCSweepSpan",
        "desc": "GCSweepSpan traces the sweep of a single span. If this is the first span swept since traceGCSweepStart was called, this will emit a GCSweepBegin event.  This may be called outside a traceGCSweepStart/traceGCSweepDone pair; however, it will not emit any trace events in this case.  Must be called with a valid P."
      },
      {
        "name": "GCSweepStart",
        "desc": "GCSweepStart prepares to trace a sweep loop. This does not emit any events until traceGCSweepSpan is called.  GCSweepStart must be paired with traceGCSweepDone and there must be no preemption points between these two calls.  Must be called with a valid P."
      },
      {
        "name": "GoCreate",
        "desc": "GoCreate emits a GoCreate event."
      },
      {
        "name": "GoCreateSyscall",
        "desc": "GoCreateSyscall indicates that a goroutine has transitioned from dead to GoSyscall.  Unlike GoCreate, the caller must be running on gp.  This occurs when C code calls into Go. On pthread platforms it occurs only when a C thread calls into Go code for the first time."
      },
      {
        "name": "GoDestroySyscall",
        "desc": "GoDestroySyscall indicates that a goroutine has transitioned from GoSyscall to dead.  Must not have a P.  This occurs when Go code returns back to C. On pthread platforms it occurs only when the C thread is destroyed."
      },
      {
        "name": "GoEnd",
        "desc": "GoEnd emits a GoDestroy event.  TODO(mknyszek): Rename this to GoDestroy."
      },
      {
        "name": "GoPark",
        "desc": "GoPark emits a GoBlock event with the provided reason.  TODO(mknyszek): Replace traceBlockReason with waitReason. It's silly that we have both, and waitReason is way more descriptive."
      },
      {
        "name": "GoPreempt",
        "desc": "GoPreempt emits a GoStop event with a GoPreempted reason."
      },
      {
        "name": "GoSched",
        "desc": "GoSched emits a GoStop event with a GoSched reason."
      },
      {
        "name": "GoStart",
        "desc": "GoStart emits a GoStart event.  Must be called with a valid P."
      },
      {
        "name": "GoStop",
        "desc": "GoStop emits a GoStop event with the provided reason."
      },
      {
        "name": "GoSwitch",
        "desc": "GoSwitch emits a GoSwitch event. If destroy is true, the calling goroutine is simultaneously being destroyed."
      },
      {
        "name": "GoSysCall",
        "desc": "GoSysCall emits a GoSyscallBegin event.  Must be called with a valid P."
      },
      {
        "name": "GoSysExit",
        "desc": "GoSysExit emits a GoSyscallEnd event, possibly along with a GoSyscallBlocked event if lostP is true.  lostP must be true in all cases that a goroutine loses its P during a syscall. This means it's not sufficient to check if it has no P. In particular, it needs to be true in the following cases: - The goroutine lost its P, it ran some other code, and then got it back. It's now running with that P. - The goroutine lost its P and was unable to reacquire it, and is now running without a P. - The goroutine lost its P and acquired a different one, and is now running with that P."
      },
      {
        "name": "GoUnpark",
        "desc": "GoUnpark emits a GoUnblock event."
      },
      {
        "name": "Gomaxprocs",
        "desc": "Gomaxprocs emits a ProcsChange event."
      },
      {
        "name": "GoroutineStackAlloc",
        "desc": "GoroutineStackAlloc records that a goroutine stack was newly allocated at address base with the provided size.."
      },
      {
        "name": "GoroutineStackExists",
        "desc": "GoroutineStackExists records that a goroutine stack already exists at address base with the provided size."
      },
      {
        "name": "GoroutineStackFree",
        "desc": "GoroutineStackFree records that a goroutine stack at address base is about to be freed."
      },
      {
        "name": "HeapAlloc",
        "desc": "HeapAlloc emits a HeapAlloc event."
      },
      {
        "name": "HeapGoal",
        "desc": "HeapGoal reads the current heap goal and emits a HeapGoal event."
      },
      {
        "name": "HeapObjectAlloc",
        "desc": "HeapObjectAlloc records that an object was newly allocated at addr with the provided type. The type is optional, and the size of the slot occupied the object is inferred from the span containing it."
      },
      {
        "name": "HeapObjectExists",
        "desc": "HeapObjectExists records that an object already exists at addr with the provided type. The type is optional, and the size of the slot occupied the object is inferred from the span containing it."
      },
      {
        "name": "HeapObjectFree",
        "desc": "HeapObjectFree records that an object at addr is about to be freed."
      },
      {
        "name": "ProcStart",
        "desc": "ProcStart traces a ProcStart event.  Must be called with a valid P."
      },
      {
        "name": "ProcSteal",
        "desc": "ProcSteal indicates that our current M stole a P from another M.  inSyscall indicates that we're stealing the P from a syscall context.  The caller must have ownership of pp."
      },
      {
        "name": "ProcStop",
        "desc": "ProcStop traces a ProcStop event."
      },
      {
        "name": "STWDone",
        "desc": "STWDone traces a STWEnd event."
      },
      {
        "name": "STWStart",
        "desc": "STWStart traces a STWBegin event."
      },
      {
        "name": "SpanAlloc",
        "desc": "SpanAlloc records an event indicating that the span has just been allocated."
      },
      {
        "name": "SpanExists",
        "desc": "SpanExists records an event indicating that the span exists."
      },
      {
        "name": "SpanFree",
        "desc": "SpanFree records an event indicating that the span is about to be freed."
      },
      {
        "name": "available",
        "desc": "nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "byte",
        "desc": "byte appends v to buf.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "emitUnblockStatus",
        "desc": "emitUnblockStatus emits a GoStatus GoWaiting event for a goroutine about to be unblocked to the trace writer."
      },
      {
        "name": "end",
        "desc": "end writes the buffer back into the m.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "ensure",
        "desc": "ensure makes sure that at least maxSize bytes are available to write.  Returns whether the buffer was flushed.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "event",
        "desc": "event writes out the bytes of an event into the event stream.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "eventWriter",
        "desc": "eventWriter creates a new traceEventWriter. It is the main entrypoint for writing trace events.  Before creating the event writer, this method will emit a status for the current goroutine or proc if it exists, and if it hasn't had its status emitted yet. goStatus and procStatus indicate what the status of goroutine or P should be immediately *before* the events that are about to be written using the eventWriter (if they exist). No status will be written if there's no active goroutine or P.  Callers can elect to pass a constant value here if the status is clear (e.g. a goroutine must have been Runnable before a GoStart). Otherwise, callers can query the status of either the goroutine or P and pass the appropriate status.  In this case, the default status should be tracev2.GoBad or tracev2.ProcBad to help identify bugs sooner."
      },
      {
        "name": "expWriter",
        "desc": "expWriter returns a traceWriter that writes into the current M's stream for the given experiment."
      },
      {
        "name": "flush",
        "desc": "flush puts w.traceBuf on the queue of full buffers.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "ok",
        "desc": "ok returns true if the traceLocker is valid (i.e. tracing is enabled).  nosplit because it's called on the syscall path when stack movement is forbidden."
      },
      {
        "name": "refill",
        "desc": "refill puts w.traceBuf on the queue of full buffers and refresh's w's buffer."
      },
      {
        "name": "rtype",
        "desc": "rtype returns a traceArg representing typ which may be passed to write."
      },
      {
        "name": "stack",
        "desc": "stack takes a stack trace skipping the provided number of frames. It then returns a traceArg representing that stack which may be passed to write."
      },
      {
        "name": "startPC",
        "desc": "startPC takes a start PC for a goroutine and produces a unique stack ID for it.  It then returns a traceArg representing that stack which may be passed to write."
      },
      {
        "name": "string",
        "desc": "string returns a traceArg representing s which may be passed to write. The string is assumed to be relatively short and popular, so it may be stored for a while in the string dictionary."
      },
      {
        "name": "stringData",
        "desc": "stringData appends s's data directly to buf.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "uniqueString",
        "desc": "uniqueString returns a traceArg representing s which may be passed to write. The string is assumed to be unique or long, so it will be written out to the trace eagerly."
      },
      {
        "name": "varint",
        "desc": "varint appends v to buf in little-endian-base-128 encoding.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "varintAt",
        "desc": "varintAt writes varint v at byte position pos in buf. This always consumes traceBytesPerNumber bytes. This is intended for when the caller needs to reserve space for a varint but can't populate it until later. Use varintReserve to reserve this space.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "varintReserve",
        "desc": "varintReserve reserves enough space in buf to hold any varint.  Space reserved this way can be filled in with the varintAt method.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "writeGoStatus",
        "desc": "writeGoStatus emits a GoStatus event as well as any active ranges on the goroutine.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "writeProcStatus",
        "desc": "writeProcStatus emits a ProcStatus event with all the provided information.  The caller must have taken ownership of a P's status writing, and the P must be prevented from transitioning.  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "writeProcStatusForP",
        "desc": "writeProcStatusForP emits a ProcStatus event for the provided p based on its status.  The caller must fully own pp and it must be prevented from transitioning (e.g. this can be called by a forEachP callback or from a STW).  nosplit because it's part of writing an event for an M, which must not have any stack growth."
      },
      {
        "name": "writer",
        "desc": "writer returns an a traceWriter that writes into the current M's stream.  Once this is called, the caller must guard against stack growth until end is called on it. Therefore, it's highly recommended to use this API in a \"fluent\" style, for example tl.writer().event(...).end(). Better yet, callers just looking to write events should use eventWriter when possible, which is a much safer wrapper around this function.  nosplit to allow for safe reentrant tracing from stack growth paths."
      },
      {
        "name": "fastForward",
        "desc": "fastForward moves the iterator forward by n bytes. n must be a multiple of goarch.PtrSize. limit must be the same limit passed to next for this iterator.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "next",
        "desc": "next advances the pointers iterator, returning the updated iterator and the address of the next pointer.  limit must be the same each time it is passed to next.  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "nextFast",
        "desc": "nextFast is the fast path of next. nextFast is written to be inlineable and, as the name implies, fast.  Callers that are performance-critical should iterate using the following pattern:  \tfor { \t\tvar addr uintptr \t\tif tp, addr = tp.nextFast(); addr == 0 { \t\t\tif tp, addr = tp.next(limit); addr == 0 { \t\t\t\tbreak \t\t\t} \t\t} \t\t// Use addr. \t\t... \t}  nosplit because it is used during write barriers and must not be preempted."
      },
      {
        "name": "cgoCallers",
        "desc": "cgoCallers populates pcBuf with the cgo callers of the current frame using the registered cgo unwinder. It returns the number of PCs written to pcBuf. If the current frame is not a cgo frame or if there's no registered cgo unwinder, it returns 0."
      },
      {
        "name": "finishInternal",
        "desc": "finishInternal is an unwinder-internal helper called after the stack has been exhausted. It sets the unwinder to an invalid state and checks that it successfully unwound the entire stack."
      },
      {
        "name": "init",
        "desc": "init initializes u to start unwinding gp's stack and positions the iterator on gp's innermost frame. gp must not be the current G.  A single unwinder can be reused for multiple unwinds."
      },
      {
        "name": "initAt",
        "desc": ""
      },
      {
        "name": "next",
        "desc": ""
      },
      {
        "name": "resolveInternal",
        "desc": "resolveInternal fills in u.frame based on u.frame.fn, pc, and sp.  innermost indicates that this is the first resolve on this stack. If innermost is set, isSyscall indicates that the PC/SP was retrieved from gp.syscall*; this is otherwise ignored.  On entry, u.frame contains:   - fn is the running function.   - pc is the PC in the running function.   - sp is the stack pointer at that program counter.   - For the innermost frame on LR machines, lr is the program counter that called fn.  On return, u.frame contains:   - fp is the stack pointer of the caller.   - lr is the program counter that called fn.   - varp, argp, and continpc are populated for the current frame.  If fn is a stack-jumping function, resolveInternal can change the entire frame state to follow that stack jump.  This is internal to unwinder."
      },
      {
        "name": "symPC",
        "desc": "symPC returns the PC that should be used for symbolizing the current frame. Specifically, this is the PC of the last instruction executed in this frame.  If this frame did a normal call, then frame.pc is a return PC, so this will return frame.pc-1, which points into the CALL instruction. If the frame was interrupted by a signal (e.g., profiler, segv, etc) then frame.pc is for the trapped instruction, so this returns frame.pc. See issue #34123. Finally, frame.pc can be at function entry when the frame is initialized without actually running code, like in runtime.mstart, in which case this returns frame.pc because that's the best we can do."
      },
      {
        "name": "valid",
        "desc": ""
      },
      {
        "name": "alloc",
        "desc": "alloc reserves space in the current chunk or calls refill and reserves space in a new chunk. If cap is negative, the type will be taken literally, otherwise it will be considered as an element type for a slice backing store with capacity cap."
      },
      {
        "name": "free",
        "desc": "free returns the userArena's chunks back to mheap and marks it as defunct.  Must be called at most once for any given arena.  This operation is not safe to call concurrently with other operations on the same arena."
      },
      {
        "name": "new",
        "desc": "new allocates a new object of the provided type into the arena, and returns its pointer.  This operation is not safe to call concurrently with other operations on the same arena."
      },
      {
        "name": "refill",
        "desc": "refill inserts the current arena chunk onto the full list and obtains a new one, either from the partial list or allocating a new one, both from mheap."
      },
      {
        "name": "slice",
        "desc": "slice allocates a new slice backing store. slice must be a pointer to a slice (i.e. *[]T), because userArenaSlice will update the slice directly.  cap determines the capacity of the slice backing store and must be non-negative.  This operation is not safe to call concurrently with other operations on the same arena."
      },
      {
        "name": "getHPETTimecounter",
        "desc": ""
      },
      {
        "name": "getTSCTimecounter",
        "desc": ""
      },
      {
        "name": "getTimecounter",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isIdleInSynctest",
        "desc": ""
      },
      {
        "name": "isMutexWait",
        "desc": ""
      },
      {
        "name": "isWaitingForSuspendG",
        "desc": ""
      },
      {
        "name": "dequeue",
        "desc": ""
      },
      {
        "name": "dequeueSudoG",
        "desc": ""
      },
      {
        "name": "enqueue",
        "desc": ""
      },
      {
        "name": "close",
        "desc": "close wakes any goroutine sleeping on the timer and prevents further sleeping on it.  Once close is called, the wakeableSleep must no longer be used.  It must only be called once no goroutine is sleeping on the timer *and* nothing else will call wake concurrently."
      },
      {
        "name": "sleep",
        "desc": "sleep sleeps for the provided duration in nanoseconds or until another goroutine calls wake.  Must not be called by more than one goroutine at a time and must not be called concurrently with close."
      },
      {
        "name": "wake",
        "desc": "wake awakens any goroutine sleeping on the timer.  Safe for concurrent use with all other methods."
      },
      {
        "name": "discard",
        "desc": "discard resets b's next pointer, but not its end pointer.  This must be nosplit because it's called by wbBufFlush."
      },
      {
        "name": "empty",
        "desc": "empty reports whether b contains no pointers."
      },
      {
        "name": "get1",
        "desc": "getX returns space in the write barrier buffer to store X pointers. getX will flush the buffer if necessary. Callers should use this as:  \tbuf := \u0026getg().m.p.ptr().wbBuf \tp := buf.get2() \tp[0], p[1] = old, new \t... actual memory write ...  The caller must ensure there are no preemption points during the above sequence. There must be no preemption points while buf is in use because it is a per-P resource. There must be no preemption points between the buffer put and the write to memory because this could allow a GC phase change, which could result in missed write barriers.  getX must be nowritebarrierrec to because write barriers here would corrupt the write barrier buffer. It (and everything it calls, if it called anything) has to be nosplit to avoid scheduling on to a different P and a different buffer."
      },
      {
        "name": "get2",
        "desc": ""
      },
      {
        "name": "reset",
        "desc": "reset empties b by resetting its next and end pointers."
      },
      {
        "name": "accumulate",
        "desc": "accumulate takes a cpuStats and adds in the current state of all GC CPU counters.  gcMarkPhase indicates that we're in the mark phase and that certain counter values should be used."
      },
      {
        "name": "accumulateGCPauseTime",
        "desc": "accumulateGCPauseTime add dt*stwProcs to the GC CPU pause time stats. dt should be the actual time spent paused, for orthogonality. maxProcs should be GOMAXPROCS, not work.stwprocs, since this number must be comparable to a total time computed from GOMAXPROCS."
      },
      {
        "name": "checkempty",
        "desc": ""
      },
      {
        "name": "checknonempty",
        "desc": ""
      },
      {
        "name": "flush",
        "desc": "Flush the bits that have been written, and add zeros as needed to cover the full object [addr, addr+size)."
      },
      {
        "name": "pad",
        "desc": "Add padding of size bytes."
      },
      {
        "name": "write",
        "desc": "write appends the pointerness of the next valid pointer slots using the low valid bits of bits. 1=pointer, 0=scalar."
      }
    ],
    "types": [
      {
        "name": "AddrRange",
        "desc": "AddrRange is a wrapper around addrRange for testing."
      },
      {
        "name": "AddrRanges",
        "desc": "AddrRanges is a wrapper around addrRanges for testing."
      },
      {
        "name": "BitCursor",
        "desc": ""
      },
      {
        "name": "BitRange",
        "desc": "BitRange represents a range over a bitmap."
      },
      {
        "name": "BitsMismatch",
        "desc": ""
      },
      {
        "name": "BlockProfileRecord",
        "desc": "BlockProfileRecord describes blocking events originated at a particular call sequence (stack trace)."
      },
      {
        "name": "CPUStats",
        "desc": ""
      },
      {
        "name": "ChunkIdx",
        "desc": "Expose chunk index type."
      },
      {
        "name": "Cleanup",
        "desc": "Cleanup is a handle to a cleanup call for a specific object."
      },
      {
        "name": "ContextStub",
        "desc": ""
      },
      {
        "name": "Dlogger",
        "desc": ""
      },
      {
        "name": "EpollEvent",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": "Error identifies a runtime error used in panic.  The Go runtime triggers panics for a variety of cases, as described by the Go Language Spec, such as out-of-bounds slice/array access, close of nil channels, type assertion failures, etc.  When these cases occur, the Go runtime panics with an error that implements Error. This can be useful when recovering from panics to distinguish between custom application panics and fundamental runtime panics.  Packages outside of the Go standard library should not implement Error."
      },
      {
        "name": "ExceptionState32",
        "desc": ""
      },
      {
        "name": "ExceptionState64",
        "desc": ""
      },
      {
        "name": "FPControl",
        "desc": ""
      },
      {
        "name": "FPStatus",
        "desc": ""
      },
      {
        "name": "FPregset",
        "desc": ""
      },
      {
        "name": "FloatState32",
        "desc": ""
      },
      {
        "name": "FloatState64",
        "desc": ""
      },
      {
        "name": "Fpreg",
        "desc": ""
      },
      {
        "name": "Fpreg1",
        "desc": ""
      },
      {
        "name": "Fpregset",
        "desc": ""
      },
      {
        "name": "Fpstate",
        "desc": ""
      },
      {
        "name": "Fpstate1",
        "desc": ""
      },
      {
        "name": "Fpxreg",
        "desc": ""
      },
      {
        "name": "Fpxreg1",
        "desc": ""
      },
      {
        "name": "Frame",
        "desc": "Frame is the information returned by [Frames] for each call frame."
      },
      {
        "name": "Frames",
        "desc": "Frames may be used to get function/file/line information for a slice of PC values returned by [Callers]."
      },
      {
        "name": "Func",
        "desc": "A Func represents a Go function in the running binary."
      },
      {
        "name": "G",
        "desc": ""
      },
      {
        "name": "GCCPULimiter",
        "desc": ""
      },
      {
        "name": "GCController",
        "desc": ""
      },
      {
        "name": "GCControllerReviseDelta",
        "desc": ""
      },
      {
        "name": "Gregset",
        "desc": ""
      },
      {
        "name": "Itimerspec",
        "desc": ""
      },
      {
        "name": "Itimerval",
        "desc": ""
      },
      {
        "name": "Kevent",
        "desc": ""
      },
      {
        "name": "KeventT",
        "desc": ""
      },
      {
        "name": "LFNode",
        "desc": ""
      },
      {
        "name": "LockRank",
        "desc": ""
      },
      {
        "name": "Lwpparams",
        "desc": ""
      },
      {
        "name": "M",
        "desc": ""
      },
      {
        "name": "MSpan",
        "desc": "mspan wrapper for testing."
      },
      {
        "name": "MSpanQueue",
        "desc": ""
      },
      {
        "name": "MachMsgTypeNumber",
        "desc": ""
      },
      {
        "name": "MachPort",
        "desc": ""
      },
      {
        "name": "MachTimebaseInfo",
        "desc": ""
      },
      {
        "name": "MachVMAddress",
        "desc": ""
      },
      {
        "name": "MachVMMapRead",
        "desc": ""
      },
      {
        "name": "MachVMRegionFlavour",
        "desc": ""
      },
      {
        "name": "MachVMRegionInfo",
        "desc": ""
      },
      {
        "name": "MachVMSize",
        "desc": ""
      },
      {
        "name": "Mcontext",
        "desc": ""
      },
      {
        "name": "Mcontext32",
        "desc": ""
      },
      {
        "name": "Mcontext64",
        "desc": ""
      },
      {
        "name": "McontextT",
        "desc": ""
      },
      {
        "name": "MemProfileRecord",
        "desc": "A MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace)."
      },
      {
        "name": "MemStats",
        "desc": "A MemStats records statistics about the memory allocator."
      },
      {
        "name": "Mutex",
        "desc": ""
      },
      {
        "name": "PIController",
        "desc": ""
      },
      {
        "name": "PageAlloc",
        "desc": "Expose pageAlloc for testing. Note that because pageAlloc is not in the heap, so is PageAlloc."
      },
      {
        "name": "PageCache",
        "desc": "Expose pageCache for testing."
      },
      {
        "name": "PallocBits",
        "desc": "Expose pallocBits for testing."
      },
      {
        "name": "PallocData",
        "desc": "Expose pallocData for testing."
      },
      {
        "name": "PallocSum",
        "desc": "Expose pallocSum for testing."
      },
      {
        "name": "PanicNilError",
        "desc": "A PanicNilError happens when code calls panic(nil).  Before Go 1.21, programs that called panic(nil) observed recover returning nil. Starting in Go 1.21, programs that call panic(nil) observe recover returning a *PanicNilError. Programs can change back to the old behavior by setting GODEBUG=panicnil=1."
      },
      {
        "name": "Pinner",
        "desc": "A Pinner is a set of Go objects each pinned to a fixed location in memory. The [Pinner.Pin] method pins one object, while [Pinner.Unpin] unpins all pinned objects. See their comments for more information."
      },
      {
        "name": "PortEvent",
        "desc": ""
      },
      {
        "name": "ProfBuf",
        "desc": ""
      },
      {
        "name": "Pthread",
        "desc": ""
      },
      {
        "name": "PthreadAttr",
        "desc": ""
      },
      {
        "name": "PthreadCond",
        "desc": ""
      },
      {
        "name": "PthreadCondAttr",
        "desc": ""
      },
      {
        "name": "PthreadMutex",
        "desc": ""
      },
      {
        "name": "PthreadMutexAttr",
        "desc": ""
      },
      {
        "name": "Ptregs",
        "desc": "types used in sigcontext"
      },
      {
        "name": "RWMutex",
        "desc": ""
      },
      {
        "name": "RegMMST",
        "desc": ""
      },
      {
        "name": "RegXMM",
        "desc": ""
      },
      {
        "name": "Regs32",
        "desc": ""
      },
      {
        "name": "Regs64",
        "desc": ""
      },
      {
        "name": "Rtprio",
        "desc": ""
      },
      {
        "name": "ScavengeIndex",
        "desc": ""
      },
      {
        "name": "Scavenger",
        "desc": ""
      },
      {
        "name": "SemT",
        "desc": ""
      },
      {
        "name": "SemTable",
        "desc": "SemTable is a wrapper around semTable exported for testing."
      },
      {
        "name": "Sigaction",
        "desc": ""
      },
      {
        "name": "Sigcontext",
        "desc": ""
      },
      {
        "name": "Sigevent",
        "desc": ""
      },
      {
        "name": "Sighandler",
        "desc": ""
      },
      {
        "name": "Siginfo",
        "desc": ""
      },
      {
        "name": "Sigset",
        "desc": ""
      },
      {
        "name": "Sigval",
        "desc": ""
      },
      {
        "name": "StackRecord",
        "desc": "A StackRecord describes a single execution stack."
      },
      {
        "name": "StackT",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": "depends on Timespec, must appear below"
      },
      {
        "name": "Sudog",
        "desc": ""
      },
      {
        "name": "TestingT",
        "desc": ""
      },
      {
        "name": "TforkT",
        "desc": ""
      },
      {
        "name": "ThrParam",
        "desc": ""
      },
      {
        "name": "TimeHistogram",
        "desc": ""
      },
      {
        "name": "TimeTimer",
        "desc": ""
      },
      {
        "name": "Timespec",
        "desc": ""
      },
      {
        "name": "Timeval",
        "desc": ""
      },
      {
        "name": "TraceMap",
        "desc": ""
      },
      {
        "name": "TraceStackTable",
        "desc": ""
      },
      {
        "name": "TypeAssertionError",
        "desc": "A TypeAssertionError explains a failed type assertion."
      },
      {
        "name": "Ucontext",
        "desc": ""
      },
      {
        "name": "UcontextT",
        "desc": ""
      },
      {
        "name": "Umtx_time",
        "desc": ""
      },
      {
        "name": "UserArena",
        "desc": ""
      },
      {
        "name": "Usigaction",
        "desc": ""
      },
      {
        "name": "Usigset",
        "desc": ""
      },
      {
        "name": "Vreg",
        "desc": ""
      },
      {
        "name": "Xmmreg",
        "desc": ""
      },
      {
        "name": "Xmmreg1",
        "desc": ""
      },
      {
        "name": "_Ctype_struct___extctx",
        "desc": ""
      },
      {
        "name": "_DISPATCHER_CONTEXT",
        "desc": ""
      },
      {
        "name": "_OSVERSIONINFOW",
        "desc": "https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_osversioninfow"
      },
      {
        "name": "_Plink",
        "desc": ""
      },
      {
        "name": "_defer",
        "desc": "A _defer holds an entry on the list of deferred calls. If you add a field here, add code to clear it in deferProcStack. This struct must match the code in cmd/compile/internal/ssagen/ssa.go:deferstruct and cmd/compile/internal/ssagen/ssa.go:(*state).call. Some defers will be allocated on the stack and some on the heap. All defers are logically part of the stack, so write barriers to initialize them are not required. All defers must be manually scanned, and for heap defers, marked."
      },
      {
        "name": "_func",
        "desc": "Layout of in-memory per-function information prepared by linker See https://golang.org/s/go12symtab. Keep in sync with linker (../cmd/link/internal/ld/pcln.go:/pclntab) and with package debug/gosym and with symtab.go in package runtime."
      },
      {
        "name": "_panic",
        "desc": "A _panic holds information about an active panic.  A _panic value must only ever live on the stack.  The argp and link fields are stack pointers, but don't need special handling during stack growth: because they are pointer-typed and _panic values only live on the stack, regular stack pointer adjustment takes care of them."
      },
      {
        "name": "_type",
        "desc": ""
      },
      {
        "name": "_typePair",
        "desc": ""
      },
      {
        "name": "abiDesc",
        "desc": "abiDesc specifies how to translate from a C frame to a Go frame. This does not specify how to translate back because the result is always a uintptr. If the C ABI is fastcall, this assumes the four fastcall registers were first spilled to the shadow space."
      },
      {
        "name": "abiPart",
        "desc": "abiPart encodes a step in translating between calling ABIs."
      },
      {
        "name": "abiPartKind",
        "desc": "abiPartKind is the action an abiPart should take."
      },
      {
        "name": "activeSweep",
        "desc": "activeSweep is a type that captures whether sweeping is done, and whether there are any outstanding sweepers.  Every potential sweeper must call begin() before they look for work, and end() after they've finished sweeping."
      },
      {
        "name": "addrRange",
        "desc": "addrRange represents a region of address space.  An addrRange must never span a gap in the address space."
      },
      {
        "name": "addrRanges",
        "desc": "addrRanges is a data structure holding a collection of ranges of address space.  The ranges are coalesced eagerly to reduce the number ranges it holds.  The slice backing store for this field is persistentalloc'd and thus there is no way to free it.  addrRanges is not thread-safe."
      },
      {
        "name": "adjustinfo",
        "desc": ""
      },
      {
        "name": "ancestorInfo",
        "desc": "ancestorInfo records details of where a goroutine was started."
      },
      {
        "name": "arenaHint",
        "desc": "arenaHint is a hint for where to grow the heap arenas. See mheap_.arenaHints."
      },
      {
        "name": "arenaIdx",
        "desc": ""
      },
      {
        "name": "argset",
        "desc": "argset matches runtime/cgo/linux_syscall.c:argset_t"
      },
      {
        "name": "arraytype",
        "desc": ""
      },
      {
        "name": "atomicHeadTailIndex",
        "desc": "atomicHeadTailIndex is an atomically-accessed headTailIndex."
      },
      {
        "name": "atomicMSpanPointer",
        "desc": "atomicMSpanPointer is an atomic.Pointer[mspan]. Can't use generics because it's NotInHeap."
      },
      {
        "name": "atomicOffAddr",
        "desc": "atomicOffAddr is like offAddr, but operations on it are atomic. It also contains operations to be able to store marked addresses to ensure that they're not overridden until they've been seen."
      },
      {
        "name": "atomicScavChunkData",
        "desc": "atomicScavChunkData is an atomic wrapper around a scavChunkData that stores it in its packed form."
      },
      {
        "name": "atomicSpanSetSpinePointer",
        "desc": "atomicSpanSetSpinePointer is an atomically-accessed spanSetSpinePointer.  It has the same semantics as atomic.UnsafePointer."
      },
      {
        "name": "bintime",
        "desc": ""
      },
      {
        "name": "bitCursor",
        "desc": "A bitCursor is a simple cursor to memory to which we can write a set of bits."
      },
      {
        "name": "bitvector",
        "desc": "Information from the compiler about the layout of stack frames. Note: this type must agree with reflect.bitVector."
      },
      {
        "name": "blockRecord",
        "desc": "A blockRecord is the bucket data for a bucket of type blockProfile, which is used in blocking and mutex profiles."
      },
      {
        "name": "bmap",
        "desc": "A bucket for a Go map."
      },
      {
        "name": "boundsError",
        "desc": "A boundsError represents an indexing or slicing operation gone wrong."
      },
      {
        "name": "boundsErrorCode",
        "desc": ""
      },
      {
        "name": "bucket",
        "desc": "A bucket holds per-call-stack profiling information. The representation is a bit sleazy, inherited from C. This struct defines the bucket header. It is followed in memory by the stack words and then the actual record data, either a memRecord or a blockRecord.  Per-call-stack profiling information. Lookup by hashing call stack into a linked-list hash table.  None of the fields in this bucket header are modified after creation, including its next and allnext links.  No heap pointers."
      },
      {
        "name": "bucketType",
        "desc": ""
      },
      {
        "name": "buckhashArray",
        "desc": ""
      },
      {
        "name": "callbackArgs",
        "desc": ""
      },
      {
        "name": "cgoCallers",
        "desc": "Addresses collected in a cgo backtrace when crashing. Length must match arg.Max in x_cgo_callers in runtime/cgo/gcc_traceback.c."
      },
      {
        "name": "cgoContextArg",
        "desc": "cgoContextArg is the type passed to the context function."
      },
      {
        "name": "cgoSymbolizerArg",
        "desc": "cgoSymbolizerArg is the type passed to cgoSymbolizer."
      },
      {
        "name": "cgoTracebackArg",
        "desc": "cgoTracebackArg is the type passed to cgoTraceback."
      },
      {
        "name": "cgothreadstart",
        "desc": ""
      },
      {
        "name": "chantype",
        "desc": ""
      },
      {
        "name": "checkmarksMap",
        "desc": "A checkmarksMap stores the GC marks in \"checkmarks\" mode. It is a per-arena bitmap with a bit for every word in the arena. The mark is stored on the bit corresponding to the first word of the marked allocation."
      },
      {
        "name": "childInfo",
        "desc": ""
      },
      {
        "name": "chunkIdx",
        "desc": "Global chunk index.  Represents an index into the leaf level of the radix tree. Similar to arenaIndex, except instead of arenas, it divides the address space into chunks."
      },
      {
        "name": "cleanupBlock",
        "desc": "cleanupBlock is an block of cleanups to be executed.  cleanupBlock is allocated from non-GC'd memory, so any heap pointers must be specially handled. The GC and cleanup queue currently assume that the cleanup queue does not grow during marking (but it can shrink)."
      },
      {
        "name": "cleanupBlockHeader",
        "desc": ""
      },
      {
        "name": "cleanupQueue",
        "desc": "cleanupQueue is a queue of ready-to-run cleanup functions."
      },
      {
        "name": "clockid",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-clockid-variant"
      },
      {
        "name": "consistentHeapStats",
        "desc": "consistentHeapStats represents a set of various memory statistics whose updates must be viewed completely to get a consistent state of the world.  To write updates to memory stats use the acquire and release methods. To obtain a consistent global snapshot of these statistics, use read."
      },
      {
        "name": "context",
        "desc": "See https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-arm64_nt_context"
      },
      {
        "name": "context64",
        "desc": ""
      },
      {
        "name": "coro",
        "desc": "A coro represents extra concurrency without extra parallelism, as would be needed for a coroutine implementation. The coro does not represent a specific coroutine, only the ability to do coroutine-style control transfers. It can be thought of as like a special channel that always has a goroutine blocked on it. If another goroutine calls coroswitch(c), the caller becomes the goroutine blocked in c, and the goroutine formerly blocked in c starts running. These switches continue until a call to coroexit(c), which ends the use of the coro by releasing the blocked goroutine in c and exiting the current goroutine.  Coros are heap allocated and garbage collected, so that user code can hold a pointer to a coro without causing potential dangling pointer errors."
      },
      {
        "name": "cpuProfile",
        "desc": ""
      },
      {
        "name": "cpuStats",
        "desc": ""
      },
      {
        "name": "cpuStatsAggregate",
        "desc": "cpuStatsAggregate represents CPU stats obtained from the runtime acquired together to avoid skew and inconsistencies."
      },
      {
        "name": "dbgVar",
        "desc": ""
      },
      {
        "name": "debugCallHandler",
        "desc": ""
      },
      {
        "name": "debugCallWrapArgs",
        "desc": ""
      },
      {
        "name": "debugLogBuf",
        "desc": ""
      },
      {
        "name": "debugLogReader",
        "desc": ""
      },
      {
        "name": "debugLogWriter",
        "desc": "A debugLogWriter is a ring buffer of binary debug log records.  A log record consists of a 2-byte framing header and a sequence of fields. The framing header gives the size of the record as a little endian 16-bit value. Each field starts with a byte indicating its type, followed by type-specific data. If the size in the framing header is 0, it's a sync record consisting of two little endian 64-bit values giving a new time base.  Because this is a ring buffer, new records will eventually overwrite old records. Hence, it maintains a reader that consumes the log as it gets overwritten. That reader state is where an actual log reader would start."
      },
      {
        "name": "dlogPerM",
        "desc": "dlogPerM is the per-M debug log data. This is embedded in the m struct."
      },
      {
        "name": "dlogger",
        "desc": "dlogger is the underlying implementation of the dlogger interface, selected at build time.  We use a type alias instead of struct embedding so that the dlogger type is identical to the type returned by method chaining on the methods of this type."
      },
      {
        "name": "dloggerFake",
        "desc": "A dloggerFake is a no-op implementation of dlogger."
      },
      {
        "name": "dloggerImpl",
        "desc": "A dloggerImpl writes to the debug log.  To obtain a dloggerImpl, call dlog(). When done with the dloggerImpl, call end()."
      },
      {
        "name": "eface",
        "desc": ""
      },
      {
        "name": "elfDyn",
        "desc": ""
      },
      {
        "name": "elfEhdr",
        "desc": ""
      },
      {
        "name": "elfPhdr",
        "desc": ""
      },
      {
        "name": "elfShdr",
        "desc": ""
      },
      {
        "name": "elfSym",
        "desc": ""
      },
      {
        "name": "elfVerdaux",
        "desc": ""
      },
      {
        "name": "elfVerdef",
        "desc": ""
      },
      {
        "name": "errno",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-errno-variant"
      },
      {
        "name": "errorAddressString",
        "desc": ""
      },
      {
        "name": "errorString",
        "desc": "An errorString represents a runtime error described by a single string."
      },
      {
        "name": "evacDst",
        "desc": "evacDst is an evacuation destination."
      },
      {
        "name": "event",
        "desc": "The go:wasmimport directive currently does not accept values of type uint16 in arguments or returns of the function signature. Most WASI imports return an errno value, which we have to define as uint32 because of that limitation. However, the WASI errno type is intended to be a 16 bits integer, and in the event struct the error field should be of type errno. If we used the errno type for the error field it would result in a mismatching field alignment and struct size because errno is declared as a 32 bits type, so we declare the error field as a plain uint16."
      },
      {
        "name": "eventFdReadwrite",
        "desc": ""
      },
      {
        "name": "eventrwflags",
        "desc": ""
      },
      {
        "name": "eventtype",
        "desc": ""
      },
      {
        "name": "exceptionpointers",
        "desc": ""
      },
      {
        "name": "exceptionrecord",
        "desc": ""
      },
      {
        "name": "exceptionstate32",
        "desc": ""
      },
      {
        "name": "exceptionstate64",
        "desc": ""
      },
      {
        "name": "filesize",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-filesize-u64"
      },
      {
        "name": "finBlock",
        "desc": "finBlock is an block of finalizers to be executed. finBlocks are arranged in a linked list for the finalizer queue.  finBlock is allocated from non-GC'd memory, so any heap pointers must be specially handled. GC currently assumes that the finalizer queue does not grow during marking (but it can shrink)."
      },
      {
        "name": "finalizer",
        "desc": "NOTE: Layout known to queuefinalizer."
      },
      {
        "name": "findfuncbucket",
        "desc": "findfuncbucket is an array of these structures. Each bucket represents 4096 bytes of the text segment. Each subbucket represents 256 bytes of the text segment. To find a function given a pc, locate the bucket and subbucket for that pc. Add together the idx and subbucket value to obtain a function index. Then scan the functab array starting at that index to find the target function. This table uses 20 bytes for every 4096 bytes of code, or ~0.5% overhead."
      },
      {
        "name": "fixalloc",
        "desc": "fixalloc is a simple free-list allocator for fixed size objects. Malloc uses a FixAlloc wrapped around sysAlloc to manage its mcache and mspan objects.  Memory returned by fixalloc.alloc is zeroed by default, but the caller may take responsibility for zeroing allocations by setting the zero flag to false. This is only safe if the memory never contains heap pointers.  The caller is responsible for locking around FixAlloc calls. Callers can keep state in the object but the first word is smashed by freeing and reallocating.  Consider marking fixalloc'd types not in heap by embedding internal/runtime/sys.NotInHeap."
      },
      {
        "name": "floatingsavearea",
        "desc": ""
      },
      {
        "name": "floatstate32",
        "desc": ""
      },
      {
        "name": "floatstate64",
        "desc": ""
      },
      {
        "name": "floaty",
        "desc": ""
      },
      {
        "name": "forcegcstate",
        "desc": ""
      },
      {
        "name": "fpcontrol",
        "desc": ""
      },
      {
        "name": "fpreg",
        "desc": ""
      },
      {
        "name": "fpreg1",
        "desc": ""
      },
      {
        "name": "fpregs",
        "desc": ""
      },
      {
        "name": "fpregset",
        "desc": ""
      },
      {
        "name": "fpstate",
        "desc": ""
      },
      {
        "name": "fpstate1",
        "desc": ""
      },
      {
        "name": "fpstatus",
        "desc": ""
      },
      {
        "name": "fpxreg",
        "desc": ""
      },
      {
        "name": "fpxreg1",
        "desc": ""
      },
      {
        "name": "funcDescriptor",
        "desc": "funcDescriptor is a structure representing a function descriptor A variable with this type is always created in assembler"
      },
      {
        "name": "funcInfo",
        "desc": ""
      },
      {
        "name": "funcinl",
        "desc": "Pseudo-Func that is returned for PCs that occur in inlined code. A *Func can be either a *_func or a *funcinl, and they are distinguished by the first uintptr.  TODO(austin): Can we merge this with inlinedCall?"
      },
      {
        "name": "functab",
        "desc": ""
      },
      {
        "name": "functype",
        "desc": ""
      },
      {
        "name": "funcval",
        "desc": ""
      },
      {
        "name": "g",
        "desc": ""
      },
      {
        "name": "gList",
        "desc": "A gList is a list of Gs linked through g.schedlink. A G can only be on one gQueue or gList at a time."
      },
      {
        "name": "gQueue",
        "desc": "A gQueue is a dequeue of Gs linked through g.schedlink. A G can only be on one gQueue or gList at a time."
      },
      {
        "name": "gTraceState",
        "desc": "gTraceState is per-G state for the tracer."
      },
      {
        "name": "gcBgMarkWorkerNode",
        "desc": "gcBgMarkWorkerNode is an entry in the gcBgMarkWorkerPool. It points to a single gcBgMarkWorker goroutine."
      },
      {
        "name": "gcBgMarkWorkerNodePadded",
        "desc": ""
      },
      {
        "name": "gcBits",
        "desc": "gcBits is an alloc/mark bitmap. This is always used as gcBits.x."
      },
      {
        "name": "gcBitsArena",
        "desc": ""
      },
      {
        "name": "gcBitsHeader",
        "desc": ""
      },
      {
        "name": "gcCPULimiterState",
        "desc": ""
      },
      {
        "name": "gcControllerState",
        "desc": ""
      },
      {
        "name": "gcDrainFlags",
        "desc": ""
      },
      {
        "name": "gcMarkWorkerMode",
        "desc": "gcMarkWorkerMode represents the mode that a concurrent mark worker should operate in.  Concurrent marking happens through four different mechanisms. One is mutator assists, which happen in response to allocations and are not scheduled. The other three are variations in the per-P mark workers and are distinguished by gcMarkWorkerMode."
      },
      {
        "name": "gcMode",
        "desc": "gcMode indicates how concurrent a GC cycle should be."
      },
      {
        "name": "gcStatsAggregate",
        "desc": "gcStatsAggregate represents various GC stats obtained from the runtime acquired together to avoid skew and inconsistencies."
      },
      {
        "name": "gcTrigger",
        "desc": "A gcTrigger is a predicate for starting a GC cycle. Specifically, it is an exit condition for the _GCoff phase."
      },
      {
        "name": "gcTriggerKind",
        "desc": ""
      },
      {
        "name": "gcWork",
        "desc": "A gcWork provides the interface to produce and consume work for the garbage collector.  A gcWork can be used on the stack as follows:  \t(preemption must be disabled) \tgcw := \u0026getg().m.p.ptr().gcw \t.. call gcw.put() to produce and gcw.tryGet() to consume ..  It's important that any use of gcWork during the mark phase prevent the garbage collector from transitioning to mark termination since gcWork may locally hold GC work buffers. This can be done by disabling preemption (systemstack or acquirem)."
      },
      {
        "name": "gclink",
        "desc": "A gclink is a node in a linked list of blocks, like mlink, but it is opaque to the garbage collector. The GC does not trace the pointers during collection, and the compiler does not emit write barriers for assignments of gclinkptr values. Code should store references to gclinks as gclinkptr, not as *gclink."
      },
      {
        "name": "gclinkptr",
        "desc": "A gclinkptr is a pointer to a gclink, but it is opaque to the garbage collector."
      },
      {
        "name": "gobuf",
        "desc": ""
      },
      {
        "name": "godebugInc",
        "desc": "A godebugInc provides access to internal/godebug's IncNonDefault function for a given GODEBUG setting. Calls before internal/godebug registers itself are dropped on the floor."
      },
      {
        "name": "goroutineProfileState",
        "desc": "goroutineProfileState indicates the status of a goroutine's stack for the current in-progress goroutine profile. Goroutines' stacks are initially \"Absent\" from the profile, and end up \"Satisfied\" by the time the profile is complete. While a goroutine's stack is being captured, its goroutineProfileState will be \"InProgress\" and it will not be able to run until the capture completes and the state moves to \"Satisfied\".  Some goroutines (the finalizer goroutine, which at various times can be either a \"system\" or a \"user\" goroutine, and the goroutine that is coordinating the profile, any goroutines created during the profile) move directly to the \"Satisfied\" state."
      },
      {
        "name": "goroutineProfileStateHolder",
        "desc": ""
      },
      {
        "name": "gpregs",
        "desc": ""
      },
      {
        "name": "gsignalStack",
        "desc": "gsignalStack is unused on Windows."
      },
      {
        "name": "guintptr",
        "desc": "A guintptr holds a goroutine pointer, but typed as a uintptr to bypass write barriers. It is used in the Gobuf goroutine state and in scheduling lists that are manipulated without a P.  The Gobuf.g goroutine pointer is almost always updated by assembly code. In one of the few places it is updated by Go code - func save - it must be treated as a uintptr to avoid a write barrier being emitted at a bad time. Instead of figuring out how to emit the write barriers missing in the assembly manipulation, we change the type of the field to uintptr, so that it does not require write barriers at all.  Goroutine structs are published in the allg list and never freed. That will keep the goroutine structs from being collected. There is never a time that Gobuf.g's contain the only references to a goroutine: the publishing of the goroutine in allg comes first. Goroutine pointers are also kept in non-GC-visible places like TLS, so I can't see them ever moving. If we did want to start moving data in the GC, we'd need to allocate the goroutine structs from an alternate arena. Using guintptr doesn't make that problem any worse. Note that pollDesc.rg, pollDesc.wg also store g in uintptr form, so they would need to be updated too if g's start moving."
      },
      {
        "name": "hchan",
        "desc": ""
      },
      {
        "name": "headTailIndex",
        "desc": "headTailIndex represents a combined 32-bit head and 32-bit tail of a queue into a single 64-bit value."
      },
      {
        "name": "heapArena",
        "desc": "A heapArena stores metadata for a heap arena. heapArenas are stored outside of the Go heap and accessed via the mheap_.arenas index."
      },
      {
        "name": "heapStatsAggregate",
        "desc": "heapStatsAggregate represents memory stats obtained from the runtime. This set of stats is grouped together because they depend on each other in some way to make sense of the runtime's current heap memory use. They're also sharded across Ps, so it makes sense to grab them all at once."
      },
      {
        "name": "heapStatsDelta",
        "desc": "heapStatsDelta contains deltas of various runtime memory statistics that need to be updated together in order for them to be kept consistent with one another."
      },
      {
        "name": "heldLockInfo",
        "desc": "heldLockInfo gives info on a held lock and the rank of that lock"
      },
      {
        "name": "hex",
        "desc": "The compiler knows that a print of a value of this type should use printhex instead of printuint (decimal)."
      },
      {
        "name": "hiter",
        "desc": "A hash iteration structure. If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go and reflect/value.go to match the layout of this structure."
      },
      {
        "name": "hmap",
        "desc": "A header for a Go map."
      },
      {
        "name": "iface",
        "desc": ""
      },
      {
        "name": "immortalWeakHandle",
        "desc": "immortalWeakHandle is a lock-free append-only hash-trie.  Key features:   - 2-ary trie. Child nodes are indexed by the highest bit (remaining) of the hash of the address.   - New nodes are placed at the first empty level encountered.   - When the first child is added to a node, the existing value is not moved into a child.     This means that we must check the value at each level, not just at the leaf.   - No deletion or rebalancing.   - Intentionally devolves into a linked list on hash collisions (the hash bits will all     get shifted out during iteration, and new nodes will just be appended to the 0th child)."
      },
      {
        "name": "immortalWeakHandleMap",
        "desc": ""
      },
      {
        "name": "initTask",
        "desc": "An initTask represents the set of initializations that need to be done for a package. Keep in sync with ../../test/noinit.go:initTask"
      },
      {
        "name": "inlineFrame",
        "desc": "An inlineFrame is a position in an inlineUnwinder."
      },
      {
        "name": "inlineUnwinder",
        "desc": "An inlineUnwinder iterates over the stack of inlined calls at a PC by decoding the inline table. The last step of iteration is always the frame of the physical function, so there's always at least one frame.  This is typically used as:  \tfor u, uf := newInlineUnwinder(...); uf.valid(); uf = u.next(uf) { ... }  Implementation note: This is used in contexts that disallow write barriers. Hence, the constructor returns this by value and pointer receiver methods must not mutate pointer fields. Also, we keep the mutable state in a separate struct mostly to keep both structs SSA-able, which generates much better code."
      },
      {
        "name": "inlinedCall",
        "desc": "inlinedCall is the encoding of entries in the FUNCDATA_InlTree table."
      },
      {
        "name": "interfacetype",
        "desc": ""
      },
      {
        "name": "iovec",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-iovec-record"
      },
      {
        "name": "itab",
        "desc": ""
      },
      {
        "name": "itabTableType",
        "desc": "Note: change the formula in the mallocgc call in itabAdd if you change these fields."
      },
      {
        "name": "itimerspec",
        "desc": ""
      },
      {
        "name": "itimerval",
        "desc": ""
      },
      {
        "name": "jmpbuf",
        "desc": ""
      },
      {
        "name": "keventt",
        "desc": ""
      },
      {
        "name": "lfnode",
        "desc": "Lock-free stack node. Also known to export_test.go."
      },
      {
        "name": "lfstack",
        "desc": "lfstack is the head of a lock-free stack.  The zero value of lfstack is an empty list.  This stack is intrusive. Nodes must embed lfnode as the first field.  The stack does not keep GC-visible pointers to nodes, so the caller must ensure the nodes are allocated outside the Go heap."
      },
      {
        "name": "libFunc",
        "desc": ""
      },
      {
        "name": "libcFunc",
        "desc": ""
      },
      {
        "name": "libcall",
        "desc": ""
      },
      {
        "name": "limiterEvent",
        "desc": "limiterEvent represents tracking state for an event tracked by the GC CPU limiter."
      },
      {
        "name": "limiterEventStamp",
        "desc": "limiterEventStamp is a nanotime timestamp packed with a limiterEventType."
      },
      {
        "name": "limiterEventType",
        "desc": "limiterEventType indicates the type of an event occurring on some P.  These events represent the full set of events that the GC CPU limiter tracks to execute its function.  This type may use no more than limiterEventBits bits of information."
      },
      {
        "name": "linearAlloc",
        "desc": "linearAlloc is a simple linear allocator that pre-reserves a region of memory and then optionally maps that region into the Ready state as needed.  The caller is responsible for locking."
      },
      {
        "name": "linknameIter",
        "desc": "linknameIter is the it argument to mapiterinit and mapiternext.  Callers of mapiterinit allocate their own iter structure, which has the layout of the pre-Go 1.24 hiter structure, shown here for posterity:  \ttype hiter struct { \t\tkey         unsafe.Pointer \t\telem        unsafe.Pointer \t\tt           *maptype \t\th           *hmap \t\tbuckets     unsafe.Pointer \t\tbptr        *bmap \t\toverflow    *[]*bmap \t\toldoverflow *[]*bmap \t\tstartBucket uintptr \t\toffset      uint8 \t\twrapped     bool \t\tB           uint8 \t\ti           uint8 \t\tbucket      uintptr \t\tcheckBucket uintptr \t}  Our structure must maintain compatibility with the old structure. This means:    - Our structure must be the same size or smaller than hiter. Otherwise we     may write outside the caller's hiter allocation.   - Our structure must have the same pointer layout as hiter, so that the GC     tracks pointers properly.  Based on analysis of the \"hall of shame\" users of these linknames:    - The key and elem fields must be kept up to date with the current key/elem.     Some users directly access the key and elem fields rather than calling     reflect.mapiterkey/reflect.mapiterelem.   - The t field must be non-nil after mapiterinit. gonum.org/v1/gonum uses     this to verify the iterator is initialized.   - github.com/segmentio/encoding and github.com/RomiChan/protobuf check if h     is non-nil, but the code has no effect. Thus the value of h does not     matter. See internal/runtime_reflect/map.go."
      },
      {
        "name": "liveUserArenaChunk",
        "desc": ""
      },
      {
        "name": "localSpanQueue",
        "desc": ""
      },
      {
        "name": "lockRank",
        "desc": ""
      },
      {
        "name": "lockRankStruct",
        "desc": "lockRankStruct is embedded in mutex"
      },
      {
        "name": "loggerType",
        "desc": "Prior to Android-L, logging was done through writes to /dev/log files implemented in kernel ring buffers. In Android-L, those /dev/log files are no longer accessible and logging is done through a centralized user-mode logger, logd.  https://android.googlesource.com/platform/system/core/+/refs/tags/android-6.0.1_r78/liblog/logd_write.c"
      },
      {
        "name": "lwpparams",
        "desc": ""
      },
      {
        "name": "m",
        "desc": ""
      },
      {
        "name": "m0Stack",
        "desc": ""
      },
      {
        "name": "m128a",
        "desc": ""
      },
      {
        "name": "mLockProfile",
        "desc": "mLockProfile holds information about the runtime-internal lock contention experienced and caused by this M, to report in metrics and profiles.  These measurements are subject to some notable constraints: First, the fast path for lock and unlock must remain very fast, with a minimal critical section. Second, the critical section during contention has to remain small too, so low levels of contention are less likely to snowball into large ones. The reporting code cannot acquire new locks until the M has released all other locks, which means no memory allocations and encourages use of (temporary) M-local storage.  The M has space for storing one call stack that caused contention, and the magnitude of that contention. It also has space to store the magnitude of additional contention the M caused, since it might encounter several contention events before it releases all of its locks and is thus able to transfer the locally buffered call stack and magnitude into the profile.  The M collects the call stack when it unlocks the contended lock. The traceback takes place outside of the lock's critical section.  The profile for contention on sync.Mutex blames the caller of Unlock for the amount of contention experienced by the callers of Lock which had to wait. When there are several critical sections, this allows identifying which of them is responsible. We must match that reporting behavior for contention on runtime-internal locks.  When the M unlocks its last mutex, it transfers the locally buffered call stack and magnitude into the profile. As part of that step, it also transfers any \"additional contention\" time to the profile. Any lock contention that it experiences while adding samples to the profile will be recorded later as \"additional contention\" and not include a call stack, to avoid an echo."
      },
      {
        "name": "mOS",
        "desc": ""
      },
      {
        "name": "mPadded",
        "desc": ""
      },
      {
        "name": "mProfCycleHolder",
        "desc": "mProfCycleHolder holds the global heap profile cycle number (wrapped at mProfCycleWrap, stored starting at bit 1), and a flag (stored at bit 0) to indicate whether future[cycle] in all buckets has been queued to flush into the active profile."
      },
      {
        "name": "mSpanList",
        "desc": "mSpanList heads a linked list of spans."
      },
      {
        "name": "mSpanQueue",
        "desc": "mSpanQueue is like an mSpanList but is FIFO instead of LIFO and may be allocated on the stack. (mSpanList can be visible from the mspan itself, so it is marked as not-in-heap)."
      },
      {
        "name": "mSpanState",
        "desc": "An mspan representing actual memory has state mSpanInUse, mSpanManual, or mSpanFree. Transitions between these states are constrained as follows:    - A span may transition from free to in-use or manual during any GC     phase.    - During sweeping (gcphase == _GCoff), a span may transition from     in-use to free (as a result of sweeping) or manual to free (as a     result of stacks being freed).    - During GC (gcphase != _GCoff), a span *must not* transition from     manual or in-use to free. Because concurrent GC may read a pointer     and then look up its span, the span state must be monotonic.  Setting mspan.state to mSpanInUse or mSpanManual must be done atomically and only after all other span fields are valid. Likewise, if inspecting a span is contingent on it being mSpanInUse, the state should be loaded atomically and checked before depending on other fields. This allows the garbage collector to safely deal with potentially invalid pointers, since resolving such pointers may race with a span being allocated."
      },
      {
        "name": "mSpanStateBox",
        "desc": "mSpanStateBox holds an atomic.Uint8 to provide atomic operations on an mSpanState. This is a separate type to disallow accidental comparison or assignment with mSpanState."
      },
      {
        "name": "mTraceState",
        "desc": "mTraceState is per-M state for the tracer."
      },
      {
        "name": "mWaitList",
        "desc": ""
      },
      {
        "name": "machMsgTypeNumber",
        "desc": ""
      },
      {
        "name": "machPort",
        "desc": ""
      },
      {
        "name": "machTimebaseInfo",
        "desc": ""
      },
      {
        "name": "machVMAddress",
        "desc": ""
      },
      {
        "name": "machVMMapRead",
        "desc": ""
      },
      {
        "name": "machVMRegionFlavour",
        "desc": ""
      },
      {
        "name": "machVMRegionInfo",
        "desc": ""
      },
      {
        "name": "machVMSize",
        "desc": ""
      },
      {
        "name": "mapextra",
        "desc": "mapextra holds fields that are not present on all maps."
      },
      {
        "name": "maptype",
        "desc": ""
      },
      {
        "name": "markBits",
        "desc": "markBits provides access to the mark bit for an object in the heap. bytep points to the byte holding the mark bit. mask is a byte with a single bit set that can be \u0026ed with *bytep to see if the bit has been set. *m.byte\u0026m.mask != 0 indicates the mark bit is set. index can be used along with span information to generate the address of the object in the heap. We maintain one set of mark bits for allocation and one for marking purposes."
      },
      {
        "name": "mcache",
        "desc": "Per-thread (in Go, per-P) cache for small objects. This includes a small object cache and local allocation stats. No locking needed because it is per-thread (per-P).  mcaches are allocated from non-GC'd memory, so any heap pointers must be specially handled."
      },
      {
        "name": "mcentral",
        "desc": "Central list of free objects of a given size."
      },
      {
        "name": "mcontext",
        "desc": ""
      },
      {
        "name": "mcontext32",
        "desc": ""
      },
      {
        "name": "mcontext64",
        "desc": ""
      },
      {
        "name": "mcontextt",
        "desc": ""
      },
      {
        "name": "memHdr",
        "desc": ""
      },
      {
        "name": "memHdrPtr",
        "desc": ""
      },
      {
        "name": "memRecord",
        "desc": "A memRecord is the bucket data for a bucket of type memProfile, part of the memory profile."
      },
      {
        "name": "memRecordCycle",
        "desc": "memRecordCycle"
      },
      {
        "name": "memoryBasicInformation",
        "desc": ""
      },
      {
        "name": "metricData",
        "desc": ""
      },
      {
        "name": "metricFloat64Histogram",
        "desc": "metricFloat64Histogram is a runtime copy of runtime/metrics.Float64Histogram and must be kept structurally identical to that type."
      },
      {
        "name": "metricKind",
        "desc": "metricKind is a runtime copy of runtime/metrics.ValueKind and must be kept structurally identical to that type."
      },
      {
        "name": "metricName",
        "desc": ""
      },
      {
        "name": "metricReader",
        "desc": ""
      },
      {
        "name": "metricSample",
        "desc": "metricSample is a runtime copy of runtime/metrics.Sample and must be kept structurally identical to that type."
      },
      {
        "name": "metricValue",
        "desc": "metricValue is a runtime copy of runtime/metrics.Sample and must be kept structurally identical to that type."
      },
      {
        "name": "mheap",
        "desc": "Main malloc heap. The heap itself is the \"free\" and \"scav\" treaps, but all the other global data is here too.  mheap must not be heap-allocated because it contains mSpanLists, which must not be heap-allocated."
      },
      {
        "name": "mlink",
        "desc": "A generic linked list of blocks.  (Typically the block is bigger than sizeof(MLink).) Since assignments to mlink.next will result in a write barrier being performed this cannot be used by some of the internal GC structures. For example when the sweeper is placing an unmarked object on the free list it does not want the write barrier to be called since that could result in the object being reachable."
      },
      {
        "name": "moduledata",
        "desc": "moduledata records information about the layout of the executable image. It is written by the linker. Any changes here must be matched changes to the code in cmd/link/internal/ld/symtab.go:symtab. moduledata is stored in statically allocated non-pointer memory; none of the pointers here are visible to the garbage collector."
      },
      {
        "name": "modulehash",
        "desc": "A modulehash is used to compare the ABI of a new module or a package in a new module with the loaded program.  For each shared library a module links against, the linker creates an entry in the moduledata.modulehashes slice containing the name of the module, the abi hash seen at link time and a pointer to the runtime abi hash. These are checked in moduledataverify1 below.  For each loaded plugin, the pkghashes slice has a modulehash of the newly loaded package that can be used to check the plugin's version of a package against any previously loaded version of the package. This is done in plugin.lastmoduleinit."
      },
      {
        "name": "mscratch",
        "desc": ""
      },
      {
        "name": "mspan",
        "desc": ""
      },
      {
        "name": "mstats",
        "desc": ""
      },
      {
        "name": "mts",
        "desc": ""
      },
      {
        "name": "muintptr",
        "desc": "muintptr is a *m that is not tracked by the garbage collector.  Because we do free Ms, there are some additional constrains on muintptrs:   1. Never hold an muintptr locally across a safe point.   2. Any muintptr in the heap must be owned by the M itself so it can     ensure it is not in use when the last true *m is released."
      },
      {
        "name": "mutex",
        "desc": "Mutual exclusion locks.  In the uncontended case, as fast as spin locks (just a few user-level instructions), but on the contention path they sleep in the kernel. A zeroed Mutex is unlocked (no need to initialize each lock). Initialization is helpful for static lock ranking, but not required."
      },
      {
        "name": "name",
        "desc": ""
      },
      {
        "name": "nameOff",
        "desc": ""
      },
      {
        "name": "neon128",
        "desc": ""
      },
      {
        "name": "neonstate64",
        "desc": ""
      },
      {
        "name": "neverCallThisFunction",
        "desc": ""
      },
      {
        "name": "notInHeap",
        "desc": "notInHeap is off-heap memory allocated by a lower-level allocator like sysAlloc or persistentAlloc.  In general, it's better to use real types which embed internal/runtime/sys.NotInHeap, but this serves as a generic type for situations where that isn't possible (like in the allocators).  TODO: Use this as the return type of sysAlloc, persistentAlloc, etc?"
      },
      {
        "name": "notInHeapSlice",
        "desc": "A notInHeapSlice is a slice backed by internal/runtime/sys.NotInHeap memory."
      },
      {
        "name": "note",
        "desc": "sleep and wakeup on one-time events. before any calls to notesleep or notewakeup, must call noteclear to initialize the Note. then, exactly one thread can call notesleep and exactly one thread can call notewakeup (once). once notewakeup has been called, the notesleep will return.  future notesleep will return immediately. subsequent noteclear must be called only after previous notesleep has returned, e.g. it's disallowed to call noteclear straight after notewakeup.  notetsleep is like notesleep but wakes up after a given number of nanoseconds even if the event has not yet happened.  if a goroutine uses notetsleep to wake up early, it must wait to call noteclear until it can be sure that no other goroutine is calling notewakeup.  notesleep/notetsleep are generally called on g0, notetsleepg is similar to notetsleep but is called on user g."
      },
      {
        "name": "noteData",
        "desc": ""
      },
      {
        "name": "noteQueue",
        "desc": ""
      },
      {
        "name": "notifyList",
        "desc": "notifyList is a ticket-based notification list used to implement sync.Cond.  It must be kept in sync with the sync package."
      },
      {
        "name": "objptr",
        "desc": ""
      },
      {
        "name": "offAddr",
        "desc": "offAddr represents an address in a contiguous view of the address space on systems where the address space is segmented. On other systems, it's just a normal address."
      },
      {
        "name": "overlapped",
        "desc": ""
      },
      {
        "name": "overlappedEntry",
        "desc": "overlappedEntry contains the information returned by a call to GetQueuedCompletionStatusEx. https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry"
      },
      {
        "name": "p",
        "desc": ""
      },
      {
        "name": "pMask",
        "desc": "pMask is an atomic bitstring with one bit per P."
      },
      {
        "name": "pTraceState",
        "desc": "pTraceState is per-P state for the tracer."
      },
      {
        "name": "pageAlloc",
        "desc": ""
      },
      {
        "name": "pageBits",
        "desc": "pageBits is a bitmap representing one bit per page in a palloc chunk."
      },
      {
        "name": "pageCache",
        "desc": "pageCache represents a per-p cache of pages the allocator can allocate from without a lock. More specifically, it represents a pageCachePages*pageSize chunk of memory with 0 or more free pages in it."
      },
      {
        "name": "pallocBits",
        "desc": "pallocBits is a bitmap that tracks page allocations for at most one palloc chunk.  The precise representation is an implementation detail, but for the sake of documentation, 0s are free pages and 1s are allocated pages."
      },
      {
        "name": "pallocData",
        "desc": "pallocData encapsulates pallocBits and a bitmap for whether or not a given page is scavenged in a single structure. It's effectively a pallocBits with additional functionality.  Update the comment on (*pageAlloc).chunks should this structure change."
      },
      {
        "name": "pallocSum",
        "desc": "pallocSum is a packed summary type which packs three numbers: start, max, and end into a single 8-byte value. Each of these values are a summary of a bitmap and are thus counts, each of which may have a maximum value of 2^21 - 1, or all three may be equal to 2^21. The latter case is represented by just setting the 64th bit."
      },
      {
        "name": "pcHeader",
        "desc": "pcHeader holds data used by the pclntab lookups."
      },
      {
        "name": "pcvalueCache",
        "desc": ""
      },
      {
        "name": "pcvalueCacheEnt",
        "desc": ""
      },
      {
        "name": "perThreadSyscallArgs",
        "desc": "perThreadSyscallArgs contains the system call number, arguments, and expected return values for a system call to be executed on all threads."
      },
      {
        "name": "persistentAlloc",
        "desc": ""
      },
      {
        "name": "piController",
        "desc": ""
      },
      {
        "name": "pinState",
        "desc": ""
      },
      {
        "name": "pinner",
        "desc": ""
      },
      {
        "name": "pinnerBits",
        "desc": "pinnerBits is the same type as gcBits but has different methods."
      },
      {
        "name": "plainError",
        "desc": "plainError represents a runtime error described a string without the prefix \"runtime error: \" after invoking errorString.Error(). See Issue #14965."
      },
      {
        "name": "pollCache",
        "desc": ""
      },
      {
        "name": "pollDesc",
        "desc": "Network poller descriptor.  No heap pointers."
      },
      {
        "name": "pollInfo",
        "desc": "pollInfo is the bits needed by netpollcheckerr, stored atomically, mostly duplicating state that is manipulated under lock in pollDesc. The one exception is the pollEventErr bit, which is maintained only in the pollInfo."
      },
      {
        "name": "pollOperation",
        "desc": "pollOperation must be the same as beginning of internal/poll.operation. Keep these in sync."
      },
      {
        "name": "pollfd",
        "desc": "pollfd represents the poll structure for AIX operating system."
      },
      {
        "name": "portevent",
        "desc": ""
      },
      {
        "name": "profAtomic",
        "desc": "A profAtomic is the atomically-accessed word holding a profIndex."
      },
      {
        "name": "profBuf",
        "desc": "A profBuf is a lock-free buffer for profiling events, safe for concurrent use by one reader and one writer. The writer may be a signal handler running without a user g. The reader is assumed to be a user g.  Each logged event corresponds to a fixed size header, a list of uintptrs (typically a stack), and exactly one unsafe.Pointer tag. The header and uintptrs are stored in the circular buffer data and the tag is stored in a circular buffer tags, running in parallel. In the circular buffer data, each event takes 2+hdrsize+len(stk) words: the value 2+hdrsize+len(stk), then the time of the event, then hdrsize words giving the fixed-size header, and then len(stk) words for the stack.  The current effective offsets into the tags and data circular buffers for reading and writing are stored in the high 30 and low 32 bits of r and w. The bottom bits of the high 32 are additional flag bits in w, unused in r. \"Effective\" offsets means the total number of reads or writes, mod 2^length. The offset in the buffer is the effective offset mod the length of the buffer. To make wraparound mod 2^length match wraparound mod length of the buffer, the length of the buffer must be a power of two.  If the reader catches up to the writer, a flag passed to read controls whether the read blocks until more data is available. A read returns a pointer to the buffer data itself; the caller is assumed to be done with that data at the next read. The read offset rNext tracks the next offset to be returned by read. By definition, r ≤ rNext ≤ w (before wraparound), and rNext is only used by the reader, so it can be accessed without atomics.  If the writer gets ahead of the reader, so that the buffer fills, future writes are discarded and replaced in the output stream by an overflow entry, which has size 2+hdrsize+1, time set to the time of the first discarded write, a header of all zeroed words, and a \"stack\" containing one word, the number of discarded writes.  Between the time the buffer fills and the buffer becomes empty enough to hold more data, the overflow entry is stored as a pending overflow entry in the fields overflow and overflowTime. The pending overflow entry can be turned into a real record by either the writer or the reader. If the writer is called to write a new record and finds that the output buffer has room for both the pending overflow entry and the new record, the writer emits the pending overflow entry and the new record into the buffer. If the reader is called to read data and finds that the output buffer is empty but that there is a pending overflow entry, the reader will return a synthesized record for the pending overflow entry.  Only the writer can create or add to a pending overflow entry, but either the reader or the writer can clear the pending overflow entry. A pending overflow entry is indicated by the low 32 bits of 'overflow' holding the number of discarded writes, and overflowTime holding the time of the first discarded write. The high 32 bits of 'overflow' increment each time the low 32 bits transition from zero to non-zero or vice versa. This sequence number avoids ABA problems in the use of compare-and-swap to coordinate between reader and writer. The overflowTime is only written when the low 32 bits of overflow are zero, that is, only when there is no pending overflow entry, in preparation for creating a new one. The reader can therefore fetch and clear the entry atomically using  \tfor { \t\toverflow = load(\u0026b.overflow) \t\tif uint32(overflow) == 0 { \t\t\t// no pending entry \t\t\tbreak \t\t} \t\ttime = load(\u0026b.overflowTime) \t\tif cas(\u0026b.overflow, overflow, ((overflow\u003e\u003e32)+1)\u003c\u003c32) { \t\t\t// pending entry cleared \t\t\tbreak \t\t} \t} \tif uint32(overflow) \u003e 0 { \t\temit entry for uint32(overflow), time \t}"
      },
      {
        "name": "profBufReadMode",
        "desc": "profBufReadMode specifies whether to block when no data is available to read."
      },
      {
        "name": "profIndex",
        "desc": "A profIndex is the packet tag and data counts and flags bits, described above."
      },
      {
        "name": "ptabEntry",
        "desc": "A ptabEntry is generated by the compiler for each exported function and global variable in the main package of a plugin. It is used to initialize the plugin module's symbol map."
      },
      {
        "name": "pthread",
        "desc": ""
      },
      {
        "name": "pthread_attr",
        "desc": ""
      },
      {
        "name": "pthreadattr",
        "desc": ""
      },
      {
        "name": "pthreadcond",
        "desc": ""
      },
      {
        "name": "pthreadcondattr",
        "desc": ""
      },
      {
        "name": "pthreadkey",
        "desc": ""
      },
      {
        "name": "pthreadmutex",
        "desc": ""
      },
      {
        "name": "pthreadmutexattr",
        "desc": ""
      },
      {
        "name": "ptregs",
        "desc": ""
      },
      {
        "name": "ptrtype",
        "desc": ""
      },
      {
        "name": "puintptr",
        "desc": ""
      },
      {
        "name": "randomEnum",
        "desc": ""
      },
      {
        "name": "randomOrder",
        "desc": "randomOrder/randomEnum are helper types for randomized work stealing. They allow to enumerate all Ps in different pseudo-random orders without repetitions. The algorithm is based on the fact that if we have X such that X and GOMAXPROCS are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration."
      },
      {
        "name": "reflectMethodValue",
        "desc": "reflectMethodValue is a partial duplicate of reflect.makeFuncImpl and reflect.methodValue."
      },
      {
        "name": "regmmst",
        "desc": ""
      },
      {
        "name": "regs32",
        "desc": ""
      },
      {
        "name": "regs64",
        "desc": ""
      },
      {
        "name": "regxmm",
        "desc": ""
      },
      {
        "name": "riscvHWProbePairs",
        "desc": ""
      },
      {
        "name": "rtprio",
        "desc": ""
      },
      {
        "name": "rtype",
        "desc": "rtype is a wrapper that allows us to define additional methods."
      },
      {
        "name": "runtimeSelect",
        "desc": "A runtimeSelect is a single case passed to rselect. This must match ../reflect/value.go:/runtimeSelect"
      },
      {
        "name": "rusage",
        "desc": ""
      },
      {
        "name": "rwmutex",
        "desc": "A rwmutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. This is a variant of sync.RWMutex, for the runtime package. Like mutex, rwmutex blocks the calling M. It does not interact with the goroutine scheduler."
      },
      {
        "name": "savedOpenDeferState",
        "desc": "savedOpenDeferState tracks the extra state from _panic that's necessary for deferreturn to pick up where gopanic left off, without needing to unwind the stack."
      },
      {
        "name": "scase",
        "desc": "Select case descriptor. Known to compiler. Changes here must also be made in src/cmd/compile/internal/walk/select.go's scasetype."
      },
      {
        "name": "scavChunkData",
        "desc": "scavChunkData tracks information about a palloc chunk for scavenging. It packs well into 64 bits.  The zero value always represents a valid newly-grown chunk."
      },
      {
        "name": "scavChunkFlags",
        "desc": "scavChunkFlags is a set of bit-flags for the scavenger for each palloc chunk."
      },
      {
        "name": "scavengeIndex",
        "desc": "scavengeIndex is a structure for efficiently managing which pageAlloc chunks have memory available to scavenge."
      },
      {
        "name": "scavengerState",
        "desc": ""
      },
      {
        "name": "schedt",
        "desc": ""
      },
      {
        "name": "selectDir",
        "desc": "These values must match ../reflect/value.go:/SelectDir."
      },
      {
        "name": "semTable",
        "desc": ""
      },
      {
        "name": "semaProfileFlags",
        "desc": ""
      },
      {
        "name": "semaRoot",
        "desc": "A semaRoot holds a balanced tree of sudog with distinct addresses (s.elem). Each of those sudog may in turn point (through s.waitlink) to a list of other sudogs waiting on the same address. The operations on the inner lists of sudogs with the same address are all O(1). The scanning of the top-level semaRoot list is O(log n), where n is the number of distinct addresses with goroutines blocked on them that hash to the given semaRoot. See golang.org/issue/17953 for a program that worked badly before we introduced the second level of list, and BenchmarkSemTable/OneAddrCollision/* for a benchmark that exercises this."
      },
      {
        "name": "semt",
        "desc": ""
      },
      {
        "name": "sigContext",
        "desc": ""
      },
      {
        "name": "sigTabT",
        "desc": "sigTabT is the type of an entry in the global sigtable array. sigtable is inherently system dependent, and appears in OS-specific files, but sigTabT is the same for all Unixy systems. The sigtable array is indexed by a system signal number to get the flags and printable name of each signal."
      },
      {
        "name": "sigactiont",
        "desc": ""
      },
      {
        "name": "sigcontext",
        "desc": ""
      },
      {
        "name": "sigctxt",
        "desc": ""
      },
      {
        "name": "sigevent",
        "desc": ""
      },
      {
        "name": "sigeventFields",
        "desc": ""
      },
      {
        "name": "siginfo",
        "desc": ""
      },
      {
        "name": "siginfoFields",
        "desc": ""
      },
      {
        "name": "sigset",
        "desc": ""
      },
      {
        "name": "size",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-size-u32"
      },
      {
        "name": "sizeClassScanStats",
        "desc": ""
      },
      {
        "name": "slice",
        "desc": ""
      },
      {
        "name": "sliceInterfacePtr",
        "desc": "The specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed."
      },
      {
        "name": "slicetype",
        "desc": ""
      },
      {
        "name": "sockaddr_un",
        "desc": ""
      },
      {
        "name": "spanAllocType",
        "desc": "spanAllocType represents the type of allocation to make, or the type of allocation to be freed."
      },
      {
        "name": "spanClass",
        "desc": "A spanClass represents the size class and noscan-ness of a span.  Each size class has a noscan spanClass and a scan spanClass. The noscan spanClass contains only noscan objects, which do not contain pointers and thus do not need to be scanned by the garbage collector."
      },
      {
        "name": "spanInlineMarkBits",
        "desc": ""
      },
      {
        "name": "spanQueue",
        "desc": ""
      },
      {
        "name": "spanScanOwnership",
        "desc": "spanScanOwnership indicates whether some thread has acquired the span for scanning, and whether there has been one or more attempts to acquire the span. The latter information helps to fast-track span scans that only apply to a single mark, skipping the relatively costly merge-and-diff process for scans and marks by allowing one to just set the mark directly."
      },
      {
        "name": "spanSet",
        "desc": "A spanSet is a set of *mspans.  spanSet is safe for concurrent push and pop operations."
      },
      {
        "name": "spanSetBlock",
        "desc": ""
      },
      {
        "name": "spanSetBlockAlloc",
        "desc": "spanSetBlockAlloc represents a concurrent pool of spanSetBlocks."
      },
      {
        "name": "spanSetBlockHeader",
        "desc": ""
      },
      {
        "name": "spanSetBlockHeader2",
        "desc": ""
      },
      {
        "name": "spanSetSpinePointer",
        "desc": "spanSetSpinePointer represents a pointer to a contiguous block of atomic.Pointer[spanSetBlock]."
      },
      {
        "name": "special",
        "desc": ""
      },
      {
        "name": "specialBubble",
        "desc": "specialBubble is a special used to associate objects with bubbles."
      },
      {
        "name": "specialCheckFinalizer",
        "desc": "Always paired with a specialCleanup or specialfinalizer, adds context."
      },
      {
        "name": "specialCleanup",
        "desc": "The described object has a cleanup set for it."
      },
      {
        "name": "specialPinCounter",
        "desc": "specialPinCounter tracks whether an object is pinned multiple times."
      },
      {
        "name": "specialReachable",
        "desc": "specialReachable tracks whether an object is reachable on the next GC cycle. This is used by testing."
      },
      {
        "name": "specialTinyBlock",
        "desc": "Indicates that an allocation is a tiny block. Used only if debug.checkfinalizers != 0."
      },
      {
        "name": "specialWeakHandle",
        "desc": "The described object has a weak pointer.  Weak pointers in the GC have the following invariants:    - Strong-to-weak conversions must ensure the strong pointer     remains live until the weak handle is installed. This ensures     that creating a weak pointer cannot fail.    - Weak-to-strong conversions require the weakly-referenced     object to be swept before the conversion may proceed. This     ensures that weak-to-strong conversions cannot resurrect     dead objects by sweeping them before that happens.    - Weak handles are unique and canonical for each byte offset into     an object that a strong pointer may point to, until an object     becomes unreachable.    - Weak handles contain nil as soon as an object becomes unreachable     the first time, before a finalizer makes it reachable again. New     weak handles created after resurrection are newly unique.  specialWeakHandle is allocated from non-GC'd memory, so any heap pointers must be specially handled."
      },
      {
        "name": "specialfinalizer",
        "desc": "The described object has a finalizer set for it.  specialfinalizer is allocated from non-GC'd memory, so any heap pointers must be specially handled."
      },
      {
        "name": "specialprofile",
        "desc": "The described object is being heap profiled."
      },
      {
        "name": "specialsIter",
        "desc": "specialsIter helps iterate over specials lists."
      },
      {
        "name": "srcFunc",
        "desc": "A srcFunc represents a logical function in the source code. This may correspond to an actual symbol in the binary text, or it may correspond to a source function that has been inlined."
      },
      {
        "name": "stack",
        "desc": "Stack describes a Go execution stack. The bounds of the stack are exactly [lo, hi), with no implicit data structures on either side."
      },
      {
        "name": "stackObject",
        "desc": "A stackObject represents a variable on the stack that has had its address taken."
      },
      {
        "name": "stackObjectBuf",
        "desc": "Buffer for stack objects found on a goroutine stack. Must be smaller than or equal to workbuf."
      },
      {
        "name": "stackObjectBufHdr",
        "desc": ""
      },
      {
        "name": "stackObjectRecord",
        "desc": "A stackObjectRecord is generated by the compiler for each stack object in a stack frame. This record must match the generator code in cmd/compile/internal/liveness/plive.go:emitStackObjects."
      },
      {
        "name": "stackScanState",
        "desc": "A stackScanState keeps track of the state used during the GC walk of a goroutine."
      },
      {
        "name": "stackWorkBuf",
        "desc": "Buffer for pointers found during stack tracing. Must be smaller than or equal to workbuf."
      },
      {
        "name": "stackWorkBufHdr",
        "desc": "Header declaration must come after the buf declaration above, because of issue #14620."
      },
      {
        "name": "stackfreelist",
        "desc": ""
      },
      {
        "name": "stackmap",
        "desc": ""
      },
      {
        "name": "stackpoolItem",
        "desc": ""
      },
      {
        "name": "stackt",
        "desc": ""
      },
      {
        "name": "stat",
        "desc": ""
      },
      {
        "name": "statAggregate",
        "desc": "statAggregate is the main driver of the metrics implementation.  It contains multiple aggregates of runtime statistics, as well as a set of these aggregates that it has populated. The aggregates are populated lazily by its ensure method."
      },
      {
        "name": "statDep",
        "desc": "statDep is a dependency on a group of statistics that a metric might have."
      },
      {
        "name": "statDepSet",
        "desc": "statDepSet represents a set of statDeps.  Under the hood, it's a bitmap."
      },
      {
        "name": "stdFunction",
        "desc": ""
      },
      {
        "name": "stkframe",
        "desc": "A stkframe holds information about a single physical stack frame."
      },
      {
        "name": "stringInterfacePtr",
        "desc": "The specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed."
      },
      {
        "name": "stringStruct",
        "desc": ""
      },
      {
        "name": "stringStructDWARF",
        "desc": "Variant with *byte pointer type for DWARF debugging."
      },
      {
        "name": "stringer",
        "desc": ""
      },
      {
        "name": "structtype",
        "desc": ""
      },
      {
        "name": "stwReason",
        "desc": "stwReason is an enumeration of reasons the world is stopping."
      },
      {
        "name": "subclockflags",
        "desc": ""
      },
      {
        "name": "subscription",
        "desc": ""
      },
      {
        "name": "subscriptionClock",
        "desc": ""
      },
      {
        "name": "subscriptionFdReadwrite",
        "desc": ""
      },
      {
        "name": "subscriptionUnion",
        "desc": ""
      },
      {
        "name": "sudog",
        "desc": "sudog (pseudo-g) represents a g in a wait list, such as for sending/receiving on a channel.  sudog is necessary because the g ↔ synchronization object relation is many-to-many. A g can be on many wait lists, so there may be many sudogs for one g; and many gs may be waiting on the same synchronization object, so there may be many sudogs for one object.  sudogs are allocated from a special pool. Use acquireSudog and releaseSudog to allocate and free them."
      },
      {
        "name": "suspendGState",
        "desc": ""
      },
      {
        "name": "sweepClass",
        "desc": "sweepClass is a spanClass and one bit to represent whether we're currently sweeping partial or full spans."
      },
      {
        "name": "sweepLocked",
        "desc": "sweepLocked represents sweep ownership of a span."
      },
      {
        "name": "sweepLocker",
        "desc": "sweepLocker acquires sweep ownership of spans."
      },
      {
        "name": "sweepdata",
        "desc": "State of background sweep."
      },
      {
        "name": "symbolizeCodeContext",
        "desc": ""
      },
      {
        "name": "symbolizeDataContext",
        "desc": ""
      },
      {
        "name": "synctestBubble",
        "desc": "A synctestBubble is a set of goroutines started by synctest.Run."
      },
      {
        "name": "synctestDeadlockError",
        "desc": ""
      },
      {
        "name": "sysMemStat",
        "desc": "sysMemStat represents a global system statistic that is managed atomically.  This type must structurally be a uint64 so that mstats aligns with MemStats."
      },
      {
        "name": "sysStatsAggregate",
        "desc": "sysStatsAggregate represents system memory stats obtained from the runtime. This set of stats is grouped together because they're all relatively cheap to acquire and generally independent of one another and other runtime memory stats. The fact that they may be acquired at different times, especially with respect to heapStatsAggregate, means there could be some skew, but because of these stats are independent, there's no real consistency issue here."
      },
      {
        "name": "sysmontick",
        "desc": ""
      },
      {
        "name": "systeminfo",
        "desc": ""
      },
      {
        "name": "taggedPointer",
        "desc": "taggedPointer is a pointer with a numeric tag. The size of the numeric tag is GOARCH-dependent, currently at least 16 bits. This should only be used with pointers allocated outside the Go heap."
      },
      {
        "name": "textOff",
        "desc": ""
      },
      {
        "name": "textsect",
        "desc": ""
      },
      {
        "name": "tforkt",
        "desc": ""
      },
      {
        "name": "thread",
        "desc": ""
      },
      {
        "name": "throwType",
        "desc": "throwType indicates the current type of ongoing throw, which affects the amount of detail printed to stderr. Higher values include more detail."
      },
      {
        "name": "thrparam",
        "desc": ""
      },
      {
        "name": "ticksType",
        "desc": ""
      },
      {
        "name": "timeHistogram",
        "desc": "timeHistogram represents a distribution of durations in nanoseconds.  The accuracy and range of the histogram is defined by the timeHistSubBucketBits and timeHistNumBuckets constants.  It is an HDR histogram with exponentially-distributed buckets and linearly distributed sub-buckets.  The histogram is safe for concurrent reads and writes."
      },
      {
        "name": "timeTimer",
        "desc": "A timeTimer is a runtime-allocated time.Timer or time.Ticker with the additional runtime state following it. The runtime state is inaccessible to package time."
      },
      {
        "name": "timeoutEvent",
        "desc": ""
      },
      {
        "name": "timer",
        "desc": "A timer is a potentially repeating trigger for calling t.f(t.arg, t.seq). Timers are allocated by client code, often as part of other data structures. Each P has a heap of pointers to timers that it manages.  A timer is expected to be used by only one client goroutine at a time, but there will be concurrent access by the P managing that timer. Timer accesses are protected by the lock t.mu, with a snapshot of t's state bits published in t.astate to enable certain fast paths to make decisions about a timer without acquiring the lock."
      },
      {
        "name": "timerWhen",
        "desc": ""
      },
      {
        "name": "timers",
        "desc": "A timers is a per-P set of timers."
      },
      {
        "name": "timespec",
        "desc": ""
      },
      {
        "name": "timestamp",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-timestamp-u64"
      },
      {
        "name": "timestruc",
        "desc": ""
      },
      {
        "name": "timeval",
        "desc": ""
      },
      {
        "name": "tmpBuf",
        "desc": ""
      },
      {
        "name": "tos",
        "desc": ""
      },
      {
        "name": "traceAdvancerState",
        "desc": ""
      },
      {
        "name": "traceArg",
        "desc": "traceArg is a simple wrapper type to help ensure that arguments passed to traces are well-formed."
      },
      {
        "name": "traceBlockReason",
        "desc": "traceBlockReason is an enumeration of reasons a goroutine might block. This is the interface the rest of the runtime uses to tell the tracer why a goroutine blocked. The tracer then propagates this information into the trace however it sees fit.  Note that traceBlockReasons should not be compared, since reasons that are distinct by name may *not* be distinct by value."
      },
      {
        "name": "traceBuf",
        "desc": "traceBuf is per-M tracing buffer.  TODO(mknyszek): Rename traceBuf to traceBatch, since they map 1:1 with event batches."
      },
      {
        "name": "traceBufHeader",
        "desc": "traceBufHeader is per-P tracing buffer."
      },
      {
        "name": "traceBufQueue",
        "desc": "traceBufQueue is a FIFO of traceBufs."
      },
      {
        "name": "traceEventWriter",
        "desc": "traceEventWriter is the high-level API for writing trace events.  See the comment on traceWriter about style for more details as to why this type and its methods are structured the way they are."
      },
      {
        "name": "traceFrame",
        "desc": ""
      },
      {
        "name": "traceGoStopReason",
        "desc": "traceGoStopReason is an enumeration of reasons a goroutine might yield.  Note that traceGoStopReasons should not be compared, since reasons that are distinct by name may *not* be distinct by value."
      },
      {
        "name": "traceLocker",
        "desc": "traceLocker represents an M writing trace events. While a traceLocker value is valid, the tracer observes all operations on the G/M/P or trace events being written as happening atomically."
      },
      {
        "name": "traceMap",
        "desc": ""
      },
      {
        "name": "traceMapNode",
        "desc": "traceMapNode is an implementation of a lock-free append-only hash-trie (a trie of the hash bits).  Key features:   - 4-ary trie. Child nodes are indexed by the upper 2 (remaining) bits of the hash.     For example, top level uses bits [63:62], next level uses [61:60] and so on.   - New nodes are placed at the first empty level encountered.   - When the first child is added to a node, the existing value is not moved into a child.     This means that you must check the key at each level, not just at the leaf.   - No deletion or rebalancing.   - Intentionally devolves into a linked list on hash collisions (the hash bits will all     get shifted out during iteration, and new nodes will just be appended to the 0th child)."
      },
      {
        "name": "traceRegionAlloc",
        "desc": "traceRegionAlloc is a thread-safe region allocator. It holds a linked list of traceRegionAllocBlock."
      },
      {
        "name": "traceRegionAllocBlock",
        "desc": "traceRegionAllocBlock is a block in traceRegionAlloc.  traceRegionAllocBlock is allocated from non-GC'd memory, so it must not contain heap pointers. Writes to pointers to traceRegionAllocBlocks do not need write barriers."
      },
      {
        "name": "traceRegionAllocBlockHeader",
        "desc": ""
      },
      {
        "name": "traceSchedResourceState",
        "desc": "traceSchedResourceState is shared state for scheduling resources (i.e. fields common to both Gs and Ps)."
      },
      {
        "name": "traceStackTable",
        "desc": "traceStackTable maps stack traces (arrays of PC's) to unique uint32 ids. It is lock-free for reading."
      },
      {
        "name": "traceStringTable",
        "desc": "traceStringTable is map of string -\u003e unique ID that also manages writing strings out into the trace."
      },
      {
        "name": "traceTime",
        "desc": "traceTime represents a timestamp for the trace."
      },
      {
        "name": "traceTypeTable",
        "desc": "traceTypeTable maps stack traces (arrays of PC's) to unique uint32 ids. It is lock-free for reading."
      },
      {
        "name": "traceWriter",
        "desc": "traceWriter is the interface for writing all trace data.  This type is passed around as a value, and all of its methods return a new traceWriter. This allows for chaining together calls in a fluent-style API. This is partly stylistic, and very slightly for performance, since the compiler can destructure this value and pass it between calls as just regular arguments. However, this style is not load-bearing, and we can change it if it's deemed too error-prone."
      },
      {
        "name": "tracestat",
        "desc": ""
      },
      {
        "name": "tstate",
        "desc": ""
      },
      {
        "name": "typeCacheBucket",
        "desc": ""
      },
      {
        "name": "typeOff",
        "desc": ""
      },
      {
        "name": "typePointers",
        "desc": "typePointers is an iterator over the pointers in a heap object.  Iteration through this type implements the tiling algorithm described at the top of this file."
      },
      {
        "name": "ucontext",
        "desc": ""
      },
      {
        "name": "ucontextt",
        "desc": ""
      },
      {
        "name": "uinptr",
        "desc": ""
      },
      {
        "name": "uint16InterfacePtr",
        "desc": "The specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed."
      },
      {
        "name": "uint32InterfacePtr",
        "desc": "The specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed."
      },
      {
        "name": "uint64InterfacePtr",
        "desc": "The specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed."
      },
      {
        "name": "uintptr32",
        "desc": "GOARCH=wasm currently has 64 bits pointers, but the WebAssembly host expects pointers to be 32 bits so we use this type alias to represent pointers in structs and arrays passed as arguments to WASI functions.  Note that the use of an integer type prevents the compiler from tracking pointers passed to WASI functions, so we must use KeepAlive to explicitly retain the objects that could otherwise be reclaimed by the GC."
      },
      {
        "name": "umtx_time",
        "desc": ""
      },
      {
        "name": "uncommontype",
        "desc": ""
      },
      {
        "name": "unwindFlags",
        "desc": "unwindFlags control the behavior of various unwinders."
      },
      {
        "name": "unwinder",
        "desc": "An unwinder iterates the physical stack frames of a Go sack.  Typical use of an unwinder looks like:  \tvar u unwinder \tfor u.init(gp, 0); u.valid(); u.next() { \t\t// ... use frame info in u ... \t}  Implementation note: This is carefully structured to be pointer-free because tracebacks happen in places that disallow write barriers (e.g., signals). Even if this is stack-allocated, its pointer-receiver methods don't know that their receiver is on the stack, so they still emit write barriers. Here we address that by carefully avoiding any pointers in this type. Another approach would be to split this into a mutable part that's passed by pointer but contains no pointers itself and an immutable part that's passed and returned by value and can contain pointers. We could potentially hide that we're doing that in trivial methods that are inlined into the caller that has the stack allocation, but that's fragile."
      },
      {
        "name": "updateMaxProcsGState",
        "desc": ""
      },
      {
        "name": "ureg",
        "desc": ""
      },
      {
        "name": "userArena",
        "desc": ""
      },
      {
        "name": "user_fpregs_struct",
        "desc": ""
      },
      {
        "name": "user_regs_struct",
        "desc": ""
      },
      {
        "name": "userdata",
        "desc": ""
      },
      {
        "name": "usigactiont",
        "desc": ""
      },
      {
        "name": "usigset",
        "desc": ""
      },
      {
        "name": "vdsoInfo",
        "desc": ""
      },
      {
        "name": "vdsoSymbolKey",
        "desc": ""
      },
      {
        "name": "vdsoTimehands",
        "desc": ""
      },
      {
        "name": "vdsoTimekeep",
        "desc": ""
      },
      {
        "name": "vdsoVersionKey",
        "desc": ""
      },
      {
        "name": "vreg",
        "desc": ""
      },
      {
        "name": "waitReason",
        "desc": "A waitReason explains why a goroutine has been stopped. See gopark. Do not re-use waitReasons, add new ones."
      },
      {
        "name": "waitq",
        "desc": ""
      },
      {
        "name": "wakeableSleep",
        "desc": "wakeableSleep manages a wakeable goroutine sleep.  Users of this type must call init before first use and close to free up resources. Once close is called, init must be called before another use."
      },
      {
        "name": "wbBuf",
        "desc": "wbBuf is a per-P buffer of pointers queued by the write barrier. This buffer is flushed to the GC workbufs when it fills up and on various GC transitions.  This is closely related to a \"sequential store buffer\" (SSB), except that SSBs are usually used for maintaining remembered sets, while this is used for marking."
      },
      {
        "name": "winCallback",
        "desc": "winCallback records information about a registered Go callback."
      },
      {
        "name": "winCallbackKey",
        "desc": ""
      },
      {
        "name": "winlibcall",
        "desc": ""
      },
      {
        "name": "workType",
        "desc": ""
      },
      {
        "name": "workbuf",
        "desc": ""
      },
      {
        "name": "workbufhdr",
        "desc": ""
      },
      {
        "name": "worldStop",
        "desc": "worldStop provides context from the stop-the-world required by the start-the-world."
      },
      {
        "name": "writeUserArenaHeapBits",
        "desc": ""
      },
      {
        "name": "xmmreg",
        "desc": ""
      },
      {
        "name": "xmmreg1",
        "desc": ""
      }
    ]
  },
  {
    "name": "runtime/asan",
    "desc": "",
    "functions": null,
    "types": null
  },
  {
    "name": "runtime/cgo",
    "desc": "Package cgo contains runtime support for code generated by the cgo tool.  See the documentation for the cgo command for details on using cgo.",
    "functions": [
      {
        "name": "BenchmarkHandle",
        "desc": ""
      },
      {
        "name": "TestHandle",
        "desc": ""
      },
      {
        "name": "TestInvalidHandle",
        "desc": ""
      },
      {
        "name": "_cgo_panic",
        "desc": ""
      },
      {
        "name": "_runtime_cgo_panic_internal",
        "desc": ""
      },
      {
        "name": "set_crosscall2",
        "desc": "Set the x_crosscall2_ptr C function pointer variable point to crosscall2. It's for the runtime package to call at init time."
      },
      {
        "name": "xx_cgo_panicmem",
        "desc": ""
      },
      {
        "name": "Delete",
        "desc": "Delete invalidates a handle. This method should only be called once the program no longer needs to pass the handle to C and the C code no longer has a copy of the handle value.  The method panics if the handle is invalid."
      },
      {
        "name": "Value",
        "desc": "Value returns the associated Go value for a valid handle.  The method panics if the handle is invalid."
      }
    ],
    "types": [
      {
        "name": "Handle",
        "desc": "Handle provides a way to pass values that contain Go pointers (pointers to memory allocated by Go) between Go and C without breaking the cgo pointer passing rules. A Handle is an integer value that can represent any Go value. A Handle can be passed through C and back to Go, and Go code can use the Handle to retrieve the original Go value.  The underlying type of Handle is guaranteed to fit in an integer type that is large enough to hold the bit pattern of any pointer. The zero value of a Handle is not valid, and thus is safe to use as a sentinel in C APIs.  For instance, on the Go side:  \tpackage main  \t/* \t#include \u003cstdint.h\u003e // for uintptr_t  \textern void MyGoPrint(uintptr_t handle); \tvoid myprint(uintptr_t handle); \t*/ \timport \"C\" \timport \"runtime/cgo\"  \t//export MyGoPrint \tfunc MyGoPrint(handle C.uintptr_t) { \t\th := cgo.Handle(handle) \t\tval := h.Value().(string) \t\tprintln(val) \t\th.Delete() \t}  \tfunc main() { \t\tval := \"hello Go\" \t\tC.myprint(C.uintptr_t(cgo.NewHandle(val))) \t\t// Output: hello Go \t}  and on the C side:  \t#include \u003cstdint.h\u003e // for uintptr_t  \t// A Go function \textern void MyGoPrint(uintptr_t handle);  \t// A C function \tvoid myprint(uintptr_t handle) { \t    MyGoPrint(handle); \t}  Some C functions accept a void* argument that points to an arbitrary data value supplied by the caller. It is not safe to coerce a Handle (an integer) to a Go [unsafe.Pointer], but instead we can pass the address of the cgo.Handle to the void* parameter, as in this variant of the previous example.  Note that, as described in the [cmd/cgo] documentation, the C code must not keep a copy of the Go pointer that it receives, unless the memory is explicitly pinned using [runtime.Pinner]. This example is OK because the C function myprint does not keep a copy of the pointer.  \tpackage main  \t/* \textern void MyGoPrint(void *context); \tstatic inline void myprint(void *context) { \t    MyGoPrint(context); \t} \t*/ \timport \"C\" \timport ( \t\t\"runtime/cgo\" \t\t\"unsafe\" \t)  \t//export MyGoPrint \tfunc MyGoPrint(context unsafe.Pointer) { \t\th := *(*cgo.Handle)(context) \t\tval := h.Value().(string) \t\tprintln(val) \t\th.Delete() \t}  \tfunc main() { \t\tval := \"hello Go\" \t\th := cgo.NewHandle(val) \t\tC.myprint(unsafe.Pointer(\u0026h)) \t\t// Output: hello Go \t}"
      },
      {
        "name": "Incomplete",
        "desc": "Incomplete is used specifically for the semantics of incomplete C types."
      }
    ]
  },
  {
    "name": "runtime/coverage",
    "desc": "Package coverage contains APIs for writing coverage profile data at runtime from long-running and/or server programs that do not terminate via [os.Exit].",
    "functions": [
      {
        "name": "ClearCounters",
        "desc": "ClearCounters clears/resets all coverage counter variables in the currently running program. It returns an error if the program in question was not built with the \"-cover\" flag. Clearing of coverage counters is also not supported for programs not using atomic counter mode (see more detailed comments below for the rationale here)."
      },
      {
        "name": "WriteCounters",
        "desc": "WriteCounters writes coverage counter-data content for the currently running program to the writer 'w'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if a write fails). The counter data written will be a snapshot taken at the point of the invocation."
      },
      {
        "name": "WriteCountersDir",
        "desc": "WriteCountersDir writes a coverage counter-data file for the currently running program to the directory specified in 'dir'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if the directory does not exist). The counter data written will be a snapshot taken at the point of the call."
      },
      {
        "name": "WriteMeta",
        "desc": "WriteMeta writes the meta-data content (the payload that would normally be emitted to a meta-data file) for the currently running program to the writer 'w'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if a write fails)."
      },
      {
        "name": "WriteMetaDir",
        "desc": "WriteMetaDir writes a coverage meta-data file for the currently running program to the directory specified in 'dir'. An error will be returned if the operation can't be completed successfully (for example, if the currently running program was not built with \"-cover\", or if the directory does not exist)."
      },
      {
        "name": "initHook",
        "desc": "initHook is invoked from main.init in programs built with -cover. The call is emitted by the compiler."
      }
    ],
    "types": null
  },
  {
    "name": "runtime/debug",
    "desc": "",
    "functions": [
      {
        "name": "ExampleSetCrashOutput_monitor",
        "desc": "ExampleSetCrashOutput_monitor shows an example of using [debug.SetCrashOutput] to direct crashes to a \"monitor\" process, for automated crash reporting. The monitor is the same executable, invoked in a special mode indicated by an environment variable."
      },
      {
        "name": "FuzzParseBuildInfoRoundTrip",
        "desc": ""
      },
      {
        "name": "TestFreeOSMemory",
        "desc": ""
      },
      {
        "name": "TestMain",
        "desc": ""
      },
      {
        "name": "TestPanicOnFault",
        "desc": ""
      },
      {
        "name": "TestReadGCStats",
        "desc": ""
      },
      {
        "name": "TestSetCrashOutput",
        "desc": ""
      },
      {
        "name": "TestSetGCPercent",
        "desc": ""
      },
      {
        "name": "TestSetMaxThreadsOvf",
        "desc": ""
      },
      {
        "name": "TestStack",
        "desc": "The traceback should look something like this, modulo line numbers and hex constants. Don't worry much about the base levels, but check the ones in our own package.  \tgoroutine 10 [running]: \truntime/debug.Stack(0x0, 0x0, 0x0) \t\t/Users/r/go/src/runtime/debug/stack.go:28 +0x80 \truntime/debug.(*T).ptrmethod(0xc82005ee70, 0x0, 0x0, 0x0) \t\t/Users/r/go/src/runtime/debug/stack_test.go:15 +0x29 \truntime/debug.T.method(0x0, 0x0, 0x0, 0x0) \t\t/Users/r/go/src/runtime/debug/stack_test.go:18 +0x32 \truntime/debug.TestStack(0xc8201ce000) \t\t/Users/r/go/src/runtime/debug/stack_test.go:37 +0x38 \ttesting.tRunner(0xc8201ce000, 0x664b58) \t\t/Users/r/go/src/testing/testing.go:456 +0x98 \tcreated by testing.RunTests \t\t/Users/r/go/src/testing/testing.go:561 +0x86d"
      },
      {
        "name": "TestWriteHeapDumpFinalizers",
        "desc": ""
      },
      {
        "name": "TestWriteHeapDumpNonempty",
        "desc": ""
      },
      {
        "name": "TestWriteHeapDumpTypeName",
        "desc": ""
      },
      {
        "name": "abs64",
        "desc": ""
      },
      {
        "name": "appmain",
        "desc": "appmain represents the 'main' function of your application."
      },
      {
        "name": "monitor",
        "desc": "monitor starts the monitor process, which performs automated crash reporting. Call this function immediately within main.  This function re-executes the same executable as a child process, in a special mode. In that mode, the call to monitor will never return."
      },
      {
        "name": "objfin",
        "desc": ""
      },
      {
        "name": "strip",
        "desc": "strip removes two leading tabs after each newline of s."
      },
      {
        "name": "M",
        "desc": ""
      },
      {
        "name": "method",
        "desc": ""
      },
      {
        "name": "ptrmethod",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "G",
        "desc": ""
      },
      {
        "name": "I",
        "desc": ""
      },
      {
        "name": "Obj",
        "desc": ""
      },
      {
        "name": "T",
        "desc": ""
      }
    ]
  },
  {
    "name": "runtime/metrics",
    "desc": "Package metrics provides a stable interface to access implementation-defined metrics exported by the Go runtime. This package is similar to existing functions like [runtime.ReadMemStats] and [runtime/debug.ReadGCStats], but significantly more general.  The set of metrics defined by this package may evolve as the runtime itself evolves, and also enables variation across Go implementations, whose relevant metric sets may not intersect.  # Interface  Metrics are designated by a string key, rather than, for example, a field name in a struct. The full list of supported metrics is always available in the slice of Descriptions returned by [All]. Each [Description] also includes useful information about the metric.  Thus, users of this API are encouraged to sample supported metrics defined by the slice returned by All to remain compatible across Go versions. Of course, situations arise where reading specific metrics is critical. For these cases, users are encouraged to use build tags, and although metrics may be deprecated and removed, users should consider this to be an exceptional and rare event, coinciding with a very large change in a particular Go implementation.  Each metric key also has a \"kind\" (see [ValueKind]) that describes the format of the metric's value. In the interest of not breaking users of this package, the \"kind\" for a given metric is guaranteed not to change. If it must change, then a new metric will be introduced with a new key and a new \"kind.\"  # Metric key format  As mentioned earlier, metric keys are strings. Their format is simple and well-defined, designed to be both human and machine readable. It is split into two components, separated by a colon: a rooted path and a unit. The choice to include the unit in the key is motivated by compatibility: if a metric's unit changes, its semantics likely did also, and a new key should be introduced.  For more details on the precise definition of the metric key's path and unit formats, see the documentation of the Name field of the Description struct.  # A note about floats  This package supports metrics whose values have a floating-point representation. In order to improve ease-of-use, this package promises to never produce the following classes of floating-point values: NaN, infinity.  # Supported metrics  Below is the full list of supported metrics, ordered lexicographically.  \t/cgo/go-to-c-calls:calls \t\tCount of calls made from Go to C by the current process.  \t/cpu/classes/gc/mark/assist:cpu-seconds \t\tEstimated total CPU time goroutines spent performing GC \t\ttasks to assist the GC and prevent it from falling behind the \t\tapplication. This metric is an overestimate, and not directly \t\tcomparable to system CPU time measurements. Compare only with \t\tother /cpu/classes metrics.  \t/cpu/classes/gc/mark/dedicated:cpu-seconds \t\tEstimated total CPU time spent performing GC tasks on processors \t\t(as defined by GOMAXPROCS) dedicated to those tasks. This metric \t\tis an overestimate, and not directly comparable to system CPU \t\ttime measurements. Compare only with other /cpu/classes metrics.  \t/cpu/classes/gc/mark/idle:cpu-seconds \t\tEstimated total CPU time spent performing GC tasks on spare CPU \t\tresources that the Go scheduler could not otherwise find a use \t\tfor. This should be subtracted from the total GC CPU time to \t\tobtain a measure of compulsory GC CPU time. This metric is an \t\toverestimate, and not directly comparable to system CPU time \t\tmeasurements. Compare only with other /cpu/classes metrics.  \t/cpu/classes/gc/pause:cpu-seconds \t\tEstimated total CPU time spent with the application paused by \t\tthe GC. Even if only one thread is running during the pause, \t\tthis is computed as GOMAXPROCS times the pause latency because \t\tnothing else can be executing. This is the exact sum of samples \t\tin /sched/pauses/total/gc:seconds if each sample is multiplied \t\tby GOMAXPROCS at the time it is taken. This metric is an \t\toverestimate, and not directly comparable to system CPU time \t\tmeasurements. Compare only with other /cpu/classes metrics.  \t/cpu/classes/gc/total:cpu-seconds \t\tEstimated total CPU time spent performing GC tasks. This metric \t\tis an overestimate, and not directly comparable to system CPU \t\ttime measurements. Compare only with other /cpu/classes metrics. \t\tSum of all metrics in /cpu/classes/gc.  \t/cpu/classes/idle:cpu-seconds \t\tEstimated total available CPU time not spent executing \t\tany Go or Go runtime code. In other words, the part of \t\t/cpu/classes/total:cpu-seconds that was unused. This metric is \t\tan overestimate, and not directly comparable to system CPU time \t\tmeasurements. Compare only with other /cpu/classes metrics.  \t/cpu/classes/scavenge/assist:cpu-seconds \t\tEstimated total CPU time spent returning unused memory to the \t\tunderlying platform in response eagerly in response to memory \t\tpressure. This metric is an overestimate, and not directly \t\tcomparable to system CPU time measurements. Compare only with \t\tother /cpu/classes metrics.  \t/cpu/classes/scavenge/background:cpu-seconds \t\tEstimated total CPU time spent performing background tasks to \t\treturn unused memory to the underlying platform. This metric is \t\tan overestimate, and not directly comparable to system CPU time \t\tmeasurements. Compare only with other /cpu/classes metrics.  \t/cpu/classes/scavenge/total:cpu-seconds \t\tEstimated total CPU time spent performing tasks that return \t\tunused memory to the underlying platform. This metric is an \t\toverestimate, and not directly comparable to system CPU time \t\tmeasurements. Compare only with other /cpu/classes metrics. \t\tSum of all metrics in /cpu/classes/scavenge.  \t/cpu/classes/total:cpu-seconds \t\tEstimated total available CPU time for user Go code or the Go \t\truntime, as defined by GOMAXPROCS. In other words, GOMAXPROCS \t\tintegrated over the wall-clock duration this process has been \t\texecuting for. This metric is an overestimate, and not directly \t\tcomparable to system CPU time measurements. Compare only with \t\tother /cpu/classes metrics. Sum of all metrics in /cpu/classes.  \t/cpu/classes/user:cpu-seconds \t\tEstimated total CPU time spent running user Go code. This may \t\talso include some small amount of time spent in the Go runtime. \t\tThis metric is an overestimate, and not directly comparable \t\tto system CPU time measurements. Compare only with other \t\t/cpu/classes metrics.  \t/gc/cycles/automatic:gc-cycles \t\tCount of completed GC cycles generated by the Go runtime.  \t/gc/cycles/forced:gc-cycles \t\tCount of completed GC cycles forced by the application.  \t/gc/cycles/total:gc-cycles \t\tCount of all completed GC cycles.  \t/gc/gogc:percent \t\tHeap size target percentage configured by the user, otherwise \t\t100. This value is set by the GOGC environment variable, and the \t\truntime/debug.SetGCPercent function.  \t/gc/gomemlimit:bytes \t\tGo runtime memory limit configured by the user, otherwise \t\tmath.MaxInt64. This value is set by the GOMEMLIMIT environment \t\tvariable, and the runtime/debug.SetMemoryLimit function.  \t/gc/heap/allocs-by-size:bytes \t\tDistribution of heap allocations by approximate size. \t\tBucket counts increase monotonically. Note that this does not \t\tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects, \t\tonly tiny blocks.  \t/gc/heap/allocs:bytes \t\tCumulative sum of memory allocated to the heap by the \t\tapplication.  \t/gc/heap/allocs:objects \t\tCumulative count of heap allocations triggered by the \t\tapplication. Note that this does not include tiny objects as \t\tdefined by /gc/heap/tiny/allocs:objects, only tiny blocks.  \t/gc/heap/frees-by-size:bytes \t\tDistribution of freed heap allocations by approximate size. \t\tBucket counts increase monotonically. Note that this does not \t\tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects, \t\tonly tiny blocks.  \t/gc/heap/frees:bytes \t\tCumulative sum of heap memory freed by the garbage collector.  \t/gc/heap/frees:objects \t\tCumulative count of heap allocations whose storage was freed \t\tby the garbage collector. Note that this does not include tiny \t\tobjects as defined by /gc/heap/tiny/allocs:objects, only tiny \t\tblocks.  \t/gc/heap/goal:bytes \t\tHeap size target for the end of the GC cycle.  \t/gc/heap/live:bytes \t\tHeap memory occupied by live objects that were marked by the \t\tprevious GC.  \t/gc/heap/objects:objects \t\tNumber of objects, live or unswept, occupying heap memory.  \t/gc/heap/tiny/allocs:objects \t\tCount of small allocations that are packed together into blocks. \t\tThese allocations are counted separately from other allocations \t\tbecause each individual allocation is not tracked by the \t\truntime, only their block. Each block is already accounted for \t\tin allocs-by-size and frees-by-size.  \t/gc/limiter/last-enabled:gc-cycle \t\tGC cycle the last time the GC CPU limiter was enabled. \t\tThis metric is useful for diagnosing the root cause of an \t\tout-of-memory error, because the limiter trades memory for CPU \t\ttime when the GC's CPU time gets too high. This is most likely \t\tto occur with use of SetMemoryLimit. The first GC cycle is cycle \t\t1, so a value of 0 indicates that it was never enabled.  \t/gc/pauses:seconds \t\tDeprecated. Prefer the identical /sched/pauses/total/gc:seconds.  \t/gc/scan/globals:bytes \t\tThe total amount of global variable space that is scannable.  \t/gc/scan/heap:bytes \t\tThe total amount of heap space that is scannable.  \t/gc/scan/stack:bytes \t\tThe number of bytes of stack that were scanned last GC cycle.  \t/gc/scan/total:bytes \t\tThe total amount space that is scannable. Sum of all metrics in \t\t/gc/scan.  \t/gc/stack/starting-size:bytes \t\tThe stack size of new goroutines.  \t/godebug/non-default-behavior/allowmultiplevcs:events \t\tThe number of non-default behaviors executed by the cmd/go \t\tpackage due to a non-default GODEBUG=allowmultiplevcs=... \t\tsetting.  \t/godebug/non-default-behavior/asynctimerchan:events \t\tThe number of non-default behaviors executed by the time package \t\tdue to a non-default GODEBUG=asynctimerchan=... setting.  \t/godebug/non-default-behavior/containermaxprocs:events \t\tThe number of non-default behaviors executed by the runtime \t\tpackage due to a non-default GODEBUG=containermaxprocs=... \t\tsetting.  \t/godebug/non-default-behavior/embedfollowsymlinks:events \t\tThe number of non-default behaviors executed by the cmd/go \t\tpackage due to a non-default GODEBUG=embedfollowsymlinks=... \t\tsetting.  \t/godebug/non-default-behavior/execerrdot:events \t\tThe number of non-default behaviors executed by the os/exec \t\tpackage due to a non-default GODEBUG=execerrdot=... setting.  \t/godebug/non-default-behavior/gocachehash:events \t\tThe number of non-default behaviors executed by the cmd/go \t\tpackage due to a non-default GODEBUG=gocachehash=... setting.  \t/godebug/non-default-behavior/gocachetest:events \t\tThe number of non-default behaviors executed by the cmd/go \t\tpackage due to a non-default GODEBUG=gocachetest=... setting.  \t/godebug/non-default-behavior/gocacheverify:events \t\tThe number of non-default behaviors executed by the cmd/go \t\tpackage due to a non-default GODEBUG=gocacheverify=... setting.  \t/godebug/non-default-behavior/gotestjsonbuildtext:events \t\tThe number of non-default behaviors executed by the cmd/go \t\tpackage due to a non-default GODEBUG=gotestjsonbuildtext=... \t\tsetting.  \t/godebug/non-default-behavior/gotypesalias:events \t\tThe number of non-default behaviors executed by the go/types \t\tpackage due to a non-default GODEBUG=gotypesalias=... setting.  \t/godebug/non-default-behavior/http2client:events \t\tThe number of non-default behaviors executed by the net/http \t\tpackage due to a non-default GODEBUG=http2client=... setting.  \t/godebug/non-default-behavior/http2server:events \t\tThe number of non-default behaviors executed by the net/http \t\tpackage due to a non-default GODEBUG=http2server=... setting.  \t/godebug/non-default-behavior/httpcookiemaxnum:events \t\tThe number of non-default behaviors executed by the net/http \t\tpackage due to a non-default GODEBUG=httpcookiemaxnum=... \t\tsetting.  \t/godebug/non-default-behavior/httplaxcontentlength:events \t\tThe number of non-default behaviors executed by the net/http \t\tpackage due to a non-default GODEBUG=httplaxcontentlength=... \t\tsetting.  \t/godebug/non-default-behavior/httpmuxgo121:events \t\tThe number of non-default behaviors executed by the net/http \t\tpackage due to a non-default GODEBUG=httpmuxgo121=... setting.  \t/godebug/non-default-behavior/httpservecontentkeepheaders:events \t\tThe number of non-default behaviors executed \t\tby the net/http package due to a non-default \t\tGODEBUG=httpservecontentkeepheaders=... setting.  \t/godebug/non-default-behavior/installgoroot:events \t\tThe number of non-default behaviors executed by the go/build \t\tpackage due to a non-default GODEBUG=installgoroot=... setting.  \t/godebug/non-default-behavior/multipartmaxheaders:events \t\tThe number of non-default behaviors executed by \t\tthe mime/multipart package due to a non-default \t\tGODEBUG=multipartmaxheaders=... setting.  \t/godebug/non-default-behavior/multipartmaxparts:events \t\tThe number of non-default behaviors executed by \t\tthe mime/multipart package due to a non-default \t\tGODEBUG=multipartmaxparts=... setting.  \t/godebug/non-default-behavior/multipathtcp:events \t\tThe number of non-default behaviors executed by the net package \t\tdue to a non-default GODEBUG=multipathtcp=... setting.  \t/godebug/non-default-behavior/netedns0:events \t\tThe number of non-default behaviors executed by the net package \t\tdue to a non-default GODEBUG=netedns0=... setting.  \t/godebug/non-default-behavior/panicnil:events \t\tThe number of non-default behaviors executed by the runtime \t\tpackage due to a non-default GODEBUG=panicnil=... setting.  \t/godebug/non-default-behavior/randautoseed:events \t\tThe number of non-default behaviors executed by the math/rand \t\tpackage due to a non-default GODEBUG=randautoseed=... setting.  \t/godebug/non-default-behavior/randseednop:events \t\tThe number of non-default behaviors executed by the math/rand \t\tpackage due to a non-default GODEBUG=randseednop=... setting.  \t/godebug/non-default-behavior/rsa1024min:events \t\tThe number of non-default behaviors executed by the crypto/rsa \t\tpackage due to a non-default GODEBUG=rsa1024min=... setting.  \t/godebug/non-default-behavior/tarinsecurepath:events \t\tThe number of non-default behaviors executed by the archive/tar \t\tpackage due to a non-default GODEBUG=tarinsecurepath=... \t\tsetting.  \t/godebug/non-default-behavior/tls10server:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=tls10server=... setting.  \t/godebug/non-default-behavior/tls3des:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=tls3des=... setting.  \t/godebug/non-default-behavior/tlsmaxrsasize:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=tlsmaxrsasize=... setting.  \t/godebug/non-default-behavior/tlsrsakex:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=tlsrsakex=... setting.  \t/godebug/non-default-behavior/tlssha1:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=tlssha1=... setting.  \t/godebug/non-default-behavior/tlsunsafeekm:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=tlsunsafeekm=... setting.  \t/godebug/non-default-behavior/updatemaxprocs:events \t\tThe number of non-default behaviors executed by the runtime \t\tpackage due to a non-default GODEBUG=updatemaxprocs=... setting.  \t/godebug/non-default-behavior/winreadlinkvolume:events \t\tThe number of non-default behaviors executed by the os package \t\tdue to a non-default GODEBUG=winreadlinkvolume=... setting.  \t/godebug/non-default-behavior/winsymlink:events \t\tThe number of non-default behaviors executed by the os package \t\tdue to a non-default GODEBUG=winsymlink=... setting.  \t/godebug/non-default-behavior/x509keypairleaf:events \t\tThe number of non-default behaviors executed by the crypto/tls \t\tpackage due to a non-default GODEBUG=x509keypairleaf=... \t\tsetting.  \t/godebug/non-default-behavior/x509negativeserial:events \t\tThe number of non-default behaviors executed by the crypto/x509 \t\tpackage due to a non-default GODEBUG=x509negativeserial=... \t\tsetting.  \t/godebug/non-default-behavior/x509rsacrt:events \t\tThe number of non-default behaviors executed by the crypto/x509 \t\tpackage due to a non-default GODEBUG=x509rsacrt=... setting.  \t/godebug/non-default-behavior/x509sha256skid:events \t\tThe number of non-default behaviors executed by the crypto/x509 \t\tpackage due to a non-default GODEBUG=x509sha256skid=... setting.  \t/godebug/non-default-behavior/x509usefallbackroots:events \t\tThe number of non-default behaviors executed by the crypto/x509 \t\tpackage due to a non-default GODEBUG=x509usefallbackroots=... \t\tsetting.  \t/godebug/non-default-behavior/x509usepolicies:events \t\tThe number of non-default behaviors executed by the crypto/x509 \t\tpackage due to a non-default GODEBUG=x509usepolicies=... \t\tsetting.  \t/godebug/non-default-behavior/zipinsecurepath:events \t\tThe number of non-default behaviors executed by the archive/zip \t\tpackage due to a non-default GODEBUG=zipinsecurepath=... \t\tsetting.  \t/memory/classes/heap/free:bytes \t\tMemory that is completely free and eligible to be returned to \t\tthe underlying system, but has not been. This metric is the \t\truntime's estimate of free address space that is backed by \t\tphysical memory.  \t/memory/classes/heap/objects:bytes \t\tMemory occupied by live objects and dead objects that have not \t\tyet been marked free by the garbage collector.  \t/memory/classes/heap/released:bytes \t\tMemory that is completely free and has been returned to the \t\tunderlying system. This metric is the runtime's estimate of free \t\taddress space that is still mapped into the process, but is not \t\tbacked by physical memory.  \t/memory/classes/heap/stacks:bytes \t\tMemory allocated from the heap that is reserved for stack space, \t\twhether or not it is currently in-use. Currently, this \t\trepresents all stack memory for goroutines. It also includes all \t\tOS thread stacks in non-cgo programs. Note that stacks may be \t\tallocated differently in the future, and this may change.  \t/memory/classes/heap/unused:bytes \t\tMemory that is reserved for heap objects but is not currently \t\tused to hold heap objects.  \t/memory/classes/metadata/mcache/free:bytes \t\tMemory that is reserved for runtime mcache structures, but not \t\tin-use.  \t/memory/classes/metadata/mcache/inuse:bytes \t\tMemory that is occupied by runtime mcache structures that are \t\tcurrently being used.  \t/memory/classes/metadata/mspan/free:bytes \t\tMemory that is reserved for runtime mspan structures, but not \t\tin-use.  \t/memory/classes/metadata/mspan/inuse:bytes \t\tMemory that is occupied by runtime mspan structures that are \t\tcurrently being used.  \t/memory/classes/metadata/other:bytes \t\tMemory that is reserved for or used to hold runtime metadata.  \t/memory/classes/os-stacks:bytes \t\tStack memory allocated by the underlying operating system. \t\tIn non-cgo programs this metric is currently zero. This may \t\tchange in the future.In cgo programs this metric includes \t\tOS thread stacks allocated directly from the OS. Currently, \t\tthis only accounts for one stack in c-shared and c-archive build \t\tmodes, and other sources of stacks from the OS are not measured. \t\tThis too may change in the future.  \t/memory/classes/other:bytes \t\tMemory used by execution trace buffers, structures for debugging \t\tthe runtime, finalizer and profiler specials, and more.  \t/memory/classes/profiling/buckets:bytes \t\tMemory that is used by the stack trace hash map used for \t\tprofiling.  \t/memory/classes/total:bytes \t\tAll memory mapped by the Go runtime into the current process \t\tas read-write. Note that this does not include memory mapped \t\tby code called via cgo or via the syscall package. Sum of all \t\tmetrics in /memory/classes.  \t/sched/gomaxprocs:threads \t\tThe current runtime.GOMAXPROCS setting, or the number of \t\toperating system threads that can execute user-level Go code \t\tsimultaneously.  \t/sched/goroutines:goroutines \t\tCount of live goroutines.  \t/sched/latencies:seconds \t\tDistribution of the time goroutines have spent in the scheduler \t\tin a runnable state before actually running. Bucket counts \t\tincrease monotonically.  \t/sched/pauses/stopping/gc:seconds \t\tDistribution of individual GC-related stop-the-world stopping \t\tlatencies. This is the time it takes from deciding to stop the \t\tworld until all Ps are stopped. This is a subset of the total \t\tGC-related stop-the-world time (/sched/pauses/total/gc:seconds). \t\tDuring this time, some threads may be executing. Bucket counts \t\tincrease monotonically.  \t/sched/pauses/stopping/other:seconds \t\tDistribution of individual non-GC-related stop-the-world \t\tstopping latencies. This is the time it takes from deciding \t\tto stop the world until all Ps are stopped. This is a \t\tsubset of the total non-GC-related stop-the-world time \t\t(/sched/pauses/total/other:seconds). During this time, some \t\tthreads may be executing. Bucket counts increase monotonically.  \t/sched/pauses/total/gc:seconds \t\tDistribution of individual GC-related stop-the-world pause \t\tlatencies. This is the time from deciding to stop the world \t\tuntil the world is started again. Some of this time is spent \t\tgetting all threads to stop (this is measured directly in \t\t/sched/pauses/stopping/gc:seconds), during which some threads \t\tmay still be running. Bucket counts increase monotonically.  \t/sched/pauses/total/other:seconds \t\tDistribution of individual non-GC-related stop-the-world \t\tpause latencies. This is the time from deciding to stop the \t\tworld until the world is started again. Some of this time \t\tis spent getting all threads to stop (measured directly in \t\t/sched/pauses/stopping/other:seconds). Bucket counts increase \t\tmonotonically.  \t/sync/mutex/wait/total:seconds \t\tApproximate cumulative time goroutines have spent blocked on a \t\tsync.Mutex, sync.RWMutex, or runtime-internal lock. This metric \t\tis useful for identifying global changes in lock contention. \t\tCollect a mutex or block profile using the runtime/pprof package \t\tfor more detailed contention data.",
    "functions": [
      {
        "name": "Read",
        "desc": "Read populates each [Value] field in the given slice of metric samples.  Desired metrics should be present in the slice with the appropriate name. The user of this API is encouraged to re-use the same slice between calls for efficiency, but is not required to do so.  Note that re-use has some caveats. Notably, Values should not be read or manipulated while a Read with that value is outstanding; that is a data race. This property includes pointer-typed Values (for example, [Float64Histogram]) whose underlying storage will be reused by Read when possible. To safely use such values in a concurrent setting, all data must be deep-copied.  It is safe to execute multiple Read calls concurrently, but their arguments must share no underlying memory. When in doubt, create a new []Sample from scratch, which is always safe, though may be inefficient.  Sample values with names not appearing in [All] will have their Value populated as KindBad to indicate that the name is unknown."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "runtime_readMetrics",
        "desc": "Implemented in the runtime."
      },
      {
        "name": "Float64",
        "desc": "Float64 returns the internal float64 value for the metric.  If v.Kind() != KindFloat64, this method panics."
      },
      {
        "name": "Float64Histogram",
        "desc": "Float64Histogram returns the internal *Float64Histogram value for the metric.  If v.Kind() != KindFloat64Histogram, this method panics."
      },
      {
        "name": "Kind",
        "desc": "Kind returns the tag representing the kind of value this is."
      },
      {
        "name": "Uint64",
        "desc": "Uint64 returns the internal uint64 value for the metric.  If v.Kind() != KindUint64, this method panics."
      }
    ],
    "types": [
      {
        "name": "Description",
        "desc": "Description describes a runtime metric."
      },
      {
        "name": "Float64Histogram",
        "desc": "Float64Histogram represents a distribution of float64 values."
      },
      {
        "name": "Sample",
        "desc": "Sample captures a single metric sample."
      },
      {
        "name": "Value",
        "desc": "Value represents a metric value returned by the runtime."
      },
      {
        "name": "ValueKind",
        "desc": "ValueKind is a tag for a metric [Value] which indicates its type."
      }
    ]
  },
  {
    "name": "runtime/msan",
    "desc": "",
    "functions": null,
    "types": null
  },
  {
    "name": "runtime/pprof",
    "desc": "Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.  # Profiling a Go program  The first step to profiling a Go program is to enable profiling. Support for profiling benchmarks built with the standard testing package is built into go test. For example, the following command runs benchmarks in the current directory and writes the CPU and memory profiles to cpu.prof and mem.prof:  \tgo test -cpuprofile cpu.prof -memprofile mem.prof -bench .  To add equivalent profiling support to a standalone program, add code like the following to your main function:  \tvar cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\") \tvar memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")  \tfunc main() { \t    flag.Parse() \t    if *cpuprofile != \"\" { \t        f, err := os.Create(*cpuprofile) \t        if err != nil { \t            log.Fatal(\"could not create CPU profile: \", err) \t        } \t        defer f.Close() // error handling omitted for example \t        if err := pprof.StartCPUProfile(f); err != nil { \t            log.Fatal(\"could not start CPU profile: \", err) \t        } \t        defer pprof.StopCPUProfile() \t    }  \t    // ... rest of the program ...  \t    if *memprofile != \"\" { \t        f, err := os.Create(*memprofile) \t        if err != nil { \t            log.Fatal(\"could not create memory profile: \", err) \t        } \t        defer f.Close() // error handling omitted for example \t        runtime.GC() // get up-to-date statistics \t        // Lookup(\"allocs\") creates a profile similar to go test -memprofile. \t        // Alternatively, use Lookup(\"heap\") for a profile \t        // that has inuse_space as the default index. \t        if err := pprof.Lookup(\"allocs\").WriteTo(f, 0); err != nil { \t            log.Fatal(\"could not write memory profile: \", err) \t        } \t    } \t}  There is also a standard HTTP interface to profiling data. Adding the following line will install handlers under the /debug/pprof/ URL to download live profiles:  \timport _ \"net/http/pprof\"  See the net/http/pprof package for more details.  Profiles can then be visualized with the pprof tool:  \tgo tool pprof cpu.prof  There are many commands available from the pprof command line. Commonly used commands include \"top\", which prints a summary of the top program hot-spots, and \"web\", which opens an interactive graph of hot-spots and their call graphs. Use \"help\" for information on all pprof commands.  For more information about pprof, see https://github.com/google/pprof/blob/main/doc/README.md.",
    "functions": [
      {
        "name": "BenchmarkGoroutine",
        "desc": ""
      },
      {
        "name": "BenchmarkLabels",
        "desc": ""
      },
      {
        "name": "Do",
        "desc": "Do calls f with a copy of the parent context with the given labels added to the parent's label map. Goroutines spawned while executing f will inherit the augmented label-set. Each key/value pair in labels is inserted into the label map in the order provided, overriding any previous value for the same key. The augmented label map will be set for the duration of the call to f and restored once f returns."
      },
      {
        "name": "ForLabels",
        "desc": "ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early."
      },
      {
        "name": "Label",
        "desc": "Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists."
      },
      {
        "name": "SetGoroutineLabels",
        "desc": "SetGoroutineLabels sets the current goroutine's labels to match ctx. A new goroutine inherits the labels of the goroutine that created it. This is a lower-level API than [Do], which should be used instead when possible."
      },
      {
        "name": "StartCPUProfile",
        "desc": "StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.  On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call [os/signal.Notify] for [syscall.SIGPROF], but note that doing so may break any profiling being done by the main program."
      },
      {
        "name": "StopCPUProfile",
        "desc": "StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed."
      },
      {
        "name": "TestAtomicLoadStore64",
        "desc": "Check that there is no deadlock when the program receives SIGPROF while in 64bit atomics' critical section. Used to happen on mips{,le}. See #20146."
      },
      {
        "name": "TestBlockMutexProfileInlineExpansion",
        "desc": ""
      },
      {
        "name": "TestBlockProfile",
        "desc": ""
      },
      {
        "name": "TestBlockProfileBias",
        "desc": "See http://golang.org/cl/299991."
      },
      {
        "name": "TestCPUProfile",
        "desc": ""
      },
      {
        "name": "TestCPUProfileInlining",
        "desc": ""
      },
      {
        "name": "TestCPUProfileLabel",
        "desc": ""
      },
      {
        "name": "TestCPUProfileMultithreadMagnitude",
        "desc": ""
      },
      {
        "name": "TestCPUProfileMultithreaded",
        "desc": ""
      },
      {
        "name": "TestCPUProfileRecursion",
        "desc": ""
      },
      {
        "name": "TestCPUProfileWithFork",
        "desc": "Fork can hang if preempted with signals frequently enough (see issue 5517). Ensure that we do not do this."
      },
      {
        "name": "TestContextLabels",
        "desc": ""
      },
      {
        "name": "TestConvertCPUProfile",
        "desc": ""
      },
      {
        "name": "TestConvertCPUProfileNoSamples",
        "desc": ""
      },
      {
        "name": "TestConvertMemProfile",
        "desc": ""
      },
      {
        "name": "TestDo",
        "desc": ""
      },
      {
        "name": "TestEmptyCallStack",
        "desc": "Issue 18836."
      },
      {
        "name": "TestEmptyStack",
        "desc": "Make sure the profiler can handle an empty stack trace. See issue 37967."
      },
      {
        "name": "TestFakeMapping",
        "desc": "TestFakeMapping tests if at least one mapping exists (including a fake mapping), and their HasFunctions bits are set correctly."
      },
      {
        "name": "TestGenericsHashKeyInPprofBuilder",
        "desc": "This is a regression test for https://go.dev/issue/64528."
      },
      {
        "name": "TestGenericsInlineLocations",
        "desc": ""
      },
      {
        "name": "TestGoroutineCounts",
        "desc": ""
      },
      {
        "name": "TestGoroutineProfileConcurrency",
        "desc": ""
      },
      {
        "name": "TestGoroutineProfileCoro",
        "desc": "Regression test for #69998."
      },
      {
        "name": "TestGoroutineProfileIssue74090",
        "desc": "This test tries to provoke a situation wherein the finalizer goroutine is erroneously inspected by the goroutine profiler in such a way that could cause a crash. See go.dev/issue/74090."
      },
      {
        "name": "TestGoroutineProfileLabelRace",
        "desc": ""
      },
      {
        "name": "TestGoroutineSwitch",
        "desc": "Test that profiler does not observe runtime.gogo as \"user\" goroutine execution. If it did, it would see inconsistent state and would either record an incorrect stack or crash because the stack was malformed."
      },
      {
        "name": "TestHeapRuntimeFrames",
        "desc": "Runtime frames are hidden in heap profiles. This is a regression test for https://go.dev/issue/71174."
      },
      {
        "name": "TestLabelMapStringer",
        "desc": ""
      },
      {
        "name": "TestLabelRace",
        "desc": ""
      },
      {
        "name": "TestLabelSystemstack",
        "desc": "TestLabelSystemstack makes sure CPU profiler samples of goroutines running on systemstack include the correct pprof labels. See issue #48577"
      },
      {
        "name": "TestMapping",
        "desc": "TestMapping checks the mapping section of CPU profiles has the HasFunctions field set correctly. If all PCs included in the samples are successfully symbolized, the corresponding mapping entry (in this test case, only one entry) should have its HasFunctions field set true. The test generates a CPU profile that includes PCs from C side that the runtime can't symbolize. See ./testdata/mappingtest."
      },
      {
        "name": "TestMathBigDivide",
        "desc": "Test that profiling of division operations is okay, especially on ARM. See issue 6681."
      },
      {
        "name": "TestMemoryProfiler",
        "desc": ""
      },
      {
        "name": "TestMorestack",
        "desc": ""
      },
      {
        "name": "TestMutexBlockFullAggregation",
        "desc": ""
      },
      {
        "name": "TestMutexProfile",
        "desc": ""
      },
      {
        "name": "TestMutexProfileRateAdjust",
        "desc": ""
      },
      {
        "name": "TestProcSelfMaps",
        "desc": ""
      },
      {
        "name": "TestProfileRecordNullPadding",
        "desc": ""
      },
      {
        "name": "TestProfilerStackDepth",
        "desc": ""
      },
      {
        "name": "TestSetGoroutineLabels",
        "desc": ""
      },
      {
        "name": "TestTimeVDSO",
        "desc": ""
      },
      {
        "name": "TestTracebackAll",
        "desc": ""
      },
      {
        "name": "TestTryAdd",
        "desc": "TestTryAdd tests the cases that are hard to test with real program execution.  For example, the current go compilers may not always inline functions involved in recursion but that may not be true in the future compilers. This tests such cases by using fake call sequences and forcing the profile build utilizing translateCPUProfile defined in proto_test.go"
      },
      {
        "name": "TestVMInfo",
        "desc": ""
      },
      {
        "name": "TestWriteToErr",
        "desc": ""
      },
      {
        "name": "WithLabels",
        "desc": "WithLabels returns a new [context.Context] with the given labels added. A label overwrites a prior label with the same key."
      },
      {
        "name": "WriteHeapProfile",
        "desc": "WriteHeapProfile is shorthand for [Lookup](\"heap\").WriteTo(w, 0). It is preserved for backwards compatibility."
      },
      {
        "name": "addMaxRSS",
        "desc": "Stub call for platforms that don't support rusage."
      },
      {
        "name": "allocDeep",
        "desc": "allocDeep calls itself n times before calling fn."
      },
      {
        "name": "allocatePersistent1K",
        "desc": ""
      },
      {
        "name": "allocateReflect",
        "desc": ""
      },
      {
        "name": "allocateReflectTransient",
        "desc": ""
      },
      {
        "name": "allocateTransient1M",
        "desc": ""
      },
      {
        "name": "allocateTransient2M",
        "desc": ""
      },
      {
        "name": "allocateTransient2MInline",
        "desc": ""
      },
      {
        "name": "avoidFunctions",
        "desc": "Return a list of functions that we don't want to ever appear in CPU profiles. For gccgo, that list includes the sigprof handler itself."
      },
      {
        "name": "awaitBlockedGoroutine",
        "desc": "awaitBlockedGoroutine spins on runtime.Gosched until a runtime stack dump shows a goroutine in the given state with a stack frame in runtime/pprof.\u003cfName\u003e."
      },
      {
        "name": "blockChanClose",
        "desc": ""
      },
      {
        "name": "blockChanDeep",
        "desc": "blockChanDeep produces a block profile event at stack depth n, including the caller."
      },
      {
        "name": "blockChanRecv",
        "desc": ""
      },
      {
        "name": "blockChanSend",
        "desc": ""
      },
      {
        "name": "blockCond",
        "desc": ""
      },
      {
        "name": "blockFrequentShort",
        "desc": "blockFrequentShort produces 100000 block events with an average duration of rate / 10."
      },
      {
        "name": "blockInfrequentLong",
        "desc": "blockInfrequentLong produces 10000 block events with an average duration of rate."
      },
      {
        "name": "blockMutex",
        "desc": ""
      },
      {
        "name": "blockMutexDeep",
        "desc": "blockMutexDeep produces a block profile event at stack depth n, including the caller."
      },
      {
        "name": "blockMutexN",
        "desc": ""
      },
      {
        "name": "blockRecordStacks",
        "desc": ""
      },
      {
        "name": "blockSelectRecvAsync",
        "desc": ""
      },
      {
        "name": "blockSelectSendSync",
        "desc": ""
      },
      {
        "name": "blockevent",
        "desc": "Used by TestBlockProfileBias."
      },
      {
        "name": "checkProfile",
        "desc": ""
      },
      {
        "name": "containsCountsLabels",
        "desc": ""
      },
      {
        "name": "containsInOrder",
        "desc": ""
      },
      {
        "name": "containsInlinedCall",
        "desc": "containsInlinedCall reports whether the function body for the function f is known to contain an inlined function call within the first maxBytes bytes."
      },
      {
        "name": "containsStack",
        "desc": ""
      },
      {
        "name": "countBlock",
        "desc": "countBlock returns the number of records in the blocking profile."
      },
      {
        "name": "countGoroutine",
        "desc": "countGoroutine returns the number of goroutines."
      },
      {
        "name": "countHeap",
        "desc": "countHeap returns the number of records in the heap profile."
      },
      {
        "name": "countMutex",
        "desc": "countMutex returns the number of records in the mutex profile."
      },
      {
        "name": "countThreadCreate",
        "desc": "countThreadCreate returns the size of the current ThreadCreateProfile."
      },
      {
        "name": "cpuHog0",
        "desc": ""
      },
      {
        "name": "cpuHog1",
        "desc": "The actual CPU hogging function. Must not call other functions nor access heap/globals in the loop, otherwise under race detector the samples will be in the race runtime."
      },
      {
        "name": "cpuHog2",
        "desc": ""
      },
      {
        "name": "cpuHogger",
        "desc": ""
      },
      {
        "name": "createModuleSnapshot",
        "desc": ""
      },
      {
        "name": "diffCPUTime",
        "desc": ""
      },
      {
        "name": "diffCPUTimeRUsage",
        "desc": ""
      },
      {
        "name": "disableSampling",
        "desc": "disableSampling configures the profilers to capture all events, otherwise it's difficult to assert anything."
      },
      {
        "name": "dumpCallers",
        "desc": ""
      },
      {
        "name": "elfBuildID",
        "desc": "elfBuildID returns the GNU build ID of the named ELF binary, without introducing a dependency on debug/elf and its dependencies."
      },
      {
        "name": "expandInlinedFrames",
        "desc": "expandInlinedFrames copies the call stack from pcs into dst, expanding any PCs corresponding to inlined calls into the corresponding PCs for the inlined functions. Returns the number of frames copied to dst."
      },
      {
        "name": "f1",
        "desc": ""
      },
      {
        "name": "f2",
        "desc": ""
      },
      {
        "name": "findInlinedCall",
        "desc": "findInlinedCall returns the PC of an inlined function call within the function body for the function f if any."
      },
      {
        "name": "fmtJSON",
        "desc": "fmtJSON returns a pretty-printed JSON form for x. It works reasonably well for printing protocol-buffer data structures like profile.Profile."
      },
      {
        "name": "fprintStack",
        "desc": ""
      },
      {
        "name": "func1",
        "desc": ""
      },
      {
        "name": "func2",
        "desc": ""
      },
      {
        "name": "func3",
        "desc": ""
      },
      {
        "name": "func4",
        "desc": ""
      },
      {
        "name": "genericAllocFunc",
        "desc": ""
      },
      {
        "name": "getProfLabel",
        "desc": ""
      },
      {
        "name": "getProfileStacks",
        "desc": ""
      },
      {
        "name": "goroutineDeep",
        "desc": "goroutineDeep blocks at stack depth n, including the caller until the test is finished."
      },
      {
        "name": "growMap",
        "desc": ""
      },
      {
        "name": "growstack",
        "desc": ""
      },
      {
        "name": "growstack1",
        "desc": ""
      },
      {
        "name": "hasPrefix",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "inlineA",
        "desc": ""
      },
      {
        "name": "inlineB",
        "desc": ""
      },
      {
        "name": "inlineC",
        "desc": ""
      },
      {
        "name": "inlineD",
        "desc": ""
      },
      {
        "name": "inlineE",
        "desc": ""
      },
      {
        "name": "inlineF",
        "desc": ""
      },
      {
        "name": "inlinedCallee",
        "desc": ""
      },
      {
        "name": "inlinedCalleeDump",
        "desc": ""
      },
      {
        "name": "inlinedCaller",
        "desc": ""
      },
      {
        "name": "inlinedCallerDump",
        "desc": ""
      },
      {
        "name": "inlinedWrapperCallerDump",
        "desc": ""
      },
      {
        "name": "isExecutable",
        "desc": ""
      },
      {
        "name": "labelHog",
        "desc": "labelHog is designed to burn CPU time in a way that a high number of CPU samples end up running on systemstack."
      },
      {
        "name": "locationToStrings",
        "desc": ""
      },
      {
        "name": "lockProfiles",
        "desc": ""
      },
      {
        "name": "lostProfileEvent",
        "desc": "lostProfileEvent is the function to which lost profiling events are attributed. (The name shows up in the pprof graphs.)"
      },
      {
        "name": "machVMInfo",
        "desc": "machVMInfo uses the mach_vm_region region system call to add mapping entries for the text region of the running process."
      },
      {
        "name": "mach_vm_region",
        "desc": "mach_vm_region and proc_regionfilename are implemented by the runtime package (runtime/sys_darwin.go)."
      },
      {
        "name": "nonRecursiveGenericAllocFunction",
        "desc": ""
      },
      {
        "name": "parallelLabelHog",
        "desc": "parallelLabelHog runs GOMAXPROCS goroutines running labelHog."
      },
      {
        "name": "parseProcSelfMaps",
        "desc": ""
      },
      {
        "name": "parseProfile",
        "desc": ""
      },
      {
        "name": "parseVmmap",
        "desc": "parseVmmap parses the output of vmmap and calls addMapping for the first r-x TEXT segment in the output."
      },
      {
        "name": "peBuildID",
        "desc": "peBuildID returns a best effort unique ID for the named executable.  It would be wasteful to calculate the hash of the whole file, instead use the binary name and the last modified time for the buildid."
      },
      {
        "name": "pprof_blockProfileInternal",
        "desc": ""
      },
      {
        "name": "pprof_cyclesPerSecond",
        "desc": ""
      },
      {
        "name": "pprof_fpunwindExpand",
        "desc": ""
      },
      {
        "name": "pprof_goroutineProfileWithLabels",
        "desc": ""
      },
      {
        "name": "pprof_makeProfStack",
        "desc": ""
      },
      {
        "name": "pprof_memProfileInternal",
        "desc": ""
      },
      {
        "name": "pprof_mutexProfileInternal",
        "desc": ""
      },
      {
        "name": "pprof_threadCreateInternal",
        "desc": ""
      },
      {
        "name": "printCountCycleProfile",
        "desc": "printCountCycleProfile outputs block profile records (for block or mutex profiles) as the pprof-proto format output. Translations from cycle count to time duration are done because The proto expects count and time (nanoseconds) instead of count and the number of cycles for block, contention profiles."
      },
      {
        "name": "printCountProfile",
        "desc": "printCountProfile prints a countProfile at the specified debug level. The profile will be in compressed proto format unless debug is nonzero."
      },
      {
        "name": "printStackRecord",
        "desc": "printStackRecord prints the function + source line information for a single stack trace."
      },
      {
        "name": "proc_regionfilename",
        "desc": ""
      },
      {
        "name": "produceProfileEvents",
        "desc": "produceProfileEvents produces pprof events at the given stack depth and then blocks in goroutineDeep until the test completes. The stack traces are guaranteed to have exactly the desired depth with produceProfileEvents as their root frame which is expected by TestProfilerStackDepth."
      },
      {
        "name": "profileOk",
        "desc": ""
      },
      {
        "name": "profileStacks",
        "desc": ""
      },
      {
        "name": "profileToStrings",
        "desc": ""
      },
      {
        "name": "profileWriter",
        "desc": ""
      },
      {
        "name": "readMainModuleMapping",
        "desc": ""
      },
      {
        "name": "readProfile",
        "desc": "readProfile, provided by the runtime, returns the next chunk of binary CPU profiling stack trace data, blocking until data is available. If profiling is turned off and all the profile data accumulated while it was on has been returned, readProfile returns eof=true. The caller must save the returned data and tags before calling readProfile again."
      },
      {
        "name": "recursionCallee",
        "desc": ""
      },
      {
        "name": "recursionCaller",
        "desc": ""
      },
      {
        "name": "recursionChainBottom",
        "desc": ""
      },
      {
        "name": "recursionChainMiddle",
        "desc": ""
      },
      {
        "name": "recursionChainTop",
        "desc": ""
      },
      {
        "name": "regionFilename",
        "desc": ""
      },
      {
        "name": "runtime_FrameStartLine",
        "desc": "runtime_FrameStartLine is defined in runtime/symtab.go."
      },
      {
        "name": "runtime_FrameSymbolName",
        "desc": "runtime_FrameSymbolName is defined in runtime/symtab.go."
      },
      {
        "name": "runtime_expandFinalInlineFrame",
        "desc": "runtime_expandFinalInlineFrame is defined in runtime/symtab.go."
      },
      {
        "name": "runtime_getProfLabel",
        "desc": "runtime_getProfLabel is defined in runtime/proflabel.go."
      },
      {
        "name": "runtime_setProfLabel",
        "desc": "runtime_setProfLabel is defined in runtime/proflabel.go."
      },
      {
        "name": "sampleToString",
        "desc": ""
      },
      {
        "name": "scaleHeapSample",
        "desc": "scaleHeapSample adjusts the data from a heap Sample to account for its probability of appearing in the collected data. heap profiles are a sampling of the memory allocations requests in a program. We estimate the unsampled value by dividing each collected sample by its probability of appearing in the profile. heap profiles rely on a poisson process to determine which samples to collect, based on the desired average collection rate R. The probability of a sample of size S to appear in that profile is 1-exp(-S/R)."
      },
      {
        "name": "stackContains",
        "desc": "stackContains matches if a function named spec appears anywhere in the stack trace."
      },
      {
        "name": "stackContainsAll",
        "desc": "stackContainsAll matches if all functions in spec (comma-separated) appear somewhere in the stack trace."
      },
      {
        "name": "stackContainsLabeled",
        "desc": "stackContainsLabeled takes a spec like funcname;key=value and matches if the stack has that key and value and has funcname somewhere in the stack."
      },
      {
        "name": "storeAlloc",
        "desc": ""
      },
      {
        "name": "symbolized",
        "desc": ""
      },
      {
        "name": "testCPUProfile",
        "desc": "testCPUProfile runs f under the CPU profiler, checking for some conditions specified by need, as interpreted by matches, and returns the parsed profile."
      },
      {
        "name": "testPCs",
        "desc": "testPCs returns two PCs and two corresponding memory mappings to use in test profiles."
      },
      {
        "name": "testProfileRecordNullPadding",
        "desc": ""
      },
      {
        "name": "translateCPUProfile",
        "desc": "translateCPUProfile parses binary CPU profiling stack trace data generated by runtime.CPUProfile() into a profile struct. This is only used for testing. Real conversions stream the data into the profileBuilder as it becomes available.  count is the number of records in data."
      },
      {
        "name": "unlockProfiles",
        "desc": ""
      },
      {
        "name": "use",
        "desc": ""
      },
      {
        "name": "useVMMap",
        "desc": ""
      },
      {
        "name": "useVMMapWithRetry",
        "desc": ""
      },
      {
        "name": "writeAlloc",
        "desc": "writeAlloc writes the current runtime heap profile to w with the total allocation space as the default sample type."
      },
      {
        "name": "writeBlock",
        "desc": "writeBlock writes the current blocking profile to w."
      },
      {
        "name": "writeGoroutine",
        "desc": "writeGoroutine writes the current runtime GoroutineProfile to w."
      },
      {
        "name": "writeGoroutineStacks",
        "desc": ""
      },
      {
        "name": "writeHeap",
        "desc": "writeHeap writes the current runtime heap profile to w."
      },
      {
        "name": "writeHeapInternal",
        "desc": ""
      },
      {
        "name": "writeHeapProto",
        "desc": "writeHeapProto writes the current heap profile in protobuf format to w."
      },
      {
        "name": "writeMutex",
        "desc": "writeMutex writes the current mutex profile to w."
      },
      {
        "name": "writeProfileInternal",
        "desc": "writeProfileInternal writes the current blocking or mutex profile depending on the passed parameters."
      },
      {
        "name": "writeRuntimeProfile",
        "desc": ""
      },
      {
        "name": "writeThreadCreate",
        "desc": "writeThreadCreate writes the current runtime ThreadCreateProfile to w."
      },
      {
        "name": "Add",
        "desc": "Add adds the current execution stack to the profile, associated with value. Add stores value in an internal map, so value must be suitable for use as a map key and will not be garbage collected until the corresponding call to [Profile.Remove]. Add panics if the profile already contains a stack for value.  The skip parameter has the same meaning as [runtime.Caller]'s skip and controls where the stack trace begins. Passing skip=0 begins the trace in the function calling Add. For example, given this execution stack:  \tAdd \tcalled from rpc.NewClient \tcalled from mypkg.Run \tcalled from main.main  Passing skip=0 begins the stack trace at the call to Add inside rpc.NewClient. Passing skip=1 begins the stack trace at the call to NewClient inside mypkg.Run."
      },
      {
        "name": "Count",
        "desc": "Count returns the number of execution stacks currently in the profile."
      },
      {
        "name": "Name",
        "desc": "Name returns this profile's name, which can be passed to [Lookup] to reobtain the profile."
      },
      {
        "name": "Remove",
        "desc": "Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to w returns an error, WriteTo returns that error. Otherwise, WriteTo returns nil.  The debug parameter enables additional output. Passing debug=0 writes the gzip-compressed protocol buffer described in https://github.com/google/pprof/tree/main/proto#overview. Passing debug=1 writes the legacy text format with comments translating addresses to function names and line numbers, so that a programmer can read the profile without tools.  The predefined profiles may assign meaning to other debug values; for example, when printing the \"goroutine\" profile, debug=2 means to print the goroutine stacks in the same form that a Go program uses when dying due to an unrecovered panic."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "dump",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String satisfies Stringer and returns key, value pairs in a consistent order."
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "tryAdd",
        "desc": "tryAdd tries to add the pc and Frames expanded from it (most likely one, since the stack trace is already fully expanded) and the symbolizeResult to the deck. If it fails the caller needs to flush the deck and retry."
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "addCPUData",
        "desc": "addCPUData adds the CPU profiling data to the profile.  The data must be a whole number of records, as delivered by the runtime. len(tags) must be equal to the number of records in data."
      },
      {
        "name": "addMapping",
        "desc": ""
      },
      {
        "name": "addMappingEntry",
        "desc": ""
      },
      {
        "name": "appendLocsForStack",
        "desc": "appendLocsForStack appends the location IDs for the given stack trace to the given location ID slice, locs. The addresses in the stack are return PCs or 1 + the PC of an inline marker as the runtime traceback function returns.  It may return an empty slice even if locs is non-empty, for example if locs consists solely of runtime.goexit. We still count these empty stacks in profiles in order to get the right cumulative sample count.  It may emit to b.pb, so there must be no message encoding in progress."
      },
      {
        "name": "build",
        "desc": "build completes and returns the constructed profile."
      },
      {
        "name": "emitLocation",
        "desc": "emitLocation emits the new location and function information recorded in the deck and returns the location ID encoded in the profile protobuf. It emits to b.pb, so there must be no message encoding in progress. It resets the deck."
      },
      {
        "name": "flush",
        "desc": ""
      },
      {
        "name": "pbLabel",
        "desc": "pbLabel encodes a Label message to b.pb."
      },
      {
        "name": "pbLine",
        "desc": "pbLine encodes a Line message to b.pb."
      },
      {
        "name": "pbMapping",
        "desc": "pbMapping encodes a Mapping message to b.pb."
      },
      {
        "name": "pbSample",
        "desc": "pbSample encodes a Sample message to b.pb."
      },
      {
        "name": "pbValueType",
        "desc": "pbValueType encodes a ValueType message to b.pb."
      },
      {
        "name": "readMapping",
        "desc": "readMapping adds memory mapping information to the profile."
      },
      {
        "name": "stringIndex",
        "desc": "stringIndex adds s to the string table if not already present and returns the index of s in the string table."
      },
      {
        "name": "bool",
        "desc": ""
      },
      {
        "name": "boolOpt",
        "desc": ""
      },
      {
        "name": "endMessage",
        "desc": ""
      },
      {
        "name": "int64",
        "desc": ""
      },
      {
        "name": "int64Opt",
        "desc": ""
      },
      {
        "name": "int64s",
        "desc": ""
      },
      {
        "name": "length",
        "desc": ""
      },
      {
        "name": "startMessage",
        "desc": ""
      },
      {
        "name": "string",
        "desc": ""
      },
      {
        "name": "stringOpt",
        "desc": ""
      },
      {
        "name": "strings",
        "desc": ""
      },
      {
        "name": "uint64",
        "desc": ""
      },
      {
        "name": "uint64Opt",
        "desc": ""
      },
      {
        "name": "uint64s",
        "desc": ""
      },
      {
        "name": "varint",
        "desc": ""
      },
      {
        "name": "Label",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Stack",
        "desc": ""
      },
      {
        "name": "Label",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Stack",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "LabelSet",
        "desc": "LabelSet is a set of labels."
      },
      {
        "name": "Obj32",
        "desc": ""
      },
      {
        "name": "Profile",
        "desc": "A Profile is a collection of stack traces showing the call sequences that led to instances of a particular event, such as allocation. Packages can create and maintain their own profiles; the most common use is for tracking resources that must be explicitly closed, such as files or network connections.  A Profile's methods can be called from multiple goroutines simultaneously.  Each Profile has a unique name. A few profiles are predefined:  \tgoroutine    - stack traces of all current goroutines \theap         - a sampling of memory allocations of live objects \tallocs       - a sampling of all past memory allocations \tthreadcreate - stack traces that led to the creation of new OS threads \tblock        - stack traces that led to blocking on synchronization primitives \tmutex        - stack traces of holders of contended mutexes  These predefined profiles maintain themselves and panic on an explicit [Profile.Add] or [Profile.Remove] method call.  The CPU profile is not available as a Profile. It has a special API, the [StartCPUProfile] and [StopCPUProfile] functions, because it streams output to a writer during profiling.  # Heap profile  The heap profile reports statistics as of the most recently completed garbage collection; it elides more recent allocation to avoid skewing the profile away from live data and toward garbage. If there has been no garbage collection at all, the heap profile reports all known allocations. This exception helps mainly in programs running without garbage collection enabled, usually for debugging purposes.  The heap profile tracks both the allocation sites for all live objects in the application memory and for all objects allocated since the program start. Pprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects flags select which to display, defaulting to -inuse_space (live objects, scaled by size).  # Allocs profile  The allocs profile is the same as the heap profile but changes the default pprof display to -alloc_space, the total number of bytes allocated since the program began (including garbage-collected bytes).  # Block profile  The block profile tracks time spent blocked on synchronization primitives, such as [sync.Mutex], [sync.RWMutex], [sync.WaitGroup], [sync.Cond], and channel send/receive/select.  Stack traces correspond to the location that blocked (for example, [sync.Mutex.Lock]).  Sample values correspond to cumulative time spent blocked at that stack trace, subject to time-based sampling specified by [runtime.SetBlockProfileRate].  # Mutex profile  The mutex profile tracks contention on mutexes, such as [sync.Mutex], [sync.RWMutex], and runtime-internal locks.  Stack traces correspond to the end of the critical section causing contention. For example, a lock held for a long time while other goroutines are waiting to acquire the lock will report contention when the lock is finally unlocked (that is, at [sync.Mutex.Unlock]).  Sample values correspond to the approximate cumulative time other goroutines spent blocked waiting for the lock, subject to event-based sampling specified by [runtime.SetMutexProfileFraction]. For example, if a caller holds a lock for 1s while 5 other goroutines are waiting for the entire second to acquire the lock, its unlock call stack will report 5s of contention."
      },
      {
        "name": "countProfile",
        "desc": "A countProfile is a set of stack traces to be printed as counts grouped by stack trace. There are multiple implementations: all that matters is that we can find out how many traces there are and obtain each trace in turn."
      },
      {
        "name": "errWriter",
        "desc": ""
      },
      {
        "name": "inlineWrapper",
        "desc": ""
      },
      {
        "name": "inlineWrapperInterface",
        "desc": ""
      },
      {
        "name": "keysByCount",
        "desc": "keysByCount sorts keys with higher counts first, breaking ties by key string order."
      },
      {
        "name": "label",
        "desc": ""
      },
      {
        "name": "labelContextKey",
        "desc": "labelContextKey is the type of contextKeys used for profiler labels."
      },
      {
        "name": "labelMap",
        "desc": "labelMap is the representation of the label set held in the context type. This is an initial implementation, but it will be replaced with something that admits incremental immutable modification more efficiently."
      },
      {
        "name": "locInfo",
        "desc": ""
      },
      {
        "name": "machVMRegionBasicInfoData",
        "desc": ""
      },
      {
        "name": "mapping",
        "desc": ""
      },
      {
        "name": "memMap",
        "desc": ""
      },
      {
        "name": "msgOffset",
        "desc": ""
      },
      {
        "name": "opAlloc",
        "desc": ""
      },
      {
        "name": "opCall",
        "desc": ""
      },
      {
        "name": "pcDeck",
        "desc": "pcDeck is a helper to detect a sequence of inlined functions from a stack trace returned by the runtime.  The stack traces returned by runtime's trackback functions are fully expanded (at least for Go functions) and include the fake pcs representing inlined functions. The profile proto expects the inlined functions to be encoded in one Location message. https://github.com/google/pprof/blob/5e965273ee43930341d897407202dd5e10e952cb/proto/profile.proto#L177-L184  Runtime does not directly expose whether a frame is for an inlined function and looking up debug info is not ideal, so we use a heuristic to filter the fake pcs and restore the inlined and entry functions. Inlined functions have the following properties:  \tFrame's Func is nil (note: also true for non-Go functions), and \tFrame's Entry matches its entry function frame's Entry (note: could also be true for recursive calls and non-Go functions), and \tFrame's Name does not match its entry function frame's name (note: inlined functions cannot be directly recursive).  As reading and processing the pcs in a stack trace one by one (from leaf to the root), we use pcDeck to temporarily hold the observed pcs and their expanded frames until we observe the entry function frame."
      },
      {
        "name": "profMap",
        "desc": "A profMap is a map from (stack, tag) to mapEntry. It grows without bound, but that's assumed to be OK."
      },
      {
        "name": "profMapEntry",
        "desc": "A profMapEntry is a single entry in the profMap."
      },
      {
        "name": "profileBuilder",
        "desc": "A profileBuilder writes a profile incrementally from a stream of profile samples delivered by the runtime."
      },
      {
        "name": "profileMatchFunc",
        "desc": ""
      },
      {
        "name": "protobuf",
        "desc": "A protobuf is a simple protocol buffer encoder."
      },
      {
        "name": "runtimeProfile",
        "desc": ""
      },
      {
        "name": "sampleMatchFunc",
        "desc": ""
      },
      {
        "name": "stackProfile",
        "desc": ""
      },
      {
        "name": "symbolizeFlag",
        "desc": "symbolizeFlag keeps track of symbolization result.  \t0                  : no symbol lookup was performed \t1\u003c\u003c0 (lookupTried) : symbol lookup was performed \t1\u003c\u003c1 (lookupFailed): symbol lookup was performed but failed"
      }
    ]
  },
  {
    "name": "runtime/race",
    "desc": "Package race implements data race detection logic. No public interface is provided. For details about the race detector see https://golang.org/doc/articles/race_detector.html",
    "functions": [
      {
        "name": "TestIssue37485",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "runtime/trace",
    "desc": "Package trace contains facilities for programs to generate traces for the Go execution tracer.  # Tracing runtime activities  The execution trace captures a wide range of execution events such as goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc. When CPU profiling is active, the execution tracer makes an effort to include those samples as well. A precise nanosecond-precision timestamp and a stack trace is captured for most events. The generated trace can be interpreted using `go tool trace`.  Support for tracing tests and benchmarks built with the standard testing package is built into `go test`. For example, the following command runs the test in the current directory and writes the trace file (trace.out).  \tgo test -trace=trace.out  This runtime/trace package provides APIs to add equivalent tracing support to a standalone program. See the Example that demonstrates how to use this API to enable tracing.  There is also a standard HTTP interface to trace data. Adding the following line will install a handler under the /debug/pprof/trace URL to download a live trace:  \timport _ \"net/http/pprof\"  See the [net/http/pprof] package for more details about all of the debug endpoints installed by this import.  # User annotation  Package trace provides user annotation APIs that can be used to log interesting events during execution.  There are three types of user annotations: log messages, regions, and tasks.  [Log] emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called [Log]. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in [Log].  A region is for logging a time interval during a goroutine's execution. By definition, a region starts and ends in the same goroutine. Regions can be nested to represent subintervals. For example, the following code records four regions in the execution trace to trace the durations of sequential steps in a cappuccino making operation.  \ttrace.WithRegion(ctx, \"makeCappuccino\", func() {  \t   // orderID allows to identify a specific order \t   // among many cappuccino order region records. \t   trace.Log(ctx, \"orderID\", orderID)  \t   trace.WithRegion(ctx, \"steamMilk\", steamMilk) \t   trace.WithRegion(ctx, \"extractCoffee\", extractCoffee) \t   trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee) \t})  A task is a higher-level component that aids tracing of logical operations such as an RPC request, an HTTP request, or an interesting local operation which may require multiple goroutines working together. Since tasks can involve multiple goroutines, they are tracked via a [context.Context] object. [NewTask] creates a new task and embeds it in the returned [context.Context] object. Log messages and regions are attached to the task, if any, in the Context passed to [Log] and [WithRegion].  For example, assume that we decided to froth milk, extract coffee, and mix milk and coffee in separate goroutines. With a task, the trace tool can identify the goroutines involved in a specific cappuccino order.  \tctx, task := trace.NewTask(ctx, \"makeCappuccino\") \ttrace.Log(ctx, \"orderID\", orderID)  \tmilk := make(chan bool) \tespresso := make(chan bool)  \tgo func() { \t        trace.WithRegion(ctx, \"steamMilk\", steamMilk) \t        milk \u003c- true \t}() \tgo func() { \t        trace.WithRegion(ctx, \"extractCoffee\", extractCoffee) \t        espresso \u003c- true \t}() \tgo func() { \t        defer task.End() // When assemble is done, the order is complete. \t        \u003c-espresso \t        \u003c-milk \t        trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee) \t}()  The trace tool computes the latency of a task by measuring the time between the task creation and the task end and provides latency distributions for each task type found in the trace.",
    "functions": [
      {
        "name": "IsEnabled",
        "desc": "IsEnabled reports whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns."
      },
      {
        "name": "Log",
        "desc": "Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system."
      },
      {
        "name": "Logf",
        "desc": "Logf is like [Log], but the value is formatted using the specified format spec."
      },
      {
        "name": "Start",
        "desc": "Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled."
      },
      {
        "name": "Stop",
        "desc": "Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed."
      },
      {
        "name": "WithRegion",
        "desc": "WithRegion starts a region associated with its calling goroutine, runs fn, and then ends the region. If the context carries a task, the region is associated with the task. Otherwise, the region is attached to the background task.  The regionType is used to classify regions, so there should be only a handful of unique region types."
      },
      {
        "name": "newID",
        "desc": ""
      },
      {
        "name": "putUvarint",
        "desc": "putUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic. TODO deduplicate this function."
      },
      {
        "name": "readBatch",
        "desc": "readBatch copies b and parses the trace batch header inside. Returns the batch, the generation, bytes read, and an error."
      },
      {
        "name": "readUvarint",
        "desc": "TODO deduplicate this function."
      },
      {
        "name": "runtime_readTrace",
        "desc": ""
      },
      {
        "name": "runtime_traceAdvance",
        "desc": ""
      },
      {
        "name": "runtime_traceClockNow",
        "desc": ""
      },
      {
        "name": "runtime_traceClockUnitsPerSecond",
        "desc": ""
      },
      {
        "name": "userLog",
        "desc": "emits UserLog event."
      },
      {
        "name": "userRegion",
        "desc": "emits UserRegion event."
      },
      {
        "name": "userTaskCreate",
        "desc": "emits UserTaskCreate event."
      },
      {
        "name": "userTaskEnd",
        "desc": "emits UserTaskEnd event."
      },
      {
        "name": "Enabled",
        "desc": "Enabled returns true if the flight recorder is active. Specifically, it will return true if Start did not return an error, and Stop has not yet been called. It is safe to call from multiple goroutines simultaneously."
      },
      {
        "name": "Start",
        "desc": "Start activates the flight recorder and begins recording trace data. Only one call to trace.Start may be active at any given time. In addition, currently only one flight recorder may be active in the program. Returns an error if the flight recorder cannot be started or is already started."
      },
      {
        "name": "Stop",
        "desc": "Stop ends recording of trace data. It blocks until any concurrent WriteTo calls complete."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo snapshots the moving window tracked by the flight recorder. The snapshot is expected to contain data that is up-to-date as of when WriteTo is called, though this is not a hard guarantee. Only one goroutine may execute WriteTo at a time. An error is returned upon failure to write to w, if another WriteTo call is already in-progress, or if the flight recorder is inactive."
      },
      {
        "name": "End",
        "desc": "End marks the end of the traced code region."
      },
      {
        "name": "End",
        "desc": "End marks the end of the operation represented by the [Task]."
      },
      {
        "name": "Sub",
        "desc": "Sub subtracts t0 from t, returning the duration in nanoseconds."
      },
      {
        "name": "mul",
        "desc": "mul multiplies an unprocessed to produce a time in nanoseconds."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "endGeneration",
        "desc": ""
      },
      {
        "name": "addedSubscriber",
        "desc": ""
      },
      {
        "name": "removedSubscriber",
        "desc": ""
      },
      {
        "name": "removingSubscriber",
        "desc": ""
      },
      {
        "name": "startLocked",
        "desc": ""
      },
      {
        "name": "subscribeFlightRecorder",
        "desc": ""
      },
      {
        "name": "subscribeTraceStartWriter",
        "desc": ""
      },
      {
        "name": "unsubscribeFlightRecorder",
        "desc": ""
      },
      {
        "name": "unsubscribeTraceStartWriter",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "FlightRecorder",
        "desc": "FlightRecorder represents a single consumer of a Go execution trace. It tracks a moving window over the execution trace produced by the runtime, always containing the most recent trace data.  At most one flight recorder may be active at any given time, though flight recording is allowed to be concurrently active with a trace consumer using trace.Start. This restriction of only a single flight recorder may be removed in the future."
      },
      {
        "name": "FlightRecorderConfig",
        "desc": ""
      },
      {
        "name": "Region",
        "desc": "Region is a region of code whose execution time interval is traced."
      },
      {
        "name": "Task",
        "desc": "Task is a data type for tracing a user-defined, logical operation."
      },
      {
        "name": "batch",
        "desc": "batch represents a batch of trace events. It is unparsed except for its header."
      },
      {
        "name": "eventTime",
        "desc": "eventTime is a timestamp in nanoseconds.  It corresponds to the monotonic clock on the platform that the trace was taken, and so is possible to correlate with timestamps for other traces taken on the same machine using the same clock (i.e. no reboots in between).  The actual absolute value of the timestamp is only meaningful in relation to other timestamps from the same clock.  BUG: Timestamps coming from traces on Windows platforms are only comparable with timestamps from the same trace. Timestamps across traces cannot be compared, because the system clock is not used as of Go 1.22.  BUG: Traces produced by Go versions 1.21 and earlier cannot be compared with timestamps from other traces taken on the same machine. This is because the system clock was not used at all to collect those timestamps."
      },
      {
        "name": "frequency",
        "desc": "frequency is nanoseconds per timestamp unit."
      },
      {
        "name": "rawGeneration",
        "desc": ""
      },
      {
        "name": "recorder",
        "desc": "A recorder receives bytes from the runtime tracer, processes it."
      },
      {
        "name": "threadID",
        "desc": "threadID is the runtime-internal M structure's ID. This is unique for each OS thread."
      },
      {
        "name": "timestamp",
        "desc": "timestamp is an unprocessed timestamp."
      },
      {
        "name": "traceContextKey",
        "desc": ""
      },
      {
        "name": "traceMultiplexer",
        "desc": ""
      }
    ]
  },
  {
    "name": "slices",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkBinarySearchFloats",
        "desc": ""
      },
      {
        "name": "BenchmarkBinarySearchFuncStruct",
        "desc": ""
      },
      {
        "name": "BenchmarkCompact",
        "desc": ""
      },
      {
        "name": "BenchmarkCompactFunc",
        "desc": ""
      },
      {
        "name": "BenchmarkCompactFunc_Large",
        "desc": ""
      },
      {
        "name": "BenchmarkCompact_Large",
        "desc": ""
      },
      {
        "name": "BenchmarkEqualFunc_Large",
        "desc": ""
      },
      {
        "name": "BenchmarkIndexFunc_Large",
        "desc": ""
      },
      {
        "name": "BenchmarkIndex_Large",
        "desc": ""
      },
      {
        "name": "BenchmarkReplace",
        "desc": ""
      },
      {
        "name": "BenchmarkSortFuncStruct",
        "desc": ""
      },
      {
        "name": "ExampleAll",
        "desc": ""
      },
      {
        "name": "ExampleAppendSeq",
        "desc": ""
      },
      {
        "name": "ExampleBackward",
        "desc": ""
      },
      {
        "name": "ExampleBinarySearch",
        "desc": ""
      },
      {
        "name": "ExampleBinarySearchFunc",
        "desc": ""
      },
      {
        "name": "ExampleChunk",
        "desc": ""
      },
      {
        "name": "ExampleClip",
        "desc": ""
      },
      {
        "name": "ExampleClone",
        "desc": ""
      },
      {
        "name": "ExampleCollect",
        "desc": ""
      },
      {
        "name": "ExampleCompact",
        "desc": ""
      },
      {
        "name": "ExampleCompactFunc",
        "desc": ""
      },
      {
        "name": "ExampleCompare",
        "desc": ""
      },
      {
        "name": "ExampleCompareFunc",
        "desc": ""
      },
      {
        "name": "ExampleConcat",
        "desc": ""
      },
      {
        "name": "ExampleContains",
        "desc": ""
      },
      {
        "name": "ExampleContainsFunc",
        "desc": ""
      },
      {
        "name": "ExampleDelete",
        "desc": ""
      },
      {
        "name": "ExampleDeleteFunc",
        "desc": ""
      },
      {
        "name": "ExampleEqual",
        "desc": ""
      },
      {
        "name": "ExampleEqualFunc",
        "desc": ""
      },
      {
        "name": "ExampleGrow",
        "desc": ""
      },
      {
        "name": "ExampleIndex",
        "desc": ""
      },
      {
        "name": "ExampleIndexFunc",
        "desc": ""
      },
      {
        "name": "ExampleInsert",
        "desc": ""
      },
      {
        "name": "ExampleIsSorted",
        "desc": ""
      },
      {
        "name": "ExampleIsSortedFunc",
        "desc": ""
      },
      {
        "name": "ExampleMax",
        "desc": ""
      },
      {
        "name": "ExampleMaxFunc",
        "desc": ""
      },
      {
        "name": "ExampleMin",
        "desc": ""
      },
      {
        "name": "ExampleMinFunc",
        "desc": ""
      },
      {
        "name": "ExampleRepeat",
        "desc": ""
      },
      {
        "name": "ExampleReplace",
        "desc": ""
      },
      {
        "name": "ExampleReverse",
        "desc": ""
      },
      {
        "name": "ExampleSort",
        "desc": ""
      },
      {
        "name": "ExampleSortFunc_caseInsensitive",
        "desc": ""
      },
      {
        "name": "ExampleSortFunc_multiField",
        "desc": ""
      },
      {
        "name": "ExampleSortStableFunc",
        "desc": ""
      },
      {
        "name": "ExampleSorted",
        "desc": ""
      },
      {
        "name": "ExampleSortedFunc",
        "desc": ""
      },
      {
        "name": "ExampleSortedStableFunc",
        "desc": ""
      },
      {
        "name": "ExampleValues",
        "desc": ""
      },
      {
        "name": "TestAll",
        "desc": ""
      },
      {
        "name": "TestAppendSeq",
        "desc": ""
      },
      {
        "name": "TestBackward",
        "desc": ""
      },
      {
        "name": "TestBinarySearch",
        "desc": ""
      },
      {
        "name": "TestBinarySearchFloats",
        "desc": ""
      },
      {
        "name": "TestBinarySearchFunc",
        "desc": ""
      },
      {
        "name": "TestBinarySearchInts",
        "desc": ""
      },
      {
        "name": "TestChunk",
        "desc": ""
      },
      {
        "name": "TestChunkPanics",
        "desc": ""
      },
      {
        "name": "TestChunkRange",
        "desc": ""
      },
      {
        "name": "TestClip",
        "desc": ""
      },
      {
        "name": "TestClone",
        "desc": ""
      },
      {
        "name": "TestCollect",
        "desc": ""
      },
      {
        "name": "TestCompact",
        "desc": ""
      },
      {
        "name": "TestCompactClearTail",
        "desc": ""
      },
      {
        "name": "TestCompactFunc",
        "desc": ""
      },
      {
        "name": "TestCompactFuncClearTail",
        "desc": ""
      },
      {
        "name": "TestCompare",
        "desc": ""
      },
      {
        "name": "TestCompareFunc",
        "desc": ""
      },
      {
        "name": "TestConcat",
        "desc": ""
      },
      {
        "name": "TestConcat_too_large",
        "desc": ""
      },
      {
        "name": "TestContains",
        "desc": ""
      },
      {
        "name": "TestContainsFunc",
        "desc": ""
      },
      {
        "name": "TestDelete",
        "desc": ""
      },
      {
        "name": "TestDeleteClearTail",
        "desc": ""
      },
      {
        "name": "TestDeleteFunc",
        "desc": ""
      },
      {
        "name": "TestDeleteFuncClearTail",
        "desc": ""
      },
      {
        "name": "TestDeletePanics",
        "desc": ""
      },
      {
        "name": "TestEqual",
        "desc": ""
      },
      {
        "name": "TestEqualFunc",
        "desc": ""
      },
      {
        "name": "TestGrow",
        "desc": ""
      },
      {
        "name": "TestIndex",
        "desc": ""
      },
      {
        "name": "TestIndexFunc",
        "desc": ""
      },
      {
        "name": "TestInference",
        "desc": "Test type inference with a named slice type."
      },
      {
        "name": "TestInsert",
        "desc": ""
      },
      {
        "name": "TestInsertGrowthRate",
        "desc": ""
      },
      {
        "name": "TestInsertOverlap",
        "desc": ""
      },
      {
        "name": "TestInsertPanics",
        "desc": ""
      },
      {
        "name": "TestIssue68488",
        "desc": ""
      },
      {
        "name": "TestMinMax",
        "desc": ""
      },
      {
        "name": "TestMinMaxNaNs",
        "desc": ""
      },
      {
        "name": "TestMinMaxPanics",
        "desc": ""
      },
      {
        "name": "TestNilness",
        "desc": "This test asserts the behavior when the primary slice operand is nil.  Some operations preserve the nilness of their operand while others do not, but in all cases the behavior is documented."
      },
      {
        "name": "TestRepeat",
        "desc": ""
      },
      {
        "name": "TestRepeatPanics",
        "desc": ""
      },
      {
        "name": "TestReplace",
        "desc": ""
      },
      {
        "name": "TestReplaceClearTail",
        "desc": ""
      },
      {
        "name": "TestReplaceEndClearTail",
        "desc": ""
      },
      {
        "name": "TestReplaceGrow",
        "desc": ""
      },
      {
        "name": "TestReplaceGrowthRate",
        "desc": ""
      },
      {
        "name": "TestReplaceOverlap",
        "desc": ""
      },
      {
        "name": "TestReplacePanics",
        "desc": ""
      },
      {
        "name": "TestReverse",
        "desc": ""
      },
      {
        "name": "TestSortFloat64Slice",
        "desc": ""
      },
      {
        "name": "TestSortFuncIntSlice",
        "desc": ""
      },
      {
        "name": "TestSortIntSlice",
        "desc": ""
      },
      {
        "name": "TestSortLarge_Random",
        "desc": ""
      },
      {
        "name": "TestSortStringSlice",
        "desc": ""
      },
      {
        "name": "TestSorted",
        "desc": ""
      },
      {
        "name": "TestSortedFunc",
        "desc": ""
      },
      {
        "name": "TestSortedStableFunc",
        "desc": ""
      },
      {
        "name": "TestStability",
        "desc": ""
      },
      {
        "name": "TestValues",
        "desc": ""
      },
      {
        "name": "TestValuesAppendSeq",
        "desc": ""
      },
      {
        "name": "TestValuesCollect",
        "desc": ""
      },
      {
        "name": "apply",
        "desc": ""
      },
      {
        "name": "chunkEqual",
        "desc": ""
      },
      {
        "name": "cmpS",
        "desc": ""
      },
      {
        "name": "equal",
        "desc": "equal is simply ==."
      },
      {
        "name": "equalNaN",
        "desc": "equalNaN is like == except that all NaNs are equal."
      },
      {
        "name": "equalToCmp",
        "desc": ""
      },
      {
        "name": "equalToIndex",
        "desc": ""
      },
      {
        "name": "intPairCmp",
        "desc": "Pairs compare on a only."
      },
      {
        "name": "naiveReplace",
        "desc": "naiveReplace is a baseline implementation to the Replace function."
      },
      {
        "name": "offByOne",
        "desc": "offByOne returns true if integers v1 and v2 differ by 1."
      },
      {
        "name": "panics",
        "desc": ""
      },
      {
        "name": "testSeq",
        "desc": ""
      },
      {
        "name": "inOrder",
        "desc": "InOrder checks if a-equal elements were not reordered. If reversed is true, expect reverse ordering."
      },
      {
        "name": "initB",
        "desc": "Record initial order in B."
      }
    ],
    "types": [
      {
        "name": "S",
        "desc": ""
      },
      {
        "name": "intPair",
        "desc": ""
      },
      {
        "name": "intPairs",
        "desc": ""
      },
      {
        "name": "myStruct",
        "desc": ""
      }
    ]
  },
  {
    "name": "sort",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkSearchWrappers",
        "desc": ""
      },
      {
        "name": "BenchmarkSlicesIsSorted",
        "desc": ""
      },
      {
        "name": "BenchmarkSlicesSortInts",
        "desc": ""
      },
      {
        "name": "BenchmarkSlicesSortStrings",
        "desc": ""
      },
      {
        "name": "BenchmarkSlicesSortStrings_Sorted",
        "desc": ""
      },
      {
        "name": "BenchmarkSort1e2",
        "desc": ""
      },
      {
        "name": "BenchmarkSort1e4",
        "desc": ""
      },
      {
        "name": "BenchmarkSort1e6",
        "desc": ""
      },
      {
        "name": "BenchmarkSortFuncStructs",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInt1K",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInt1K_Mod8",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInt1K_Reversed",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInt1K_Sorted",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInt64K",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInt64K_Slice",
        "desc": ""
      },
      {
        "name": "BenchmarkSortInts",
        "desc": ""
      },
      {
        "name": "BenchmarkSortIsSorted",
        "desc": ""
      },
      {
        "name": "BenchmarkSortString1K",
        "desc": ""
      },
      {
        "name": "BenchmarkSortString1K_Slice",
        "desc": ""
      },
      {
        "name": "BenchmarkSortStrings",
        "desc": ""
      },
      {
        "name": "BenchmarkSortStrings_Sorted",
        "desc": ""
      },
      {
        "name": "BenchmarkSortStructs",
        "desc": ""
      },
      {
        "name": "BenchmarkStable1e2",
        "desc": ""
      },
      {
        "name": "BenchmarkStable1e4",
        "desc": ""
      },
      {
        "name": "BenchmarkStable1e6",
        "desc": ""
      },
      {
        "name": "BenchmarkStableInt1K",
        "desc": ""
      },
      {
        "name": "BenchmarkStableInt1K_Slice",
        "desc": ""
      },
      {
        "name": "BenchmarkStableInt64K",
        "desc": ""
      },
      {
        "name": "BenchmarkStableString1K",
        "desc": ""
      },
      {
        "name": "Example",
        "desc": ""
      },
      {
        "name": "ExampleFind",
        "desc": "This example demonstrates finding a string in a list sorted in ascending order."
      },
      {
        "name": "ExampleFloat64s",
        "desc": ""
      },
      {
        "name": "ExampleFloat64sAreSorted",
        "desc": ""
      },
      {
        "name": "ExampleInts",
        "desc": ""
      },
      {
        "name": "ExampleIntsAreSorted",
        "desc": ""
      },
      {
        "name": "ExampleReverse",
        "desc": ""
      },
      {
        "name": "ExampleSearch",
        "desc": "This example demonstrates searching a list sorted in ascending order."
      },
      {
        "name": "ExampleSearchFloat64s",
        "desc": "This example demonstrates searching for float64 in a list sorted in ascending order."
      },
      {
        "name": "ExampleSearchInts",
        "desc": "This example demonstrates searching for int in a list sorted in ascending order."
      },
      {
        "name": "ExampleSearchStrings",
        "desc": "This example demonstrates searching for string in a list sorted in ascending order."
      },
      {
        "name": "ExampleSearch_descendingOrder",
        "desc": "This example demonstrates searching a list sorted in descending order. The approach is the same as searching a list in ascending order, but with the condition inverted."
      },
      {
        "name": "ExampleSlice",
        "desc": ""
      },
      {
        "name": "ExampleSliceIsSorted",
        "desc": ""
      },
      {
        "name": "ExampleSliceStable",
        "desc": ""
      },
      {
        "name": "ExampleStrings",
        "desc": ""
      },
      {
        "name": "Example_sortKeys",
        "desc": "Example_sortKeys demonstrates a technique for sorting a struct type using programmable sort criteria."
      },
      {
        "name": "Example_sortMultiKeys",
        "desc": "Example_sortMultiKeys demonstrates a technique for sorting a struct type using different sets of multiple fields in the comparison. We chain together \"Less\" functions, each of which compares a single field."
      },
      {
        "name": "Example_sortWrapper",
        "desc": ""
      },
      {
        "name": "TestAdversary",
        "desc": ""
      },
      {
        "name": "TestBreakPatterns",
        "desc": ""
      },
      {
        "name": "TestCountSortOps",
        "desc": ""
      },
      {
        "name": "TestCountStableOps",
        "desc": ""
      },
      {
        "name": "TestFind",
        "desc": ""
      },
      {
        "name": "TestFindExhaustive",
        "desc": "Abstract exhaustive test for Find."
      },
      {
        "name": "TestFloat64s",
        "desc": ""
      },
      {
        "name": "TestHeapsortBM",
        "desc": ""
      },
      {
        "name": "TestInts",
        "desc": ""
      },
      {
        "name": "TestNonDeterministicComparison",
        "desc": ""
      },
      {
        "name": "TestReverseRange",
        "desc": ""
      },
      {
        "name": "TestReverseSortIntSlice",
        "desc": ""
      },
      {
        "name": "TestSearch",
        "desc": ""
      },
      {
        "name": "TestSearchEfficiency",
        "desc": ""
      },
      {
        "name": "TestSearchExhaustive",
        "desc": "Abstract exhaustive test: all sizes up to 100, all possible return values. If there are any small corner cases, this test exercises them."
      },
      {
        "name": "TestSearchWrappers",
        "desc": ""
      },
      {
        "name": "TestSearchWrappersDontAlloc",
        "desc": ""
      },
      {
        "name": "TestSlice",
        "desc": ""
      },
      {
        "name": "TestSortBM",
        "desc": ""
      },
      {
        "name": "TestSortFloat64Slice",
        "desc": ""
      },
      {
        "name": "TestSortFloat64sCompareSlicesSort",
        "desc": "Compare Sort with slices.Sort sorting a float64 slice containing NaNs."
      },
      {
        "name": "TestSortIntSlice",
        "desc": ""
      },
      {
        "name": "TestSortLarge_Random",
        "desc": ""
      },
      {
        "name": "TestSortStringSlice",
        "desc": ""
      },
      {
        "name": "TestStability",
        "desc": ""
      },
      {
        "name": "TestStableBM",
        "desc": ""
      },
      {
        "name": "TestStableInts",
        "desc": ""
      },
      {
        "name": "TestStrings",
        "desc": ""
      },
      {
        "name": "TestStructSorts",
        "desc": ""
      },
      {
        "name": "bench",
        "desc": ""
      },
      {
        "name": "countOps",
        "desc": ""
      },
      {
        "name": "f",
        "desc": ""
      },
      {
        "name": "lg",
        "desc": ""
      },
      {
        "name": "log2",
        "desc": "log2 computes the binary logarithm of x, rounded up to the next integer. (log2(0) == 0, log2(1) == 0, log2(2) == 1, log2(3) == 2, etc.)"
      },
      {
        "name": "makeRandomInts",
        "desc": ""
      },
      {
        "name": "makeRandomStrings",
        "desc": "makeRandomStrings generates n random strings with alphabetic runes of varying lengths."
      },
      {
        "name": "makeReversedInts",
        "desc": ""
      },
      {
        "name": "makeSortedInts",
        "desc": ""
      },
      {
        "name": "makeSortedStrings",
        "desc": ""
      },
      {
        "name": "printOrgans",
        "desc": ""
      },
      {
        "name": "runSearchWrappers",
        "desc": ""
      },
      {
        "name": "testBentleyMcIlroy",
        "desc": ""
      },
      {
        "name": "Sort",
        "desc": "Sort is a method on the function type, By, that sorts the argument slice according to the function."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": "IntPairs compare on a only."
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "inOrder",
        "desc": "InOrder checks if a-equal elements were not reordered."
      },
      {
        "name": "initB",
        "desc": "Record initial order in B."
      },
      {
        "name": "Len",
        "desc": "Len is part of sort.Interface."
      },
      {
        "name": "Less",
        "desc": "Less is part of sort.Interface. It is implemented by looping along the less functions until it finds a comparison that discriminates between the two items (one is less than the other). Note that it can call the less functions twice per call. We could change the functions to return -1, 0, 1 and reduce the number of calls for greater efficiency: an exercise for the reader."
      },
      {
        "name": "Sort",
        "desc": "Sort sorts the argument slice according to the less functions passed to OrderedBy."
      },
      {
        "name": "Swap",
        "desc": "Swap is part of sort.Interface."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": "Len is part of sort.Interface."
      },
      {
        "name": "Less",
        "desc": "Less is part of sort.Interface. It is implemented by calling the \"by\" closure in the sorter."
      },
      {
        "name": "Swap",
        "desc": "Swap is part of sort.Interface."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "By",
        "desc": "By is the type of a \"less\" function that defines the ordering of its Planet arguments."
      },
      {
        "name": "ByAge",
        "desc": "ByAge implements sort.Interface for []Person based on the Age field."
      },
      {
        "name": "ByName",
        "desc": "ByName implements sort.Interface by providing Less and using the Len and Swap methods of the embedded Organs value."
      },
      {
        "name": "ByWeight",
        "desc": "ByWeight implements sort.Interface by providing Less and using the Len and Swap methods of the embedded Organs value."
      },
      {
        "name": "Change",
        "desc": "A Change is a record of source code changes, recording user, language, and delta size."
      },
      {
        "name": "Grams",
        "desc": ""
      },
      {
        "name": "Organ",
        "desc": ""
      },
      {
        "name": "Organs",
        "desc": ""
      },
      {
        "name": "Person",
        "desc": ""
      },
      {
        "name": "Planet",
        "desc": "A Planet defines the properties of a solar system object."
      },
      {
        "name": "adversaryTestingData",
        "desc": "This is based on the \"antiquicksort\" implementation by M. Douglas McIlroy. See https://www.cs.dartmouth.edu/~doug/mdmspe.pdf for more info."
      },
      {
        "name": "au",
        "desc": ""
      },
      {
        "name": "earthMass",
        "desc": "A couple of type definitions to make the units clear."
      },
      {
        "name": "intPairs",
        "desc": ""
      },
      {
        "name": "lessFunc",
        "desc": ""
      },
      {
        "name": "multiSorter",
        "desc": "multiSorter implements the Sort interface, sorting the changes within."
      },
      {
        "name": "myStruct",
        "desc": "These benchmarks compare sorting a slice of structs with sort.Sort vs. slices.SortFunc."
      },
      {
        "name": "myStructs",
        "desc": ""
      },
      {
        "name": "nonDeterministicTestingData",
        "desc": ""
      },
      {
        "name": "planetSorter",
        "desc": "planetSorter joins a By function and a slice of Planets to be sorted."
      },
      {
        "name": "testingData",
        "desc": ""
      }
    ]
  },
  {
    "name": "strconv",
    "desc": "Package strconv implements conversions to and from string representations of basic data types.  # Numeric Conversions  The most common numeric conversions are [Atoi] (string to int) and [Itoa] (int to string).  \ti, err := strconv.Atoi(\"-42\") \ts := strconv.Itoa(-42)  These assume decimal and the Go int type.  [ParseBool], [ParseFloat], [ParseInt], and [ParseUint] convert strings to values:  \tb, err := strconv.ParseBool(\"true\") \tf, err := strconv.ParseFloat(\"3.1415\", 64) \ti, err := strconv.ParseInt(\"-42\", 10, 64) \tu, err := strconv.ParseUint(\"42\", 10, 64)  The parse functions return the widest type (float64, int64, and uint64), but if the size argument specifies a narrower width the result can be converted to that narrower type without data loss:  \ts := \"2147483647\" // biggest int32 \ti64, err := strconv.ParseInt(s, 10, 32) \t... \ti := int32(i64)  [FormatBool], [FormatFloat], [FormatInt], and [FormatUint] convert values to strings:  \ts := strconv.FormatBool(true) \ts := strconv.FormatFloat(3.1415, 'E', -1, 64) \ts := strconv.FormatInt(-42, 16) \ts := strconv.FormatUint(42, 16)  [AppendBool], [AppendFloat], [AppendInt], and [AppendUint] are similar but append the formatted value to a destination slice.  # String Conversions  [Quote] and [QuoteToASCII] convert strings to quoted Go string literals. The latter guarantees that the result is an ASCII string, by escaping any non-ASCII Unicode with \\u:  \tq := strconv.Quote(\"Hello, 世界\") \tq := strconv.QuoteToASCII(\"Hello, 世界\")  [QuoteRune] and [QuoteRuneToASCII] are similar but accept runes and return quoted Go rune literals.  [Unquote] and [UnquoteChar] unquote Go string and rune literals.",
    "functions": [
      {
        "name": "AppendBool",
        "desc": "AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer."
      },
      {
        "name": "AppendFloat",
        "desc": "AppendFloat appends the string form of the floating-point number f, as generated by [FormatFloat], to dst and returns the extended buffer."
      },
      {
        "name": "AppendInt",
        "desc": "AppendInt appends the string form of the integer i, as generated by [FormatInt], to dst and returns the extended buffer."
      },
      {
        "name": "AppendQuote",
        "desc": "AppendQuote appends a double-quoted Go string literal representing s, as generated by [Quote], to dst and returns the extended buffer."
      },
      {
        "name": "AppendQuoteRune",
        "desc": "AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by [QuoteRune], to dst and returns the extended buffer."
      },
      {
        "name": "AppendQuoteRuneToASCII",
        "desc": "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by [QuoteRuneToASCII], to dst and returns the extended buffer."
      },
      {
        "name": "AppendQuoteRuneToGraphic",
        "desc": "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by [QuoteRuneToGraphic], to dst and returns the extended buffer."
      },
      {
        "name": "AppendQuoteToASCII",
        "desc": "AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by [QuoteToASCII], to dst and returns the extended buffer."
      },
      {
        "name": "AppendQuoteToGraphic",
        "desc": "AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by [QuoteToGraphic], to dst and returns the extended buffer."
      },
      {
        "name": "AppendUint",
        "desc": "AppendUint appends the string form of the unsigned integer i, as generated by [FormatUint], to dst and returns the extended buffer."
      },
      {
        "name": "Atoi",
        "desc": "Atoi is equivalent to ParseInt(s, 10, 0), converted to type int."
      },
      {
        "name": "CanBackquote",
        "desc": "CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab."
      },
      {
        "name": "FormatBool",
        "desc": "FormatBool returns \"true\" or \"false\" according to the value of b."
      },
      {
        "name": "FormatComplex",
        "desc": "FormatComplex converts the complex number c to a string of the form (a+bi) where a and b are the real and imaginary parts, formatted according to the format fmt and precision prec.  The format fmt and precision prec have the same meaning as in [FormatFloat]. It rounds the result assuming that the original was obtained from a complex value of bitSize bits, which must be 64 for complex64 and 128 for complex128."
      },
      {
        "name": "FormatFloat",
        "desc": "FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).  The format fmt is one of   - 'b' (-ddddp±ddd, a binary exponent),   - 'e' (-d.dddde±dd, a decimal exponent),   - 'E' (-d.ddddE±dd, a decimal exponent),   - 'f' (-ddd.dddd, no exponent),   - 'g' ('e' for large exponents, 'f' otherwise),   - 'G' ('E' for large exponents, 'f' otherwise),   - 'x' (-0xd.ddddp±ddd, a hexadecimal fraction and binary exponent), or   - 'X' (-0Xd.ddddP±ddd, a hexadecimal fraction and binary exponent).  The precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E', 'f', 'x', and 'X', it is the number of digits after the decimal point. For 'g' and 'G' it is the maximum number of significant digits (trailing zeros are removed). The special precision -1 uses the smallest number of digits necessary such that ParseFloat will return f exactly. The exponent is written as a decimal integer; for all formats other than 'b', it will be at least two digits."
      },
      {
        "name": "FormatInt",
        "desc": "FormatInt returns the string representation of i in the given base, for 2 \u003c= base \u003c= 36. The result uses the lower-case letters 'a' to 'z' for digit values \u003e= 10."
      },
      {
        "name": "FormatUint",
        "desc": "FormatUint returns the string representation of i in the given base, for 2 \u003c= base \u003c= 36. The result uses the lower-case letters 'a' to 'z' for digit values \u003e= 10."
      },
      {
        "name": "IsGraphic",
        "desc": "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs."
      },
      {
        "name": "IsPrint",
        "desc": "IsPrint reports whether the rune is defined as printable by Go, with the same definition as [unicode.IsPrint]: letters, numbers, punctuation, symbols and ASCII space."
      },
      {
        "name": "Itoa",
        "desc": "Itoa is equivalent to [FormatInt](int64(i), 10)."
      },
      {
        "name": "MulByLog10Log2",
        "desc": ""
      },
      {
        "name": "MulByLog2Log10",
        "desc": ""
      },
      {
        "name": "ParseBool",
        "desc": "ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error."
      },
      {
        "name": "ParseComplex",
        "desc": "ParseComplex converts the string s to a complex number with the precision specified by bitSize: 64 for complex64, or 128 for complex128. When bitSize=64, the result still has type complex128, but it will be convertible to complex64 without changing its value.  The number represented by s must be of the form N, Ni, or N±Ni, where N stands for a floating-point number as recognized by [ParseFloat], and i is the imaginary component. If the second N is unsigned, a + sign is required between the two components as indicated by the ±. If the second N is NaN, only a + sign is accepted. The form may be parenthesized and cannot contain any spaces. The resulting complex number consists of the two components converted by ParseFloat.  The errors that ParseComplex returns have concrete type [*NumError] and include err.Num = s.  If s is not syntactically well-formed, ParseComplex returns err.Err = ErrSyntax.  If s is syntactically well-formed but either component is more than 1/2 ULP away from the largest floating point number of the given component's size, ParseComplex returns err.Err = ErrRange and c = ±Inf for the respective component."
      },
      {
        "name": "ParseFloat",
        "desc": "ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.  ParseFloat accepts decimal and hexadecimal floating-point numbers as defined by the Go syntax for [floating-point literals]. If s is well-formed and near a valid floating-point number, ParseFloat returns the nearest floating-point number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal floating-point value only rounds when there are more bits in the hexadecimal representation than will fit in the mantissa.)  The errors that ParseFloat returns have concrete type *NumError and include err.Num = s.  If s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.  If s is syntactically well-formed but is more than 1/2 ULP away from the largest floating point number of the given size, ParseFloat returns f = ±Inf, err.Err = ErrRange.  ParseFloat recognizes the string \"NaN\", and the (possibly signed) strings \"Inf\" and \"Infinity\" as their respective special floating point values. It ignores case when matching.  [floating-point literals]: https://go.dev/ref/spec#Floating-point_literals"
      },
      {
        "name": "ParseFloatPrefix",
        "desc": ""
      },
      {
        "name": "ParseInt",
        "desc": "ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.  The string may begin with a leading sign: \"+\" or \"-\".  If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the Go syntax for [integer literals].  The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is returned.  The errors that ParseInt returns have concrete type [*NumError] and include err.Num = s. If s is empty or contains invalid digits, err.Err = [ErrSyntax] and the returned value is 0; if the value corresponding to s cannot be represented by a signed integer of the given size, err.Err = [ErrRange] and the returned value is the maximum magnitude integer of the appropriate bitSize and sign.  [integer literals]: https://go.dev/ref/spec#Integer_literals"
      },
      {
        "name": "ParseUint",
        "desc": "ParseUint is like [ParseInt] but for unsigned numbers.  A sign prefix is not permitted."
      },
      {
        "name": "Quote",
        "desc": "Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by [IsPrint]."
      },
      {
        "name": "QuoteRune",
        "desc": "QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by [IsPrint]. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD."
      },
      {
        "name": "QuoteRuneToASCII",
        "desc": "QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by [IsPrint]. If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD."
      },
      {
        "name": "QuoteRuneToGraphic",
        "desc": "QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. If the rune is not a Unicode graphic character, as defined by [IsGraphic], the returned string will use a Go escape sequence (\\t, \\n, \\xFF, \\u0100). If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD."
      },
      {
        "name": "QuoteToASCII",
        "desc": "QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by [IsPrint]."
      },
      {
        "name": "QuoteToGraphic",
        "desc": "QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string leaves Unicode graphic characters, as defined by [IsGraphic], unchanged and uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-graphic characters."
      },
      {
        "name": "QuotedPrefix",
        "desc": "QuotedPrefix returns the quoted string (as understood by [Unquote]) at the prefix of s. If s does not start with a valid quoted string, QuotedPrefix returns an error."
      },
      {
        "name": "SetOptimize",
        "desc": ""
      },
      {
        "name": "Unquote",
        "desc": "Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes.  (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string. For an empty character literal Unquote returns the empty string.)"
      },
      {
        "name": "UnquoteChar",
        "desc": "UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:   1. value, the decoded Unicode code point or byte value;  2. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;  3. tail, the remainder of the string after the character; and  4. an error that will be nil if the character is syntactically valid.  The second argument, quote, specifies the type of literal being parsed and therefore which escaped quote character is permitted. If set to a single quote, it permits the sequence \\' and disallows unescaped '. If set to a double quote, it permits \\\" and disallows unescaped \". If set to zero, it does not permit either escape and allows both quote characters to appear unescaped."
      },
      {
        "name": "appendEscapedRune",
        "desc": ""
      },
      {
        "name": "appendQuotedRuneWith",
        "desc": ""
      },
      {
        "name": "appendQuotedWith",
        "desc": ""
      },
      {
        "name": "atof32",
        "desc": ""
      },
      {
        "name": "atof32exact",
        "desc": "If possible to compute mantissa*10^exp to 32-bit float f exactly, entirely in floating-point math, do so, avoiding the machinery above."
      },
      {
        "name": "atof64",
        "desc": ""
      },
      {
        "name": "atof64exact",
        "desc": "If possible to convert decimal representation to 64-bit float f exactly, entirely in floating-point math, do so, avoiding the expense of decimalToFloatBits. Three common cases:  \tvalue is exact integer \tvalue is exact integer * exact power of ten \tvalue is exact integer / exact power of ten  These all produce potentially inexact but correctly rounded answers."
      },
      {
        "name": "atofHex",
        "desc": "atofHex converts the hex floating-point string s to a rounded float32 or float64 value (depending on flt==\u0026float32info or flt==\u0026float64info) and returns it as a float64. The string s has already been parsed into a mantissa, exponent, and sign (neg==true for negative). If trunc is true, trailing non-zero bits have been omitted from the mantissa."
      },
      {
        "name": "bigFtoa",
        "desc": "bigFtoa uses multiprecision computations to format a float."
      },
      {
        "name": "bsearch",
        "desc": "bsearch is semantically the same as [slices.BinarySearch] (without NaN checks) We copied this function because we can not import \"slices\" here."
      },
      {
        "name": "commonPrefixLenIgnoreCase",
        "desc": "commonPrefixLenIgnoreCase returns the length of the common prefix of s and prefix, with the character case of s ignored. The prefix argument must be all lower-case."
      },
      {
        "name": "computeBounds",
        "desc": "computeBounds returns a floating-point vector (l, c, u)×2^e2 where the mantissas are 55-bit (or 26-bit) integers, describing the interval represented by the input float64 or float32."
      },
      {
        "name": "contains",
        "desc": "contains reports whether the string contains the byte c."
      },
      {
        "name": "convErr",
        "desc": "convErr splits an error returned by parseFloatPrefix into a syntax or range error for ParseComplex."
      },
      {
        "name": "digitZero",
        "desc": ""
      },
      {
        "name": "divisibleByPower5",
        "desc": ""
      },
      {
        "name": "divmod1e9",
        "desc": "divmod1e9 computes quotient and remainder of division by 1e9, avoiding runtime uint64 division on 32-bit platforms."
      },
      {
        "name": "eiselLemire32",
        "desc": ""
      },
      {
        "name": "eiselLemire64",
        "desc": ""
      },
      {
        "name": "fmtB",
        "desc": "%b: -ddddddddp±ddd"
      },
      {
        "name": "fmtE",
        "desc": "%e: -d.ddddde±dd"
      },
      {
        "name": "fmtF",
        "desc": "%f: -ddddddd.ddddd"
      },
      {
        "name": "fmtX",
        "desc": "%x: -0x1.yyyyyyyyp±ddd or -0x0p+0. (y is hex digit, d is decimal digit)"
      },
      {
        "name": "formatBits",
        "desc": "formatBits computes the string representation of u in the given base. If neg is set, u is treated as negative int64 value. If append_ is set, the string is appended to dst and the resulting byte slice is returned as the first result value; otherwise the string is returned as the second result value."
      },
      {
        "name": "formatDecimal",
        "desc": "formatDecimal fills d with at most prec decimal digits of mantissa m. The boolean trunc indicates whether m is truncated compared to the original number being formatted."
      },
      {
        "name": "formatDigits",
        "desc": ""
      },
      {
        "name": "genericFtoa",
        "desc": ""
      },
      {
        "name": "index",
        "desc": "index returns the index of the first instance of c in s, or -1 if missing."
      },
      {
        "name": "isInGraphicList",
        "desc": "isInGraphicList reports whether the rune is in the isGraphic list. This separation from IsGraphic allows quoteWith to avoid two calls to IsPrint. Should be called only if IsPrint fails."
      },
      {
        "name": "isPowerOfTwo",
        "desc": ""
      },
      {
        "name": "leftShift",
        "desc": "Binary shift left (* 2) by k bits.  k \u003c= maxShift to avoid overflow."
      },
      {
        "name": "lower",
        "desc": "lower(c) is a lower-case letter if and only if c is either that lower-case letter or the equivalent upper-case letter. Instead of writing c == 'x' || c == 'X' one can write lower(c) == 'x'. Note that lower of non-letters can produce other non-letters."
      },
      {
        "name": "mulByLog10Log2",
        "desc": "mulByLog10Log2 returns math.Floor(x * log(10)/log(2)) for an integer x in the range -500 \u003c= x \u0026\u0026 x \u003c= +500.  The range restriction lets us work in faster integer arithmetic instead of slower floating point arithmetic. Correctness is verified by unit tests."
      },
      {
        "name": "mulByLog2Log10",
        "desc": "mulByLog2Log10 returns math.Floor(x * log(2)/log(10)) for an integer x in the range -1600 \u003c= x \u0026\u0026 x \u003c= +1600.  The range restriction lets us work in faster integer arithmetic instead of slower floating point arithmetic. Correctness is verified by unit tests."
      },
      {
        "name": "mult128bitPow10",
        "desc": "mult128bitPow10 takes a floating-point input with a 55-bit mantissa and multiplies it with 10^q. The resulting mantissa is m*P \u003e\u003e 119 where P is a 128-bit element of the detailedPowersOfTen tables. It is typically 63 or 64-bit wide. The returned boolean is true is all trimmed bits were zero.  That is:  \tm*2^e2 * round(10^q) = resM * 2^resE + ε \texact = ε == 0"
      },
      {
        "name": "mult64bitPow10",
        "desc": "mult64bitPow10 takes a floating-point input with a 25-bit mantissa and multiplies it with 10^q. The resulting mantissa is m*P \u003e\u003e 57 where P is a 64-bit element of the detailedPowersOfTen tables. It is typically 31 or 32-bit wide. The returned boolean is true if all trimmed bits were zero.  That is:  \tm*2^e2 * round(10^q) = resM * 2^resE + ε \texact = ε == 0"
      },
      {
        "name": "parseFloatPrefix",
        "desc": ""
      },
      {
        "name": "prefixIsLessThan",
        "desc": "Is the leading prefix of b lexicographically less than s?"
      },
      {
        "name": "quoteRuneWith",
        "desc": ""
      },
      {
        "name": "quoteWith",
        "desc": ""
      },
      {
        "name": "readFloat",
        "desc": "readFloat reads a decimal or hexadecimal mantissa and exponent from a float string representation in s; the number may be followed by other characters. readFloat reports the number of bytes consumed (i), and whether the number is valid (ok)."
      },
      {
        "name": "rightShift",
        "desc": "Binary shift right (/ 2) by k bits.  k \u003c= maxShift to avoid overflow."
      },
      {
        "name": "roundShortest",
        "desc": "roundShortest rounds d (= mant * 2^exp) to the shortest number of digits that will let the original floating point value be precisely reconstructed."
      },
      {
        "name": "ryuDigits",
        "desc": ""
      },
      {
        "name": "ryuDigits32",
        "desc": "ryuDigits32 emits decimal digits for a number less than 1e9."
      },
      {
        "name": "ryuFtoaFixed32",
        "desc": "ryuFtoaFixed32 formats mant*(2^exp) with prec decimal digits."
      },
      {
        "name": "ryuFtoaFixed64",
        "desc": "ryuFtoaFixed64 formats mant*(2^exp) with prec decimal digits."
      },
      {
        "name": "ryuFtoaShortest",
        "desc": "ryuFtoaShortest formats mant*2^exp with prec decimal digits."
      },
      {
        "name": "shouldRoundUp",
        "desc": "If we chop a at nd digits, should we round up?"
      },
      {
        "name": "small",
        "desc": "small returns the string for an i with 0 \u003c= i \u003c nSmalls."
      },
      {
        "name": "special",
        "desc": "special returns the floating-point value for the special, possibly signed floating-point representations inf, infinity, and NaN. The result is ok if a prefix of s contains one of these representations and n is the length of that prefix. The character case is ignored."
      },
      {
        "name": "trim",
        "desc": "trim trailing zeros from number. (They are meaningless; the decimal point is tracked independent of the number of digits.)"
      },
      {
        "name": "underscoreOK",
        "desc": "underscoreOK reports whether the underscores in s are allowed. Checking them in this one function lets all the parsers skip over them simply. Underscore must appear only between digits or between a base prefix and a digit."
      },
      {
        "name": "unhex",
        "desc": ""
      },
      {
        "name": "unquote",
        "desc": "unquote parses a quoted string at the start of the input, returning the parsed prefix, the remaining suffix, and any parse errors. If unescape is true, the parsed prefix is unescaped, otherwise the input prefix is provided verbatim."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Assign",
        "desc": "Assign v to a."
      },
      {
        "name": "Round",
        "desc": "Round a to nd digits (or fewer). If nd is zero, it means we're rounding just to the left of the digits, as in 0.09 -\u003e 0.1."
      },
      {
        "name": "RoundDown",
        "desc": "Round a down to nd digits (or fewer)."
      },
      {
        "name": "RoundUp",
        "desc": "Round a up to nd digits (or fewer)."
      },
      {
        "name": "RoundedInteger",
        "desc": "Extract integer part, rounded appropriately. No guarantees about overflow."
      },
      {
        "name": "Shift",
        "desc": "Binary shift left (k \u003e 0) or right (k \u003c 0)."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "floatBits",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "NumError",
        "desc": "A NumError records a failed conversion."
      },
      {
        "name": "decimal",
        "desc": ""
      },
      {
        "name": "decimalSlice",
        "desc": ""
      },
      {
        "name": "floatInfo",
        "desc": "TODO: move elsewhere?"
      },
      {
        "name": "leftCheat",
        "desc": ""
      }
    ]
  },
  {
    "name": "strings",
    "desc": "Package strings implements simple functions to manipulate UTF-8 encoded strings.  For information about UTF-8 strings in Go, see https://blog.golang.org/strings.",
    "functions": [
      {
        "name": "Clone",
        "desc": "Clone returns a fresh copy of s. It guarantees to make a copy of s into a new allocation, which can be important when retaining only a small substring of a much larger string. Using Clone can help such programs use less memory. Of course, since using Clone makes a copy, overuse of Clone can make programs use more memory. Clone should typically be used only rarely, and only when profiling indicates that it is needed. For strings of length zero the string \"\" will be returned and no allocation is made."
      },
      {
        "name": "Compare",
        "desc": "Compare returns an integer comparing two strings lexicographically. The result will be 0 if a == b, -1 if a \u003c b, and +1 if a \u003e b.  Use Compare when you need to perform a three-way comparison (with [slices.SortFunc], for example). It is usually clearer and always faster to use the built-in string comparison operators ==, \u003c, \u003e, and so on."
      },
      {
        "name": "Contains",
        "desc": "Contains reports whether substr is within s."
      },
      {
        "name": "ContainsAny",
        "desc": "ContainsAny reports whether any Unicode code points in chars are within s."
      },
      {
        "name": "ContainsFunc",
        "desc": "ContainsFunc reports whether any Unicode code points r within s satisfy f(r)."
      },
      {
        "name": "ContainsRune",
        "desc": "ContainsRune reports whether the Unicode code point r is within s."
      },
      {
        "name": "Count",
        "desc": "Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s."
      },
      {
        "name": "Cut",
        "desc": "Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, \"\", false."
      },
      {
        "name": "CutPrefix",
        "desc": "CutPrefix returns s without the provided leading prefix string and reports whether it found the prefix. If s doesn't start with prefix, CutPrefix returns s, false. If prefix is the empty string, CutPrefix returns s, true."
      },
      {
        "name": "CutSuffix",
        "desc": "CutSuffix returns s without the provided ending suffix string and reports whether it found the suffix. If s doesn't end with suffix, CutSuffix returns s, false. If suffix is the empty string, CutSuffix returns s, true."
      },
      {
        "name": "DumpTables",
        "desc": ""
      },
      {
        "name": "EqualFold",
        "desc": "EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity."
      },
      {
        "name": "Fields",
        "desc": "Fields splits the string s around each instance of one or more consecutive white space characters, as defined by [unicode.IsSpace], returning a slice of substrings of s or an empty slice if s contains only white space. Every element of the returned slice is non-empty. Unlike [Split], leading and trailing runs runs of white space characters are discarded."
      },
      {
        "name": "FieldsFunc",
        "desc": "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. Every element of the returned slice is non-empty. Unlike [SplitFunc], leading and trailing runs of code points satisfying f(c) are discarded.  FieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c."
      },
      {
        "name": "FieldsFuncSeq",
        "desc": "FieldsFuncSeq returns an iterator over substrings of s split around runs of Unicode code points satisfying f(c). The iterator yields the same strings that would be returned by [FieldsFunc](s), but without constructing the slice."
      },
      {
        "name": "FieldsSeq",
        "desc": "FieldsSeq returns an iterator over substrings of s split around runs of whitespace characters, as defined by [unicode.IsSpace]. The iterator yields the same strings that would be returned by [Fields](s), but without constructing the slice."
      },
      {
        "name": "HasPrefix",
        "desc": "HasPrefix reports whether the string s begins with prefix."
      },
      {
        "name": "HasSuffix",
        "desc": "HasSuffix reports whether the string s ends with suffix."
      },
      {
        "name": "Index",
        "desc": "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s."
      },
      {
        "name": "IndexAny",
        "desc": "IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s."
      },
      {
        "name": "IndexByte",
        "desc": "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s."
      },
      {
        "name": "IndexFunc",
        "desc": "IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do."
      },
      {
        "name": "IndexRune",
        "desc": "IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is [utf8.RuneError], it returns the first instance of any invalid UTF-8 byte sequence."
      },
      {
        "name": "Join",
        "desc": "Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string."
      },
      {
        "name": "LastIndex",
        "desc": "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s."
      },
      {
        "name": "LastIndexAny",
        "desc": "LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s."
      },
      {
        "name": "LastIndexByte",
        "desc": "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s."
      },
      {
        "name": "LastIndexFunc",
        "desc": "LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do."
      },
      {
        "name": "Lines",
        "desc": "Lines returns an iterator over the newline-terminated lines in the string s. The lines yielded by the iterator include their terminating newlines. If s is empty, the iterator yields no lines at all. If s does not end in a newline, the final yielded line will not end in a newline. It returns a single-use iterator."
      },
      {
        "name": "Map",
        "desc": "Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement."
      },
      {
        "name": "Repeat",
        "desc": "Repeat returns a new string consisting of count copies of the string s.  It panics if count is negative or if the result of (len(s) * count) overflows."
      },
      {
        "name": "Replace",
        "desc": "Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n \u003c 0, there is no limit on the number of replacements."
      },
      {
        "name": "ReplaceAll",
        "desc": "ReplaceAll returns a copy of the string s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string."
      },
      {
        "name": "Split",
        "desc": "Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.  If s does not contain sep and sep is not empty, Split returns a slice of length 1 whose only element is s.  If sep is empty, Split splits after each UTF-8 sequence. If both s and sep are empty, Split returns an empty slice.  It is equivalent to [SplitN] with a count of -1.  To split around the first instance of a separator, see [Cut]."
      },
      {
        "name": "SplitAfter",
        "desc": "SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.  If s does not contain sep and sep is not empty, SplitAfter returns a slice of length 1 whose only element is s.  If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and sep are empty, SplitAfter returns an empty slice.  It is equivalent to [SplitAfterN] with a count of -1."
      },
      {
        "name": "SplitAfterN",
        "desc": "SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.  The count determines the number of substrings to return:   - n \u003e 0: at most n substrings; the last substring will be the unsplit remainder;   - n == 0: the result is nil (zero substrings);   - n \u003c 0: all substrings.  Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for [SplitAfter]."
      },
      {
        "name": "SplitAfterSeq",
        "desc": "SplitAfterSeq returns an iterator over substrings of s split after each instance of sep. The iterator yields the same strings that would be returned by [SplitAfter](s, sep), but without constructing the slice. It returns a single-use iterator."
      },
      {
        "name": "SplitN",
        "desc": "SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.  The count determines the number of substrings to return:   - n \u003e 0: at most n substrings; the last substring will be the unsplit remainder;   - n == 0: the result is nil (zero substrings);   - n \u003c 0: all substrings.  Edge cases for s and sep (for example, empty strings) are handled as described in the documentation for [Split].  To split around the first instance of a separator, see [Cut]."
      },
      {
        "name": "SplitSeq",
        "desc": "SplitSeq returns an iterator over all substrings of s separated by sep. The iterator yields the same strings that would be returned by [Split](s, sep), but without constructing the slice. It returns a single-use iterator."
      },
      {
        "name": "StringFind",
        "desc": ""
      },
      {
        "name": "Title",
        "desc": "Title returns a copy of the string s with all Unicode letters that begin words mapped to their Unicode title case.  Deprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead."
      },
      {
        "name": "ToLower",
        "desc": "ToLower returns s with all Unicode letters mapped to their lower case."
      },
      {
        "name": "ToLowerSpecial",
        "desc": "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case using the case mapping specified by c."
      },
      {
        "name": "ToTitle",
        "desc": "ToTitle returns a copy of the string s with all Unicode letters mapped to their Unicode title case."
      },
      {
        "name": "ToTitleSpecial",
        "desc": "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their Unicode title case, giving priority to the special casing rules."
      },
      {
        "name": "ToUpper",
        "desc": "ToUpper returns s with all Unicode letters mapped to their upper case."
      },
      {
        "name": "ToUpperSpecial",
        "desc": "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case using the case mapping specified by c."
      },
      {
        "name": "ToValidUTF8",
        "desc": "ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences replaced by the replacement string, which may be empty."
      },
      {
        "name": "Trim",
        "desc": "Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed."
      },
      {
        "name": "TrimFunc",
        "desc": "TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed."
      },
      {
        "name": "TrimLeft",
        "desc": "TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.  To remove a prefix, use [TrimPrefix] instead."
      },
      {
        "name": "TrimLeftFunc",
        "desc": "TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed."
      },
      {
        "name": "TrimPrefix",
        "desc": "TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged."
      },
      {
        "name": "TrimRight",
        "desc": "TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.  To remove a suffix, use [TrimSuffix] instead."
      },
      {
        "name": "TrimRightFunc",
        "desc": "TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed."
      },
      {
        "name": "TrimSpace",
        "desc": "TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode."
      },
      {
        "name": "TrimSuffix",
        "desc": "TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged."
      },
      {
        "name": "explode",
        "desc": "explode splits s into a slice of UTF-8 strings, one string per Unicode character up to a maximum of n (n \u003c 0 means no limit). Invalid UTF-8 bytes are sliced individually."
      },
      {
        "name": "genSplit",
        "desc": "Generic split: splits after each instance of sep, including sepSave bytes of sep in the subarrays."
      },
      {
        "name": "getStringWriter",
        "desc": ""
      },
      {
        "name": "indexFunc",
        "desc": "indexFunc is the same as IndexFunc except that if truth==false, the sense of the predicate function is inverted."
      },
      {
        "name": "isSeparator",
        "desc": "isSeparator reports whether the rune could mark a word boundary. TODO: update when package unicode captures more of the properties."
      },
      {
        "name": "lastIndexFunc",
        "desc": "lastIndexFunc is the same as LastIndexFunc except that if truth==false, the sense of the predicate function is inverted."
      },
      {
        "name": "longestCommonSuffix",
        "desc": ""
      },
      {
        "name": "splitSeq",
        "desc": "splitSeq is SplitSeq or SplitAfterSeq, configured by how many bytes of sep to include in the results (none or all)."
      },
      {
        "name": "trimLeftASCII",
        "desc": ""
      },
      {
        "name": "trimLeftByte",
        "desc": ""
      },
      {
        "name": "trimLeftUnicode",
        "desc": ""
      },
      {
        "name": "trimRightASCII",
        "desc": ""
      },
      {
        "name": "trimRightByte",
        "desc": ""
      },
      {
        "name": "trimRightUnicode",
        "desc": ""
      },
      {
        "name": "Cap",
        "desc": "Cap returns the capacity of the builder's underlying byte slice. It is the total space allocated for the string being built and includes any bytes already written."
      },
      {
        "name": "Grow",
        "desc": "Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of accumulated bytes; b.Len() == len(b.String())."
      },
      {
        "name": "Reset",
        "desc": "Reset resets the [Builder] to be empty."
      },
      {
        "name": "String",
        "desc": "String returns the accumulated string."
      },
      {
        "name": "Write",
        "desc": "Write appends the contents of p to b's buffer. Write always returns len(p), nil."
      },
      {
        "name": "WriteByte",
        "desc": "WriteByte appends the byte c to b's buffer. The returned error is always nil."
      },
      {
        "name": "WriteRune",
        "desc": "WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error."
      },
      {
        "name": "WriteString",
        "desc": "WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error."
      },
      {
        "name": "copyCheck",
        "desc": "copyCheck implements a dynamic check to prevent modification after copying a non-zero Builder, which would be unsafe (see #25907, #47276).  We cannot add a noCopy field to Builder, to cause vet's copylocks check to report copying, because copylocks cannot reliably discriminate the zero and nonzero cases."
      },
      {
        "name": "grow",
        "desc": "grow copies the buffer to a new, larger buffer so that there are at least n bytes of capacity beyond len(b.buf)."
      },
      {
        "name": "Len",
        "desc": "Len returns the number of bytes of the unread portion of the string."
      },
      {
        "name": "Read",
        "desc": "Read implements the [io.Reader] interface."
      },
      {
        "name": "ReadAt",
        "desc": "ReadAt implements the [io.ReaderAt] interface."
      },
      {
        "name": "ReadByte",
        "desc": "ReadByte implements the [io.ByteReader] interface."
      },
      {
        "name": "ReadRune",
        "desc": "ReadRune implements the [io.RuneReader] interface."
      },
      {
        "name": "Reset",
        "desc": "Reset resets the [Reader] to be reading from s."
      },
      {
        "name": "Seek",
        "desc": "Seek implements the [io.Seeker] interface."
      },
      {
        "name": "Size",
        "desc": "Size returns the original length of the underlying string. Size is the number of bytes available for reading via [Reader.ReadAt]. The returned value is always the same and is not affected by calls to any other method."
      },
      {
        "name": "UnreadByte",
        "desc": "UnreadByte implements the [io.ByteScanner] interface."
      },
      {
        "name": "UnreadRune",
        "desc": "UnreadRune implements the [io.RuneScanner] interface."
      },
      {
        "name": "WriteTo",
        "desc": "WriteTo implements the [io.WriterTo] interface."
      },
      {
        "name": "PrintTrie",
        "desc": ""
      },
      {
        "name": "Replace",
        "desc": "Replace returns a copy of s with all replacements performed."
      },
      {
        "name": "Replacer",
        "desc": ""
      },
      {
        "name": "WriteString",
        "desc": "WriteString writes s to w with all replacements performed."
      },
      {
        "name": "build",
        "desc": ""
      },
      {
        "name": "buildOnce",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": "Write writes to the buffer to satisfy [io.Writer]."
      },
      {
        "name": "WriteString",
        "desc": "WriteString writes to the buffer without string-\u003e[]byte-\u003estring allocations."
      },
      {
        "name": "contains",
        "desc": "contains reports whether c is inside the set."
      },
      {
        "name": "Replace",
        "desc": ""
      },
      {
        "name": "WriteString",
        "desc": ""
      },
      {
        "name": "Replace",
        "desc": ""
      },
      {
        "name": "WriteString",
        "desc": ""
      },
      {
        "name": "Replace",
        "desc": ""
      },
      {
        "name": "WriteString",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "printNode",
        "desc": ""
      },
      {
        "name": "Replace",
        "desc": ""
      },
      {
        "name": "WriteString",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "next returns the index in text of the first occurrence of the pattern. If the pattern is not found, it returns -1."
      },
      {
        "name": "WriteString",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Builder",
        "desc": "A Builder is used to efficiently build a string using [Builder.Write] methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder."
      },
      {
        "name": "Reader",
        "desc": "A Reader implements the [io.Reader], [io.ReaderAt], [io.ByteReader], [io.ByteScanner], [io.RuneReader], [io.RuneScanner], [io.Seeker], and [io.WriterTo] interfaces by reading from a string. The zero value for Reader operates like a Reader of an empty string."
      },
      {
        "name": "Replacer",
        "desc": "Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines."
      },
      {
        "name": "appendSliceWriter",
        "desc": ""
      },
      {
        "name": "asciiSet",
        "desc": "asciiSet is a 32-byte value, where each bit represents the presence of a given ASCII character in the set. The 128-bits of the lower 16 bytes, starting with the least-significant bit of the lowest word to the most-significant bit of the highest word, map to the full range of all 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed, ensuring that any non-ASCII character will be reported as not in the set. This allocates a total of 32 bytes even though the upper half is unused to avoid bounds checks in asciiSet.contains."
      },
      {
        "name": "byteReplacer",
        "desc": "byteReplacer is the implementation that's used when all the \"old\" and \"new\" values are single ASCII bytes. The array contains replacement bytes indexed by old byte."
      },
      {
        "name": "byteStringReplacer",
        "desc": "byteStringReplacer is the implementation that's used when all the \"old\" values are single ASCII bytes but the \"new\" values vary in size."
      },
      {
        "name": "genericReplacer",
        "desc": "genericReplacer is the fully generic algorithm. It's used as a fallback when nothing faster can be used."
      },
      {
        "name": "replacer",
        "desc": "replacer is the interface that a replacement algorithm needs to implement."
      },
      {
        "name": "singleStringReplacer",
        "desc": "singleStringReplacer is the implementation that's used when there is only one string to replace (and that string has more than one byte)."
      },
      {
        "name": "stringFinder",
        "desc": "stringFinder efficiently finds strings in a source text. It's implemented using the Boyer-Moore string search algorithm: https://en.wikipedia.org/wiki/Boyer-Moore_string_search_algorithm https://www.cs.utexas.edu/~moore/publications/fstrpos.pdf (note: this aged document uses 1-based indexing)"
      },
      {
        "name": "stringWriter",
        "desc": ""
      },
      {
        "name": "trieNode",
        "desc": "trieNode is a node in a lookup trie for prioritized key/value pairs. Keys and values may be empty. For example, the trie containing keys \"ax\", \"ay\", \"bcbc\", \"x\" and \"xy\" could have eight nodes:  \tn0  - \tn1  a- \tn2  .x+ \tn3  .y+ \tn4  b- \tn5  .cbc+ \tn6  x+ \tn7  .y+  n0 is the root node, and its children are n1, n4 and n6; n1's children are n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked with a trailing \"-\") are partial keys, and nodes n2, n3, n5, n6 and n7 (marked with a trailing \"+\") are complete keys."
      }
    ]
  },
  {
    "name": "structs",
    "desc": "Package structs defines marker types that can be used as struct fields to modify the properties of a struct.  By convention, a marker type should be used as the type of a field named \"_\", placed at the beginning of a struct type definition.",
    "functions": null,
    "types": [
      {
        "name": "HostLayout",
        "desc": "HostLayout marks a struct as using host memory layout. A struct with a field of type HostLayout will be laid out in memory according to host expectations, generally following the host's C ABI.  HostLayout does not affect layout within any other struct-typed fields of the containing struct, nor does it affect layout of structs containing the struct marked as host layout.  By convention, HostLayout should be used as the type of a field named \"_\", placed at the beginning of the struct type definition."
      },
      {
        "name": "hostLayout",
        "desc": "We use an unexported type within the exported type to give the marker type itself, rather than merely its name, a recognizable identity in the type system. The main consequence of this is that a user can give the type a new name and it will still have the same properties, e.g.,  \ttype HL structs.HostLayout  It also prevents unintentional conversion of struct{} to a named marker type."
      }
    ]
  },
  {
    "name": "sync",
    "desc": "Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the [Once] and [WaitGroup] types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.  Values containing the types defined in this package should not be copied.",
    "functions": [
      {
        "name": "OnceFunc",
        "desc": "OnceFunc returns a function that invokes f only once. The returned function may be called concurrently.  If f panics, the returned function will panic with the same value on every call."
      },
      {
        "name": "OnceValue",
        "desc": "OnceValue returns a function that invokes f only once and returns the value returned by f. The returned function may be called concurrently.  If f panics, the returned function will panic with the same value on every call."
      },
      {
        "name": "OnceValues",
        "desc": "OnceValues returns a function that invokes f only once and returns the values returned by f. The returned function may be called concurrently.  If f panics, the returned function will panic with the same value on every call."
      },
      {
        "name": "fatal",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "poolCleanup",
        "desc": "poolCleanup should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/bytedance/gopkg   - github.com/songzhibin97/gkit  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "poolRaceAddr",
        "desc": "poolRaceAddr returns an address to use as the synchronization point for race detector logic. We don't use the actual pointer stored in x directly, for fear of conflicting with other synchronization on that address. Instead, we hash the pointer to get an index into poolRaceHash. See discussion on golang.org/cl/31589."
      },
      {
        "name": "runtime_LoadAcquintptr",
        "desc": ""
      },
      {
        "name": "runtime_Semacquire",
        "desc": "Semacquire waits until *s \u003e 0 and then atomically decrements it. It is intended as a simple sleep primitive for use by the synchronization library and should not be used directly."
      },
      {
        "name": "runtime_SemacquireRWMutex",
        "desc": ""
      },
      {
        "name": "runtime_SemacquireRWMutexR",
        "desc": "Semacquire(RW)Mutex(R) is like Semacquire, but for profiling contended Mutexes and RWMutexes. If lifo is true, queue waiter at the head of wait queue. skipframes is the number of frames to omit during tracing, counting from runtime_SemacquireMutex's caller. The different forms of this function just tell the runtime how to present the reason for waiting in a backtrace, and is used to compute some metrics. Otherwise they're functionally identical."
      },
      {
        "name": "runtime_SemacquireWaitGroup",
        "desc": "SemacquireWaitGroup is like Semacquire, but for WaitGroup.Wait."
      },
      {
        "name": "runtime_Semrelease",
        "desc": "Semrelease atomically increments *s and notifies a waiting goroutine if one is blocked in Semacquire. It is intended as a simple wakeup primitive for use by the synchronization library and should not be used directly. If handoff is true, pass count directly to the first waiter. skipframes is the number of frames to omit during tracing, counting from runtime_Semrelease's caller."
      },
      {
        "name": "runtime_StoreReluintptr",
        "desc": ""
      },
      {
        "name": "runtime_notifyListAdd",
        "desc": "See runtime/sema.go for documentation."
      },
      {
        "name": "runtime_notifyListCheck",
        "desc": "Ensure that sync and runtime agree on size of notifyList."
      },
      {
        "name": "runtime_notifyListNotifyAll",
        "desc": "See runtime/sema.go for documentation."
      },
      {
        "name": "runtime_notifyListNotifyOne",
        "desc": "See runtime/sema.go for documentation."
      },
      {
        "name": "runtime_notifyListWait",
        "desc": "See runtime/sema.go for documentation."
      },
      {
        "name": "runtime_procPin",
        "desc": ""
      },
      {
        "name": "runtime_procUnpin",
        "desc": ""
      },
      {
        "name": "runtime_randn",
        "desc": "from runtime"
      },
      {
        "name": "runtime_registerPoolCleanup",
        "desc": "Implemented in runtime."
      },
      {
        "name": "syscall_hasWaitingReaders",
        "desc": "syscall_hasWaitingReaders reports whether any goroutine is waiting to acquire a read lock on rw. This exists because syscall.ForkLock is an RWMutex, and we can't change that without breaking compatibility. We don't need or want RWMutex semantics for ForkLock, and we use this private API to avoid having to change the type of ForkLock. For more details see the syscall package."
      },
      {
        "name": "throw",
        "desc": ""
      },
      {
        "name": "Broadcast",
        "desc": "Broadcast wakes all goroutines waiting on c.  It is allowed but not required for the caller to hold c.L during the call."
      },
      {
        "name": "Signal",
        "desc": "Signal wakes one goroutine waiting on c, if there is any.  It is allowed but not required for the caller to hold c.L during the call.  Signal() does not affect goroutine scheduling priority; if other goroutines are attempting to lock c.L, they may be awoken before a \"waiting\" goroutine."
      },
      {
        "name": "Wait",
        "desc": "Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal].  Because c.L is not locked while Wait is waiting, the caller typically cannot assume that the condition is true when Wait returns. Instead, the caller should Wait in a loop:  \tc.L.Lock() \tfor !condition() { \t    c.Wait() \t} \t... make use of condition ... \tc.L.Unlock()"
      },
      {
        "name": "Clear",
        "desc": "Clear deletes all the entries, resulting in an empty Map."
      },
      {
        "name": "CompareAndDelete",
        "desc": "CompareAndDelete deletes the entry for key if its value is equal to old. The old value must be of a comparable type.  If there is no current value for key in the map, CompareAndDelete returns false (even if the old value is the nil interface value)."
      },
      {
        "name": "CompareAndSwap",
        "desc": "CompareAndSwap swaps the old and new values for key if the value stored in the map is equal to old. The old value must be of a comparable type."
      },
      {
        "name": "Delete",
        "desc": "Delete deletes the value for a key."
      },
      {
        "name": "Load",
        "desc": "Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map."
      },
      {
        "name": "LoadAndDelete",
        "desc": "LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present."
      },
      {
        "name": "LoadOrStore",
        "desc": "LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored."
      },
      {
        "name": "Range",
        "desc": "Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.  Range does not necessarily correspond to any consistent snapshot of the Map's contents: no key will be visited more than once, but if the value for any key is stored or deleted concurrently (including by f), Range may reflect any mapping for that key from any point during the Range call. Range does not block other methods on the receiver; even f itself may call any method on m.  Range may be O(N) with the number of elements in the map even if f returns false after a constant number of calls."
      },
      {
        "name": "Store",
        "desc": "Store sets the value for a key."
      },
      {
        "name": "Swap",
        "desc": "Swap swaps the value for a key and returns the previous value if any. The loaded result reports whether the key was present."
      },
      {
        "name": "dirtyLocked",
        "desc": ""
      },
      {
        "name": "loadReadOnly",
        "desc": ""
      },
      {
        "name": "missLocked",
        "desc": ""
      },
      {
        "name": "Lock",
        "desc": "Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available."
      },
      {
        "name": "TryLock",
        "desc": "TryLock tries to lock m and reports whether it succeeded.  Note that while correct uses of TryLock do exist, they are rare, and use of TryLock is often a sign of a deeper problem in a particular use of mutexes."
      },
      {
        "name": "Unlock",
        "desc": "Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.  A locked [Mutex] is not associated with a particular goroutine. It is allowed for one goroutine to lock a Mutex and then arrange for another goroutine to unlock it."
      },
      {
        "name": "Do",
        "desc": "Do calls the function f if and only if Do is being called for the first time for this instance of [Once]. In other words, given  \tvar once Once  if once.Do(f) is called multiple times, only the first call will invoke f, even if f has a different value in each invocation. A new instance of Once is required for each function to execute.  Do is intended for initialization that must be run exactly once. Since f is niladic, it may be necessary to use a function literal to capture the arguments to a function to be invoked by Do:  \tconfig.once.Do(func() { config.init(filename) })  Because no call to Do returns until the one call to f returns, if f causes Do to be called, it will deadlock.  If f panics, Do considers it to have returned; future calls of Do return without calling f."
      },
      {
        "name": "doSlow",
        "desc": ""
      },
      {
        "name": "Get",
        "desc": "Get selects an arbitrary item from the [Pool], removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to [Pool.Put] and the values returned by Get.  If Get would otherwise return nil and p.New is non-nil, Get returns the result of calling p.New."
      },
      {
        "name": "Put",
        "desc": "Put adds x to the pool."
      },
      {
        "name": "getSlow",
        "desc": ""
      },
      {
        "name": "pin",
        "desc": "pin pins the current goroutine to P, disables preemption and returns poolLocal pool for the P and the P's id. Caller must call runtime_procUnpin() when done with the pool."
      },
      {
        "name": "pinSlow",
        "desc": ""
      },
      {
        "name": "Lock",
        "desc": "Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available."
      },
      {
        "name": "RLock",
        "desc": "RLock locks rw for reading.  It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the [RWMutex] type."
      },
      {
        "name": "RLocker",
        "desc": "RLocker returns a [Locker] interface that implements the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock."
      },
      {
        "name": "RUnlock",
        "desc": "RUnlock undoes a single [RWMutex.RLock] call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock."
      },
      {
        "name": "TryLock",
        "desc": "TryLock tries to lock rw for writing and reports whether it succeeded.  Note that while correct uses of TryLock do exist, they are rare, and use of TryLock is often a sign of a deeper problem in a particular use of mutexes."
      },
      {
        "name": "TryRLock",
        "desc": "TryRLock tries to lock rw for reading and reports whether it succeeded.  Note that while correct uses of TryRLock do exist, they are rare, and use of TryRLock is often a sign of a deeper problem in a particular use of mutexes."
      },
      {
        "name": "Unlock",
        "desc": "Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.  As with Mutexes, a locked [RWMutex] is not associated with a particular goroutine. One goroutine may [RWMutex.RLock] ([RWMutex.Lock]) a RWMutex and then arrange for another goroutine to [RWMutex.RUnlock] ([RWMutex.Unlock]) it."
      },
      {
        "name": "rUnlockSlow",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": "Add adds delta, which may be negative, to the [WaitGroup] task counter. If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released. If the counter goes negative, Add panics.  Callers should prefer [WaitGroup.Go].  Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example."
      },
      {
        "name": "Done",
        "desc": "Done decrements the [WaitGroup] task counter by one. It is equivalent to Add(-1).  Callers should prefer [WaitGroup.Go].  In the terminology of [the Go memory model], a call to Done \"synchronizes before\" the return of any Wait call that it unblocks.  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "Go",
        "desc": "Go calls f in a new goroutine and adds that task to the [WaitGroup]. When f returns, the task is removed from the WaitGroup.  The function f must not panic.  If the WaitGroup is empty, Go must happen before a [WaitGroup.Wait]. Typically, this simply means Go is called to start tasks before Wait is called. If the WaitGroup is not empty, Go may happen at any time. This means a goroutine started by Go may itself call Go. If a WaitGroup is reused to wait for several independent sets of tasks, new Go calls must happen after all previous Wait calls have returned.  In the terminology of [the Go memory model], the return from f \"synchronizes before\" the return of any Wait call that it unblocks.  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "Wait",
        "desc": "Wait blocks until the [WaitGroup] task counter is zero."
      },
      {
        "name": "check",
        "desc": ""
      },
      {
        "name": "delete",
        "desc": ""
      },
      {
        "name": "load",
        "desc": ""
      },
      {
        "name": "swapLocked",
        "desc": "swapLocked unconditionally swaps a value into the entry.  The entry must be known not to be expunged."
      },
      {
        "name": "tryCompareAndSwap",
        "desc": "tryCompareAndSwap compare the entry with the given old value and swaps it with a new value if the entry is equal to the old value, and the entry has not been expunged.  If the entry is expunged, tryCompareAndSwap returns false and leaves the entry unchanged."
      },
      {
        "name": "tryExpungeLocked",
        "desc": ""
      },
      {
        "name": "tryLoadOrStore",
        "desc": "tryLoadOrStore atomically loads or stores a value if the entry is not expunged.  If the entry is expunged, tryLoadOrStore leaves the entry unchanged and returns with ok==false."
      },
      {
        "name": "trySwap",
        "desc": "trySwap swaps a value if the entry has not been expunged.  If the entry is expunged, trySwap returns false and leaves the entry unchanged."
      },
      {
        "name": "unexpungeLocked",
        "desc": "unexpungeLocked ensures that the entry is not marked as expunged.  If the entry was previously expunged, it must be added to the dirty map before m.mu is unlocked."
      },
      {
        "name": "Lock",
        "desc": "Lock is a no-op used by -copylocks checker from `go vet`."
      },
      {
        "name": "Unlock",
        "desc": ""
      },
      {
        "name": "PopHead",
        "desc": ""
      },
      {
        "name": "PopTail",
        "desc": ""
      },
      {
        "name": "PushHead",
        "desc": ""
      },
      {
        "name": "popHead",
        "desc": ""
      },
      {
        "name": "popTail",
        "desc": ""
      },
      {
        "name": "pushHead",
        "desc": ""
      },
      {
        "name": "PopHead",
        "desc": ""
      },
      {
        "name": "PopTail",
        "desc": ""
      },
      {
        "name": "PushHead",
        "desc": ""
      },
      {
        "name": "pack",
        "desc": ""
      },
      {
        "name": "popHead",
        "desc": "popHead removes and returns the element at the head of the queue. It returns false if the queue is empty. It must only be called by a single producer."
      },
      {
        "name": "popTail",
        "desc": "popTail removes and returns the element at the tail of the queue. It returns false if the queue is empty. It may be called by any number of consumers."
      },
      {
        "name": "pushHead",
        "desc": "pushHead adds val at the head of the queue. It returns false if the queue is full. It must only be called by a single producer."
      },
      {
        "name": "unpack",
        "desc": ""
      },
      {
        "name": "PopHead",
        "desc": ""
      },
      {
        "name": "PopTail",
        "desc": ""
      },
      {
        "name": "PushHead",
        "desc": ""
      },
      {
        "name": "pack",
        "desc": ""
      },
      {
        "name": "popHead",
        "desc": "popHead removes and returns the element at the head of the queue. It returns false if the queue is empty. It must only be called by a single producer."
      },
      {
        "name": "popTail",
        "desc": "popTail removes and returns the element at the tail of the queue. It returns false if the queue is empty. It may be called by any number of consumers."
      },
      {
        "name": "pushHead",
        "desc": "pushHead adds val at the head of the queue. It returns false if the queue is full. It must only be called by a single producer."
      },
      {
        "name": "unpack",
        "desc": ""
      },
      {
        "name": "Lock",
        "desc": ""
      },
      {
        "name": "Unlock",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Cond",
        "desc": "Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event.  Each Cond has an associated Locker L (often a [*Mutex] or [*RWMutex]), which must be held when changing the condition and when calling the [Cond.Wait] method.  A Cond must not be copied after first use.  In the terminology of [the Go memory model], Cond arranges that a call to [Cond.Broadcast] or [Cond.Signal] “synchronizes before” any Wait call that it unblocks.  For many simple use cases, users will be better off using channels than a Cond (Broadcast corresponds to closing a channel, and Signal corresponds to sending on a channel).  For more on replacements for [sync.Cond], see [Roberto Clapis's series on advanced concurrency patterns], as well as [Bryan Mills's talk on concurrency patterns].  [the Go memory model]: https://go.dev/ref/mem [Roberto Clapis's series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/ [Bryan Mills's talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view"
      },
      {
        "name": "Locker",
        "desc": "A Locker represents an object that can be locked and unlocked."
      },
      {
        "name": "Map",
        "desc": "Map is like a Go map[any]any but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.  The Map type is specialized. Most code should use a plain Go map instead, with separate locking or coordination, for better type safety and to make it easier to maintain other invariants along with the map content.  The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate [Mutex] or [RWMutex].  The zero Map is empty and ready for use. A Map must not be copied after first use.  In the terminology of [the Go memory model], Map arranges that a write operation “synchronizes before” any read operation that observes the effect of the write, where read and write operations are defined as follows. [Map.Load], [Map.LoadAndDelete], [Map.LoadOrStore], [Map.Swap], [Map.CompareAndSwap], and [Map.CompareAndDelete] are read operations; [Map.Delete], [Map.LoadAndDelete], [Map.Store], and [Map.Swap] are write operations; [Map.LoadOrStore] is a write operation when it returns loaded set to false; [Map.CompareAndSwap] is a write operation when it returns swapped set to true; and [Map.CompareAndDelete] is a write operation when it returns deleted set to true.  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "Mutex",
        "desc": "A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.  A Mutex must not be copied after first use.  In the terminology of [the Go memory model], the n'th call to [Mutex.Unlock] “synchronizes before” the m'th call to [Mutex.Lock] for any n \u003c m. A successful call to [Mutex.TryLock] is equivalent to a call to Lock. A failed call to TryLock does not establish any “synchronizes before” relation at all.  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "Once",
        "desc": "Once is an object that will perform exactly one action.  A Once must not be copied after first use.  In the terminology of [the Go memory model], the return from f “synchronizes before” the return from any call of once.Do(f).  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "Pool",
        "desc": "A Pool is a set of temporary objects that may be individually saved and retrieved.  Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated.  A Pool is safe for use by multiple goroutines simultaneously.  Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.  An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients.  An example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. The store scales under load (when many goroutines are actively printing) and shrinks when quiescent.  On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.  A Pool must not be copied after first use.  In the terminology of [the Go memory model], a call to Put(x) “synchronizes before” a call to [Pool.Get] returning that same value x. Similarly, a call to New returning x “synchronizes before” a call to Get returning that same value x.  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "PoolDequeue",
        "desc": "PoolDequeue exports an interface for pollDequeue testing."
      },
      {
        "name": "RWMutex",
        "desc": "A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.  A RWMutex must not be copied after first use.  If any goroutine calls [RWMutex.Lock] while the lock is already held by one or more readers, concurrent calls to [RWMutex.RLock] will block until the writer has acquired (and released) the lock, to ensure that the lock eventually becomes available to the writer. Note that this prohibits recursive read-locking. A [RWMutex.RLock] cannot be upgraded into a [RWMutex.Lock], nor can a [RWMutex.Lock] be downgraded into a [RWMutex.RLock].  In the terminology of [the Go memory model], the n'th call to [RWMutex.Unlock] “synchronizes before” the m'th call to Lock for any n \u003c m, just as for [Mutex]. For any call to RLock, there exists an n such that the n'th call to Unlock “synchronizes before” that call to RLock, and the corresponding call to [RWMutex.RUnlock] “synchronizes before” the n+1'th call to Lock.  [the Go memory model]: https://go.dev/ref/mem"
      },
      {
        "name": "WaitGroup",
        "desc": "A WaitGroup is a counting semaphore typically used to wait for a group of goroutines or tasks to finish.  Typically, a main goroutine will start tasks, each in a new goroutine, by calling [WaitGroup.Go] and then wait for all tasks to complete by calling [WaitGroup.Wait]. For example:  \tvar wg sync.WaitGroup \twg.Go(task1) \twg.Go(task2) \twg.Wait()  A WaitGroup may also be used for tracking tasks without using Go to start new goroutines by using [WaitGroup.Add] and [WaitGroup.Done].  The previous example can be rewritten using explicitly created goroutines along with Add and Done:  \tvar wg sync.WaitGroup \twg.Add(1) \tgo func() { \t\tdefer wg.Done() \t\ttask1() \t}() \twg.Add(1) \tgo func() { \t\tdefer wg.Done() \t\ttask2() \t}() \twg.Wait()  This pattern is common in code that predates [WaitGroup.Go].  A WaitGroup must not be copied after first use."
      },
      {
        "name": "copyChecker",
        "desc": "copyChecker holds back pointer to itself to detect object copying."
      },
      {
        "name": "dequeueNil",
        "desc": "dequeueNil is used in poolDequeue to represent interface{}(nil). Since we use nil to represent empty slots, we need a sentinel value to represent nil."
      },
      {
        "name": "eface",
        "desc": ""
      },
      {
        "name": "entry",
        "desc": "An entry is a slot in the map corresponding to a particular key."
      },
      {
        "name": "noCopy",
        "desc": "noCopy may be added to structs which must not be copied after the first use.  See https://golang.org/issues/8005#issuecomment-190753527 for details.  Note that it must not be embedded, due to the Lock and Unlock methods."
      },
      {
        "name": "notifyList",
        "desc": "Approximation of notifyList in runtime/sema.go. Size and alignment must agree."
      },
      {
        "name": "poolChain",
        "desc": "poolChain is a dynamically-sized version of poolDequeue.  This is implemented as a doubly-linked list queue of poolDequeues where each dequeue is double the size of the previous one. Once a dequeue fills up, this allocates a new one and only ever pushes to the latest dequeue. Pops happen from the other end of the list and once a dequeue is exhausted, it gets removed from the list."
      },
      {
        "name": "poolChainElt",
        "desc": ""
      },
      {
        "name": "poolDequeue",
        "desc": "poolDequeue is a lock-free fixed-size single-producer, multi-consumer queue. The single producer can both push and pop from the head, and consumers can pop from the tail.  It has the added feature that it nils out unused slots to avoid unnecessary retention of objects. This is important for sync.Pool, but not typically a property considered in the literature."
      },
      {
        "name": "poolLocal",
        "desc": ""
      },
      {
        "name": "poolLocalInternal",
        "desc": "Local per-P Pool appendix."
      },
      {
        "name": "readOnly",
        "desc": "readOnly is an immutable struct stored atomically in the Map.read field."
      },
      {
        "name": "rlocker",
        "desc": ""
      }
    ]
  },
  {
    "name": "sync/atomic",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkValueRead",
        "desc": ""
      },
      {
        "name": "ExampleValue_config",
        "desc": "The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines."
      },
      {
        "name": "ExampleValue_readMostly",
        "desc": "The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom."
      },
      {
        "name": "TestAddInt32",
        "desc": ""
      },
      {
        "name": "TestAddInt32Method",
        "desc": ""
      },
      {
        "name": "TestAddInt64",
        "desc": ""
      },
      {
        "name": "TestAddInt64Method",
        "desc": ""
      },
      {
        "name": "TestAddUint32",
        "desc": ""
      },
      {
        "name": "TestAddUint32Method",
        "desc": ""
      },
      {
        "name": "TestAddUint64",
        "desc": ""
      },
      {
        "name": "TestAddUint64Method",
        "desc": ""
      },
      {
        "name": "TestAddUintptr",
        "desc": ""
      },
      {
        "name": "TestAddUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestAndInt32",
        "desc": ""
      },
      {
        "name": "TestAndInt32Method",
        "desc": ""
      },
      {
        "name": "TestAndInt64",
        "desc": ""
      },
      {
        "name": "TestAndInt64Method",
        "desc": ""
      },
      {
        "name": "TestAndUint32",
        "desc": ""
      },
      {
        "name": "TestAndUint32Method",
        "desc": ""
      },
      {
        "name": "TestAndUint64",
        "desc": ""
      },
      {
        "name": "TestAndUint64Method",
        "desc": ""
      },
      {
        "name": "TestAndUintptr",
        "desc": ""
      },
      {
        "name": "TestAndUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestAutoAligned64",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapInt32",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapInt32Method",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapInt64",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapInt64Method",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapPointer",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapPointerMethod",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapUint32",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapUint32Method",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapUint64",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapUint64Method",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapUintptr",
        "desc": ""
      },
      {
        "name": "TestCompareAndSwapUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestHammer32",
        "desc": ""
      },
      {
        "name": "TestHammer64",
        "desc": ""
      },
      {
        "name": "TestHammerStoreLoad",
        "desc": ""
      },
      {
        "name": "TestLoadInt32",
        "desc": ""
      },
      {
        "name": "TestLoadInt32Method",
        "desc": ""
      },
      {
        "name": "TestLoadInt64",
        "desc": ""
      },
      {
        "name": "TestLoadInt64Method",
        "desc": ""
      },
      {
        "name": "TestLoadPointer",
        "desc": ""
      },
      {
        "name": "TestLoadPointerMethod",
        "desc": ""
      },
      {
        "name": "TestLoadUint32",
        "desc": ""
      },
      {
        "name": "TestLoadUint32Method",
        "desc": ""
      },
      {
        "name": "TestLoadUint64",
        "desc": ""
      },
      {
        "name": "TestLoadUint64Method",
        "desc": ""
      },
      {
        "name": "TestLoadUintptr",
        "desc": ""
      },
      {
        "name": "TestLoadUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestNilDeref",
        "desc": ""
      },
      {
        "name": "TestOrInt32",
        "desc": ""
      },
      {
        "name": "TestOrInt32Method",
        "desc": ""
      },
      {
        "name": "TestOrInt64",
        "desc": ""
      },
      {
        "name": "TestOrInt64Method",
        "desc": ""
      },
      {
        "name": "TestOrUint32",
        "desc": ""
      },
      {
        "name": "TestOrUint32Method",
        "desc": ""
      },
      {
        "name": "TestOrUint64",
        "desc": ""
      },
      {
        "name": "TestOrUint64Method",
        "desc": ""
      },
      {
        "name": "TestOrUintptr",
        "desc": ""
      },
      {
        "name": "TestOrUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestStoreInt32",
        "desc": ""
      },
      {
        "name": "TestStoreInt32Method",
        "desc": ""
      },
      {
        "name": "TestStoreInt64",
        "desc": ""
      },
      {
        "name": "TestStoreInt64Method",
        "desc": ""
      },
      {
        "name": "TestStoreLoadRelAcq32",
        "desc": ""
      },
      {
        "name": "TestStoreLoadRelAcq64",
        "desc": ""
      },
      {
        "name": "TestStoreLoadSeqCst32",
        "desc": ""
      },
      {
        "name": "TestStoreLoadSeqCst64",
        "desc": ""
      },
      {
        "name": "TestStorePointer",
        "desc": ""
      },
      {
        "name": "TestStorePointerMethod",
        "desc": ""
      },
      {
        "name": "TestStoreUint32",
        "desc": ""
      },
      {
        "name": "TestStoreUint32Method",
        "desc": ""
      },
      {
        "name": "TestStoreUint64",
        "desc": ""
      },
      {
        "name": "TestStoreUint64Method",
        "desc": ""
      },
      {
        "name": "TestStoreUintptr",
        "desc": ""
      },
      {
        "name": "TestStoreUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestSwapInt32",
        "desc": ""
      },
      {
        "name": "TestSwapInt32Method",
        "desc": ""
      },
      {
        "name": "TestSwapInt64",
        "desc": ""
      },
      {
        "name": "TestSwapInt64Method",
        "desc": ""
      },
      {
        "name": "TestSwapPointer",
        "desc": ""
      },
      {
        "name": "TestSwapPointerMethod",
        "desc": ""
      },
      {
        "name": "TestSwapUint32",
        "desc": ""
      },
      {
        "name": "TestSwapUint32Method",
        "desc": ""
      },
      {
        "name": "TestSwapUint64",
        "desc": ""
      },
      {
        "name": "TestSwapUint64Method",
        "desc": ""
      },
      {
        "name": "TestSwapUintptr",
        "desc": ""
      },
      {
        "name": "TestSwapUintptrMethod",
        "desc": ""
      },
      {
        "name": "TestUnaligned64",
        "desc": ""
      },
      {
        "name": "TestValue",
        "desc": ""
      },
      {
        "name": "TestValueCompareAndSwapConcurrent",
        "desc": ""
      },
      {
        "name": "TestValueConcurrent",
        "desc": ""
      },
      {
        "name": "TestValueLarge",
        "desc": ""
      },
      {
        "name": "TestValuePanic",
        "desc": ""
      },
      {
        "name": "TestValueSwapConcurrent",
        "desc": ""
      },
      {
        "name": "TestValue_CompareAndSwap",
        "desc": ""
      },
      {
        "name": "TestValue_Swap",
        "desc": ""
      },
      {
        "name": "hammerAddInt32",
        "desc": ""
      },
      {
        "name": "hammerAddInt32Method",
        "desc": ""
      },
      {
        "name": "hammerAddInt64",
        "desc": ""
      },
      {
        "name": "hammerAddInt64Method",
        "desc": ""
      },
      {
        "name": "hammerAddUint32",
        "desc": ""
      },
      {
        "name": "hammerAddUint32Method",
        "desc": ""
      },
      {
        "name": "hammerAddUint64",
        "desc": ""
      },
      {
        "name": "hammerAddUint64Method",
        "desc": ""
      },
      {
        "name": "hammerAddUintptr32",
        "desc": ""
      },
      {
        "name": "hammerAddUintptr32Method",
        "desc": ""
      },
      {
        "name": "hammerAddUintptr64",
        "desc": ""
      },
      {
        "name": "hammerAddUintptr64Method",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapInt32",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapInt32Method",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapInt64",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapInt64Method",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUint32",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUint32Method",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUint64",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUint64Method",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUintptr32",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUintptr32Method",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUintptr64",
        "desc": ""
      },
      {
        "name": "hammerCompareAndSwapUintptr64Method",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadInt32",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadInt32Method",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadInt64",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadInt64Method",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadPointer",
        "desc": "This code is just testing that LoadPointer/StorePointer operate atomically; it's not actually calculating pointers."
      },
      {
        "name": "hammerStoreLoadPointerMethod",
        "desc": "This code is just testing that LoadPointer/StorePointer operate atomically; it's not actually calculating pointers."
      },
      {
        "name": "hammerStoreLoadUint32",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadUint32Method",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadUint64",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadUint64Method",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadUintptr",
        "desc": ""
      },
      {
        "name": "hammerStoreLoadUintptrMethod",
        "desc": ""
      },
      {
        "name": "hammerSwapInt32",
        "desc": ""
      },
      {
        "name": "hammerSwapInt32Method",
        "desc": ""
      },
      {
        "name": "hammerSwapInt64",
        "desc": ""
      },
      {
        "name": "hammerSwapInt64Method",
        "desc": ""
      },
      {
        "name": "hammerSwapUint32",
        "desc": ""
      },
      {
        "name": "hammerSwapUint32Method",
        "desc": ""
      },
      {
        "name": "hammerSwapUint64",
        "desc": ""
      },
      {
        "name": "hammerSwapUint64Method",
        "desc": ""
      },
      {
        "name": "hammerSwapUintptr32",
        "desc": ""
      },
      {
        "name": "hammerSwapUintptr32Method",
        "desc": ""
      },
      {
        "name": "hammerSwapUintptr64",
        "desc": ""
      },
      {
        "name": "hammerSwapUintptr64Method",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "loadConfig",
        "desc": ""
      },
      {
        "name": "requests",
        "desc": ""
      },
      {
        "name": "shouldPanic",
        "desc": ""
      },
      {
        "name": "testCompareAndSwapUint64",
        "desc": ""
      },
      {
        "name": "testPointers",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "List",
        "desc": "Test that this compiles. When atomic.Pointer used _ [0]T, it did not."
      }
    ]
  },
  {
    "name": "syscall",
    "desc": "Package syscall contains an interface to the low-level operating system primitives. The details vary depending on the underlying system, and by default, godoc will display the syscall documentation for the current system. If you want godoc to display syscall documentation for another system, set $GOOS and $GOARCH to the desired system. For example, if you want to view documentation for freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm. The primary use of syscall is inside other packages that provide a more portable interface to the system, such as \"os\", \"time\" and \"net\".  Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has type [Errno].  NOTE: Most of the functions, types, and constants defined in this package are also available in the [golang.org/x/sys] package. That package has more system call support than this one, and most new code should prefer that package where possible. See https://golang.org/s/go1.4-syscall for more information.",
    "functions": [
      {
        "name": "Accept",
        "desc": ""
      },
      {
        "name": "Accept4",
        "desc": ""
      },
      {
        "name": "AcceptEx",
        "desc": ""
      },
      {
        "name": "Access",
        "desc": ""
      },
      {
        "name": "Acct",
        "desc": ""
      },
      {
        "name": "Adjtime",
        "desc": ""
      },
      {
        "name": "Adjtimex",
        "desc": ""
      },
      {
        "name": "AllThreadsSyscall",
        "desc": "AllThreadsSyscall performs a syscall on each OS thread of the Go runtime. It first invokes the syscall on one thread. Should that invocation fail, it returns immediately with the error status. Otherwise, it invokes the syscall on all of the remaining threads in parallel. It will terminate the program if it observes any invoked syscall's return value differs from that of the first invocation.  AllThreadsSyscall is intended for emulating simultaneous process-wide state changes that require consistently modifying per-thread state of the Go runtime.  AllThreadsSyscall is unaware of any threads that are launched explicitly by cgo linked code, so the function always returns [ENOTSUP] in binaries that use cgo."
      },
      {
        "name": "AllThreadsSyscall6",
        "desc": "AllThreadsSyscall6 is like [AllThreadsSyscall], but extended to six arguments."
      },
      {
        "name": "AttachLsf",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "Await",
        "desc": ""
      },
      {
        "name": "Bind",
        "desc": ""
      },
      {
        "name": "BindToDevice",
        "desc": "BindToDevice binds the socket associated with fd to device."
      },
      {
        "name": "BpfBuflen",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "BpfDatalink",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "BpfHeadercmpl",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "BpfInterface",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "BpfStats",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "BpfTimeout",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "BytePtrFromString",
        "desc": "BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, [EINVAL])."
      },
      {
        "name": "ByteSliceFromString",
        "desc": "ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, [EINVAL])."
      },
      {
        "name": "CancelIo",
        "desc": ""
      },
      {
        "name": "CancelIoEx",
        "desc": ""
      },
      {
        "name": "CertAddCertificateContextToStore",
        "desc": ""
      },
      {
        "name": "CertCloseStore",
        "desc": ""
      },
      {
        "name": "CertCreateCertificateContext",
        "desc": ""
      },
      {
        "name": "CertEnumCertificatesInStore",
        "desc": ""
      },
      {
        "name": "CertFreeCertificateChain",
        "desc": ""
      },
      {
        "name": "CertFreeCertificateContext",
        "desc": ""
      },
      {
        "name": "CertGetCertificateChain",
        "desc": ""
      },
      {
        "name": "CertOpenStore",
        "desc": ""
      },
      {
        "name": "CertOpenSystemStore",
        "desc": ""
      },
      {
        "name": "CertVerifyCertificateChainPolicy",
        "desc": ""
      },
      {
        "name": "Chdir",
        "desc": ""
      },
      {
        "name": "CheckBpfVersion",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "Chflags",
        "desc": ""
      },
      {
        "name": "Chmod",
        "desc": ""
      },
      {
        "name": "Chown",
        "desc": ""
      },
      {
        "name": "Chroot",
        "desc": ""
      },
      {
        "name": "Clearenv",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "CloseHandle",
        "desc": ""
      },
      {
        "name": "CloseOnExec",
        "desc": ""
      },
      {
        "name": "Closesocket",
        "desc": ""
      },
      {
        "name": "CmsgLen",
        "desc": "CmsgLen returns the value to store in the Len field of the [Cmsghdr] structure, taking into account any necessary alignment."
      },
      {
        "name": "CmsgSpace",
        "desc": "CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies."
      },
      {
        "name": "CommandLineToArgv",
        "desc": ""
      },
      {
        "name": "ComputerName",
        "desc": ""
      },
      {
        "name": "Connect",
        "desc": ""
      },
      {
        "name": "ConnectEx",
        "desc": ""
      },
      {
        "name": "ConvertSidToStringSid",
        "desc": ""
      },
      {
        "name": "ConvertStringSidToSid",
        "desc": ""
      },
      {
        "name": "CopySid",
        "desc": ""
      },
      {
        "name": "Creat",
        "desc": ""
      },
      {
        "name": "Create",
        "desc": ""
      },
      {
        "name": "CreateDirectory",
        "desc": ""
      },
      {
        "name": "CreateFile",
        "desc": ""
      },
      {
        "name": "CreateFileMapping",
        "desc": ""
      },
      {
        "name": "CreateHardLink",
        "desc": ""
      },
      {
        "name": "CreateIoCompletionPort",
        "desc": "Deprecated: CreateIoCompletionPort has the wrong function signature. Use x/sys/windows.CreateIoCompletionPort."
      },
      {
        "name": "CreatePipe",
        "desc": ""
      },
      {
        "name": "CreateProcess",
        "desc": ""
      },
      {
        "name": "CreateProcessAsUser",
        "desc": ""
      },
      {
        "name": "CreateSymbolicLink",
        "desc": ""
      },
      {
        "name": "CreateToolhelp32Snapshot",
        "desc": ""
      },
      {
        "name": "CryptAcquireContext",
        "desc": ""
      },
      {
        "name": "CryptGenRandom",
        "desc": ""
      },
      {
        "name": "CryptReleaseContext",
        "desc": ""
      },
      {
        "name": "DeleteFile",
        "desc": ""
      },
      {
        "name": "DetachLsf",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "DeviceIoControl",
        "desc": ""
      },
      {
        "name": "DnsNameCompare",
        "desc": ""
      },
      {
        "name": "DnsQuery",
        "desc": ""
      },
      {
        "name": "DnsRecordListFree",
        "desc": ""
      },
      {
        "name": "Dup",
        "desc": ""
      },
      {
        "name": "Dup2",
        "desc": ""
      },
      {
        "name": "Dup3",
        "desc": ""
      },
      {
        "name": "DuplicateHandle",
        "desc": ""
      },
      {
        "name": "Environ",
        "desc": ""
      },
      {
        "name": "EpollCreate",
        "desc": ""
      },
      {
        "name": "EpollCreate1",
        "desc": ""
      },
      {
        "name": "EpollCtl",
        "desc": ""
      },
      {
        "name": "EpollWait",
        "desc": ""
      },
      {
        "name": "EscapeArg",
        "desc": "EscapeArg rewrites command line argument s as prescribed in https://msdn.microsoft.com/en-us/library/ms880421. This function returns \"\" (2 double quotes) if s is empty. Alternatively, these transformations are done:   - every back slash (\\) is doubled, but only if immediately     followed by double quote (\");   - every double quote (\") is escaped by back slash (\\);   - finally, s is wrapped with double quotes (arg -\u003e \"arg\"),     but only if there is space or tab inside s."
      },
      {
        "name": "Exchangedata",
        "desc": ""
      },
      {
        "name": "Exec",
        "desc": "Ordinary exec."
      },
      {
        "name": "Exit",
        "desc": ""
      },
      {
        "name": "ExitProcess",
        "desc": ""
      },
      {
        "name": "Faccessat",
        "desc": ""
      },
      {
        "name": "Fallocate",
        "desc": ""
      },
      {
        "name": "Fchdir",
        "desc": ""
      },
      {
        "name": "Fchflags",
        "desc": ""
      },
      {
        "name": "Fchmod",
        "desc": ""
      },
      {
        "name": "Fchmodat",
        "desc": ""
      },
      {
        "name": "Fchown",
        "desc": ""
      },
      {
        "name": "Fchownat",
        "desc": ""
      },
      {
        "name": "FcntlFlock",
        "desc": "FcntlFlock performs a fcntl syscall for the [F_GETLK], [F_SETLK] or [F_SETLKW] command."
      },
      {
        "name": "Fd2path",
        "desc": ""
      },
      {
        "name": "Fdatasync",
        "desc": ""
      },
      {
        "name": "FindClose",
        "desc": ""
      },
      {
        "name": "FindFirstFile",
        "desc": ""
      },
      {
        "name": "FindNextFile",
        "desc": ""
      },
      {
        "name": "Fixwd",
        "desc": "Ensure current working directory seen by this goroutine matches the most recent [Chdir] called in any goroutine. It's called internally before executing any syscall which uses a relative pathname. Must be called with the goroutine locked to the OS thread, to prevent rescheduling on a different thread (potentially with a different working directory) before the syscall is executed."
      },
      {
        "name": "Flock",
        "desc": ""
      },
      {
        "name": "FlushBpf",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "FlushFileBuffers",
        "desc": ""
      },
      {
        "name": "FlushViewOfFile",
        "desc": ""
      },
      {
        "name": "ForkExec",
        "desc": "Combination of fork and exec, careful to be thread safe."
      },
      {
        "name": "FormatMessage",
        "desc": "FormatMessage is deprecated (msgsrc should be uintptr, not uint32, but can not be changed due to the Go 1 compatibility guarantee).  Deprecated: Use FormatMessage from golang.org/x/sys/windows instead."
      },
      {
        "name": "Fpathconf",
        "desc": ""
      },
      {
        "name": "FreeAddrInfoW",
        "desc": ""
      },
      {
        "name": "FreeEnvironmentStrings",
        "desc": ""
      },
      {
        "name": "FreeLibrary",
        "desc": ""
      },
      {
        "name": "Fstat",
        "desc": ""
      },
      {
        "name": "Fstatat",
        "desc": ""
      },
      {
        "name": "Fstatfs",
        "desc": ""
      },
      {
        "name": "Fsync",
        "desc": ""
      },
      {
        "name": "Ftruncate",
        "desc": ""
      },
      {
        "name": "FullPath",
        "desc": "FullPath retrieves the full path of the specified file."
      },
      {
        "name": "Futimes",
        "desc": ""
      },
      {
        "name": "Futimesat",
        "desc": ""
      },
      {
        "name": "Fwstat",
        "desc": ""
      },
      {
        "name": "GetAcceptExSockaddrs",
        "desc": ""
      },
      {
        "name": "GetAdaptersInfo",
        "desc": ""
      },
      {
        "name": "GetAddrInfoW",
        "desc": ""
      },
      {
        "name": "GetCommandLine",
        "desc": ""
      },
      {
        "name": "GetComputerName",
        "desc": ""
      },
      {
        "name": "GetConsoleMode",
        "desc": ""
      },
      {
        "name": "GetCurrentDirectory",
        "desc": ""
      },
      {
        "name": "GetCurrentProcess",
        "desc": ""
      },
      {
        "name": "GetEnvironmentStrings",
        "desc": ""
      },
      {
        "name": "GetEnvironmentVariable",
        "desc": ""
      },
      {
        "name": "GetExitCodeProcess",
        "desc": ""
      },
      {
        "name": "GetFileAttributes",
        "desc": ""
      },
      {
        "name": "GetFileAttributesEx",
        "desc": ""
      },
      {
        "name": "GetFileInformationByHandle",
        "desc": ""
      },
      {
        "name": "GetFileType",
        "desc": ""
      },
      {
        "name": "GetFullPathName",
        "desc": ""
      },
      {
        "name": "GetHostByName",
        "desc": ""
      },
      {
        "name": "GetIfEntry",
        "desc": ""
      },
      {
        "name": "GetInternalOrigRlimitNofile",
        "desc": ""
      },
      {
        "name": "GetLastError",
        "desc": ""
      },
      {
        "name": "GetLengthSid",
        "desc": ""
      },
      {
        "name": "GetLongPathName",
        "desc": ""
      },
      {
        "name": "GetProcAddress",
        "desc": ""
      },
      {
        "name": "GetProcessTimes",
        "desc": ""
      },
      {
        "name": "GetProtoByName",
        "desc": ""
      },
      {
        "name": "GetQueuedCompletionStatus",
        "desc": "Deprecated: GetQueuedCompletionStatus has the wrong function signature. Use x/sys/windows.GetQueuedCompletionStatus."
      },
      {
        "name": "GetServByName",
        "desc": ""
      },
      {
        "name": "GetShortPathName",
        "desc": ""
      },
      {
        "name": "GetStartupInfo",
        "desc": ""
      },
      {
        "name": "GetStdHandle",
        "desc": ""
      },
      {
        "name": "GetSystemTimeAsFileTime",
        "desc": ""
      },
      {
        "name": "GetTempPath",
        "desc": ""
      },
      {
        "name": "GetTimeZoneInformation",
        "desc": ""
      },
      {
        "name": "GetTokenInformation",
        "desc": ""
      },
      {
        "name": "GetUserNameEx",
        "desc": ""
      },
      {
        "name": "GetUserProfileDirectory",
        "desc": ""
      },
      {
        "name": "GetVersion",
        "desc": ""
      },
      {
        "name": "Getcwd",
        "desc": ""
      },
      {
        "name": "Getdents",
        "desc": ""
      },
      {
        "name": "Getdirentries",
        "desc": ""
      },
      {
        "name": "Getdtablesize",
        "desc": ""
      },
      {
        "name": "Getegid",
        "desc": ""
      },
      {
        "name": "Getenv",
        "desc": ""
      },
      {
        "name": "Geteuid",
        "desc": ""
      },
      {
        "name": "Getexecname",
        "desc": ""
      },
      {
        "name": "Getfsstat",
        "desc": ""
      },
      {
        "name": "Getgid",
        "desc": ""
      },
      {
        "name": "Getgroups",
        "desc": ""
      },
      {
        "name": "Gethostname",
        "desc": ""
      },
      {
        "name": "Getkerninfo",
        "desc": ""
      },
      {
        "name": "Getpagesize",
        "desc": ""
      },
      {
        "name": "Getpeername",
        "desc": ""
      },
      {
        "name": "Getpgid",
        "desc": ""
      },
      {
        "name": "Getpgrp",
        "desc": ""
      },
      {
        "name": "Getpid",
        "desc": ""
      },
      {
        "name": "Getppid",
        "desc": ""
      },
      {
        "name": "Getpriority",
        "desc": ""
      },
      {
        "name": "Getrlimit",
        "desc": ""
      },
      {
        "name": "Getrusage",
        "desc": ""
      },
      {
        "name": "Getsid",
        "desc": ""
      },
      {
        "name": "Getsockname",
        "desc": ""
      },
      {
        "name": "Getsockopt",
        "desc": ""
      },
      {
        "name": "GetsockoptByte",
        "desc": ""
      },
      {
        "name": "GetsockoptICMPv6Filter",
        "desc": ""
      },
      {
        "name": "GetsockoptIPMreq",
        "desc": ""
      },
      {
        "name": "GetsockoptIPMreqn",
        "desc": ""
      },
      {
        "name": "GetsockoptIPv6MTUInfo",
        "desc": ""
      },
      {
        "name": "GetsockoptIPv6Mreq",
        "desc": ""
      },
      {
        "name": "GetsockoptInet4Addr",
        "desc": ""
      },
      {
        "name": "GetsockoptInt",
        "desc": ""
      },
      {
        "name": "GetsockoptUcred",
        "desc": ""
      },
      {
        "name": "Gettid",
        "desc": ""
      },
      {
        "name": "Gettimeofday",
        "desc": ""
      },
      {
        "name": "Getuid",
        "desc": ""
      },
      {
        "name": "Getwd",
        "desc": ""
      },
      {
        "name": "Getxattr",
        "desc": ""
      },
      {
        "name": "InotifyAddWatch",
        "desc": ""
      },
      {
        "name": "InotifyInit",
        "desc": ""
      },
      {
        "name": "InotifyInit1",
        "desc": ""
      },
      {
        "name": "InotifyRmWatch",
        "desc": ""
      },
      {
        "name": "Ioperm",
        "desc": ""
      },
      {
        "name": "Iopl",
        "desc": ""
      },
      {
        "name": "Issetugid",
        "desc": ""
      },
      {
        "name": "JoinPath",
        "desc": ""
      },
      {
        "name": "Kevent",
        "desc": ""
      },
      {
        "name": "Kill",
        "desc": ""
      },
      {
        "name": "Klogctl",
        "desc": ""
      },
      {
        "name": "Kqueue",
        "desc": ""
      },
      {
        "name": "Lchown",
        "desc": ""
      },
      {
        "name": "Link",
        "desc": "TODO(brainman): fix all needed for os"
      },
      {
        "name": "Listen",
        "desc": ""
      },
      {
        "name": "Listxattr",
        "desc": ""
      },
      {
        "name": "LoadCancelIoEx",
        "desc": ""
      },
      {
        "name": "LoadConnectEx",
        "desc": ""
      },
      {
        "name": "LoadCreateSymbolicLink",
        "desc": ""
      },
      {
        "name": "LoadDLL",
        "desc": "LoadDLL loads the named DLL file into memory.  If name is not an absolute path and is not a known system DLL used by Go, Windows will search for the named DLL in many locations, causing potential DLL preloading attacks.  Use [LazyDLL] in golang.org/x/sys/windows for a secure way to load system DLLs."
      },
      {
        "name": "LoadGetAddrInfo",
        "desc": ""
      },
      {
        "name": "LoadLibrary",
        "desc": ""
      },
      {
        "name": "LoadSetFileCompletionNotificationModes",
        "desc": ""
      },
      {
        "name": "LocalFree",
        "desc": ""
      },
      {
        "name": "LookupAccountName",
        "desc": ""
      },
      {
        "name": "LookupAccountSid",
        "desc": ""
      },
      {
        "name": "LookupSID",
        "desc": "LookupSID retrieves a security identifier sid for the account and the name of the domain on which the account was found. System specify target computer to search."
      },
      {
        "name": "LsfSocket",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "Lstat",
        "desc": ""
      },
      {
        "name": "Madvise",
        "desc": ""
      },
      {
        "name": "MapViewOfFile",
        "desc": ""
      },
      {
        "name": "Mkdir",
        "desc": ""
      },
      {
        "name": "Mkdirat",
        "desc": ""
      },
      {
        "name": "Mkfifo",
        "desc": ""
      },
      {
        "name": "Mknod",
        "desc": ""
      },
      {
        "name": "Mknodat",
        "desc": ""
      },
      {
        "name": "Mlock",
        "desc": ""
      },
      {
        "name": "Mlockall",
        "desc": ""
      },
      {
        "name": "Mmap",
        "desc": ""
      },
      {
        "name": "Mount",
        "desc": ""
      },
      {
        "name": "MoveFile",
        "desc": ""
      },
      {
        "name": "Mprotect",
        "desc": ""
      },
      {
        "name": "Munlock",
        "desc": ""
      },
      {
        "name": "Munlockall",
        "desc": ""
      },
      {
        "name": "Munmap",
        "desc": ""
      },
      {
        "name": "Nanosleep",
        "desc": ""
      },
      {
        "name": "NetApiBufferFree",
        "desc": ""
      },
      {
        "name": "NetGetJoinInformation",
        "desc": ""
      },
      {
        "name": "NetUserGetInfo",
        "desc": ""
      },
      {
        "name": "NetlinkRIB",
        "desc": "NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters."
      },
      {
        "name": "NewCallback",
        "desc": "NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention. This is useful when interoperating with Windows code requiring callbacks. The argument is expected to be a function with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr. Only a limited number of callbacks may be created in a single Go process, and any memory allocated for these callbacks is never released. Between NewCallback and NewCallbackCDecl, at least 1024 callbacks can always be created."
      },
      {
        "name": "NewCallbackCDecl",
        "desc": "NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention. This is useful when interoperating with Windows code requiring callbacks. The argument is expected to be a function with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr. Only a limited number of callbacks may be created in a single Go process, and any memory allocated for these callbacks is never released. Between NewCallback and NewCallbackCDecl, at least 1024 callbacks can always be created."
      },
      {
        "name": "NewError",
        "desc": "NewError converts s to an ErrorString, which satisfies the Error interface."
      },
      {
        "name": "Ntohs",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "OpenCurrentProcessToken",
        "desc": "OpenCurrentProcessToken opens the access token associated with current process."
      },
      {
        "name": "OpenProcess",
        "desc": ""
      },
      {
        "name": "OpenProcessToken",
        "desc": ""
      },
      {
        "name": "Openat",
        "desc": ""
      },
      {
        "name": "ParseDirent",
        "desc": "ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice."
      },
      {
        "name": "ParseNetlinkMessage",
        "desc": "ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures."
      },
      {
        "name": "ParseNetlinkRouteAttr",
        "desc": "ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures."
      },
      {
        "name": "ParseRoutingMessage",
        "desc": "ParseRoutingMessage parses b as routing messages and returns the slice containing the [RoutingMessage] interfaces.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "ParseRoutingSockaddr",
        "desc": "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and returns the slice containing the [Sockaddr] interfaces.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "ParseSocketControlMessage",
        "desc": "ParseSocketControlMessage parses b as an array of socket control messages."
      },
      {
        "name": "ParseUnixCredentials",
        "desc": "ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket."
      },
      {
        "name": "ParseUnixRights",
        "desc": "ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process."
      },
      {
        "name": "Pathconf",
        "desc": ""
      },
      {
        "name": "Pause",
        "desc": ""
      },
      {
        "name": "Pipe",
        "desc": ""
      },
      {
        "name": "Pipe2",
        "desc": ""
      },
      {
        "name": "PivotRoot",
        "desc": ""
      },
      {
        "name": "PostQueuedCompletionStatus",
        "desc": "Deprecated: PostQueuedCompletionStatus has the wrong function signature. Use x/sys/windows.PostQueuedCompletionStatus."
      },
      {
        "name": "Pread",
        "desc": ""
      },
      {
        "name": "ProcExit",
        "desc": ""
      },
      {
        "name": "Process32First",
        "desc": ""
      },
      {
        "name": "Process32Next",
        "desc": ""
      },
      {
        "name": "PtraceAttach",
        "desc": ""
      },
      {
        "name": "PtraceCont",
        "desc": ""
      },
      {
        "name": "PtraceDetach",
        "desc": ""
      },
      {
        "name": "PtraceGetEventMsg",
        "desc": ""
      },
      {
        "name": "PtraceGetRegs",
        "desc": ""
      },
      {
        "name": "PtracePeekData",
        "desc": ""
      },
      {
        "name": "PtracePeekText",
        "desc": ""
      },
      {
        "name": "PtracePokeData",
        "desc": ""
      },
      {
        "name": "PtracePokeText",
        "desc": ""
      },
      {
        "name": "PtraceSetOptions",
        "desc": ""
      },
      {
        "name": "PtraceSetRegs",
        "desc": ""
      },
      {
        "name": "PtraceSingleStep",
        "desc": ""
      },
      {
        "name": "PtraceSyscall",
        "desc": ""
      },
      {
        "name": "Pwrite",
        "desc": ""
      },
      {
        "name": "RandomGet",
        "desc": ""
      },
      {
        "name": "RawSyscall",
        "desc": ""
      },
      {
        "name": "RawSyscall6",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadConsole",
        "desc": ""
      },
      {
        "name": "ReadDir",
        "desc": ""
      },
      {
        "name": "ReadDirectoryChanges",
        "desc": ""
      },
      {
        "name": "ReadDirent",
        "desc": ""
      },
      {
        "name": "ReadFile",
        "desc": ""
      },
      {
        "name": "Readlink",
        "desc": "Readlink returns the destination of the named symbolic link."
      },
      {
        "name": "Reboot",
        "desc": ""
      },
      {
        "name": "Recvfrom",
        "desc": ""
      },
      {
        "name": "Recvmsg",
        "desc": ""
      },
      {
        "name": "RegCloseKey",
        "desc": ""
      },
      {
        "name": "RegEnumKeyEx",
        "desc": "RegEnumKeyEx enumerates the subkeys of an open registry key. Each call retrieves information about one subkey. name is a buffer that should be large enough to hold the name of the subkey plus a null terminating character. nameLen is its length. On return, nameLen will contain the actual length of the subkey.  Should name not be large enough to hold the subkey, this function will return ERROR_MORE_DATA, and must be called again with an appropriately sized buffer.  reserved must be nil. class and classLen behave like name and nameLen but for the class of the subkey, except that they are optional. lastWriteTime, if not nil, will be populated with the time the subkey was last written.  The caller must enumerate all subkeys in order. That is RegEnumKeyEx must be called with index starting at 0, incrementing the index until the function returns ERROR_NO_MORE_ITEMS, or with the index of the last subkey (obtainable from RegQueryInfoKey), decrementing until index 0 is enumerated.  Successive calls to this API must happen on the same OS thread, so call [runtime.LockOSThread] before calling this function."
      },
      {
        "name": "RegOpenKeyEx",
        "desc": ""
      },
      {
        "name": "RegQueryInfoKey",
        "desc": ""
      },
      {
        "name": "RegQueryValueEx",
        "desc": ""
      },
      {
        "name": "Remove",
        "desc": ""
      },
      {
        "name": "RemoveDirectory",
        "desc": ""
      },
      {
        "name": "Removexattr",
        "desc": ""
      },
      {
        "name": "Rename",
        "desc": ""
      },
      {
        "name": "Renameat",
        "desc": ""
      },
      {
        "name": "Revoke",
        "desc": ""
      },
      {
        "name": "Rmdir",
        "desc": ""
      },
      {
        "name": "RouteRIB",
        "desc": "RouteRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "Select",
        "desc": ""
      },
      {
        "name": "Sendfile",
        "desc": ""
      },
      {
        "name": "Sendmsg",
        "desc": ""
      },
      {
        "name": "SendmsgN",
        "desc": ""
      },
      {
        "name": "Sendto",
        "desc": ""
      },
      {
        "name": "SetBpf",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfBuflen",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfDatalink",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfHeadercmpl",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfImmediate",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfInterface",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfPromisc",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetBpfTimeout",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetCurrentDirectory",
        "desc": ""
      },
      {
        "name": "SetEndOfFile",
        "desc": ""
      },
      {
        "name": "SetEnvironmentVariable",
        "desc": ""
      },
      {
        "name": "SetFileAttributes",
        "desc": ""
      },
      {
        "name": "SetFileCompletionNotificationModes",
        "desc": ""
      },
      {
        "name": "SetFilePointer",
        "desc": ""
      },
      {
        "name": "SetFileTime",
        "desc": ""
      },
      {
        "name": "SetHandleInformation",
        "desc": ""
      },
      {
        "name": "SetKevent",
        "desc": ""
      },
      {
        "name": "SetLsfPromisc",
        "desc": "Deprecated: Use golang.org/x/net/bpf instead."
      },
      {
        "name": "SetNonblock",
        "desc": ""
      },
      {
        "name": "SetReadDeadline",
        "desc": ""
      },
      {
        "name": "SetWriteDeadline",
        "desc": ""
      },
      {
        "name": "Setdomainname",
        "desc": ""
      },
      {
        "name": "Setegid",
        "desc": ""
      },
      {
        "name": "Setenv",
        "desc": ""
      },
      {
        "name": "Seteuid",
        "desc": ""
      },
      {
        "name": "Setfsgid",
        "desc": ""
      },
      {
        "name": "Setfsuid",
        "desc": ""
      },
      {
        "name": "Setgid",
        "desc": ""
      },
      {
        "name": "Setgroups",
        "desc": ""
      },
      {
        "name": "Sethostname",
        "desc": ""
      },
      {
        "name": "Setlogin",
        "desc": ""
      },
      {
        "name": "Setpgid",
        "desc": ""
      },
      {
        "name": "Setpriority",
        "desc": ""
      },
      {
        "name": "Setprivexec",
        "desc": ""
      },
      {
        "name": "Setregid",
        "desc": ""
      },
      {
        "name": "Setresgid",
        "desc": ""
      },
      {
        "name": "Setresuid",
        "desc": ""
      },
      {
        "name": "Setreuid",
        "desc": ""
      },
      {
        "name": "Setrlimit",
        "desc": ""
      },
      {
        "name": "Setsid",
        "desc": ""
      },
      {
        "name": "Setsockopt",
        "desc": ""
      },
      {
        "name": "SetsockoptByte",
        "desc": ""
      },
      {
        "name": "SetsockoptICMPv6Filter",
        "desc": ""
      },
      {
        "name": "SetsockoptIPMreq",
        "desc": ""
      },
      {
        "name": "SetsockoptIPMreqn",
        "desc": ""
      },
      {
        "name": "SetsockoptIPv6Mreq",
        "desc": ""
      },
      {
        "name": "SetsockoptInet4Addr",
        "desc": ""
      },
      {
        "name": "SetsockoptInt",
        "desc": ""
      },
      {
        "name": "SetsockoptLinger",
        "desc": ""
      },
      {
        "name": "SetsockoptString",
        "desc": ""
      },
      {
        "name": "SetsockoptTimeval",
        "desc": ""
      },
      {
        "name": "Settimeofday",
        "desc": ""
      },
      {
        "name": "Setuid",
        "desc": ""
      },
      {
        "name": "Setxattr",
        "desc": ""
      },
      {
        "name": "Shutdown",
        "desc": ""
      },
      {
        "name": "SlicePtrFromStrings",
        "desc": "SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, [EINVAL])."
      },
      {
        "name": "Socket",
        "desc": ""
      },
      {
        "name": "Socketpair",
        "desc": ""
      },
      {
        "name": "Splice",
        "desc": ""
      },
      {
        "name": "StartProcess",
        "desc": "StartProcess wraps [ForkExec] for package os."
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "Statfs",
        "desc": ""
      },
      {
        "name": "StopIO",
        "desc": ""
      },
      {
        "name": "StringBytePtr",
        "desc": "StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.  Deprecated: Use [BytePtrFromString] instead."
      },
      {
        "name": "StringByteSlice",
        "desc": "StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.  Deprecated: Use ByteSliceFromString instead."
      },
      {
        "name": "StringSlicePtr",
        "desc": "StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.  Deprecated: Use SlicePtrFromStrings instead."
      },
      {
        "name": "StringToSid",
        "desc": "StringToSid converts a string-format security identifier sid into a valid, functional sid."
      },
      {
        "name": "StringToUTF16",
        "desc": "StringToUTF16 returns the UTF-16 encoding of the UTF-8 string s, with a terminating NUL added. If s contains a NUL byte this function panics instead of returning an error.  Deprecated: Use [UTF16FromString] instead."
      },
      {
        "name": "StringToUTF16Ptr",
        "desc": "StringToUTF16Ptr returns pointer to the UTF-16 encoding of the UTF-8 string s, with a terminating NUL added. If s contains a NUL byte this function panics instead of returning an error.  Deprecated: Use [UTF16PtrFromString] instead."
      },
      {
        "name": "Symlink",
        "desc": ""
      },
      {
        "name": "Sync",
        "desc": ""
      },
      {
        "name": "SyncFileRange",
        "desc": ""
      },
      {
        "name": "Syscall",
        "desc": "Deprecated: Use [SyscallN] instead."
      },
      {
        "name": "Syscall12",
        "desc": "Deprecated: Use [SyscallN] instead."
      },
      {
        "name": "Syscall15",
        "desc": "Deprecated: Use [SyscallN] instead."
      },
      {
        "name": "Syscall18",
        "desc": "Deprecated: Use [SyscallN] instead."
      },
      {
        "name": "Syscall6",
        "desc": "Deprecated: Use [SyscallN] instead."
      },
      {
        "name": "Syscall9",
        "desc": "Deprecated: Use [SyscallN] instead."
      },
      {
        "name": "SyscallN",
        "desc": ""
      },
      {
        "name": "Sysctl",
        "desc": ""
      },
      {
        "name": "SysctlUint32",
        "desc": ""
      },
      {
        "name": "Sysinfo",
        "desc": ""
      },
      {
        "name": "Tcgetpgrp",
        "desc": ""
      },
      {
        "name": "Tcsetpgrp",
        "desc": ""
      },
      {
        "name": "Tee",
        "desc": ""
      },
      {
        "name": "TerminateProcess",
        "desc": ""
      },
      {
        "name": "Tgkill",
        "desc": ""
      },
      {
        "name": "Time",
        "desc": ""
      },
      {
        "name": "Times",
        "desc": ""
      },
      {
        "name": "TimespecToNsec",
        "desc": "TimespecToNsec returns the time stored in ts as nanoseconds."
      },
      {
        "name": "TimevalToNsec",
        "desc": "TimevalToNsec returns the time stored in tv as nanoseconds."
      },
      {
        "name": "TranslateAccountName",
        "desc": "TranslateAccountName converts a directory service object name from one format to another."
      },
      {
        "name": "TranslateName",
        "desc": ""
      },
      {
        "name": "TransmitFile",
        "desc": ""
      },
      {
        "name": "Truncate",
        "desc": ""
      },
      {
        "name": "UTF16FromString",
        "desc": "UTF16FromString returns the UTF-16 encoding of the UTF-8 string s, with a terminating NUL added. If s contains a NUL byte at any location, it returns (nil, [EINVAL]). Unpaired surrogates are encoded using WTF-8."
      },
      {
        "name": "UTF16PtrFromString",
        "desc": "UTF16PtrFromString returns pointer to the UTF-16 encoding of the UTF-8 string s, with a terminating NUL added. If s contains a NUL byte at any location, it returns (nil, EINVAL). Unpaired surrogates are encoded using WTF-8."
      },
      {
        "name": "UTF16ToString",
        "desc": "UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s, with a terminating NUL removed. Unpaired surrogates are decoded using WTF-8 instead of UTF-8 encoding."
      },
      {
        "name": "Umask",
        "desc": ""
      },
      {
        "name": "Uname",
        "desc": ""
      },
      {
        "name": "Undelete",
        "desc": ""
      },
      {
        "name": "UnixCredentials",
        "desc": "UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication."
      },
      {
        "name": "UnixRights",
        "desc": "UnixRights encodes a set of open file descriptors into a socket control message for sending to another process."
      },
      {
        "name": "Unlink",
        "desc": ""
      },
      {
        "name": "Unlinkat",
        "desc": ""
      },
      {
        "name": "UnmapViewOfFile",
        "desc": ""
      },
      {
        "name": "UnmarshalDir",
        "desc": "UnmarshalDir decodes a single 9P stat message from b and returns the resulting Dir.  If b is too small to hold a valid stat message, [ErrShortStat] is returned.  If the stat message itself is invalid, [ErrBadStat] is returned."
      },
      {
        "name": "Unmount",
        "desc": ""
      },
      {
        "name": "Unsetenv",
        "desc": ""
      },
      {
        "name": "Unshare",
        "desc": ""
      },
      {
        "name": "Ustat",
        "desc": ""
      },
      {
        "name": "Utime",
        "desc": ""
      },
      {
        "name": "Utimes",
        "desc": ""
      },
      {
        "name": "UtimesNano",
        "desc": ""
      },
      {
        "name": "VirtualLock",
        "desc": ""
      },
      {
        "name": "VirtualUnlock",
        "desc": ""
      },
      {
        "name": "WSACleanup",
        "desc": ""
      },
      {
        "name": "WSAEnumProtocols",
        "desc": ""
      },
      {
        "name": "WSAIoctl",
        "desc": ""
      },
      {
        "name": "WSARecv",
        "desc": ""
      },
      {
        "name": "WSARecvFrom",
        "desc": ""
      },
      {
        "name": "WSASend",
        "desc": ""
      },
      {
        "name": "WSASendTo",
        "desc": ""
      },
      {
        "name": "WSASendto",
        "desc": ""
      },
      {
        "name": "WSAStartup",
        "desc": ""
      },
      {
        "name": "Wait4",
        "desc": ""
      },
      {
        "name": "WaitForSingleObject",
        "desc": ""
      },
      {
        "name": "WaitProcess",
        "desc": "WaitProcess waits until the pid of a running process is found in the queue of wait messages. It is used in conjunction with [ForkExec]/[StartProcess] to wait for a running process to exit."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "WriteConsole",
        "desc": ""
      },
      {
        "name": "WriteFile",
        "desc": ""
      },
      {
        "name": "Wstat",
        "desc": ""
      },
      {
        "name": "_DnsQuery",
        "desc": ""
      },
      {
        "name": "_GetHostByName",
        "desc": ""
      },
      {
        "name": "_GetProcAddress",
        "desc": ""
      },
      {
        "name": "_GetProtoByName",
        "desc": ""
      },
      {
        "name": "_GetServByName",
        "desc": ""
      },
      {
        "name": "_LoadLibrary",
        "desc": ""
      },
      {
        "name": "accept",
        "desc": ""
      },
      {
        "name": "accept4",
        "desc": ""
      },
      {
        "name": "acquireForkLock",
        "desc": "acquireForkLock acquires a write lock on ForkLock. ForkLock is exported and we've promised that during a fork we will call ForkLock.Lock, so that no other threads create new fds that are not yet close-on-exec before we fork. But that forces all fork calls to be serialized, which is bad. But we haven't promised that serialization, and it is essentially undetectable by other users of ForkLock, which is good. Avoid the serialization by ensuring that ForkLock is locked at the first fork and unlocked when there are no more forks."
      },
      {
        "name": "adjustFileLimit",
        "desc": "adjustFileLimit adds per-OS limitations on the Rlimit used for RLIMIT_NOFILE. See rlimit.go."
      },
      {
        "name": "anyToSockaddr",
        "desc": ""
      },
      {
        "name": "appendCleanPath",
        "desc": ""
      },
      {
        "name": "appendEscapeArg",
        "desc": "appendEscapeArg escapes the string s, as per escapeArg, appends the result to b, and returns the updated slice."
      },
      {
        "name": "atoi",
        "desc": ""
      },
      {
        "name": "await",
        "desc": ""
      },
      {
        "name": "bind",
        "desc": ""
      },
      {
        "name": "capToIndex",
        "desc": "See CAP_TO_INDEX in linux/capability.h:"
      },
      {
        "name": "capToMask",
        "desc": "See CAP_TO_MASK in linux/capability.h:"
      },
      {
        "name": "cexecPipe",
        "desc": ""
      },
      {
        "name": "cgocaller",
        "desc": "linked by runtime.cgocall.go"
      },
      {
        "name": "chdir",
        "desc": ""
      },
      {
        "name": "checkErrMessageContent",
        "desc": "checkErrMessageContent checks if err message contains one of msgs."
      },
      {
        "name": "checkPath",
        "desc": "checkPath checks that the path is not empty and that it contains no null characters."
      },
      {
        "name": "clen",
        "desc": "clen returns the index of the first NULL byte in n or len(n) if n contains no NULL byte."
      },
      {
        "name": "closeFdExcept",
        "desc": "close the numbered file descriptor, unless it is fd1, fd2, or a member of fds."
      },
      {
        "name": "closedir",
        "desc": ""
      },
      {
        "name": "cmsgAlignOf",
        "desc": "Round the length of a raw sockaddr up to align it properly."
      },
      {
        "name": "compileCallback",
        "desc": "Implemented in runtime/syscall_windows.go."
      },
      {
        "name": "connect",
        "desc": ""
      },
      {
        "name": "connectEx",
        "desc": ""
      },
      {
        "name": "contains",
        "desc": "contains is a local version of strings.Contains. It knows len(sep) \u003e 1."
      },
      {
        "name": "copyFindData",
        "desc": ""
      },
      {
        "name": "create",
        "desc": ""
      },
      {
        "name": "createEnvBlock",
        "desc": "createEnvBlock converts an array of environment strings into the representation required by CreateProcess: a sequence of NUL terminated strings followed by a nil. Last bytes are two UCS-2 NULs, or four NUL bytes. If any string contains a NUL, it returns (nil, EINVAL)."
      },
      {
        "name": "createFile",
        "desc": ""
      },
      {
        "name": "createIoCompletionPort",
        "desc": ""
      },
      {
        "name": "cstring",
        "desc": ""
      },
      {
        "name": "decodeWTF16",
        "desc": "decodeWTF16 returns the WTF-8 encoding of the potentially ill-formed UTF-16 s."
      },
      {
        "name": "deleteProcThreadAttributeList",
        "desc": ""
      },
      {
        "name": "direntIno",
        "desc": ""
      },
      {
        "name": "direntNamlen",
        "desc": ""
      },
      {
        "name": "direntReclen",
        "desc": ""
      },
      {
        "name": "doCheckClonePidfd",
        "desc": "doCheckClonePidfd implements the actual clone call of os_checkClonePidfd and child execution. This is a separate function so we can separate the child's and parent's stack frames if we're using vfork.  This is go:noinline because the point is to keep the stack frames of this and os_checkClonePidfd separate."
      },
      {
        "name": "dup2child",
        "desc": ""
      },
      {
        "name": "dup3",
        "desc": ""
      },
      {
        "name": "encodeWTF16",
        "desc": "encodeWTF16 returns the potentially ill-formed UTF-16 encoding of s."
      },
      {
        "name": "errnoErr",
        "desc": "errnoErr returns common boxed Errno values, to prevent allocations at runtime."
      },
      {
        "name": "errstr",
        "desc": ""
      },
      {
        "name": "execve",
        "desc": ""
      },
      {
        "name": "exit",
        "desc": ""
      },
      {
        "name": "exitThread",
        "desc": ""
      },
      {
        "name": "extpread",
        "desc": ""
      },
      {
        "name": "extpwrite",
        "desc": ""
      },
      {
        "name": "faccessat",
        "desc": ""
      },
      {
        "name": "faccessat2",
        "desc": ""
      },
      {
        "name": "faketimeWrite",
        "desc": ""
      },
      {
        "name": "fchmodat",
        "desc": ""
      },
      {
        "name": "fchmodat2",
        "desc": ""
      },
      {
        "name": "fcntl",
        "desc": ""
      },
      {
        "name": "fcntl1",
        "desc": ""
      },
      {
        "name": "fcntlPtr",
        "desc": ""
      },
      {
        "name": "fd2path",
        "desc": ""
      },
      {
        "name": "fdToFile",
        "desc": ""
      },
      {
        "name": "fd_fdstat_get_flags",
        "desc": ""
      },
      {
        "name": "fd_fdstat_get_type",
        "desc": ""
      },
      {
        "name": "fdopendir",
        "desc": ""
      },
      {
        "name": "fdpath",
        "desc": ""
      },
      {
        "name": "fillStat_t",
        "desc": ""
      },
      {
        "name": "findFirstFile1",
        "desc": ""
      },
      {
        "name": "findNextFile1",
        "desc": ""
      },
      {
        "name": "fixwd",
        "desc": "If any of the paths is relative, call Fixwd and return true (locked to OS thread). Otherwise return false."
      },
      {
        "name": "fixwdLocked",
        "desc": ""
      },
      {
        "name": "fork",
        "desc": ""
      },
      {
        "name": "forkAndExecFailureCleanup",
        "desc": "forkAndExecFailureCleanup cleans up after an exec failure."
      },
      {
        "name": "forkAndExecInChild",
        "desc": "Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child. If a dup or exec fails, write the errno error to pipe. (Pipe is close-on-exec so if exec succeeds, it will be closed.) In the child, this function must not acquire any locks, because they might have been locked at the time of the fork. This means no rescheduling, no malloc calls, and no new stack segments. For the same reason compiler does not race instrument it. The calls to RawSyscall are okay because they are assembly functions that do not grow the stack."
      },
      {
        "name": "forkAndExecInChild1",
        "desc": "forkAndExecInChild1 implements the body of forkAndExecInChild up to the parent's post-fork path. This is a separate function so we can separate the child's and parent's stack frames if we're using vfork.  This is go:noinline because the point is to keep the stack frames of this and forkAndExecInChild separate."
      },
      {
        "name": "forkExec",
        "desc": ""
      },
      {
        "name": "forkExecPipe",
        "desc": "forkExecPipe opens a pipe and non-atomically sets O_CLOEXEC on both file descriptors."
      },
      {
        "name": "forkx",
        "desc": ""
      },
      {
        "name": "formatIDMappings",
        "desc": ""
      },
      {
        "name": "formatMessage",
        "desc": ""
      },
      {
        "name": "fsCall",
        "desc": ""
      },
      {
        "name": "fstat",
        "desc": ""
      },
      {
        "name": "fstatat",
        "desc": ""
      },
      {
        "name": "fstatatInternal",
        "desc": ""
      },
      {
        "name": "fsyncRange",
        "desc": ""
      },
      {
        "name": "futimes",
        "desc": ""
      },
      {
        "name": "futimesat",
        "desc": ""
      },
      {
        "name": "gbit16",
        "desc": "gbit16 reads a 16-bit number in little-endian order from b and returns it with the remaining slice of b."
      },
      {
        "name": "gbit32",
        "desc": "gbit32 reads a 32-bit number in little-endian order from b and returns it with the remaining slice of b."
      },
      {
        "name": "gbit64",
        "desc": "gbit64 reads a 64-bit number in little-endian order from b and returns it with the remaining slice of b."
      },
      {
        "name": "gbit8",
        "desc": "gbit8 reads an 8-bit number from b and returns it with the remaining slice of b."
      },
      {
        "name": "gdirname",
        "desc": "gdirname returns the first filename from a buffer of directory entries, and a slice containing the remaining directory entries. If the buffer doesn't start with a valid directory entry, the returned name is nil."
      },
      {
        "name": "getCurrentProcessId",
        "desc": ""
      },
      {
        "name": "getFinalPathNameByHandle",
        "desc": ""
      },
      {
        "name": "getProcessEntry",
        "desc": ""
      },
      {
        "name": "getQueuedCompletionStatus",
        "desc": ""
      },
      {
        "name": "getStartupInfo",
        "desc": ""
      },
      {
        "name": "getcwd",
        "desc": ""
      },
      {
        "name": "getdents",
        "desc": ""
      },
      {
        "name": "getdirent",
        "desc": ""
      },
      {
        "name": "getdirentries",
        "desc": ""
      },
      {
        "name": "getexecname",
        "desc": ""
      },
      {
        "name": "getfsstat",
        "desc": ""
      },
      {
        "name": "getgroups",
        "desc": ""
      },
      {
        "name": "gethostname",
        "desc": ""
      },
      {
        "name": "getpeername",
        "desc": ""
      },
      {
        "name": "getpid",
        "desc": ""
      },
      {
        "name": "getprocaddress",
        "desc": ""
      },
      {
        "name": "getsockname",
        "desc": ""
      },
      {
        "name": "getsockopt",
        "desc": ""
      },
      {
        "name": "gettimeofday",
        "desc": ""
      },
      {
        "name": "getwd",
        "desc": "goroutine-specific getwd"
      },
      {
        "name": "gstring",
        "desc": "gstring reads a string from b, prefixed with a 16-bit length in little-endian order. It returns the string with the remaining slice of b and a boolean. If the length is greater than the number of bytes in b, the boolean will be false."
      },
      {
        "name": "gstringb",
        "desc": "gstringb reads a non-empty string from b, prefixed with a 16-bit length in little-endian order. It returns the string as a byte slice, or nil if b is too short to contain the length or the full string."
      },
      {
        "name": "hasWaitingReaders",
        "desc": "hasWaitingReaders reports whether any goroutine is waiting to acquire a read lock on rw. It is defined in the sync package."
      },
      {
        "name": "init",
        "desc": "syscall defines this global on our behalf to avoid a build dependency on other platforms"
      },
      {
        "name": "initializeProcThreadAttributeList",
        "desc": ""
      },
      {
        "name": "ioctl",
        "desc": ""
      },
      {
        "name": "ioctlPtr",
        "desc": ""
      },
      {
        "name": "isAbs",
        "desc": ""
      },
      {
        "name": "isCapDacOverrideSet",
        "desc": ""
      },
      {
        "name": "isDir",
        "desc": ""
      },
      {
        "name": "isGroupMember",
        "desc": ""
      },
      {
        "name": "isSlash",
        "desc": ""
      },
      {
        "name": "joinExeDirAndFName",
        "desc": ""
      },
      {
        "name": "joinPath",
        "desc": "joinPath concatenates dir and file paths, producing a cleaned path where \".\" and \"..\" have been removed, unless dir is relative and the references to parent directories in file represented a location relative to a parent of dir.  This function is used for path resolution of all wasi functions expecting a path argument; the returned string is heap allocated, which we may want to optimize in the future. Instead of returning a string, the function could append the result to an output buffer that the functions in this file can manage to have allocated on the stack (e.g. initializing to a fixed capacity). Since it will significantly increase code complexity, we prefer to optimize for readability and maintainability at this time."
      },
      {
        "name": "kevent",
        "desc": ""
      },
      {
        "name": "kill",
        "desc": ""
      },
      {
        "name": "langid",
        "desc": ""
      },
      {
        "name": "libc_accept4_trampoline",
        "desc": ""
      },
      {
        "name": "libc_accept_trampoline",
        "desc": ""
      },
      {
        "name": "libc_access_trampoline",
        "desc": ""
      },
      {
        "name": "libc_adjtime_trampoline",
        "desc": ""
      },
      {
        "name": "libc_bind_trampoline",
        "desc": ""
      },
      {
        "name": "libc_chdir_trampoline",
        "desc": ""
      },
      {
        "name": "libc_chflags_trampoline",
        "desc": ""
      },
      {
        "name": "libc_chmod_trampoline",
        "desc": ""
      },
      {
        "name": "libc_chown_trampoline",
        "desc": ""
      },
      {
        "name": "libc_chroot_trampoline",
        "desc": ""
      },
      {
        "name": "libc_close_trampoline",
        "desc": ""
      },
      {
        "name": "libc_closedir_trampoline",
        "desc": ""
      },
      {
        "name": "libc_connect_trampoline",
        "desc": ""
      },
      {
        "name": "libc_dup2_trampoline",
        "desc": ""
      },
      {
        "name": "libc_dup3_trampoline",
        "desc": ""
      },
      {
        "name": "libc_dup_trampoline",
        "desc": ""
      },
      {
        "name": "libc_exchangedata_trampoline",
        "desc": ""
      },
      {
        "name": "libc_execve_trampoline",
        "desc": ""
      },
      {
        "name": "libc_exit_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fchdir_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fchflags_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fchmod_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fchown_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fcntl_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fdopendir_trampoline",
        "desc": ""
      },
      {
        "name": "libc_flock_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fork_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fpathconf_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fstat64_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fstat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fstatat64_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fstatat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fstatfs64_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fstatfs_trampoline",
        "desc": ""
      },
      {
        "name": "libc_fsync_trampoline",
        "desc": ""
      },
      {
        "name": "libc_ftruncate_trampoline",
        "desc": ""
      },
      {
        "name": "libc_futimes_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getcwd_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getdents_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getdtablesize_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getegid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_geteuid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getfsstat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getgid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getgroups_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getpeername_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getpgid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getpgrp_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getpid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getppid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getpriority_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getrlimit_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getrusage_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getsid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getsockname_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getsockopt_trampoline",
        "desc": ""
      },
      {
        "name": "libc_gettimeofday_trampoline",
        "desc": ""
      },
      {
        "name": "libc_getuid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_ioctl_trampoline",
        "desc": ""
      },
      {
        "name": "libc_issetugid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_kevent_trampoline",
        "desc": ""
      },
      {
        "name": "libc_kill_trampoline",
        "desc": ""
      },
      {
        "name": "libc_kqueue_trampoline",
        "desc": ""
      },
      {
        "name": "libc_lchown_trampoline",
        "desc": ""
      },
      {
        "name": "libc_link_trampoline",
        "desc": ""
      },
      {
        "name": "libc_listen_trampoline",
        "desc": ""
      },
      {
        "name": "libc_lseek_trampoline",
        "desc": ""
      },
      {
        "name": "libc_lstat64_trampoline",
        "desc": ""
      },
      {
        "name": "libc_lstat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mkdir_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mkfifo_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mknod_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mlock_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mlockall_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mmap_trampoline",
        "desc": ""
      },
      {
        "name": "libc_mprotect_trampoline",
        "desc": ""
      },
      {
        "name": "libc_msync_trampoline",
        "desc": ""
      },
      {
        "name": "libc_munlock_trampoline",
        "desc": ""
      },
      {
        "name": "libc_munlockall_trampoline",
        "desc": ""
      },
      {
        "name": "libc_munmap_trampoline",
        "desc": ""
      },
      {
        "name": "libc_nanosleep_trampoline",
        "desc": ""
      },
      {
        "name": "libc_open_trampoline",
        "desc": ""
      },
      {
        "name": "libc_openat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_pathconf_trampoline",
        "desc": ""
      },
      {
        "name": "libc_pipe2_trampoline",
        "desc": ""
      },
      {
        "name": "libc_pipe_trampoline",
        "desc": ""
      },
      {
        "name": "libc_pread_trampoline",
        "desc": ""
      },
      {
        "name": "libc_ptrace_trampoline",
        "desc": ""
      },
      {
        "name": "libc_pwrite_trampoline",
        "desc": ""
      },
      {
        "name": "libc_read_trampoline",
        "desc": ""
      },
      {
        "name": "libc_readdir_r_trampoline",
        "desc": ""
      },
      {
        "name": "libc_readlink_trampoline",
        "desc": ""
      },
      {
        "name": "libc_recvfrom_trampoline",
        "desc": ""
      },
      {
        "name": "libc_recvmsg_trampoline",
        "desc": ""
      },
      {
        "name": "libc_rename_trampoline",
        "desc": ""
      },
      {
        "name": "libc_revoke_trampoline",
        "desc": ""
      },
      {
        "name": "libc_rmdir_trampoline",
        "desc": ""
      },
      {
        "name": "libc_select_trampoline",
        "desc": ""
      },
      {
        "name": "libc_sendfile_trampoline",
        "desc": ""
      },
      {
        "name": "libc_sendmsg_trampoline",
        "desc": ""
      },
      {
        "name": "libc_sendto_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setegid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_seteuid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setgid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setgroups_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setlogin_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setpgid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setpriority_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setprivexec_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setregid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setreuid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setrlimit_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setsid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setsockopt_trampoline",
        "desc": ""
      },
      {
        "name": "libc_settimeofday_trampoline",
        "desc": ""
      },
      {
        "name": "libc_setuid_trampoline",
        "desc": ""
      },
      {
        "name": "libc_shutdown_trampoline",
        "desc": ""
      },
      {
        "name": "libc_socket_trampoline",
        "desc": ""
      },
      {
        "name": "libc_socketpair_trampoline",
        "desc": ""
      },
      {
        "name": "libc_stat64_trampoline",
        "desc": ""
      },
      {
        "name": "libc_stat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_statfs64_trampoline",
        "desc": ""
      },
      {
        "name": "libc_statfs_trampoline",
        "desc": ""
      },
      {
        "name": "libc_symlink_trampoline",
        "desc": ""
      },
      {
        "name": "libc_sync_trampoline",
        "desc": ""
      },
      {
        "name": "libc_sysctl_trampoline",
        "desc": ""
      },
      {
        "name": "libc_truncate_trampoline",
        "desc": ""
      },
      {
        "name": "libc_umask_trampoline",
        "desc": ""
      },
      {
        "name": "libc_undelete_trampoline",
        "desc": ""
      },
      {
        "name": "libc_unlink_trampoline",
        "desc": ""
      },
      {
        "name": "libc_unlinkat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_unmount_trampoline",
        "desc": ""
      },
      {
        "name": "libc_utimensat_trampoline",
        "desc": ""
      },
      {
        "name": "libc_utimes_trampoline",
        "desc": ""
      },
      {
        "name": "libc_wait4_trampoline",
        "desc": ""
      },
      {
        "name": "libc_write_trampoline",
        "desc": ""
      },
      {
        "name": "libc_writev_trampoline",
        "desc": ""
      },
      {
        "name": "linkat",
        "desc": ""
      },
      {
        "name": "listen",
        "desc": ""
      },
      {
        "name": "loadlibrary",
        "desc": ""
      },
      {
        "name": "loadsystemlibrary",
        "desc": ""
      },
      {
        "name": "localAlloc",
        "desc": ""
      },
      {
        "name": "lstat",
        "desc": ""
      },
      {
        "name": "makeCmdLine",
        "desc": "makeCmdLine builds a command line out of args by escaping \"special\" characters and joining the arguments with spaces."
      },
      {
        "name": "makedev",
        "desc": "makedev makes C dev_t from major and minor numbers the glibc way: 0xMMMM_MMMM 0xmmmm_mmmm -\u003e 0xMMMM_Mmmm_mmmM_MMmm"
      },
      {
        "name": "mapJSError",
        "desc": "mapJSError maps an error given by Node.js to the appropriate Go error."
      },
      {
        "name": "mknodat",
        "desc": ""
      },
      {
        "name": "mmap",
        "desc": "Linux on s390x uses the old mmap interface, which requires arguments to be passed in a struct. mmap2 also requires arguments to be passed in a struct; it is currently not exposed in \u003casm/unistd.h\u003e."
      },
      {
        "name": "mmap2",
        "desc": ""
      },
      {
        "name": "mount",
        "desc": ""
      },
      {
        "name": "msync",
        "desc": ""
      },
      {
        "name": "munmap",
        "desc": ""
      },
      {
        "name": "nametomib",
        "desc": "Translate \"kern.hostname\" to []_C_int{0,1,2,3}."
      },
      {
        "name": "netlinkMessageHeaderAndData",
        "desc": ""
      },
      {
        "name": "netlinkRouteAttrAndValue",
        "desc": ""
      },
      {
        "name": "newNetlinkRouteRequest",
        "desc": ""
      },
      {
        "name": "newProcThreadAttributeList",
        "desc": "newProcThreadAttributeList allocates a new [procThreadAttributeListContainer], with the requested maximum number of attributes."
      },
      {
        "name": "nlmAlignOf",
        "desc": "Round the length of a netlink message up to align it properly."
      },
      {
        "name": "normalizeDir",
        "desc": ""
      },
      {
        "name": "now",
        "desc": "Provided by package runtime."
      },
      {
        "name": "nsec",
        "desc": ""
      },
      {
        "name": "open",
        "desc": ""
      },
      {
        "name": "openat",
        "desc": ""
      },
      {
        "name": "os_checkClonePidfd",
        "desc": "checkClonePidfd verifies that clone(CLONE_PIDFD) works by actually doing a clone."
      },
      {
        "name": "paccept",
        "desc": ""
      },
      {
        "name": "parseLinkLayerAddr",
        "desc": "parseLinkLayerAddr parses b as a datalink socket address in conventional BSD kernel form."
      },
      {
        "name": "parseNetworkLayerAddr",
        "desc": "parseNetworkLayerAddr parses b as an internet socket address in conventional BSD kernel form."
      },
      {
        "name": "parseSockaddrInet",
        "desc": "parseSockaddrInet parses b as an internet socket address."
      },
      {
        "name": "parseSockaddrLink",
        "desc": "parseSockaddrLink parses b as a datalink socket address."
      },
      {
        "name": "pbit16",
        "desc": "pbit16 copies the 16-bit number v to b in little-endian order and returns the remaining slice of b."
      },
      {
        "name": "pbit32",
        "desc": "pbit32 copies the 32-bit number v to b in little-endian order and returns the remaining slice of b."
      },
      {
        "name": "pbit64",
        "desc": "pbit64 copies the 64-bit number v to b in little-endian order and returns the remaining slice of b."
      },
      {
        "name": "pbit8",
        "desc": "pbit8 copies the 8-bit number v to b and returns the remaining slice of b."
      },
      {
        "name": "pipe",
        "desc": ""
      },
      {
        "name": "pipe2",
        "desc": ""
      },
      {
        "name": "postQueuedCompletionStatus",
        "desc": ""
      },
      {
        "name": "ppoll",
        "desc": ""
      },
      {
        "name": "pread",
        "desc": ""
      },
      {
        "name": "prlimit",
        "desc": "prlimit changes a resource limit. We use a single definition so that we can tell StartProcess to not restore the original NOFILE limit.  golang.org/x/sys linknames prlimit. Do not remove or change the type signature."
      },
      {
        "name": "prlimit1",
        "desc": ""
      },
      {
        "name": "pselect",
        "desc": ""
      },
      {
        "name": "pstring",
        "desc": "pstring copies the string s to b, prepending it with a 16-bit length in little-endian order, and returning the remaining slice of b.."
      },
      {
        "name": "ptrace",
        "desc": ""
      },
      {
        "name": "ptrace64",
        "desc": ""
      },
      {
        "name": "ptrace64Ptr",
        "desc": ""
      },
      {
        "name": "ptracePeek",
        "desc": ""
      },
      {
        "name": "ptracePoke",
        "desc": ""
      },
      {
        "name": "ptracePtr",
        "desc": ""
      },
      {
        "name": "pwrite",
        "desc": ""
      },
      {
        "name": "rawSyscall",
        "desc": ""
      },
      {
        "name": "rawSyscall10X",
        "desc": ""
      },
      {
        "name": "rawSyscall6",
        "desc": "Implemented in runtime/syscall_aix.go."
      },
      {
        "name": "rawSyscall6Internal",
        "desc": ""
      },
      {
        "name": "rawSyscall6X",
        "desc": ""
      },
      {
        "name": "rawSyscallInternal",
        "desc": ""
      },
      {
        "name": "rawSyscallNoError",
        "desc": ""
      },
      {
        "name": "rawSysvicall6",
        "desc": "Implemented in asm_solaris_amd64.s."
      },
      {
        "name": "rawVforkSyscall",
        "desc": ""
      },
      {
        "name": "rawsocketcall",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "readFile",
        "desc": ""
      },
      {
        "name": "readInt",
        "desc": "readInt returns the size-bytes unsigned integer in native byte order at offset off."
      },
      {
        "name": "readIntBE",
        "desc": ""
      },
      {
        "name": "readIntLE",
        "desc": ""
      },
      {
        "name": "readdirnames",
        "desc": "readdirnames returns the names of files inside the directory represented by dirfd."
      },
      {
        "name": "readlen",
        "desc": ""
      },
      {
        "name": "readlink",
        "desc": ""
      },
      {
        "name": "readlinkat",
        "desc": ""
      },
      {
        "name": "readnum",
        "desc": ""
      },
      {
        "name": "reboot",
        "desc": ""
      },
      {
        "name": "recoverErr",
        "desc": ""
      },
      {
        "name": "recvfrom",
        "desc": ""
      },
      {
        "name": "recvfromInet4",
        "desc": ""
      },
      {
        "name": "recvfromInet6",
        "desc": ""
      },
      {
        "name": "recvmsg",
        "desc": ""
      },
      {
        "name": "recvmsgInet4",
        "desc": ""
      },
      {
        "name": "recvmsgInet6",
        "desc": ""
      },
      {
        "name": "recvmsgRaw",
        "desc": ""
      },
      {
        "name": "regEnumKeyEx",
        "desc": ""
      },
      {
        "name": "releaseForkLock",
        "desc": "releaseForkLock releases the conceptual write lock on ForkLock acquired by acquireForkLock."
      },
      {
        "name": "remove",
        "desc": ""
      },
      {
        "name": "renameat2",
        "desc": ""
      },
      {
        "name": "rsaAlignOf",
        "desc": "Round the length of a raw sockaddr up to align it properly."
      },
      {
        "name": "rtaAlignOf",
        "desc": "Round the length of a netlink route attribute up to align it properly."
      },
      {
        "name": "runtimeSetenv",
        "desc": "runtimeSetenv and runtimeUnsetenv are provided by the runtime."
      },
      {
        "name": "runtimeUnsetenv",
        "desc": ""
      },
      {
        "name": "runtimeWrite",
        "desc": ""
      },
      {
        "name": "runtime_AfterExec",
        "desc": ""
      },
      {
        "name": "runtime_AfterFork",
        "desc": ""
      },
      {
        "name": "runtime_AfterForkInChild",
        "desc": ""
      },
      {
        "name": "runtime_BeforeExec",
        "desc": "Implemented in runtime package."
      },
      {
        "name": "runtime_BeforeFork",
        "desc": "Implemented in runtime package."
      },
      {
        "name": "runtime_doAllThreadsSyscall",
        "desc": "Provided by runtime.syscall_runtime_doAllThreadsSyscall which stops the world and invokes the syscall on each OS thread. Once this function returns, all threads are in sync."
      },
      {
        "name": "runtime_entersyscall",
        "desc": ""
      },
      {
        "name": "runtime_envs",
        "desc": ""
      },
      {
        "name": "runtime_exitsyscall",
        "desc": ""
      },
      {
        "name": "seek",
        "desc": "Underlying system call writes to newoffset via pointer. Implemented in assembly to avoid allocation."
      },
      {
        "name": "sendfile",
        "desc": "TODO, see golang.org/issue/5847"
      },
      {
        "name": "sendmsg",
        "desc": ""
      },
      {
        "name": "sendmsgN",
        "desc": ""
      },
      {
        "name": "sendmsgNInet4",
        "desc": ""
      },
      {
        "name": "sendmsgNInet6",
        "desc": ""
      },
      {
        "name": "sendto",
        "desc": ""
      },
      {
        "name": "sendtoInet4",
        "desc": ""
      },
      {
        "name": "sendtoInet6",
        "desc": ""
      },
      {
        "name": "setDefaultMode",
        "desc": ""
      },
      {
        "name": "setFileInformationByHandle",
        "desc": ""
      },
      {
        "name": "setFilePointerEx",
        "desc": "setFilePointerEx calls SetFilePointerEx. See https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"
      },
      {
        "name": "setStat",
        "desc": ""
      },
      {
        "name": "setgroups",
        "desc": ""
      },
      {
        "name": "setrlimit",
        "desc": "setrlimit sets a resource limit. The Setrlimit function is in rlimit.go, and calls this one."
      },
      {
        "name": "setsid",
        "desc": ""
      },
      {
        "name": "setsockopt",
        "desc": ""
      },
      {
        "name": "shutdown",
        "desc": ""
      },
      {
        "name": "socket",
        "desc": ""
      },
      {
        "name": "socketControlMessageHeaderAndData",
        "desc": ""
      },
      {
        "name": "socketcall",
        "desc": ""
      },
      {
        "name": "socketpair",
        "desc": ""
      },
      {
        "name": "startProcess",
        "desc": "startProcess starts a new goroutine, tied to the OS thread, which runs the process and subsequently waits for it to finish, communicating the process stats back to any goroutines that may have been waiting on it.  Such a dedicated goroutine is needed because on Plan 9, only the parent thread can wait for a child, whereas goroutines tend to jump OS threads (e.g., between starting a process and running Wait(), the goroutine may have been rescheduled)."
      },
      {
        "name": "stat",
        "desc": ""
      },
      {
        "name": "statx",
        "desc": ""
      },
      {
        "name": "supportsABI",
        "desc": ""
      },
      {
        "name": "symlinkat",
        "desc": ""
      },
      {
        "name": "syncFileRange2",
        "desc": ""
      },
      {
        "name": "syscall",
        "desc": "Implemented in the runtime package (runtime/sys_openbsd3.go)"
      },
      {
        "name": "syscall10",
        "desc": ""
      },
      {
        "name": "syscall10X",
        "desc": ""
      },
      {
        "name": "syscall6",
        "desc": ""
      },
      {
        "name": "syscall6Internal",
        "desc": ""
      },
      {
        "name": "syscall6X",
        "desc": ""
      },
      {
        "name": "syscall9",
        "desc": ""
      },
      {
        "name": "syscall9Internal",
        "desc": ""
      },
      {
        "name": "syscall9X",
        "desc": ""
      },
      {
        "name": "syscallInternal",
        "desc": ""
      },
      {
        "name": "syscallPtr",
        "desc": ""
      },
      {
        "name": "syscallX",
        "desc": "Implemented in the runtime package (runtime/sys_darwin_64.go)"
      },
      {
        "name": "sysctl",
        "desc": ""
      },
      {
        "name": "sysctlNodes",
        "desc": ""
      },
      {
        "name": "sysvicall6",
        "desc": ""
      },
      {
        "name": "unlinkat",
        "desc": ""
      },
      {
        "name": "updateProcThreadAttribute",
        "desc": ""
      },
      {
        "name": "utf16PtrToString",
        "desc": "utf16PtrToString is like UTF16ToString, but takes *uint16 as a parameter instead of []uint16."
      },
      {
        "name": "utimensat",
        "desc": ""
      },
      {
        "name": "utimes",
        "desc": ""
      },
      {
        "name": "volToUpper",
        "desc": ""
      },
      {
        "name": "wait4",
        "desc": ""
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "write1",
        "desc": ""
      },
      {
        "name": "writeFile",
        "desc": ""
      },
      {
        "name": "writeIDMappings",
        "desc": "writeIDMappings writes the user namespace User ID or Group ID mappings to the specified path."
      },
      {
        "name": "writeSetgroups",
        "desc": "writeSetgroups writes to /proc/PID/setgroups \"deny\" if enable is false and \"allow\" if enable is true. This is needed since kernel 3.19, because you can't write gid_map without disabling setgroups() system call."
      },
      {
        "name": "writeUidGidMappings",
        "desc": "writeUidGidMappings writes User ID and Group ID mappings for user namespaces for a process and it is called from the parent process."
      },
      {
        "name": "writev",
        "desc": ""
      },
      {
        "name": "wsaSendtoInet4",
        "desc": ""
      },
      {
        "name": "wsaSendtoInet6",
        "desc": ""
      },
      {
        "name": "wstat",
        "desc": ""
      },
      {
        "name": "SetLen",
        "desc": ""
      },
      {
        "name": "data",
        "desc": ""
      },
      {
        "name": "FindProc",
        "desc": "FindProc searches [DLL] d for procedure named name and returns [*Proc] if found. It returns an error if search fails."
      },
      {
        "name": "MustFindProc",
        "desc": "MustFindProc is like [DLL.FindProc] but panics if search fails."
      },
      {
        "name": "Release",
        "desc": "Release unloads [DLL] d from memory."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Marshal",
        "desc": "Marshal encodes a 9P stat message corresponding to d into b  If there isn't enough space in b for a stat message, [ErrShortStat] is returned."
      },
      {
        "name": "Null",
        "desc": "Null assigns special \"don't touch\" values to members of d to avoid modifying them during [Wstat]."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Is",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Is",
        "desc": ""
      },
      {
        "name": "Temporary",
        "desc": ""
      },
      {
        "name": "Timeout",
        "desc": ""
      },
      {
        "name": "Nanoseconds",
        "desc": "Nanoseconds returns Filetime ft in nanoseconds since Epoch (00:00:00 UTC, January 1, 1970)."
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "SetLen",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": "Handle returns d's module handle."
      },
      {
        "name": "Load",
        "desc": "Load loads DLL file d.Name into memory. It returns an error if fails. Load will not try to load DLL, if it is already loaded into memory."
      },
      {
        "name": "NewProc",
        "desc": "NewProc returns a [LazyProc] for accessing the named procedure in the [DLL] d."
      },
      {
        "name": "mustLoad",
        "desc": "mustLoad is like Load but panics if search fails."
      },
      {
        "name": "Addr",
        "desc": "Addr returns the address of the procedure represented by p. The return value can be passed to Syscall to run the procedure."
      },
      {
        "name": "Call",
        "desc": "Call executes procedure p with arguments a. See the documentation of Proc.Call for more information."
      },
      {
        "name": "Find",
        "desc": "Find searches [DLL] for procedure named p.Name. It returns an error if search fails. Find will not search procedure, if it is already found and loaded into memory."
      },
      {
        "name": "mustFind",
        "desc": "mustFind is like Find but panics if search fails."
      },
      {
        "name": "SetControllen",
        "desc": ""
      },
      {
        "name": "toWireFormat",
        "desc": ""
      },
      {
        "name": "Signal",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Addr",
        "desc": "Addr returns the address of the procedure represented by p. The return value can be passed to Syscall to run the procedure."
      },
      {
        "name": "Call",
        "desc": "Call executes procedure p with arguments a.  The returned error is always non-nil, constructed from the result of GetLastError. Callers must inspect the primary return value to decide whether an error occurred (according to the semantics of the specific function being called) before consulting the error. The error always has type [Errno].  On amd64, Call can pass and return floating-point values. To pass an argument x with C type \"float\", use uintptr(math.Float32bits(x)). To pass an argument with C type \"double\", use uintptr(math.Float64bits(x)). Floating-point return values are returned in r2. The return value for C type \"float\" is [math.Float32frombits](uint32(r2)). For C type \"double\", it is [math.Float64frombits](uint64(r2))."
      },
      {
        "name": "GetEra",
        "desc": ""
      },
      {
        "name": "PC",
        "desc": ""
      },
      {
        "name": "SetEra",
        "desc": ""
      },
      {
        "name": "SetPC",
        "desc": ""
      },
      {
        "name": "Sockaddr",
        "desc": ""
      },
      {
        "name": "getLen",
        "desc": ""
      },
      {
        "name": "setLen",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": "Copy creates a duplicate of security identifier sid."
      },
      {
        "name": "Len",
        "desc": "Len returns the length, in bytes, of a valid security identifier sid."
      },
      {
        "name": "LookupAccount",
        "desc": "LookupAccount retrieves the name of the account for this sid and the name of the first domain on which this sid is found. System specify target computer to search for."
      },
      {
        "name": "String",
        "desc": "String converts sid to a string format suitable for display, storage, or transmission."
      },
      {
        "name": "Signal",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "sockaddr",
        "desc": ""
      },
      {
        "name": "Nano",
        "desc": ""
      },
      {
        "name": "Unix",
        "desc": ""
      },
      {
        "name": "Nano",
        "desc": "Nano returns the time stored in ts as nanoseconds."
      },
      {
        "name": "Unix",
        "desc": "Unix returns the time stored in ts as seconds plus nanoseconds."
      },
      {
        "name": "setTimestamp",
        "desc": ""
      },
      {
        "name": "timestamp",
        "desc": ""
      },
      {
        "name": "Nano",
        "desc": "Nano returns the time stored in tv as nanoseconds."
      },
      {
        "name": "Nanoseconds",
        "desc": ""
      },
      {
        "name": "Unix",
        "desc": "Unix returns the time stored in tv as seconds plus nanoseconds."
      },
      {
        "name": "setTimestamp",
        "desc": ""
      },
      {
        "name": "timestamp",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": "Close releases access to access token."
      },
      {
        "name": "GetTokenPrimaryGroup",
        "desc": "GetTokenPrimaryGroup retrieves access token t primary group information. A pointer to a SID structure representing a group that will become the primary group of any objects created by a process using this access token."
      },
      {
        "name": "GetTokenUser",
        "desc": "GetTokenUser retrieves access token t user account information."
      },
      {
        "name": "GetUserProfileDirectory",
        "desc": "GetUserProfileDirectory retrieves path to the root directory of the access token t user's profile."
      },
      {
        "name": "getInfo",
        "desc": "getInfo retrieves a specified type of information about an access token."
      },
      {
        "name": "Continued",
        "desc": ""
      },
      {
        "name": "CoreDump",
        "desc": ""
      },
      {
        "name": "ExitStatus",
        "desc": ""
      },
      {
        "name": "Exited",
        "desc": ""
      },
      {
        "name": "Signal",
        "desc": ""
      },
      {
        "name": "Signaled",
        "desc": ""
      },
      {
        "name": "StopSignal",
        "desc": ""
      },
      {
        "name": "Stopped",
        "desc": ""
      },
      {
        "name": "TrapCause",
        "desc": ""
      },
      {
        "name": "ExitStatus",
        "desc": ""
      },
      {
        "name": "Exited",
        "desc": ""
      },
      {
        "name": "Signaled",
        "desc": ""
      },
      {
        "name": "parseInterfaceMessage",
        "desc": ""
      },
      {
        "name": "parseRouteMessage",
        "desc": ""
      },
      {
        "name": "toRoutingMessage",
        "desc": ""
      },
      {
        "name": "Mmap",
        "desc": ""
      },
      {
        "name": "Munmap",
        "desc": ""
      },
      {
        "name": "delete",
        "desc": "Delete frees ProcThreadAttributeList's resources."
      },
      {
        "name": "list",
        "desc": "List returns the actual ProcThreadAttributeList to be passed to StartupInfoEx."
      },
      {
        "name": "update",
        "desc": "Update modifies the ProcThreadAttributeList using UpdateProcThreadAttribute."
      }
    ],
    "types": [
      {
        "name": "AddrinfoW",
        "desc": ""
      },
      {
        "name": "BpfHdr",
        "desc": ""
      },
      {
        "name": "BpfInsn",
        "desc": ""
      },
      {
        "name": "BpfProgram",
        "desc": ""
      },
      {
        "name": "BpfStat",
        "desc": ""
      },
      {
        "name": "BpfTimeval",
        "desc": ""
      },
      {
        "name": "BpfVersion",
        "desc": ""
      },
      {
        "name": "BpfZbuf",
        "desc": ""
      },
      {
        "name": "BpfZbufHeader",
        "desc": ""
      },
      {
        "name": "ByHandleFileInformation",
        "desc": ""
      },
      {
        "name": "CertChainContext",
        "desc": ""
      },
      {
        "name": "CertChainElement",
        "desc": ""
      },
      {
        "name": "CertChainPara",
        "desc": ""
      },
      {
        "name": "CertChainPolicyPara",
        "desc": ""
      },
      {
        "name": "CertChainPolicyStatus",
        "desc": ""
      },
      {
        "name": "CertContext",
        "desc": ""
      },
      {
        "name": "CertEnhKeyUsage",
        "desc": ""
      },
      {
        "name": "CertInfo",
        "desc": ""
      },
      {
        "name": "CertRevocationCrlInfo",
        "desc": ""
      },
      {
        "name": "CertRevocationInfo",
        "desc": ""
      },
      {
        "name": "CertSimpleChain",
        "desc": ""
      },
      {
        "name": "CertTrustListInfo",
        "desc": ""
      },
      {
        "name": "CertTrustStatus",
        "desc": ""
      },
      {
        "name": "CertUsageMatch",
        "desc": ""
      },
      {
        "name": "Cmsghdr",
        "desc": ""
      },
      {
        "name": "Conn",
        "desc": "Conn is implemented by some types in the net and os packages to provide access to the underlying file descriptor or handle."
      },
      {
        "name": "Credential",
        "desc": "Credential holds user and group identities to be assumed by a child process started by [StartProcess]."
      },
      {
        "name": "DLL",
        "desc": "A DLL implements access to a single DLL."
      },
      {
        "name": "DLLError",
        "desc": "DLLError describes reasons for DLL load failures."
      },
      {
        "name": "DNSMXData",
        "desc": ""
      },
      {
        "name": "DNSPTRData",
        "desc": ""
      },
      {
        "name": "DNSRecord",
        "desc": ""
      },
      {
        "name": "DNSSRVData",
        "desc": ""
      },
      {
        "name": "DNSTXTData",
        "desc": ""
      },
      {
        "name": "Dir",
        "desc": "A Dir contains the metadata for a file."
      },
      {
        "name": "Dircookie",
        "desc": ""
      },
      {
        "name": "Dirent",
        "desc": ""
      },
      {
        "name": "EpollEvent",
        "desc": ""
      },
      {
        "name": "Errno",
        "desc": "Errno is the Windows error number.  Errno values can be tested against error values using [errors.Is]. For example:  \t_, _, err := syscall.Syscall(...) \tif errors.Is(err, fs.ErrNotExist) ..."
      },
      {
        "name": "ErrorString",
        "desc": "ErrorString implements Error's String method by returning itself.  ErrorString values can be tested against error values using [errors.Is]. For example:  \t_, _, err := syscall.Syscall(...) \tif errors.Is(err, fs.ErrNotExist) ..."
      },
      {
        "name": "Fbootstraptransfer_t",
        "desc": ""
      },
      {
        "name": "FdSet",
        "desc": ""
      },
      {
        "name": "FileNotifyInformation",
        "desc": ""
      },
      {
        "name": "Filetime",
        "desc": ""
      },
      {
        "name": "Filetype",
        "desc": ""
      },
      {
        "name": "Flock_t",
        "desc": ""
      },
      {
        "name": "Fsid",
        "desc": ""
      },
      {
        "name": "Fsid64_t",
        "desc": ""
      },
      {
        "name": "Fstore_t",
        "desc": ""
      },
      {
        "name": "GUID",
        "desc": ""
      },
      {
        "name": "Handle",
        "desc": ""
      },
      {
        "name": "Hostent",
        "desc": ""
      },
      {
        "name": "ICMPv6Filter",
        "desc": ""
      },
      {
        "name": "IPMreq",
        "desc": ""
      },
      {
        "name": "IPMreqn",
        "desc": ""
      },
      {
        "name": "IPv6MTUInfo",
        "desc": ""
      },
      {
        "name": "IPv6Mreq",
        "desc": ""
      },
      {
        "name": "IfAddrmsg",
        "desc": ""
      },
      {
        "name": "IfAnnounceMsghdr",
        "desc": ""
      },
      {
        "name": "IfData",
        "desc": ""
      },
      {
        "name": "IfInfomsg",
        "desc": ""
      },
      {
        "name": "IfMsgHdr",
        "desc": ""
      },
      {
        "name": "IfMsghdr",
        "desc": ""
      },
      {
        "name": "IfaMsghdr",
        "desc": ""
      },
      {
        "name": "IfmaMsghdr",
        "desc": ""
      },
      {
        "name": "IfmaMsghdr2",
        "desc": ""
      },
      {
        "name": "Inet4Pktinfo",
        "desc": ""
      },
      {
        "name": "Inet6Pktinfo",
        "desc": ""
      },
      {
        "name": "InotifyEvent",
        "desc": ""
      },
      {
        "name": "InterfaceAddrMessage",
        "desc": "InterfaceAddrMessage represents a routing message containing network interface address entries.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "InterfaceAnnounceMessage",
        "desc": "InterfaceAnnounceMessage represents a routing message containing network interface arrival and departure information.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "InterfaceInfo",
        "desc": ""
      },
      {
        "name": "InterfaceMessage",
        "desc": "InterfaceMessage represents a routing message containing network interface entries.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "InterfaceMulticastAddrMessage",
        "desc": "InterfaceMulticastAddrMessage represents a routing message containing network interface address entries.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "Iovec",
        "desc": ""
      },
      {
        "name": "IpAdapterInfo",
        "desc": ""
      },
      {
        "name": "IpAddrString",
        "desc": ""
      },
      {
        "name": "IpAddressString",
        "desc": ""
      },
      {
        "name": "IpMaskString",
        "desc": ""
      },
      {
        "name": "Kevent_t",
        "desc": ""
      },
      {
        "name": "LazyDLL",
        "desc": "A LazyDLL implements access to a single [DLL]. It will delay the load of the DLL until the first call to its [LazyDLL.Handle] method or to one of its [LazyProc]'s Addr method.  LazyDLL is subject to the same DLL preloading attacks as documented on [LoadDLL].  Use LazyDLL in golang.org/x/sys/windows for a secure way to load system DLLs."
      },
      {
        "name": "LazyProc",
        "desc": "A LazyProc implements access to a procedure inside a [LazyDLL]. It delays the lookup until the [LazyProc.Addr], [LazyProc.Call], or [LazyProc.Find] method is called."
      },
      {
        "name": "Linger",
        "desc": ""
      },
      {
        "name": "Log2phys_t",
        "desc": ""
      },
      {
        "name": "Mclpool",
        "desc": ""
      },
      {
        "name": "MibIfRow",
        "desc": ""
      },
      {
        "name": "Msghdr",
        "desc": ""
      },
      {
        "name": "NetlinkMessage",
        "desc": "NetlinkMessage represents a netlink message."
      },
      {
        "name": "NetlinkRouteAttr",
        "desc": "NetlinkRouteAttr represents a netlink route attribute."
      },
      {
        "name": "NetlinkRouteRequest",
        "desc": "NetlinkRouteRequest represents a request message to receive routing and link states from the kernel."
      },
      {
        "name": "NlAttr",
        "desc": ""
      },
      {
        "name": "NlMsgerr",
        "desc": ""
      },
      {
        "name": "NlMsghdr",
        "desc": ""
      },
      {
        "name": "Note",
        "desc": "A Note is a string describing a process note. It implements the os.Signal interface."
      },
      {
        "name": "Overlapped",
        "desc": ""
      },
      {
        "name": "Pointer",
        "desc": "Pointer represents a pointer to an arbitrary Windows type.  Pointer-typed fields may point to one of many different types. It's up to the caller to provide a pointer to the appropriate type, cast to Pointer. The caller must obey the unsafe.Pointer rules while doing so."
      },
      {
        "name": "Proc",
        "desc": "A Proc implements access to a procedure inside a [DLL]."
      },
      {
        "name": "ProcAttr",
        "desc": "ProcAttr is a placeholder to allow compilation of the [os/exec] package because we need Go programs to be portable across platforms. WASI does not have a mechanism to spawn processes so there is no reason for an application to take a dependency on this type."
      },
      {
        "name": "ProcessEntry32",
        "desc": ""
      },
      {
        "name": "ProcessInformation",
        "desc": ""
      },
      {
        "name": "Protoent",
        "desc": ""
      },
      {
        "name": "PtraceFpregs",
        "desc": ""
      },
      {
        "name": "PtracePer",
        "desc": ""
      },
      {
        "name": "PtracePsw",
        "desc": ""
      },
      {
        "name": "PtraceRegs",
        "desc": ""
      },
      {
        "name": "Qid",
        "desc": "A Qid represents a 9P server's unique identification for a file."
      },
      {
        "name": "Radvisory_t",
        "desc": ""
      },
      {
        "name": "RawConn",
        "desc": "A RawConn is a raw network connection."
      },
      {
        "name": "RawSockaddr",
        "desc": ""
      },
      {
        "name": "RawSockaddrAny",
        "desc": ""
      },
      {
        "name": "RawSockaddrDatalink",
        "desc": ""
      },
      {
        "name": "RawSockaddrInet4",
        "desc": ""
      },
      {
        "name": "RawSockaddrInet6",
        "desc": ""
      },
      {
        "name": "RawSockaddrLinklayer",
        "desc": ""
      },
      {
        "name": "RawSockaddrNetlink",
        "desc": ""
      },
      {
        "name": "RawSockaddrUnix",
        "desc": ""
      },
      {
        "name": "Rlimit",
        "desc": ""
      },
      {
        "name": "RouteMessage",
        "desc": "RouteMessage represents a routing message containing routing entries.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "RoutingMessage",
        "desc": "RoutingMessage represents a routing message.  Deprecated: Use golang.org/x/net/route instead."
      },
      {
        "name": "RtAttr",
        "desc": ""
      },
      {
        "name": "RtGenmsg",
        "desc": ""
      },
      {
        "name": "RtMetrics",
        "desc": ""
      },
      {
        "name": "RtMsg",
        "desc": ""
      },
      {
        "name": "RtMsghdr",
        "desc": ""
      },
      {
        "name": "RtNexthop",
        "desc": ""
      },
      {
        "name": "Rusage",
        "desc": ""
      },
      {
        "name": "SID",
        "desc": "The security identifier (SID) structure is a variable-length structure used to uniquely identify users or groups."
      },
      {
        "name": "SIDAndAttributes",
        "desc": ""
      },
      {
        "name": "SSLExtraCertChainPolicyPara",
        "desc": ""
      },
      {
        "name": "SecurityAttributes",
        "desc": ""
      },
      {
        "name": "Servent",
        "desc": ""
      },
      {
        "name": "Signal",
        "desc": ""
      },
      {
        "name": "SockFilter",
        "desc": ""
      },
      {
        "name": "SockFprog",
        "desc": ""
      },
      {
        "name": "Sockaddr",
        "desc": ""
      },
      {
        "name": "SockaddrDatalink",
        "desc": ""
      },
      {
        "name": "SockaddrGen",
        "desc": ""
      },
      {
        "name": "SockaddrInet4",
        "desc": ""
      },
      {
        "name": "SockaddrInet6",
        "desc": ""
      },
      {
        "name": "SockaddrLinklayer",
        "desc": ""
      },
      {
        "name": "SockaddrNetlink",
        "desc": ""
      },
      {
        "name": "SockaddrUnix",
        "desc": ""
      },
      {
        "name": "SocketControlMessage",
        "desc": "SocketControlMessage represents a socket control message."
      },
      {
        "name": "StTimespec_t",
        "desc": ""
      },
      {
        "name": "StartupInfo",
        "desc": ""
      },
      {
        "name": "Stat_t",
        "desc": ""
      },
      {
        "name": "Statfs_t",
        "desc": ""
      },
      {
        "name": "SysProcAttr",
        "desc": ""
      },
      {
        "name": "SysProcIDMap",
        "desc": "SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).  Note that User Namespaces are not available on a number of popular Linux versions (due to security issues), or are available but subject to AppArmor restrictions like in Ubuntu 24.04."
      },
      {
        "name": "Sysctlnode",
        "desc": ""
      },
      {
        "name": "Sysinfo_t",
        "desc": ""
      },
      {
        "name": "Systemtime",
        "desc": ""
      },
      {
        "name": "TCPInfo",
        "desc": ""
      },
      {
        "name": "TCPKeepalive",
        "desc": ""
      },
      {
        "name": "Termios",
        "desc": ""
      },
      {
        "name": "Time_t",
        "desc": ""
      },
      {
        "name": "Timespec",
        "desc": ""
      },
      {
        "name": "Timeval",
        "desc": ""
      },
      {
        "name": "Timeval32",
        "desc": ""
      },
      {
        "name": "Timex",
        "desc": ""
      },
      {
        "name": "Timezone",
        "desc": ""
      },
      {
        "name": "Timezoneinformation",
        "desc": ""
      },
      {
        "name": "Tms",
        "desc": ""
      },
      {
        "name": "Token",
        "desc": "An access token contains the security information for a logon session. The system creates an access token when a user logs on, and every process executed on behalf of the user has a copy of the token. The token identifies the user, the user's groups, and the user's privileges. The system uses the token to control access to securable objects and to control the ability of the user to perform various system-related operations on the local computer."
      },
      {
        "name": "Tokenprimarygroup",
        "desc": ""
      },
      {
        "name": "Tokenuser",
        "desc": ""
      },
      {
        "name": "TransmitFileBuffers",
        "desc": ""
      },
      {
        "name": "Ucred",
        "desc": ""
      },
      {
        "name": "UserInfo10",
        "desc": ""
      },
      {
        "name": "Ustat_t",
        "desc": ""
      },
      {
        "name": "Utimbuf",
        "desc": ""
      },
      {
        "name": "Utsname",
        "desc": ""
      },
      {
        "name": "WSABuf",
        "desc": ""
      },
      {
        "name": "WSAData",
        "desc": ""
      },
      {
        "name": "WSAProtocolChain",
        "desc": ""
      },
      {
        "name": "WSAProtocolInfo",
        "desc": ""
      },
      {
        "name": "WaitStatus",
        "desc": ""
      },
      {
        "name": "Waitmsg",
        "desc": ""
      },
      {
        "name": "Win32FileAttributeData",
        "desc": ""
      },
      {
        "name": "Win32finddata",
        "desc": ""
      },
      {
        "name": "_C_int",
        "desc": ""
      },
      {
        "name": "_C_long",
        "desc": ""
      },
      {
        "name": "_C_long_long",
        "desc": ""
      },
      {
        "name": "_C_short",
        "desc": ""
      },
      {
        "name": "_Gid_t",
        "desc": ""
      },
      {
        "name": "_PROC_THREAD_ATTRIBUTE_LIST",
        "desc": "_PROC_THREAD_ATTRIBUTE_LIST is a placeholder type to represent a the opaque PROC_THREAD_ATTRIBUTE_LIST.  Manipulate this type only through [procThreadAttributeListContainer] to ensure proper handling of the underlying memory. See https://g.dev/issue/73170."
      },
      {
        "name": "_Pid_t",
        "desc": ""
      },
      {
        "name": "_STARTUPINFOEXW",
        "desc": ""
      },
      {
        "name": "_Socklen",
        "desc": ""
      },
      {
        "name": "anyMessage",
        "desc": ""
      },
      {
        "name": "capData",
        "desc": ""
      },
      {
        "name": "capHeader",
        "desc": ""
      },
      {
        "name": "caps",
        "desc": ""
      },
      {
        "name": "clockid",
        "desc": ""
      },
      {
        "name": "cloneArgs",
        "desc": "cloneArgs holds arguments for clone3 Linux syscall."
      },
      {
        "name": "dircookie",
        "desc": ""
      },
      {
        "name": "envItem",
        "desc": ""
      },
      {
        "name": "fdflags",
        "desc": ""
      },
      {
        "name": "fdstat",
        "desc": "https://github.com/WebAssembly/WASI/blob/a2b96e81c0586125cc4dc79a5be0b78d9a059925/legacy/preview1/docs.md#-fdstat-record fdflags must be at offset 2, hence the uint16 type rather than the fdflags (uint32) type."
      },
      {
        "name": "filedelta",
        "desc": ""
      },
      {
        "name": "filesize",
        "desc": ""
      },
      {
        "name": "filetype",
        "desc": ""
      },
      {
        "name": "fstflags",
        "desc": ""
      },
      {
        "name": "ifData",
        "desc": ""
      },
      {
        "name": "ifMsghdr",
        "desc": ""
      },
      {
        "name": "iflags",
        "desc": ""
      },
      {
        "name": "iovec",
        "desc": ""
      },
      {
        "name": "ivalue",
        "desc": ""
      },
      {
        "name": "jsFile",
        "desc": ""
      },
      {
        "name": "libcFunc",
        "desc": ""
      },
      {
        "name": "lookupflags",
        "desc": ""
      },
      {
        "name": "mibentry",
        "desc": ""
      },
      {
        "name": "mmapper",
        "desc": ""
      },
      {
        "name": "mountPointReparseBuffer",
        "desc": ""
      },
      {
        "name": "oflags",
        "desc": ""
      },
      {
        "name": "opendir",
        "desc": ""
      },
      {
        "name": "pollFd",
        "desc": ""
      },
      {
        "name": "preopentype",
        "desc": ""
      },
      {
        "name": "prestat",
        "desc": ""
      },
      {
        "name": "prestatDir",
        "desc": ""
      },
      {
        "name": "procThreadAttributeListContainer",
        "desc": ""
      },
      {
        "name": "ptraceFpregs",
        "desc": ""
      },
      {
        "name": "ptracePer",
        "desc": ""
      },
      {
        "name": "ptracePsw",
        "desc": ""
      },
      {
        "name": "reparseDataBuffer",
        "desc": ""
      },
      {
        "name": "rights",
        "desc": ""
      },
      {
        "name": "sdflags",
        "desc": ""
      },
      {
        "name": "sigset",
        "desc": ""
      },
      {
        "name": "sigset_t",
        "desc": ""
      },
      {
        "name": "size",
        "desc": ""
      },
      {
        "name": "stat_t",
        "desc": ""
      },
      {
        "name": "statxTimestamp",
        "desc": ""
      },
      {
        "name": "statx_t",
        "desc": ""
      },
      {
        "name": "symbolicLinkReparseBuffer",
        "desc": ""
      },
      {
        "name": "sysLinger",
        "desc": ""
      },
      {
        "name": "timestamp",
        "desc": ""
      },
      {
        "name": "uintptr32",
        "desc": ""
      },
      {
        "name": "waitErr",
        "desc": ""
      },
      {
        "name": "win32finddata1",
        "desc": "This is the actual system call structure. Win32finddata is what we committed to in Go 1."
      }
    ]
  },
  {
    "name": "syscall/js",
    "desc": "Package js gives access to the WebAssembly host environment when using the js/wasm architecture. Its API is based on JavaScript semantics.  This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.",
    "functions": [
      {
        "name": "CopyBytesToGo",
        "desc": "CopyBytesToGo copies bytes from src to dst. It panics if src is not a Uint8Array or Uint8ClampedArray. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst."
      },
      {
        "name": "CopyBytesToJS",
        "desc": "CopyBytesToJS copies bytes from src to dst. It panics if dst is not a Uint8Array or Uint8ClampedArray. It returns the number of bytes copied, which will be the minimum of the lengths of src and dst."
      },
      {
        "name": "copyBytesToGo",
        "desc": "copyBytesToGo copies bytes from src to dst.  Using go:noescape is safe because the dst byte slice is only used as a dst copy buffer and no references to it are maintained."
      },
      {
        "name": "copyBytesToJS",
        "desc": "copyBytesToJS copies bytes from src to dst.  Using go:noescape is safe because the src byte slice is only used as a src copy buffer and no references to it are maintained."
      },
      {
        "name": "finalizeRef",
        "desc": ""
      },
      {
        "name": "handleEvent",
        "desc": "handleEvent retrieves the pending event (window._pendingEvent) and calls the js.Func on it. It returns true if an event was handled."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "jsString",
        "desc": ""
      },
      {
        "name": "makeArgSlices",
        "desc": "makeArgSlices makes two slices to hold JavaScript arg data. It can be paired with storeArgs to make-and-store JavaScript arg slices. However, the two functions are separated to ensure makeArgSlices is inlined which will prevent the slices from being heap allocated for small (\u003c=16) numbers of args."
      },
      {
        "name": "setEventHandler",
        "desc": "setEventHandler is defined in the runtime package."
      },
      {
        "name": "storeArgs",
        "desc": "storeArgs maps input args onto respective Value and ref slices. It can be paired with makeArgSlices to make-and-store JavaScript arg slices."
      },
      {
        "name": "valueDelete",
        "desc": "valueDelete deletes the JavaScript property p of ref v.  Using go:noescape is safe because no references are maintained to the Go string p after the syscall returns."
      },
      {
        "name": "valueInstanceOf",
        "desc": ""
      },
      {
        "name": "valueLength",
        "desc": ""
      },
      {
        "name": "valueLoadString",
        "desc": "valueLoadString loads string data located at ref v into byte slice b.  Using go:noescape is safe because the byte slice is only used as a destination for storing the string data and references to it are not maintained."
      },
      {
        "name": "valueSet",
        "desc": "valueSet sets property p of ref v to ref x.  Using go:noescape is safe because no references are maintained to the Go string p after the syscall returns."
      },
      {
        "name": "valueSetIndex",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": "Error implements the error interface."
      },
      {
        "name": "Release",
        "desc": "Release frees up resources allocated for the function. The function must not be invoked after calling Release. It is allowed to call Release while the function is still running."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "isObject",
        "desc": ""
      },
      {
        "name": "Bool",
        "desc": "Bool returns the value v as a bool. It panics if v is not a JavaScript boolean."
      },
      {
        "name": "Call",
        "desc": "Call does a JavaScript call to the method m of value v with the given arguments. It panics if v has no method m. The arguments get mapped to JavaScript values according to the ValueOf function."
      },
      {
        "name": "Delete",
        "desc": "Delete deletes the JavaScript property p of value v. It panics if v is not a JavaScript object."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether v and w are equal according to JavaScript's === operator."
      },
      {
        "name": "Float",
        "desc": "Float returns the value v as a float64. It panics if v is not a JavaScript number."
      },
      {
        "name": "Get",
        "desc": "Get returns the JavaScript property p of value v. It panics if v is not a JavaScript object."
      },
      {
        "name": "Index",
        "desc": "Index returns JavaScript index i of value v. It panics if v is not a JavaScript object."
      },
      {
        "name": "InstanceOf",
        "desc": "InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator."
      },
      {
        "name": "Int",
        "desc": "Int returns the value v truncated to an int. It panics if v is not a JavaScript number."
      },
      {
        "name": "Invoke",
        "desc": "Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function."
      },
      {
        "name": "IsNaN",
        "desc": "IsNaN reports whether v is the JavaScript value \"NaN\"."
      },
      {
        "name": "IsNull",
        "desc": "IsNull reports whether v is the JavaScript value \"null\"."
      },
      {
        "name": "IsUndefined",
        "desc": "IsUndefined reports whether v is the JavaScript value \"undefined\"."
      },
      {
        "name": "Length",
        "desc": "Length returns the JavaScript property \"length\" of v. It panics if v is not a JavaScript object."
      },
      {
        "name": "New",
        "desc": "New uses JavaScript's \"new\" operator with value v as constructor and the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function."
      },
      {
        "name": "Set",
        "desc": "Set sets the JavaScript property p of value v to ValueOf(x). It panics if v is not a JavaScript object."
      },
      {
        "name": "SetIndex",
        "desc": "SetIndex sets the JavaScript index i of value v to ValueOf(x). It panics if v is not a JavaScript object."
      },
      {
        "name": "String",
        "desc": "String returns the value v as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Type is not TypeString. Instead, it returns a string of the form \"\u003cT\u003e\" or \"\u003cT: V\u003e\" where T is v's type and V is a string representation of v's value."
      },
      {
        "name": "Truthy",
        "desc": "Truthy returns the JavaScript \"truthiness\" of the value v. In JavaScript, false, 0, \"\", null, undefined, and NaN are \"falsy\", and everything else is \"truthy\". See https://developer.mozilla.org/en-US/docs/Glossary/Truthy."
      },
      {
        "name": "Type",
        "desc": "Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null."
      },
      {
        "name": "float",
        "desc": ""
      },
      {
        "name": "isNumber",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Error",
        "desc": "Error wraps a JavaScript error."
      },
      {
        "name": "Func",
        "desc": "Func is a wrapped Go function to be called by JavaScript."
      },
      {
        "name": "Type",
        "desc": "Type represents the JavaScript type of a Value."
      },
      {
        "name": "Value",
        "desc": "Value represents a JavaScript value. The zero value is the JavaScript value \"undefined\". Values can be checked for equality with the Equal method."
      },
      {
        "name": "ValueError",
        "desc": "A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method."
      },
      {
        "name": "ref",
        "desc": "ref is used to identify a JavaScript value, since the value itself can not be passed to WebAssembly.  The JavaScript value \"undefined\" is represented by the value 0. A JavaScript number (64-bit float, except 0 and NaN) is represented by its IEEE 754 binary representation. All other values are represented as an IEEE 754 binary representation of NaN with bits 0-31 used as an ID and bits 32-34 used to differentiate between string, symbol, function and object."
      }
    ]
  },
  {
    "name": "testing",
    "desc": "Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the \"go test\" command, which automates execution of any function of the form  \tfunc TestXxx(*testing.T)  where Xxx does not start with a lowercase letter. The function name serves to identify the test routine.  Within these functions, use [T.Error], [T.Fail] or related methods to signal failure.  To write a new test suite, create a file that contains the TestXxx functions as described here, and give that file a name ending in \"_test.go\". The file will be excluded from regular package builds but will be included when the \"go test\" command is run.  The test file can be in the same package as the one being tested, or in a corresponding package with the suffix \"_test\".  If the test file is in the same package, it may refer to unexported identifiers within the package, as in this example:  \tpackage abs  \timport \"testing\"  \tfunc TestAbs(t *testing.T) { \t    got := Abs(-1) \t    if got != 1 { \t        t.Errorf(\"Abs(-1) = %d; want 1\", got) \t    } \t}  If the file is in a separate \"_test\" package, the package being tested must be imported explicitly and only its exported identifiers may be used. This is known as \"black box\" testing.  \tpackage abs_test  \timport ( \t\t\"testing\"  \t\t\"path_to_pkg/abs\" \t)  \tfunc TestAbs(t *testing.T) { \t    got := abs.Abs(-1) \t    if got != 1 { \t        t.Errorf(\"Abs(-1) = %d; want 1\", got) \t    } \t}  For more detail, run [go help test] and [go help testflag].  # Benchmarks  Functions of the form  \tfunc BenchmarkXxx(*testing.B)  are considered benchmarks, and are executed by the \"go test\" command when its -bench flag is provided. Benchmarks are run sequentially.  For a description of the testing flags, see [go help testflag].  A sample benchmark function looks like this:  \tfunc BenchmarkRandInt(b *testing.B) { \t    for b.Loop() { \t        rand.Int() \t    } \t}  The output  \tBenchmarkRandInt-8   \t68453040\t        17.8 ns/op  means that the body of the loop ran 68453040 times at a speed of 17.8 ns per loop.  Only the body of the loop is timed, so benchmarks may do expensive setup before calling b.Loop, which will not be counted toward the benchmark measurement:  \tfunc BenchmarkBigLen(b *testing.B) { \t    big := NewBig() \t    for b.Loop() { \t        big.Len() \t    } \t}  If a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag:  \tfunc BenchmarkTemplateParallel(b *testing.B) { \t    templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\")) \t    b.RunParallel(func(pb *testing.PB) { \t        var buf bytes.Buffer \t        for pb.Next() { \t            buf.Reset() \t            templ.Execute(\u0026buf, \"World\") \t        } \t    }) \t}  A detailed specification of the benchmark results format is given in https://go.dev/design/14313-benchmark-format.  There are standard tools for working with benchmark results at [golang.org/x/perf/cmd]. In particular, [golang.org/x/perf/cmd/benchstat] performs statistically robust A/B comparisons.  # b.N-style benchmarks  Prior to the introduction of [B.Loop], benchmarks were written in a different style using B.N. For example:  \tfunc BenchmarkRandInt(b *testing.B) { \t    for range b.N { \t        rand.Int() \t    } \t}  In this style of benchmark, the benchmark function must run the target code b.N times. The benchmark function is called multiple times with b.N adjusted until the benchmark function lasts long enough to be timed reliably. This also means any setup done before the loop may be run several times.  If a benchmark needs some expensive setup before running, the timer should be explicitly reset:  \tfunc BenchmarkBigLen(b *testing.B) { \t    big := NewBig() \t    b.ResetTimer() \t    for range b.N { \t        big.Len() \t    } \t}  New benchmarks should prefer using [B.Loop], which is more robust and more efficient.  # Examples  The package also runs and verifies example code. Example functions may include a concluding line comment that begins with \"Output:\" and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example:  \tfunc ExampleHello() { \t    fmt.Println(\"hello\") \t    // Output: hello \t}  \tfunc ExampleSalutations() { \t    fmt.Println(\"hello, and\") \t    fmt.Println(\"goodbye\") \t    // Output: \t    // hello, and \t    // goodbye \t}  The comment prefix \"Unordered output:\" is like \"Output:\", but matches any line order:  \tfunc ExamplePerm() { \t    for _, value := range Perm(5) { \t        fmt.Println(value) \t    } \t    // Unordered output: 4 \t    // 2 \t    // 1 \t    // 3 \t    // 0 \t}  Example functions without output comments are compiled but not executed.  The naming convention to declare examples for the package, a function F, a type T and method M on type T are:  \tfunc Example() { ... } \tfunc ExampleF() { ... } \tfunc ExampleT() { ... } \tfunc ExampleT_M() { ... }  Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter.  \tfunc Example_suffix() { ... } \tfunc ExampleF_suffix() { ... } \tfunc ExampleT_suffix() { ... } \tfunc ExampleT_M_suffix() { ... }  The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions.  # Fuzzing  'go test' and the testing package support fuzzing, a testing technique where a function is called with randomly generated inputs to find bugs not anticipated by unit tests.  Functions of the form  \tfunc FuzzXxx(*testing.F)  are considered fuzz tests.  For example:  \tfunc FuzzHex(f *testing.F) { \t  for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} { \t    f.Add(seed) \t  } \t  f.Fuzz(func(t *testing.T, in []byte) { \t    enc := hex.EncodeToString(in) \t    out, err := hex.DecodeString(enc) \t    if err != nil { \t      t.Fatalf(\"%v: decode: %v\", in, err) \t    } \t    if !bytes.Equal(in, out) { \t      t.Fatalf(\"%v: not equal after round trip: %v\", in, out) \t    } \t  }) \t}  A fuzz test maintains a seed corpus, or a set of inputs which are run by default, and can seed input generation. Seed inputs may be registered by calling [F.Add] or by storing files in the directory testdata/fuzz/\u003cName\u003e (where \u003cName\u003e is the name of the fuzz test) within the package containing the fuzz test. Seed inputs are optional, but the fuzzing engine may find bugs more efficiently when provided with a set of small seed inputs with good code coverage. These seed inputs can also serve as regression tests for bugs identified through fuzzing.  The function passed to [F.Fuzz] within the fuzz test is considered the fuzz target. A fuzz target must accept a [*T] parameter, followed by one or more parameters for random inputs. The types of arguments passed to [F.Add] must be identical to the types of these parameters. The fuzz target may signal that it's found a problem the same way tests do: by calling [T.Fail] (or any method that calls it like [T.Error] or [T.Fatal]) or by panicking.  When fuzzing is enabled (by setting the -fuzz flag to a regular expression that matches a specific fuzz test), the fuzz target is called with arguments generated by repeatedly making random changes to the seed inputs. On supported platforms, 'go test' compiles the test executable with fuzzing coverage instrumentation. The fuzzing engine uses that instrumentation to find and cache inputs that expand coverage, increasing the likelihood of finding bugs. If the fuzz target fails for a given input, the fuzzing engine writes the inputs that caused the failure to a file in the directory testdata/fuzz/\u003cName\u003e within the package directory. This file later serves as a seed input. If the file can't be written at that location (for example, because the directory is read-only), the fuzzing engine writes the file to the fuzz cache directory within the build cache instead.  When fuzzing is disabled, the fuzz target is called with the seed inputs registered with [F.Add] and seed inputs from testdata/fuzz/\u003cName\u003e. In this mode, the fuzz test acts much like a regular test, with subtests started with [F.Fuzz] instead of [T.Run].  See https://go.dev/doc/fuzz for documentation about fuzzing.  # Skipping  Tests or benchmarks may be skipped at run time with a call to [T.Skip] or [B.Skip]:  \tfunc TestTimeConsuming(t *testing.T) { \t    if testing.Short() { \t        t.Skip(\"skipping test in short mode.\") \t    } \t    ... \t}  The [T.Skip] method can be used in a fuzz target if the input is invalid, but should not be considered a failing input. For example:  \tfunc FuzzJSONMarshaling(f *testing.F) { \t    f.Fuzz(func(t *testing.T, b []byte) { \t        var v interface{} \t        if err := json.Unmarshal(b, \u0026v); err != nil { \t            t.Skip() \t        } \t        if _, err := json.Marshal(v); err != nil { \t            t.Errorf(\"Marshal: %v\", err) \t        } \t    }) \t}  # Subtests and Sub-benchmarks  The [T.Run] and [B.Run] methods allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code:  \tfunc TestFoo(t *testing.T) { \t    // \u003csetup code\u003e \t    t.Run(\"A=1\", func(t *testing.T) { ... }) \t    t.Run(\"A=2\", func(t *testing.T) { ... }) \t    t.Run(\"B=1\", func(t *testing.T) { ... }) \t    // \u003ctear-down code\u003e \t}  Each subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation.  The argument to the -run, -bench, and -fuzz command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using \"matching\" to mean \"whose name contains\":  \tgo test -run ''        # Run all tests. \tgo test -run Foo       # Run top-level tests matching \"Foo\", such as \"TestFooBar\". \tgo test -run Foo/A=    # For top-level tests matching \"Foo\", run subtests matching \"A=\". \tgo test -run /A=1      # For all top-level tests, run subtests matching \"A=1\". \tgo test -fuzz FuzzFoo  # Fuzz the target matching \"FuzzFoo\"  The -run argument can also be used to run a specific value in the seed corpus, for debugging. For example:  \tgo test -run=FuzzFoo/9ddb952d9814  The -fuzz and -run flags can both be set, in order to fuzz a target but skip the execution of all other tests.  Subtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined:  \tfunc TestGroupedParallel(t *testing.T) { \t    for _, tc := range tests { \t        t.Run(tc.Name, func(t *testing.T) { \t            t.Parallel() \t            ... \t        }) \t    } \t}  Run does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests:  \tfunc TestTeardownParallel(t *testing.T) { \t    // This Run will not return until the parallel tests finish. \t    t.Run(\"group\", func(t *testing.T) { \t        t.Run(\"Test1\", parallelTest1) \t        t.Run(\"Test2\", parallelTest2) \t        t.Run(\"Test3\", parallelTest3) \t    }) \t    // \u003ctear-down code\u003e \t}  # Main  It is sometimes necessary for a test or benchmark program to do extra setup or teardown before or after it executes. It is also sometimes necessary to control which code runs on the main thread. To support these and other cases, if a test file contains a function:  \tfunc TestMain(m *testing.M)  then the generated test will call TestMain(m) instead of running the tests or benchmarks directly. TestMain runs in the main goroutine and can do whatever setup and teardown is necessary around a call to m.Run. m.Run will return an exit code that may be passed to [os.Exit]. If TestMain returns, the test wrapper will pass the result of m.Run to [os.Exit] itself.  When TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call [flag.Parse] explicitly. Command line flags are always parsed by the time test or benchmark functions run.  A simple implementation of TestMain is:  \tfunc TestMain(m *testing.M) { \t\t// call flag.Parse() here if TestMain uses flags \t\tm.Run() \t}  TestMain is a low-level primitive and should not be necessary for casual testing needs, where ordinary test functions suffice.  [go help test]: https://pkg.go.dev/cmd/go#hdr-Test_packages [go help testflag]: https://pkg.go.dev/cmd/go#hdr-Testing_flags",
    "functions": [
      {
        "name": "AllocsPerRun",
        "desc": "AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value.  To compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned.  AllocsPerRun sets [runtime.GOMAXPROCS] to 1 during its measurement and will restore it before returning."
      },
      {
        "name": "CoverMode",
        "desc": "CoverMode reports what the test coverage mode is set to. The values are \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage is not enabled."
      },
      {
        "name": "Coverage",
        "desc": "Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0.  When running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'."
      },
      {
        "name": "FuzzNaming",
        "desc": ""
      },
      {
        "name": "Init",
        "desc": "Init registers testing flags. These flags are automatically registered by the \"go test\" command before running test functions, so Init is only needed when calling functions such as Benchmark without using \"go test\".  Init is not safe to call concurrently. It has no effect if it was already called."
      },
      {
        "name": "Main",
        "desc": "Main is an internal function, part of the implementation of the \"go test\" command. It was exported because it is cross-package and predates \"internal\" packages. It is no longer used by \"go test\" but preserved, as much as possible, for other systems that simulate \"go test\" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating \"go test\" should be updated to use [MainStart]."
      },
      {
        "name": "RegisterCover",
        "desc": "RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines."
      },
      {
        "name": "RunBenchmarks",
        "desc": "RunBenchmarks is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command."
      },
      {
        "name": "RunExamples",
        "desc": "RunExamples is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command."
      },
      {
        "name": "RunTests",
        "desc": "RunTests is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command."
      },
      {
        "name": "Short",
        "desc": "Short reports whether the -test.short flag is set."
      },
      {
        "name": "TestBRun",
        "desc": ""
      },
      {
        "name": "TestBenchmark",
        "desc": ""
      },
      {
        "name": "TestBenchmarkBLoop",
        "desc": ""
      },
      {
        "name": "TestBenchmarkBLoopBreak",
        "desc": ""
      },
      {
        "name": "TestBenchmarkBLoopError",
        "desc": ""
      },
      {
        "name": "TestBenchmarkBLoopStop",
        "desc": ""
      },
      {
        "name": "TestBenchmarkOutput",
        "desc": ""
      },
      {
        "name": "TestBenchmarkReadMemStatsBeforeFirstRun",
        "desc": ""
      },
      {
        "name": "TestBenchmarkStartsFrom1",
        "desc": ""
      },
      {
        "name": "TestCleanup",
        "desc": ""
      },
      {
        "name": "TestCleanupCalledEvenAfterGoexit",
        "desc": ""
      },
      {
        "name": "TestCleanupParallelSubtests",
        "desc": ""
      },
      {
        "name": "TestConcurrentCleanup",
        "desc": ""
      },
      {
        "name": "TestIsSpace",
        "desc": "Verify that our IsSpace agrees with unicode.IsSpace."
      },
      {
        "name": "TestLogAfterComplete",
        "desc": "The late log message did not include the test name.  Issue 29388."
      },
      {
        "name": "TestMatcher",
        "desc": ""
      },
      {
        "name": "TestNaming",
        "desc": ""
      },
      {
        "name": "TestNestedCleanup",
        "desc": ""
      },
      {
        "name": "TestOutput",
        "desc": "TestOutput checks that log messages are written, formatted and buffered as expected by Output. It checks both the chatty and non-chatty cases."
      },
      {
        "name": "TestOutputAfterComplete",
        "desc": "TestOutputAfterComplete ensures that Output panics if called after a test function returns."
      },
      {
        "name": "TestOutputEscape1",
        "desc": ""
      },
      {
        "name": "TestOutputEscape2",
        "desc": ""
      },
      {
        "name": "TestOutputWriteAfterComplete",
        "desc": "TestOutputWriteAfterComplete ensures that Write panics if called on t.Output() of a finished test t."
      },
      {
        "name": "TestRacyOutput",
        "desc": ""
      },
      {
        "name": "TestRunCleanup",
        "desc": ""
      },
      {
        "name": "TestSplitRegexp",
        "desc": ""
      },
      {
        "name": "TestTRun",
        "desc": ""
      },
      {
        "name": "TestTestState",
        "desc": ""
      },
      {
        "name": "Testing",
        "desc": "Testing reports whether the current code is being run in a test. This will report true in programs created by \"go test\", false in programs created by \"go build\"."
      },
      {
        "name": "Verbose",
        "desc": "Verbose reports whether the -test.v flag is set."
      },
      {
        "name": "benchmarkName",
        "desc": "benchmarkName returns full name of benchmark including procs suffix."
      },
      {
        "name": "callerName",
        "desc": "callerName gives the function name (qualified with a package path) for the caller after skip frames (where 0 means the current function)."
      },
      {
        "name": "coverReport",
        "desc": "coverReport reports the coverage percentage and writes a coverage profile if requested. This invokes a callback in _testmain.go that will emit coverage data at the point where test execution is complete, for \"go test -cover\" runs."
      },
      {
        "name": "createTempFile",
        "desc": ""
      },
      {
        "name": "fRunner",
        "desc": "fRunner wraps a call to a fuzz test and ensures that cleanup functions are called and status flags are set. fRunner should be called in its own goroutine. To wait for its completion, receive from f.signal.  fRunner is analogous to tRunner, which wraps subtests started with T.Run. Unit tests and fuzz tests work a little differently, so for now, these functions aren't consolidated. In particular, because there are no F.Run and F.Parallel methods, i.e., no fuzz sub-tests or parallel fuzz tests, a few simplifications are made. We also require that F.Fuzz, F.Skip, or F.Fail is called."
      },
      {
        "name": "fmtDuration",
        "desc": "fmtDuration returns a string representing d in the form \"87.00s\"."
      },
      {
        "name": "highPrecisionTimeSince",
        "desc": "highPrecisionTimeSince returns duration since b."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initBenchmarkFlags",
        "desc": ""
      },
      {
        "name": "initFuzzFlags",
        "desc": ""
      },
      {
        "name": "isSpace",
        "desc": ""
      },
      {
        "name": "isWindowsRetryable",
        "desc": "isWindowsRetryable reports whether err is a Windows error code that may be fixed by retrying a failed filesystem operation."
      },
      {
        "name": "listTests",
        "desc": ""
      },
      {
        "name": "makeRegexp",
        "desc": ""
      },
      {
        "name": "parseCpuList",
        "desc": ""
      },
      {
        "name": "parseSubtestNumber",
        "desc": "parseSubtestNumber splits a subtest name into a \"#%02d\"-formatted int32 suffix (if present), and a prefix preceding that suffix (always)."
      },
      {
        "name": "pcToName",
        "desc": ""
      },
      {
        "name": "predictN",
        "desc": ""
      },
      {
        "name": "prettyPrint",
        "desc": ""
      },
      {
        "name": "registerCover",
        "desc": "registerCover is invoked during \"go test -cover\" runs. It is used to record a 'tear down' function (to be called when the test is complete) and the coverage mode."
      },
      {
        "name": "removeAll",
        "desc": "removeAll is like os.RemoveAll, but retries Windows \"Access is denied.\" errors up to an arbitrary timeout.  Those errors have been known to occur spuriously on at least the windows-amd64-2012 builder (https://go.dev/issue/50051), and can only occur legitimately if the test leaves behind a temp file that either is still open or the test otherwise lacks permission to delete. In the case of legitimate failures, a failing test may take a bit longer to fail, but once the test is fixed the extra latency will go away."
      },
      {
        "name": "rewrite",
        "desc": "rewrite rewrites a subname to having only printable characters and no white space."
      },
      {
        "name": "runBenchmarks",
        "desc": ""
      },
      {
        "name": "runExample",
        "desc": "TODO(@musiol, @odeke-em): unify this code back into example.go when js/wasm gets an os.Pipe implementation."
      },
      {
        "name": "runExamples",
        "desc": ""
      },
      {
        "name": "runFuzzTests",
        "desc": "runFuzzTests runs the fuzz tests matching the pattern for -run. This will only run the (*F).Fuzz function for each seed corpus without using the fuzzing engine to generate or mutate inputs."
      },
      {
        "name": "runFuzzing",
        "desc": "runFuzzing runs the fuzz test matching the pattern for -fuzz. Only one such fuzz test must match. This will run the fuzzing engine to generate and mutate new inputs against the fuzz target.  If fuzzing is disabled (-test.fuzz is not set), runFuzzing returns immediately."
      },
      {
        "name": "runTests",
        "desc": ""
      },
      {
        "name": "runningList",
        "desc": "runningList returns the list of running tests."
      },
      {
        "name": "shouldFailFast",
        "desc": ""
      },
      {
        "name": "tRunner",
        "desc": ""
      },
      {
        "name": "testOutputEscape",
        "desc": ""
      },
      {
        "name": "testingSynctestTest",
        "desc": "testingSynctestTest runs f within a synctest bubble. It is called by synctest.Test, from within an already-created bubble."
      },
      {
        "name": "toOutputDir",
        "desc": "toOutputDir returns the file name relocated, if required, to outputDir. Simple implementation to avoid pulling in path/filepath."
      },
      {
        "name": "Attr",
        "desc": "Attr emits a test attribute associated with this test.  The key must not contain whitespace. The value must not contain newlines or carriage returns.  The meaning of different attribute keys is left up to continuous integration systems and test frameworks.  Test attributes are emitted immediately in the test log, but they are intended to be treated as unordered."
      },
      {
        "name": "Chdir",
        "desc": "Chdir calls [os.Chdir] and uses Cleanup to restore the current working directory to its original value after the test. On Unix, it also sets PWD environment variable for the duration of the test.  Because Chdir affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Cleanup",
        "desc": "Cleanup registers a function to be called when the test (or subtest) and all its subtests complete. Cleanup functions will be called in last added, first called order."
      },
      {
        "name": "Context",
        "desc": "Context returns a context that is canceled just before Cleanup-registered functions are called.  Cleanup functions can wait for any resources that shut down on [context.Context.Done] before the test or benchmark completes."
      },
      {
        "name": "Elapsed",
        "desc": "Elapsed returns the measured elapsed time of the benchmark. The duration reported by Elapsed matches the one measured by [B.StartTimer], [B.StopTimer], and [B.ResetTimer]."
      },
      {
        "name": "Error",
        "desc": "Error is equivalent to Log followed by Fail."
      },
      {
        "name": "Errorf",
        "desc": "Errorf is equivalent to Logf followed by Fail."
      },
      {
        "name": "Fail",
        "desc": "Fail marks the function as having failed but continues execution."
      },
      {
        "name": "FailNow",
        "desc": "FailNow marks the function as having failed and stops its execution by calling [runtime.Goexit] (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines."
      },
      {
        "name": "Failed",
        "desc": "Failed reports whether the function has failed."
      },
      {
        "name": "Fatal",
        "desc": "Fatal is equivalent to Log followed by FailNow."
      },
      {
        "name": "Fatalf",
        "desc": "Fatalf is equivalent to Logf followed by FailNow."
      },
      {
        "name": "Helper",
        "desc": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines."
      },
      {
        "name": "Log",
        "desc": "Log formats its arguments using default formatting, analogous to [fmt.Println], and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Log after a test or benchmark returns."
      },
      {
        "name": "Logf",
        "desc": "Logf formats its arguments according to the format, analogous to [fmt.Printf], and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Logf after a test or benchmark returns."
      },
      {
        "name": "Loop",
        "desc": "Loop returns true as long as the benchmark should continue running.  A typical benchmark is structured like:  \tfunc Benchmark(b *testing.B) { \t\t... setup ... \t\tfor b.Loop() { \t\t\t... code to measure ... \t\t} \t\t... cleanup ... \t}  Loop resets the benchmark timer the first time it is called in a benchmark, so any setup performed prior to starting the benchmark loop does not count toward the benchmark measurement. Likewise, when it returns false, it stops the timer so cleanup code is not measured.  Within the body of a \"for b.Loop() { ... }\" loop, arguments to and results from function calls within the loop are kept alive, preventing the compiler from fully optimizing away the loop body. Currently, this is implemented by disabling inlining of functions called in a b.Loop loop. This applies only to calls syntactically between the curly braces of the loop, and the loop condition must be written exactly as \"b.Loop()\". Optimizations are performed as usual in any functions called by the loop.  After Loop returns false, b.N contains the total number of iterations that ran, so the benchmark may use b.N to compute other average metrics.  Prior to the introduction of Loop, benchmarks were expected to contain an explicit loop from 0 to b.N. Benchmarks should either use Loop or contain a loop to b.N, but not both. Loop offers more automatic management of the benchmark timer, and runs each benchmark function only once per measurement, whereas b.N-based benchmarks must run the benchmark function (and any associated setup and cleanup) several times."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the running (sub-) test or benchmark.  The name will include the name of the test along with the names of any nested sub-tests. If two sibling sub-tests have the same name, Name will append a suffix to guarantee the returned name is unique."
      },
      {
        "name": "Output",
        "desc": "Output returns a Writer that writes to the same test output stream as TB.Log. The output is indented like TB.Log lines, but Output does not add source locations or newlines. The output is internally line buffered, and a call to TB.Log or the end of the test will implicitly flush the buffer, followed by a newline. After a test function and all its parents return, neither Output nor the Write method may be called."
      },
      {
        "name": "ReportAllocs",
        "desc": "ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs."
      },
      {
        "name": "ReportMetric",
        "desc": "ReportMetric adds \"n unit\" to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in \"/op\". ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as \"allocs/op\"), ReportMetric will override that metric. Setting \"ns/op\" to 0 will suppress that built-in metric."
      },
      {
        "name": "ResetTimer",
        "desc": "ResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running."
      },
      {
        "name": "Run",
        "desc": "Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.  A subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1."
      },
      {
        "name": "RunParallel",
        "desc": "RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call [B.SetParallelism] before RunParallel. RunParallel is usually used with the go test -cpu flag.  The body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the [B.StartTimer], [B.StopTimer], or [B.ResetTimer] functions, because they have global effect. It should also not call [B.Run].  RunParallel reports ns/op values as wall time for the benchmark as a whole, not the sum of wall time or CPU time over each parallel goroutine."
      },
      {
        "name": "SetBytes",
        "desc": "SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s."
      },
      {
        "name": "SetParallelism",
        "desc": "SetParallelism sets the number of goroutines used by [B.RunParallel] to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect."
      },
      {
        "name": "Setenv",
        "desc": "Setenv calls [os.Setenv] and uses Cleanup to restore the environment variable to its original value after the test.  Because Setenv affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Skip",
        "desc": "Skip is equivalent to Log followed by SkipNow."
      },
      {
        "name": "SkipNow",
        "desc": "SkipNow marks the test as having been skipped and stops its execution by calling [runtime.Goexit]. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines."
      },
      {
        "name": "Skipf",
        "desc": "Skipf is equivalent to Logf followed by SkipNow."
      },
      {
        "name": "Skipped",
        "desc": "Skipped reports whether the test was skipped."
      },
      {
        "name": "StartTimer",
        "desc": "StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to [B.StopTimer]."
      },
      {
        "name": "StopTimer",
        "desc": "StopTimer stops timing a test. This can be used to pause the timer while performing steps that you don't want to measure."
      },
      {
        "name": "TempDir",
        "desc": "TempDir returns a temporary directory for the test to use. The directory is automatically removed when the test and all its subtests complete. Each subsequent call to TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal."
      },
      {
        "name": "add",
        "desc": "add simulates running benchmarks in sequence in a single iteration. It is used to give some meaningful results in case func Benchmark is used in combination with Run."
      },
      {
        "name": "callSite",
        "desc": "callSite retrieves and formats the file and line of the call site."
      },
      {
        "name": "checkFuzzFn",
        "desc": ""
      },
      {
        "name": "checkRaces",
        "desc": "checkRaces checks whether the global count of data race errors has increased since c's count was last reset.  If so, it marks c as having failed due to those races (logging an error for the first such race), and updates the race counts for the parents of c so that if they are currently suspended (such as in a call to T.Run) they will not log separate errors for the race(s).  Note that multiple tests may be marked as failed due to the same race if they are executing in parallel."
      },
      {
        "name": "destination",
        "desc": "destination selects the test to which output should be appended. It returns the test if it is incomplete. Otherwise, it finds its closest incomplete parent."
      },
      {
        "name": "doBench",
        "desc": ""
      },
      {
        "name": "flushPartial",
        "desc": "flushPartial checks the buffer for partial logs and outputs them."
      },
      {
        "name": "flushToParent",
        "desc": "flushToParent writes c.output to the parent after first writing the header with the given format and arguments."
      },
      {
        "name": "frameSkip",
        "desc": "frameSkip searches, starting after skip frames, for the first caller frame in a function not marked as a helper and returns that frame. The search stops if it finds a tRunner function that was the entry point into the test and the test is not a subtest. This function must be called with c.mu held."
      },
      {
        "name": "launch",
        "desc": "launch launches the benchmark function. It gradually increases the number of benchmark iterations until the benchmark runs for the requested benchtime. launch is run by the doBench function as a separate goroutine. run1 must have been called on b."
      },
      {
        "name": "log",
        "desc": "log generates the output. It is always at the same stack depth. log inserts indentation and the final newline if necessary. It prefixes the string with the file and line of the call site."
      },
      {
        "name": "loopSlowPath",
        "desc": ""
      },
      {
        "name": "private",
        "desc": ""
      },
      {
        "name": "resetRaces",
        "desc": "resetRaces updates c.parent's count of data race errors (or the global count, if c has no parent), and updates c.lastRaceErrors to match.  Any races that occurred prior to this call to resetRaces will not be attributed to c."
      },
      {
        "name": "run",
        "desc": "run executes the benchmark in a separate goroutine, including all of its subbenchmarks. b must not have subbenchmarks."
      },
      {
        "name": "run1",
        "desc": "run1 runs the first iteration of benchFunc. It reports whether more iterations of this benchmarks should be run."
      },
      {
        "name": "runCleanup",
        "desc": "runCleanup is called at the end of the test. If ph is recoverAndReturnPanic, it will catch panics, and return the recovered value if any."
      },
      {
        "name": "runN",
        "desc": "runN runs a single benchmark for the specified number of iterations."
      },
      {
        "name": "setOutputWriter",
        "desc": "setOutputWriter initializes an outputWriter and sets it as a common field."
      },
      {
        "name": "setRan",
        "desc": ""
      },
      {
        "name": "stopOrScaleBLoop",
        "desc": ""
      },
      {
        "name": "trimOutput",
        "desc": "trimOutput shortens the output from a benchmark, which can be very long."
      },
      {
        "name": "AllocedBytesPerOp",
        "desc": "AllocedBytesPerOp returns the \"B/op\" metric, which is calculated as r.MemBytes / r.N."
      },
      {
        "name": "AllocsPerOp",
        "desc": "AllocsPerOp returns the \"allocs/op\" metric, which is calculated as r.MemAllocs / r.N."
      },
      {
        "name": "MemString",
        "desc": "MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'."
      },
      {
        "name": "NsPerOp",
        "desc": "NsPerOp returns the \"ns/op\" metric."
      },
      {
        "name": "String",
        "desc": "String returns a summary of the benchmark results. It follows the benchmark result line format from https://golang.org/design/14313-benchmark-format, not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by [BenchmarkResult.MemString]."
      },
      {
        "name": "mbPerSec",
        "desc": "mbPerSec returns the \"MB/s\" metric."
      },
      {
        "name": "Add",
        "desc": "Add will add the arguments to the seed corpus for the fuzz test. This will be a no-op if called after or within the fuzz target, and args must match the arguments for the fuzz target."
      },
      {
        "name": "Attr",
        "desc": "Attr emits a test attribute associated with this test.  The key must not contain whitespace. The value must not contain newlines or carriage returns.  The meaning of different attribute keys is left up to continuous integration systems and test frameworks.  Test attributes are emitted immediately in the test log, but they are intended to be treated as unordered."
      },
      {
        "name": "Chdir",
        "desc": "Chdir calls [os.Chdir] and uses Cleanup to restore the current working directory to its original value after the test. On Unix, it also sets PWD environment variable for the duration of the test.  Because Chdir affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Cleanup",
        "desc": "Cleanup registers a function to be called when the test (or subtest) and all its subtests complete. Cleanup functions will be called in last added, first called order."
      },
      {
        "name": "Context",
        "desc": "Context returns a context that is canceled just before Cleanup-registered functions are called.  Cleanup functions can wait for any resources that shut down on [context.Context.Done] before the test or benchmark completes."
      },
      {
        "name": "Error",
        "desc": "Error is equivalent to Log followed by Fail."
      },
      {
        "name": "Errorf",
        "desc": "Errorf is equivalent to Logf followed by Fail."
      },
      {
        "name": "Fail",
        "desc": "Fail marks the function as having failed but continues execution."
      },
      {
        "name": "FailNow",
        "desc": "FailNow marks the function as having failed and stops its execution by calling [runtime.Goexit] (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines."
      },
      {
        "name": "Failed",
        "desc": "Failed reports whether the function has failed."
      },
      {
        "name": "Fatal",
        "desc": "Fatal is equivalent to Log followed by FailNow."
      },
      {
        "name": "Fatalf",
        "desc": "Fatalf is equivalent to Logf followed by FailNow."
      },
      {
        "name": "Fuzz",
        "desc": "Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of arguments, those arguments will be added to the seed corpus.  ff must be a function with no return value whose first argument is [*T] and whose remaining arguments are the types to be fuzzed. For example:  \tf.Fuzz(func(t *testing.T, b []byte, i int) { ... })  The following types are allowed: []byte, string, bool, byte, rune, float32, float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64. More types may be supported in the future.  ff must not call any [*F] methods, e.g. [F.Log], [F.Error], [F.Skip]. Use the corresponding [*T] method instead. The only [*F] methods that are allowed in the F.Fuzz function are [F.Failed] and [F.Name].  This function should be fast and deterministic, and its behavior should not depend on shared state. No mutable input arguments, or pointers to them, should be retained between executions of the fuzz function, as the memory backing them may be mutated during a subsequent invocation. ff must not modify the underlying data of the arguments provided by the fuzzing engine.  When fuzzing, F.Fuzz does not return until a problem is found, time runs out (set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz should be called exactly once, unless [F.Skip] or [F.Fail] is called beforehand."
      },
      {
        "name": "Helper",
        "desc": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines."
      },
      {
        "name": "Log",
        "desc": "Log formats its arguments using default formatting, analogous to [fmt.Println], and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Log after a test or benchmark returns."
      },
      {
        "name": "Logf",
        "desc": "Logf formats its arguments according to the format, analogous to [fmt.Printf], and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Logf after a test or benchmark returns."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the running (sub-) test or benchmark.  The name will include the name of the test along with the names of any nested sub-tests. If two sibling sub-tests have the same name, Name will append a suffix to guarantee the returned name is unique."
      },
      {
        "name": "Output",
        "desc": "Output returns a Writer that writes to the same test output stream as TB.Log. The output is indented like TB.Log lines, but Output does not add source locations or newlines. The output is internally line buffered, and a call to TB.Log or the end of the test will implicitly flush the buffer, followed by a newline. After a test function and all its parents return, neither Output nor the Write method may be called."
      },
      {
        "name": "Setenv",
        "desc": "Setenv calls [os.Setenv] and uses Cleanup to restore the environment variable to its original value after the test.  Because Setenv affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Skip",
        "desc": "Skip is equivalent to Log followed by SkipNow."
      },
      {
        "name": "SkipNow",
        "desc": "SkipNow marks the test as having been skipped and stops its execution by calling [runtime.Goexit]. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines."
      },
      {
        "name": "Skipf",
        "desc": "Skipf is equivalent to Logf followed by SkipNow."
      },
      {
        "name": "Skipped",
        "desc": "Skipped reports whether the test was skipped."
      },
      {
        "name": "TempDir",
        "desc": "TempDir returns a temporary directory for the test to use. The directory is automatically removed when the test and all its subtests complete. Each subsequent call to TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal."
      },
      {
        "name": "callSite",
        "desc": "callSite retrieves and formats the file and line of the call site."
      },
      {
        "name": "checkFuzzFn",
        "desc": ""
      },
      {
        "name": "checkRaces",
        "desc": "checkRaces checks whether the global count of data race errors has increased since c's count was last reset.  If so, it marks c as having failed due to those races (logging an error for the first such race), and updates the race counts for the parents of c so that if they are currently suspended (such as in a call to T.Run) they will not log separate errors for the race(s).  Note that multiple tests may be marked as failed due to the same race if they are executing in parallel."
      },
      {
        "name": "destination",
        "desc": "destination selects the test to which output should be appended. It returns the test if it is incomplete. Otherwise, it finds its closest incomplete parent."
      },
      {
        "name": "flushPartial",
        "desc": "flushPartial checks the buffer for partial logs and outputs them."
      },
      {
        "name": "flushToParent",
        "desc": "flushToParent writes c.output to the parent after first writing the header with the given format and arguments."
      },
      {
        "name": "frameSkip",
        "desc": "frameSkip searches, starting after skip frames, for the first caller frame in a function not marked as a helper and returns that frame. The search stops if it finds a tRunner function that was the entry point into the test and the test is not a subtest. This function must be called with c.mu held."
      },
      {
        "name": "log",
        "desc": "log generates the output. It is always at the same stack depth. log inserts indentation and the final newline if necessary. It prefixes the string with the file and line of the call site."
      },
      {
        "name": "private",
        "desc": ""
      },
      {
        "name": "report",
        "desc": ""
      },
      {
        "name": "resetRaces",
        "desc": "resetRaces updates c.parent's count of data race errors (or the global count, if c has no parent), and updates c.lastRaceErrors to match.  Any races that occurred prior to this call to resetRaces will not be attributed to c."
      },
      {
        "name": "runCleanup",
        "desc": "runCleanup is called at the end of the test. If ph is recoverAndReturnPanic, it will catch panics, and return the recovered value if any."
      },
      {
        "name": "setOutputWriter",
        "desc": "setOutputWriter initializes an outputWriter and sets it as a common field."
      },
      {
        "name": "setRan",
        "desc": ""
      },
      {
        "name": "processRunResult",
        "desc": "processRunResult computes a summary and status of the result of running an example test. stdout is the captured output from stdout of the test. recovered is the result of invoking recover after running the test, in case it panicked.  If stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout. If the test is chatty/verbose, it'll print a success message to stdout. If recovered is non-nil, it'll panic with that value. If the test panicked with nil, or invoked runtime.Goexit, it'll be made to fail and panic with errNilPanicOrGoexit"
      },
      {
        "name": "Run",
        "desc": "Run runs the tests. It returns an exit code to pass to os.Exit. The exit code is zero when all tests pass, and non-zero for any kind of failure. For machine readable test results, parse the output of 'go test -json'."
      },
      {
        "name": "after",
        "desc": "after runs after all testing."
      },
      {
        "name": "before",
        "desc": "before runs before all testing."
      },
      {
        "name": "startAlarm",
        "desc": "startAlarm starts an alarm if requested."
      },
      {
        "name": "stopAlarm",
        "desc": "stopAlarm turns off the alarm."
      },
      {
        "name": "writeProfiles",
        "desc": ""
      },
      {
        "name": "Next",
        "desc": "Next reports whether there are more iterations to execute."
      },
      {
        "name": "Attr",
        "desc": "Attr emits a test attribute associated with this test.  The key must not contain whitespace. The value must not contain newlines or carriage returns.  The meaning of different attribute keys is left up to continuous integration systems and test frameworks.  Test attributes are emitted immediately in the test log, but they are intended to be treated as unordered."
      },
      {
        "name": "Chdir",
        "desc": "Chdir calls [os.Chdir] and uses Cleanup to restore the current working directory to its original value after the test. On Unix, it also sets PWD environment variable for the duration of the test.  Because Chdir affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Cleanup",
        "desc": "Cleanup registers a function to be called when the test (or subtest) and all its subtests complete. Cleanup functions will be called in last added, first called order."
      },
      {
        "name": "Context",
        "desc": "Context returns a context that is canceled just before Cleanup-registered functions are called.  Cleanup functions can wait for any resources that shut down on [context.Context.Done] before the test or benchmark completes."
      },
      {
        "name": "Deadline",
        "desc": "Deadline reports the time at which the test binary will have exceeded the timeout specified by the -timeout flag.  The ok result is false if the -timeout flag indicates “no timeout” (0)."
      },
      {
        "name": "Error",
        "desc": "Error is equivalent to Log followed by Fail."
      },
      {
        "name": "Errorf",
        "desc": "Errorf is equivalent to Logf followed by Fail."
      },
      {
        "name": "Fail",
        "desc": "Fail marks the function as having failed but continues execution."
      },
      {
        "name": "FailNow",
        "desc": "FailNow marks the function as having failed and stops its execution by calling [runtime.Goexit] (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines."
      },
      {
        "name": "Failed",
        "desc": "Failed reports whether the function has failed."
      },
      {
        "name": "Fatal",
        "desc": "Fatal is equivalent to Log followed by FailNow."
      },
      {
        "name": "Fatalf",
        "desc": "Fatalf is equivalent to Logf followed by FailNow."
      },
      {
        "name": "Helper",
        "desc": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines."
      },
      {
        "name": "Log",
        "desc": "Log formats its arguments using default formatting, analogous to [fmt.Println], and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Log after a test or benchmark returns."
      },
      {
        "name": "Logf",
        "desc": "Logf formats its arguments according to the format, analogous to [fmt.Printf], and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Logf after a test or benchmark returns."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the running (sub-) test or benchmark.  The name will include the name of the test along with the names of any nested sub-tests. If two sibling sub-tests have the same name, Name will append a suffix to guarantee the returned name is unique."
      },
      {
        "name": "Output",
        "desc": "Output returns a Writer that writes to the same test output stream as TB.Log. The output is indented like TB.Log lines, but Output does not add source locations or newlines. The output is internally line buffered, and a call to TB.Log or the end of the test will implicitly flush the buffer, followed by a newline. After a test function and all its parents return, neither Output nor the Write method may be called."
      },
      {
        "name": "Parallel",
        "desc": "Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other."
      },
      {
        "name": "Run",
        "desc": "Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).  Run may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns."
      },
      {
        "name": "Setenv",
        "desc": "Setenv calls os.Setenv(key, value) and uses Cleanup to restore the environment variable to its original value after the test.  Because Setenv affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Skip",
        "desc": "Skip is equivalent to Log followed by SkipNow."
      },
      {
        "name": "SkipNow",
        "desc": "SkipNow marks the test as having been skipped and stops its execution by calling [runtime.Goexit]. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines."
      },
      {
        "name": "Skipf",
        "desc": "Skipf is equivalent to Logf followed by SkipNow."
      },
      {
        "name": "Skipped",
        "desc": "Skipped reports whether the test was skipped."
      },
      {
        "name": "TempDir",
        "desc": "TempDir returns a temporary directory for the test to use. The directory is automatically removed when the test and all its subtests complete. Each subsequent call to TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal."
      },
      {
        "name": "callSite",
        "desc": "callSite retrieves and formats the file and line of the call site."
      },
      {
        "name": "checkFuzzFn",
        "desc": ""
      },
      {
        "name": "checkParallel",
        "desc": ""
      },
      {
        "name": "checkRaces",
        "desc": "checkRaces checks whether the global count of data race errors has increased since c's count was last reset.  If so, it marks c as having failed due to those races (logging an error for the first such race), and updates the race counts for the parents of c so that if they are currently suspended (such as in a call to T.Run) they will not log separate errors for the race(s).  Note that multiple tests may be marked as failed due to the same race if they are executing in parallel."
      },
      {
        "name": "destination",
        "desc": "destination selects the test to which output should be appended. It returns the test if it is incomplete. Otherwise, it finds its closest incomplete parent."
      },
      {
        "name": "flushPartial",
        "desc": "flushPartial checks the buffer for partial logs and outputs them."
      },
      {
        "name": "flushToParent",
        "desc": "flushToParent writes c.output to the parent after first writing the header with the given format and arguments."
      },
      {
        "name": "frameSkip",
        "desc": "frameSkip searches, starting after skip frames, for the first caller frame in a function not marked as a helper and returns that frame. The search stops if it finds a tRunner function that was the entry point into the test and the test is not a subtest. This function must be called with c.mu held."
      },
      {
        "name": "log",
        "desc": "log generates the output. It is always at the same stack depth. log inserts indentation and the final newline if necessary. It prefixes the string with the file and line of the call site."
      },
      {
        "name": "private",
        "desc": ""
      },
      {
        "name": "report",
        "desc": ""
      },
      {
        "name": "resetRaces",
        "desc": "resetRaces updates c.parent's count of data race errors (or the global count, if c has no parent), and updates c.lastRaceErrors to match.  Any races that occurred prior to this call to resetRaces will not be attributed to c."
      },
      {
        "name": "runCleanup",
        "desc": "runCleanup is called at the end of the test. If ph is recoverAndReturnPanic, it will catch panics, and return the recovered value if any."
      },
      {
        "name": "setOutputWriter",
        "desc": "setOutputWriter initializes an outputWriter and sets it as a common field."
      },
      {
        "name": "setRan",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString returns a string that is more readable than the default, which makes it easier to read test errors."
      },
      {
        "name": "matches",
        "desc": ""
      },
      {
        "name": "verify",
        "desc": ""
      },
      {
        "name": "processBench",
        "desc": "processBench runs bench b for the configured CPU counts and prints the results."
      },
      {
        "name": "Get",
        "desc": ""
      },
      {
        "name": "IsBoolFlag",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "prefix",
        "desc": ""
      },
      {
        "name": "Printf",
        "desc": "Printf prints a message, generated by the named test, that does not necessarily mention that tests's name itself."
      },
      {
        "name": "Updatef",
        "desc": "Updatef prints a message about the status of the named test to w.  The formatted message must include the test name itself."
      },
      {
        "name": "prefix",
        "desc": "prefix is like chatty.prefix but using p.json instead of chatty.json. Using p.json allows tests to check the json behavior without modifying the global variable. For convenience, we allow p == nil and treat that as not in json mode (because it's not chatty at all)."
      },
      {
        "name": "Attr",
        "desc": "Attr emits a test attribute associated with this test.  The key must not contain whitespace. The value must not contain newlines or carriage returns.  The meaning of different attribute keys is left up to continuous integration systems and test frameworks.  Test attributes are emitted immediately in the test log, but they are intended to be treated as unordered."
      },
      {
        "name": "Chdir",
        "desc": "Chdir calls [os.Chdir] and uses Cleanup to restore the current working directory to its original value after the test. On Unix, it also sets PWD environment variable for the duration of the test.  Because Chdir affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Cleanup",
        "desc": "Cleanup registers a function to be called when the test (or subtest) and all its subtests complete. Cleanup functions will be called in last added, first called order."
      },
      {
        "name": "Context",
        "desc": "Context returns a context that is canceled just before Cleanup-registered functions are called.  Cleanup functions can wait for any resources that shut down on [context.Context.Done] before the test or benchmark completes."
      },
      {
        "name": "Error",
        "desc": "Error is equivalent to Log followed by Fail."
      },
      {
        "name": "Errorf",
        "desc": "Errorf is equivalent to Logf followed by Fail."
      },
      {
        "name": "Fail",
        "desc": "Fail marks the function as having failed but continues execution."
      },
      {
        "name": "FailNow",
        "desc": "FailNow marks the function as having failed and stops its execution by calling [runtime.Goexit] (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines."
      },
      {
        "name": "Failed",
        "desc": "Failed reports whether the function has failed."
      },
      {
        "name": "Fatal",
        "desc": "Fatal is equivalent to Log followed by FailNow."
      },
      {
        "name": "Fatalf",
        "desc": "Fatalf is equivalent to Logf followed by FailNow."
      },
      {
        "name": "Helper",
        "desc": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines."
      },
      {
        "name": "Log",
        "desc": "Log formats its arguments using default formatting, analogous to [fmt.Println], and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Log after a test or benchmark returns."
      },
      {
        "name": "Logf",
        "desc": "Logf formats its arguments according to the format, analogous to [fmt.Printf], and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. It is an error to call Logf after a test or benchmark returns."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the running (sub-) test or benchmark.  The name will include the name of the test along with the names of any nested sub-tests. If two sibling sub-tests have the same name, Name will append a suffix to guarantee the returned name is unique."
      },
      {
        "name": "Output",
        "desc": "Output returns a Writer that writes to the same test output stream as TB.Log. The output is indented like TB.Log lines, but Output does not add source locations or newlines. The output is internally line buffered, and a call to TB.Log or the end of the test will implicitly flush the buffer, followed by a newline. After a test function and all its parents return, neither Output nor the Write method may be called."
      },
      {
        "name": "Setenv",
        "desc": "Setenv calls [os.Setenv] and uses Cleanup to restore the environment variable to its original value after the test.  Because Setenv affects the whole process, it cannot be used in parallel tests or tests with parallel ancestors."
      },
      {
        "name": "Skip",
        "desc": "Skip is equivalent to Log followed by SkipNow."
      },
      {
        "name": "SkipNow",
        "desc": "SkipNow marks the test as having been skipped and stops its execution by calling [runtime.Goexit]. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines."
      },
      {
        "name": "Skipf",
        "desc": "Skipf is equivalent to Logf followed by SkipNow."
      },
      {
        "name": "Skipped",
        "desc": "Skipped reports whether the test was skipped."
      },
      {
        "name": "TempDir",
        "desc": "TempDir returns a temporary directory for the test to use. The directory is automatically removed when the test and all its subtests complete. Each subsequent call to TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal."
      },
      {
        "name": "callSite",
        "desc": "callSite retrieves and formats the file and line of the call site."
      },
      {
        "name": "checkFuzzFn",
        "desc": ""
      },
      {
        "name": "checkRaces",
        "desc": "checkRaces checks whether the global count of data race errors has increased since c's count was last reset.  If so, it marks c as having failed due to those races (logging an error for the first such race), and updates the race counts for the parents of c so that if they are currently suspended (such as in a call to T.Run) they will not log separate errors for the race(s).  Note that multiple tests may be marked as failed due to the same race if they are executing in parallel."
      },
      {
        "name": "destination",
        "desc": "destination selects the test to which output should be appended. It returns the test if it is incomplete. Otherwise, it finds its closest incomplete parent."
      },
      {
        "name": "flushPartial",
        "desc": "flushPartial checks the buffer for partial logs and outputs them."
      },
      {
        "name": "flushToParent",
        "desc": "flushToParent writes c.output to the parent after first writing the header with the given format and arguments."
      },
      {
        "name": "frameSkip",
        "desc": "frameSkip searches, starting after skip frames, for the first caller frame in a function not marked as a helper and returns that frame. The search stops if it finds a tRunner function that was the entry point into the test and the test is not a subtest. This function must be called with c.mu held."
      },
      {
        "name": "log",
        "desc": "log generates the output. It is always at the same stack depth. log inserts indentation and the final newline if necessary. It prefixes the string with the file and line of the call site."
      },
      {
        "name": "private",
        "desc": ""
      },
      {
        "name": "resetRaces",
        "desc": "resetRaces updates c.parent's count of data race errors (or the global count, if c has no parent), and updates c.lastRaceErrors to match.  Any races that occurred prior to this call to resetRaces will not be attributed to c."
      },
      {
        "name": "runCleanup",
        "desc": "runCleanup is called at the end of the test. If ph is recoverAndReturnPanic, it will catch panics, and return the recovered value if any."
      },
      {
        "name": "setOutputWriter",
        "desc": "setOutputWriter initializes an outputWriter and sets it as a common field."
      },
      {
        "name": "setRan",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Set",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "sub",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "CheckCorpus",
        "desc": ""
      },
      {
        "name": "CoordinateFuzzing",
        "desc": ""
      },
      {
        "name": "ImportPath",
        "desc": ""
      },
      {
        "name": "InitRuntimeCoverage",
        "desc": ""
      },
      {
        "name": "MatchString",
        "desc": ""
      },
      {
        "name": "ReadCorpus",
        "desc": ""
      },
      {
        "name": "ResetCoverage",
        "desc": ""
      },
      {
        "name": "RunFuzzWorker",
        "desc": ""
      },
      {
        "name": "SetPanicOnExit0",
        "desc": ""
      },
      {
        "name": "SnapshotCoverage",
        "desc": ""
      },
      {
        "name": "StartCPUProfile",
        "desc": ""
      },
      {
        "name": "StartTestLog",
        "desc": ""
      },
      {
        "name": "StopCPUProfile",
        "desc": ""
      },
      {
        "name": "StopTestLog",
        "desc": ""
      },
      {
        "name": "WriteProfileTo",
        "desc": ""
      },
      {
        "name": "clearSubNames",
        "desc": "clearSubNames clears the matcher's internal state, potentially freeing memory. After this is called, T.Name may return the same strings as it did for earlier subtests."
      },
      {
        "name": "fullName",
        "desc": ""
      },
      {
        "name": "unique",
        "desc": "unique creates a unique name for the given parent and subname by affixing it with one or more counts, if necessary."
      },
      {
        "name": "Write",
        "desc": "Write writes a log message to the test's output stream, properly formatted and indented. It may not be called after a test function and all its parents return."
      },
      {
        "name": "writeLine",
        "desc": "writeLine generates the output for a given line."
      },
      {
        "name": "matches",
        "desc": ""
      },
      {
        "name": "verify",
        "desc": ""
      },
      {
        "name": "release",
        "desc": ""
      },
      {
        "name": "waitParallel",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "B",
        "desc": "B is a type passed to [Benchmark] functions to manage benchmark timing and control the number of iterations.  A benchmark ends when its Benchmark function returns or calls any of the methods [B.FailNow], [B.Fatal], [B.Fatalf], [B.SkipNow], [B.Skip], or [B.Skipf]. Those methods must be called only from the goroutine running the Benchmark function. The other reporting methods, such as the variations of [B.Log] and [B.Error], may be called simultaneously from multiple goroutines.  Like in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results."
      },
      {
        "name": "BenchmarkResult",
        "desc": "BenchmarkResult contains the results of a benchmark run."
      },
      {
        "name": "Cover",
        "desc": "Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines."
      },
      {
        "name": "CoverBlock",
        "desc": "CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines."
      },
      {
        "name": "F",
        "desc": "F is a type passed to fuzz tests.  Fuzz tests run generated inputs against a provided fuzz target, which can find and report potential bugs in the code being tested.  A fuzz test runs the seed corpus by default, which includes entries provided by [F.Add] and entries in the testdata/fuzz/\u003cFuzzTestName\u003e directory. After any necessary setup and calls to [F.Add], the fuzz test must then call [F.Fuzz] to provide the fuzz target. See the testing package documentation for an example, and see the [F.Fuzz] and [F.Add] method documentation for details.  *F methods can only be called before [F.Fuzz]. Once the test is executing the fuzz target, only [*T] methods can be used. The only *F methods that are allowed in the [F.Fuzz] function are [F.Failed] and [F.Name]."
      },
      {
        "name": "HighPrecisionTime",
        "desc": ""
      },
      {
        "name": "InternalBenchmark",
        "desc": "InternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command."
      },
      {
        "name": "InternalExample",
        "desc": ""
      },
      {
        "name": "InternalFuzzTarget",
        "desc": "InternalFuzzTarget is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command."
      },
      {
        "name": "InternalTest",
        "desc": "InternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command."
      },
      {
        "name": "M",
        "desc": "M is a type passed to a TestMain function to run the actual tests."
      },
      {
        "name": "PB",
        "desc": "A PB is used by RunParallel for running parallel benchmarks."
      },
      {
        "name": "T",
        "desc": "T is a type passed to Test functions to manage test state and support formatted test logs.  A test ends when its Test function returns or calls any of the methods [T.FailNow], [T.Fatal], [T.Fatalf], [T.SkipNow], [T.Skip], or [T.Skipf]. Those methods, as well as the [T.Parallel] method, must be called only from the goroutine running the Test function.  The other reporting methods, such as the variations of [T.Log] and [T.Error], may be called simultaneously from multiple goroutines."
      },
      {
        "name": "TB",
        "desc": "TB is the interface common to [T], [B], and [F]."
      },
      {
        "name": "alternationMatch",
        "desc": "alternationMatch matches a test name if one of the alternations match."
      },
      {
        "name": "benchState",
        "desc": ""
      },
      {
        "name": "chattyFlag",
        "desc": ""
      },
      {
        "name": "chattyPrinter",
        "desc": ""
      },
      {
        "name": "common",
        "desc": "common holds the elements common between T and B and captures common methods such as Errorf."
      },
      {
        "name": "corpusEntry",
        "desc": "corpusEntry is an alias to the same type as internal/fuzz.CorpusEntry. We use a type alias because we don't want to export this type, and we can't import internal/fuzz from testing."
      },
      {
        "name": "discard",
        "desc": ""
      },
      {
        "name": "durationOrCountFlag",
        "desc": ""
      },
      {
        "name": "filterMatch",
        "desc": ""
      },
      {
        "name": "funcWriter",
        "desc": ""
      },
      {
        "name": "fuzzCrashError",
        "desc": "fuzzCrashError is satisfied by a failing input detected while fuzzing. These errors are written to the seed corpus and can be re-run with 'go test'. Errors within the fuzzing framework (like I/O errors between coordinator and worker processes) don't satisfy this interface."
      },
      {
        "name": "fuzzMode",
        "desc": ""
      },
      {
        "name": "fuzzResult",
        "desc": "fuzzResult contains the results of a fuzz run."
      },
      {
        "name": "fuzzState",
        "desc": "fuzzState holds fields common to all fuzz tests."
      },
      {
        "name": "highPrecisionTime",
        "desc": "highPrecisionTime represents a single point in time with query performance counter. time.Time on Windows has low system granularity, which is not suitable for measuring short time intervals.  TODO: If Windows runtime implements high resolution timing then highPrecisionTime can be removed."
      },
      {
        "name": "indenter",
        "desc": ""
      },
      {
        "name": "matchStringOnly",
        "desc": ""
      },
      {
        "name": "matcher",
        "desc": "matcher sanitizes, uniques, and filters names of subtests and subbenchmarks."
      },
      {
        "name": "outputWriter",
        "desc": "outputWriter buffers, formats and writes log messages."
      },
      {
        "name": "panicHandling",
        "desc": "panicHandling controls the panic handling used by runCleanup."
      },
      {
        "name": "simpleMatch",
        "desc": "simpleMatch matches a test name if all of the pattern strings match in sequence."
      },
      {
        "name": "testDeps",
        "desc": "testDeps is an internal interface of functionality that is passed into this package by a test's generated main package. The canonical implementation of this interface is testing/internal/testdeps's TestDeps."
      },
      {
        "name": "testState",
        "desc": "testState holds all fields that are common to all tests. This includes synchronization primitives to run at most *parallel tests."
      }
    ]
  },
  {
    "name": "testing/fstest",
    "desc": "Package fstest implements support for testing implementations and users of file systems.",
    "functions": [
      {
        "name": "TestDash",
        "desc": ""
      },
      {
        "name": "TestFS",
        "desc": "TestFS tests a file system implementation. It walks the entire tree of files in fsys, opening and checking that each file behaves correctly. Symbolic links are not followed, but their Lstat values are checked if the file system implements [fs.ReadLinkFS]. It also checks that the file system contains at least the expected files. As a special case, if no expected files are listed, fsys must be empty. Otherwise, fsys must contain at least the listed files; it can also contain others. The contents of fsys must not change concurrently with TestFS.  If TestFS finds any misbehaviors, it returns either the first error or a list of errors. Use [errors.Is] or [errors.As] to inspect.  Typical usage inside a test is:  \tif err := fstest.TestFS(myFS, \"file/that/should/be/present\"); err != nil { \t\tt.Fatal(err) \t}"
      },
      {
        "name": "TestMapFS",
        "desc": ""
      },
      {
        "name": "TestMapFSChmodDot",
        "desc": ""
      },
      {
        "name": "TestMapFSFileInfoName",
        "desc": ""
      },
      {
        "name": "TestMapFSSymlink",
        "desc": ""
      },
      {
        "name": "TestShuffledFS",
        "desc": ""
      },
      {
        "name": "TestSymlink",
        "desc": ""
      },
      {
        "name": "TestTestFSWrappedErrors",
        "desc": ""
      },
      {
        "name": "formatEntry",
        "desc": "formatEntry formats an fs.DirEntry into a string for error messages and comparison."
      },
      {
        "name": "formatInfo",
        "desc": "formatInfo formats an fs.FileInfo into a string for error messages and comparison."
      },
      {
        "name": "formatInfoEntry",
        "desc": "formatInfoEntry formats an fs.FileInfo into a string like the result of formatEntry, for error messages and comparison."
      },
      {
        "name": "testFS",
        "desc": ""
      },
      {
        "name": "Glob",
        "desc": ""
      },
      {
        "name": "Lstat",
        "desc": "Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link."
      },
      {
        "name": "Open",
        "desc": "Open opens the named file after following any symbolic links."
      },
      {
        "name": "ReadDir",
        "desc": ""
      },
      {
        "name": "ReadFile",
        "desc": ""
      },
      {
        "name": "ReadLink",
        "desc": "ReadLink returns the destination of the named symbolic link."
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "Sub",
        "desc": ""
      },
      {
        "name": "lstat",
        "desc": ""
      },
      {
        "name": "resolveSymlinks",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "checkBadPath",
        "desc": "checkBadPath checks that various invalid forms of file's name cannot be opened using open."
      },
      {
        "name": "checkDir",
        "desc": "checkDir checks the directory dir, which is expected to exist (it is either the root or was found in a directory listing with IsDir true)."
      },
      {
        "name": "checkDirList",
        "desc": "checkDirList checks that two directory lists contain the same files and file info. The order of the lists need not match."
      },
      {
        "name": "checkFile",
        "desc": "checkFile checks that basic file reading works correctly."
      },
      {
        "name": "checkFileRead",
        "desc": ""
      },
      {
        "name": "checkGlob",
        "desc": "checkGlob checks that various glob patterns work if the file system implements GlobFS."
      },
      {
        "name": "checkOpen",
        "desc": "checkOpen validates file opening behavior by attempting to open and then close the given file path."
      },
      {
        "name": "checkStat",
        "desc": "checkStat checks that a direct stat of path matches entry, which was found in the parent's directory listing."
      },
      {
        "name": "errorf",
        "desc": "errorf adds an error to the list of errors."
      },
      {
        "name": "openDir",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Info",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadDir",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "Info",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "Sub",
        "desc": ""
      },
      {
        "name": "Close",
        "desc": ""
      },
      {
        "name": "Info",
        "desc": ""
      },
      {
        "name": "IsDir",
        "desc": ""
      },
      {
        "name": "ModTime",
        "desc": ""
      },
      {
        "name": "Mode",
        "desc": ""
      },
      {
        "name": "Name",
        "desc": ""
      },
      {
        "name": "Read",
        "desc": ""
      },
      {
        "name": "ReadAt",
        "desc": ""
      },
      {
        "name": "Seek",
        "desc": ""
      },
      {
        "name": "Size",
        "desc": ""
      },
      {
        "name": "Stat",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Sys",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "ReadDir",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "MapFS",
        "desc": "A MapFS is a simple in-memory file system for use in tests, represented as a map from path names (arguments to Open) to information about the files, directories, or symbolic links they represent.  The map need not include parent directories for files contained in the map; those will be synthesized if needed. But a directory can still be included by setting the [MapFile.Mode]'s [fs.ModeDir] bit; this may be necessary for detailed control over the directory's [fs.FileInfo] or to create an empty directory.  File system operations read directly from the map, so that the file system can be changed by editing the map as needed. An implication is that file system operations must not run concurrently with changes to the map, which would be a race. Another implication is that opening or reading a directory requires iterating over the entire map, so a MapFS should typically be used with not more than a few hundred entries or directory reads."
      },
      {
        "name": "MapFile",
        "desc": "A MapFile describes a single file in a [MapFS]."
      },
      {
        "name": "failPermFS",
        "desc": "failPermFS is a filesystem that always fails with fs.ErrPermission."
      },
      {
        "name": "fsOnly",
        "desc": "fsOnly is a wrapper that hides all but the fs.FS methods, to avoid an infinite recursion when implementing special methods in terms of helpers that would use them. (In general, implementing these methods using the package fs helpers is redundant and unnecessary, but having the methods may make MapFS exercise more code paths when used in tests.)"
      },
      {
        "name": "fsTester",
        "desc": "An fsTester holds state for running the test."
      },
      {
        "name": "mapDir",
        "desc": "A mapDir is a directory fs.File (so also an fs.ReadDirFile) open for reading."
      },
      {
        "name": "mapFileInfo",
        "desc": "A mapFileInfo implements fs.FileInfo and fs.DirEntry for a given map file."
      },
      {
        "name": "noSub",
        "desc": ""
      },
      {
        "name": "openMapFile",
        "desc": "An openMapFile is a regular (non-directory) fs.File open for reading."
      },
      {
        "name": "shuffledFS",
        "desc": ""
      },
      {
        "name": "shuffledFile",
        "desc": ""
      }
    ]
  },
  {
    "name": "testing/iotest",
    "desc": "",
    "functions": [
      {
        "name": "ExampleErrReader",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "testing/quick",
    "desc": "Package quick implements utility functions to help with black box testing.  The testing/quick package is frozen and is not accepting new features.",
    "functions": [
      {
        "name": "Check",
        "desc": "Check looks for an input to f, any function that returns bool, such that f returns false. It calls f repeatedly, with arbitrary values for each argument. If f returns false on a given input, Check returns that input as a *[CheckError]. For example:  \tfunc TestOddMultipleOfThree(t *testing.T) { \t\tf := func(x int) bool { \t\t\ty := OddMultipleOfThree(x) \t\t\treturn y%2 == 1 \u0026\u0026 y%3 == 0 \t\t} \t\tif err := quick.Check(f, nil); err != nil { \t\t\tt.Error(err) \t\t} \t}"
      },
      {
        "name": "CheckEqual",
        "desc": "CheckEqual looks for an input on which f and g return different results. It calls f and g repeatedly with arbitrary values for each argument. If f and g return different answers, CheckEqual returns a *[CheckEqualError] describing the input and the outputs."
      },
      {
        "name": "TestCheckEqual",
        "desc": ""
      },
      {
        "name": "TestCheckProperty",
        "desc": ""
      },
      {
        "name": "TestEmptyStruct",
        "desc": ""
      },
      {
        "name": "TestFailure",
        "desc": ""
      },
      {
        "name": "TestInt64",
        "desc": ""
      },
      {
        "name": "TestMutuallyRecursive",
        "desc": ""
      },
      {
        "name": "TestNonZeroSliceAndMap",
        "desc": "Some serialization formats (e.g. encoding/pem) cannot distinguish between a nil and an empty map or slice, so avoid generating the zero value for these."
      },
      {
        "name": "TestRecursive",
        "desc": "Recursive data structures didn't terminate. Issues 8818 and 11148."
      },
      {
        "name": "Value",
        "desc": "Value returns an arbitrary value of the given type. If the type implements the [Generator] interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported."
      },
      {
        "name": "arbitraryValues",
        "desc": "arbitraryValues writes Values to args such that args contains Values suitable for calling f."
      },
      {
        "name": "fArray",
        "desc": ""
      },
      {
        "name": "fBool",
        "desc": ""
      },
      {
        "name": "fComplex128",
        "desc": ""
      },
      {
        "name": "fComplex64",
        "desc": ""
      },
      {
        "name": "fFloat32",
        "desc": ""
      },
      {
        "name": "fFloat64",
        "desc": ""
      },
      {
        "name": "fInt",
        "desc": ""
      },
      {
        "name": "fInt16",
        "desc": ""
      },
      {
        "name": "fInt32",
        "desc": ""
      },
      {
        "name": "fInt64",
        "desc": ""
      },
      {
        "name": "fInt8",
        "desc": ""
      },
      {
        "name": "fMap",
        "desc": ""
      },
      {
        "name": "fPtr",
        "desc": ""
      },
      {
        "name": "fSlice",
        "desc": ""
      },
      {
        "name": "fString",
        "desc": ""
      },
      {
        "name": "fUint",
        "desc": ""
      },
      {
        "name": "fUint16",
        "desc": ""
      },
      {
        "name": "fUint32",
        "desc": ""
      },
      {
        "name": "fUint64",
        "desc": ""
      },
      {
        "name": "fUint8",
        "desc": ""
      },
      {
        "name": "fUintptr",
        "desc": ""
      },
      {
        "name": "functionAndType",
        "desc": ""
      },
      {
        "name": "myStructProperty",
        "desc": ""
      },
      {
        "name": "randFloat32",
        "desc": "randFloat32 generates a random float taking the full range of a float32."
      },
      {
        "name": "randFloat64",
        "desc": "randFloat64 generates a random float taking the full range of a float64."
      },
      {
        "name": "randInt64",
        "desc": "randInt64 returns a random int64."
      },
      {
        "name": "reportError",
        "desc": ""
      },
      {
        "name": "sizedValue",
        "desc": "sizedValue returns an arbitrary value of the given type. The size hint is used for shrinking as a function of indirection level so that recursive data structures will terminate."
      },
      {
        "name": "toInterfaces",
        "desc": ""
      },
      {
        "name": "toString",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "getMaxCount",
        "desc": "getMaxCount returns the maximum number of iterations to run for a given Config."
      },
      {
        "name": "getRand",
        "desc": "getRand returns the *rand.Rand to use for a given Config."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Generate",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "A",
        "desc": ""
      },
      {
        "name": "B",
        "desc": ""
      },
      {
        "name": "CheckEqualError",
        "desc": "A CheckEqualError is the result [CheckEqual] finding an error."
      },
      {
        "name": "CheckError",
        "desc": "A CheckError is the result of Check finding an error."
      },
      {
        "name": "Config",
        "desc": "A Config structure contains options for running a test."
      },
      {
        "name": "Generator",
        "desc": "A Generator can generate random values of its own type."
      },
      {
        "name": "SetupError",
        "desc": "A SetupError is the result of an error in the way that check is being used, independent of the functions being tested."
      },
      {
        "name": "TestArrayAlias",
        "desc": ""
      },
      {
        "name": "TestBoolAlias",
        "desc": ""
      },
      {
        "name": "TestComplex128Alias",
        "desc": ""
      },
      {
        "name": "TestComplex64Alias",
        "desc": ""
      },
      {
        "name": "TestFloat32Alias",
        "desc": ""
      },
      {
        "name": "TestFloat64Alias",
        "desc": ""
      },
      {
        "name": "TestInt16Alias",
        "desc": ""
      },
      {
        "name": "TestInt32Alias",
        "desc": ""
      },
      {
        "name": "TestInt64Alias",
        "desc": ""
      },
      {
        "name": "TestInt8Alias",
        "desc": ""
      },
      {
        "name": "TestIntAlias",
        "desc": ""
      },
      {
        "name": "TestMapAlias",
        "desc": ""
      },
      {
        "name": "TestPtrAlias",
        "desc": ""
      },
      {
        "name": "TestSliceAlias",
        "desc": ""
      },
      {
        "name": "TestStringAlias",
        "desc": ""
      },
      {
        "name": "TestStruct",
        "desc": ""
      },
      {
        "name": "TestStructAlias",
        "desc": ""
      },
      {
        "name": "TestUint16Alias",
        "desc": ""
      },
      {
        "name": "TestUint32Alias",
        "desc": ""
      },
      {
        "name": "TestUint64Alias",
        "desc": ""
      },
      {
        "name": "TestUint8Alias",
        "desc": ""
      },
      {
        "name": "TestUintAlias",
        "desc": ""
      },
      {
        "name": "TestUintptrAlias",
        "desc": ""
      },
      {
        "name": "myStruct",
        "desc": "This tests that ArbitraryValue is working by checking that all the arbitrary values of type MyStruct have x = 42."
      }
    ]
  },
  {
    "name": "testing/slogtest",
    "desc": "",
    "functions": [
      {
        "name": "Example_parsing",
        "desc": "This example demonstrates one technique for testing a handler with this package. The handler is given a [bytes.Buffer] to write to, and each line of the resulting output is parsed. For JSON output, [encoding/json.Unmarshal] produces a result in the desired format when given a pointer to a map[string]any."
      },
      {
        "name": "TestRun",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "testing/synctest",
    "desc": "",
    "functions": [
      {
        "name": "TestCleanup",
        "desc": ""
      },
      {
        "name": "TestContext",
        "desc": ""
      },
      {
        "name": "TestContextAfterFunc",
        "desc": ""
      },
      {
        "name": "TestContextWithTimeout",
        "desc": ""
      },
      {
        "name": "TestDeadline",
        "desc": ""
      },
      {
        "name": "TestError",
        "desc": ""
      },
      {
        "name": "TestFatal",
        "desc": ""
      },
      {
        "name": "TestHTTPTransport100Continue",
        "desc": ""
      },
      {
        "name": "TestHelper",
        "desc": ""
      },
      {
        "name": "TestNow",
        "desc": ""
      },
      {
        "name": "TestParallel",
        "desc": ""
      },
      {
        "name": "TestRun",
        "desc": ""
      },
      {
        "name": "TestSkip",
        "desc": ""
      },
      {
        "name": "TestSuccess",
        "desc": ""
      },
      {
        "name": "TestTime",
        "desc": ""
      },
      {
        "name": "TestVerboseError",
        "desc": ""
      },
      {
        "name": "TestVerboseSkip",
        "desc": ""
      },
      {
        "name": "TestWait",
        "desc": ""
      },
      {
        "name": "helperLog",
        "desc": "helperLog is a t.Helper which logs. Since it is a helper, the log prefix should contain the caller's file, not helper_test.go."
      },
      {
        "name": "runTest",
        "desc": ""
      },
      {
        "name": "wantPanic",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "text/scanner",
    "desc": "",
    "functions": [
      {
        "name": "Example",
        "desc": ""
      },
      {
        "name": "Example_isIdentRune",
        "desc": ""
      },
      {
        "name": "Example_mode",
        "desc": ""
      },
      {
        "name": "Example_whitespace",
        "desc": ""
      }
    ],
    "types": null
  },
  {
    "name": "text/tabwriter",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkCode",
        "desc": ""
      },
      {
        "name": "BenchmarkPyramid",
        "desc": ""
      },
      {
        "name": "BenchmarkRagged",
        "desc": ""
      },
      {
        "name": "BenchmarkTable",
        "desc": ""
      },
      {
        "name": "ExampleWriter_Init",
        "desc": ""
      },
      {
        "name": "Example_elastic",
        "desc": ""
      },
      {
        "name": "Example_trailingTab",
        "desc": ""
      },
      {
        "name": "Test",
        "desc": ""
      },
      {
        "name": "TestPanicDuringFlush",
        "desc": ""
      },
      {
        "name": "TestPanicDuringWrite",
        "desc": ""
      },
      {
        "name": "check",
        "desc": ""
      },
      {
        "name": "verify",
        "desc": ""
      },
      {
        "name": "wantPanicString",
        "desc": ""
      },
      {
        "name": "write",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "clear",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "buffer",
        "desc": ""
      },
      {
        "name": "panicWriter",
        "desc": ""
      }
    ]
  },
  {
    "name": "text/template",
    "desc": "Package template implements data-driven templates for generating textual output.  To generate HTML output, see [html/template], which has the same interface as this package but automatically secures HTML output against certain attacks.  Templates are executed by applying them to a data structure. Annotations in the template refer to elements of the data structure (typically a field of a struct or a key in a map) to control execution and derive values to be displayed. Execution of the template walks the structure and sets the cursor, represented by a period '.' and called \"dot\", to the value at the current location in the structure as execution proceeds.  The security model used by this package assumes that template authors are trusted. The package does not auto-escape output, so injecting code into a template can lead to arbitrary code execution if the template is executed by an untrusted source.  The input text for a template is UTF-8-encoded text in any format. \"Actions\"--data evaluations or control structures--are delimited by \"{{\" and \"}}\"; all text outside actions is copied to the output unchanged.  Once parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.  Here is a trivial example that prints \"17 items are made of wool\".  \ttype Inventory struct { \t\tMaterial string \t\tCount    uint \t} \tsweaters := Inventory{\"wool\", 17} \ttmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\") \tif err != nil { panic(err) } \terr = tmpl.Execute(os.Stdout, sweaters) \tif err != nil { panic(err) }  More intricate examples appear below.  Text and spaces  By default, all text between actions is copied verbatim when the template is executed. For example, the string \" items are made of \" in the example above appears on standard output when the program is run.  However, to aid in formatting template source code, if an action's left delimiter (by default \"{{\") is followed immediately by a minus sign and white space, all trailing white space is trimmed from the immediately preceding text. Similarly, if the right delimiter (\"}}\") is preceded by white space and a minus sign, all leading white space is trimmed from the immediately following text. In these trim markers, the white space must be present: \"{{- 3}}\" is like \"{{3}}\" but trims the immediately preceding text, while \"{{-3}}\" parses as an action containing the number -3.  For instance, when executing the template whose source is  \t\"{{23 -}} \u003c {{- 45}}\"  the generated output would be  \t\"23\u003c45\"  For this trimming, the definition of white space characters is the same as in Go: space, horizontal tab, carriage return, and newline.  Actions  Here is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of data, defined in detail in the corresponding sections that follow.  \t{{/* a comment */}} \t{{- /* a comment with white space trimmed from preceding and following text */ -}} \t\tA comment; discarded. May contain newlines. \t\tComments do not nest and must start and end at the \t\tdelimiters, as shown here.  \t{{pipeline}} \t\tThe default textual representation (the same as would be \t\tprinted by fmt.Print) of the value of the pipeline is copied \t\tto the output.  \t{{if pipeline}} T1 {{end}} \t\tIf the value of the pipeline is empty, no output is generated; \t\totherwise, T1 is executed. The empty values are false, 0, any \t\tnil pointer or interface value, and any array, slice, map, or \t\tstring of length zero. \t\tDot is unaffected.  \t{{if pipeline}} T1 {{else}} T0 {{end}} \t\tIf the value of the pipeline is empty, T0 is executed; \t\totherwise, T1 is executed. Dot is unaffected.  \t{{if pipeline}} T1 {{else if pipeline}} T0 {{end}} \t\tTo simplify the appearance of if-else chains, the else action \t\tof an if may include another if directly; the effect is exactly \t\tthe same as writing \t\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}  \t{{range pipeline}} T1 {{end}} \t\tThe value of the pipeline must be an array, slice, map, iter.Seq, \t\titer.Seq2, integer or channel. \t\tIf the value of the pipeline has length zero, nothing is output; \t\totherwise, dot is set to the successive elements of the array, \t\tslice, or map and T1 is executed. If the value is a map and the \t\tkeys are of basic type with a defined order, the elements will be \t\tvisited in sorted key order.  \t{{range pipeline}} T1 {{else}} T0 {{end}} \t\tThe value of the pipeline must be an array, slice, map, iter.Seq, \t\titer.Seq2, integer or channel. \t\tIf the value of the pipeline has length zero, dot is unaffected and \t\tT0 is executed; otherwise, dot is set to the successive elements \t\tof the array, slice, or map and T1 is executed.  \t{{break}} \t\tThe innermost {{range pipeline}} loop is ended early, stopping the \t\tcurrent iteration and bypassing all remaining iterations.  \t{{continue}} \t\tThe current iteration of the innermost {{range pipeline}} loop is \t\tstopped, and the loop starts the next iteration.  \t{{template \"name\"}} \t\tThe template with the specified name is executed with nil data.  \t{{template \"name\" pipeline}} \t\tThe template with the specified name is executed with dot set \t\tto the value of the pipeline.  \t{{block \"name\" pipeline}} T1 {{end}} \t\tA block is shorthand for defining a template \t\t\t{{define \"name\"}} T1 {{end}} \t\tand then executing it in place \t\t\t{{template \"name\" pipeline}} \t\tThe typical use is to define a set of root templates that are \t\tthen customized by redefining the block templates within.  \t{{with pipeline}} T1 {{end}} \t\tIf the value of the pipeline is empty, no output is generated; \t\totherwise, dot is set to the value of the pipeline and T1 is \t\texecuted.  \t{{with pipeline}} T1 {{else}} T0 {{end}} \t\tIf the value of the pipeline is empty, dot is unaffected and T0 \t\tis executed; otherwise, dot is set to the value of the pipeline \t\tand T1 is executed.  \t{{with pipeline}} T1 {{else with pipeline}} T0 {{end}} \t\tTo simplify the appearance of with-else chains, the else action \t\tof a with may include another with directly; the effect is exactly \t\tthe same as writing \t\t\t{{with pipeline}} T1 {{else}}{{with pipeline}} T0 {{end}}{{end}}  Arguments  An argument is a simple value, denoted by one of the following.  \t- A boolean, string, character, integer, floating-point, imaginary \t  or complex constant in Go syntax. These behave like Go's untyped \t  constants. Note that, as in Go, whether a large integer constant \t  overflows when assigned or passed to a function can depend on whether \t  the host machine's ints are 32 or 64 bits. \t- The keyword nil, representing an untyped Go nil. \t- The character '.' (period):  \t\t.  \t  The result is the value of dot. \t- A variable name, which is a (possibly empty) alphanumeric string \t  preceded by a dollar sign, such as  \t\t$piOver2  \t  or  \t\t$  \t  The result is the value of the variable. \t  Variables are described below. \t- The name of a field of the data, which must be a struct, preceded \t  by a period, such as  \t\t.Field  \t  The result is the value of the field. Field invocations may be \t  chained:  \t    .Field1.Field2  \t  Fields can also be evaluated on variables, including chaining:  \t    $x.Field1.Field2 \t- The name of a key of the data, which must be a map, preceded \t  by a period, such as  \t\t.Key  \t  The result is the map element value indexed by the key. \t  Key invocations may be chained and combined with fields to any \t  depth:  \t    .Field1.Key1.Field2.Key2  \t  Although the key must be an alphanumeric identifier, unlike with \t  field names they do not need to start with an upper case letter. \t  Keys can also be evaluated on variables, including chaining:  \t    $x.key1.key2 \t- The name of a niladic method of the data, preceded by a period, \t  such as  \t\t.Method  \t  The result is the value of invoking the method with dot as the \t  receiver, dot.Method(). Such a method must have one return value (of \t  any type) or two return values, the second of which is an error. \t  If it has two and the returned error is non-nil, execution terminates \t  and an error is returned to the caller as the value of Execute. \t  Method invocations may be chained and combined with fields and keys \t  to any depth:  \t    .Field1.Key1.Method1.Field2.Key2.Method2  \t  Methods can also be evaluated on variables, including chaining:  \t    $x.Method1.Field \t- The name of a niladic function, such as  \t\tfun  \t  The result is the value of invoking the function, fun(). The return \t  types and values behave as in methods. Functions and function \t  names are described below. \t- A parenthesized instance of one the above, for grouping. The result \t  may be accessed by a field or map key invocation.  \t\tprint (.F1 arg1) (.F2 arg2) \t\t(.StructValuedMethod \"arg\").Field  Arguments may evaluate to any type; if they are pointers the implementation automatically indirects to the base type when required. If an evaluation yields a function value, such as a function-valued field of a struct, the function is not invoked automatically, but it can be used as a truth value for an if action and the like. To invoke it, use the call function, defined below.  Pipelines  A pipeline is a possibly chained sequence of \"commands\". A command is a simple value (argument) or a function or method call, possibly with multiple arguments:  \tArgument \t\tThe result is the value of evaluating the argument. \t.Method [Argument...] \t\tThe method can be alone or the last element of a chain but, \t\tunlike methods in the middle of a chain, it can take arguments. \t\tThe result is the value of calling the method with the \t\targuments: \t\t\tdot.Method(Argument1, etc.) \tfunctionName [Argument...] \t\tThe result is the value of calling the function associated \t\twith the name: \t\t\tfunction(Argument1, etc.) \t\tFunctions and function names are described below.  A pipeline may be \"chained\" by separating a sequence of commands with pipeline characters '|'. In a chained pipeline, the result of each command is passed as the last argument of the following command. The output of the final command in the pipeline is the value of the pipeline.  The output of a command will be either one value or two values, the second of which has type error. If that second value is present and evaluates to non-nil, execution terminates and the error is returned to the caller of Execute.  Variables  A pipeline inside an action may initialize a variable to capture the result. The initialization has syntax  \t$variable := pipeline  where $variable is the name of the variable. An action that declares a variable produces no output.  Variables previously declared can also be assigned, using the syntax  \t$variable = pipeline  If a \"range\" action initializes a variable, the variable is set to the successive elements of the iteration. Also, a \"range\" may declare two variables, separated by a comma:  \trange $index, $element := pipeline  in which case $index and $element are set to the successive values of the array/slice index or map key and element, respectively. Note that if there is only one variable, it is assigned the element; this is opposite to the convention in Go range clauses.  A variable's scope extends to the \"end\" action of the control structure (\"if\", \"with\", or \"range\") in which it is declared, or to the end of the template if there is no such control structure. A template invocation does not inherit variables from the point of its invocation.  When execution begins, $ is set to the data argument passed to Execute, that is, to the starting value of dot.  Examples  Here are some example one-line templates demonstrating pipelines and variables. All produce the quoted word \"output\":  \t{{\"\\\"output\\\"\"}} \t\tA string constant. \t{{`\"output\"`}} \t\tA raw string constant. \t{{printf \"%q\" \"output\"}} \t\tA function call. \t{{\"output\" | printf \"%q\"}} \t\tA function call whose final argument comes from the previous \t\tcommand. \t{{printf \"%q\" (print \"out\" \"put\")}} \t\tA parenthesized argument. \t{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}} \t\tA more elaborate call. \t{{\"output\" | printf \"%s\" | printf \"%q\"}} \t\tA longer chain. \t{{with \"output\"}}{{printf \"%q\" .}}{{end}} \t\tA with action using dot. \t{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}} \t\tA with action that creates and uses a variable. \t{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}} \t\tA with action that uses the variable in another action. \t{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}} \t\tThe same, but pipelined.  Functions  During execution functions are found in two function maps: first in the template, then in the global function map. By default, no functions are defined in the template but the Funcs method can be used to add them.  Predefined global functions are named as follows.  \tand \t\tReturns the boolean AND of its arguments by returning the \t\tfirst empty argument or the last argument. That is, \t\t\"and x y\" behaves as \"if x then y else x.\" \t\tEvaluation proceeds through the arguments left to right \t\tand returns when the result is determined. \tcall \t\tReturns the result of calling the first argument, which \t\tmust be a function, with the remaining arguments as parameters. \t\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where \t\tY is a func-valued field, map entry, or the like. \t\tThe first argument must be the result of an evaluation \t\tthat yields a value of function type (as distinct from \t\ta predefined function such as print). The function must \t\treturn either one or two result values, the second of which \t\tis of type error. If the arguments don't match the function \t\tor the returned error value is non-nil, execution stops. \thtml \t\tReturns the escaped HTML equivalent of the textual \t\trepresentation of its arguments. This function is unavailable \t\tin html/template, with a few exceptions. \tindex \t\tReturns the result of indexing its first argument by the \t\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax, \t\tx[1][2][3]. Each indexed item must be a map, slice, or array. \tslice \t\tslice returns the result of slicing its first argument by the \t\tremaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2], \t\twhile \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\" \t\tis x[1:2:3]. The first argument must be a string, slice, or array. \tjs \t\tReturns the escaped JavaScript equivalent of the textual \t\trepresentation of its arguments. \tlen \t\tReturns the integer length of its argument. \tnot \t\tReturns the boolean negation of its single argument. \tor \t\tReturns the boolean OR of its arguments by returning the \t\tfirst non-empty argument or the last argument, that is, \t\t\"or x y\" behaves as \"if x then x else y\". \t\tEvaluation proceeds through the arguments left to right \t\tand returns when the result is determined. \tprint \t\tAn alias for fmt.Sprint \tprintf \t\tAn alias for fmt.Sprintf \tprintln \t\tAn alias for fmt.Sprintln \turlquery \t\tReturns the escaped value of the textual representation of \t\tits arguments in a form suitable for embedding in a URL query. \t\tThis function is unavailable in html/template, with a few \t\texceptions.  The boolean functions take any zero value to be false and a non-zero value to be true.  There is also a set of binary comparison operators defined as functions:  \teq \t\tReturns the boolean truth of arg1 == arg2 \tne \t\tReturns the boolean truth of arg1 != arg2 \tlt \t\tReturns the boolean truth of arg1 \u003c arg2 \tle \t\tReturns the boolean truth of arg1 \u003c= arg2 \tgt \t\tReturns the boolean truth of arg1 \u003e arg2 \tge \t\tReturns the boolean truth of arg1 \u003e= arg2  For simpler multi-way equality tests, eq (only) accepts two or more arguments and compares the second and subsequent to the first, returning in effect  \targ1==arg2 || arg1==arg3 || arg1==arg4 ...  (Unlike with || in Go, however, eq is a function call and all the arguments will be evaluated.)  The comparison functions work on any values whose type Go defines as comparable. For basic types such as integers, the rules are relaxed: size and exact type are ignored, so any integer value, signed or unsigned, may be compared with any other integer value. (The arithmetic value is compared, not the bit pattern, so all negative integers are less than all unsigned integers.) However, as usual, one may not compare an int with a float32 and so on.  Associated templates  Each template is named by a string specified when it is created. Also, each template is associated with zero or more other templates that it may invoke by name; such associations are transitive and form a name space of templates.  A template may use a template invocation to instantiate another associated template; see the explanation of the \"template\" action above. The name must be that of a template associated with the template that contains the invocation.  Nested template definitions  When parsing a template, another template may be defined and associated with the template being parsed. Template definitions must appear at the top level of the template, much like global variables in a Go program.  The syntax of such definitions is to surround each template declaration with a \"define\" and \"end\" action.  The define action names the template being created by providing a string constant. Here is a simple example:  \t{{define \"T1\"}}ONE{{end}} \t{{define \"T2\"}}TWO{{end}} \t{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}} \t{{template \"T3\"}}  This defines two templates, T1 and T2, and a third T3 that invokes the other two when it is executed. Finally it invokes T3. If executed this template will produce the text  \tONE TWO  By construction, a template may reside in only one association. If it's necessary to have a template addressable from multiple associations, the template definition must be parsed multiple times to create distinct *Template values, or must be copied with [Template.Clone] or [Template.AddParseTree].  Parse may be called multiple times to assemble the various associated templates; see [ParseFiles], [ParseGlob], [Template.ParseFiles] and [Template.ParseGlob] for simple ways to parse related templates stored in files.  A template may be executed directly or through [Template.ExecuteTemplate], which executes an associated template identified by name. To invoke our example above, we might write,  \terr := tmpl.Execute(os.Stdout, \"no data needed\") \tif err != nil { \t\tlog.Fatalf(\"execution failed: %s\", err) \t}  or to invoke a particular template explicitly by name,  \terr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\") \tif err != nil { \t\tlog.Fatalf(\"execution failed: %s\", err) \t}",
    "functions": [
      {
        "name": "HTMLEscape",
        "desc": "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b."
      },
      {
        "name": "HTMLEscapeString",
        "desc": "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s."
      },
      {
        "name": "HTMLEscaper",
        "desc": "HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments."
      },
      {
        "name": "IsTrue",
        "desc": "IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions."
      },
      {
        "name": "JSEscape",
        "desc": "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b."
      },
      {
        "name": "JSEscapeString",
        "desc": "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s."
      },
      {
        "name": "JSEscaper",
        "desc": "JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments."
      },
      {
        "name": "TestAddParseTree",
        "desc": ""
      },
      {
        "name": "TestAddParseTreeToUnparsedTemplate",
        "desc": "Issue 7032"
      },
      {
        "name": "TestAddToZeroTemplate",
        "desc": "Issue 48436"
      },
      {
        "name": "TestAddrOfIndex",
        "desc": ""
      },
      {
        "name": "TestBadFuncNames",
        "desc": ""
      },
      {
        "name": "TestBlock",
        "desc": ""
      },
      {
        "name": "TestClone",
        "desc": ""
      },
      {
        "name": "TestComparison",
        "desc": ""
      },
      {
        "name": "TestDelims",
        "desc": ""
      },
      {
        "name": "TestEmptyTemplate",
        "desc": ""
      },
      {
        "name": "TestEmptyTemplateCloneCrash",
        "desc": "Issue 10879"
      },
      {
        "name": "TestEvalFieldErrors",
        "desc": ""
      },
      {
        "name": "TestExecError",
        "desc": "Check that an error from a nested template contains all the relevant information."
      },
      {
        "name": "TestExecError_CustomError",
        "desc": "Check that a custom error can be returned."
      },
      {
        "name": "TestExecute",
        "desc": ""
      },
      {
        "name": "TestExecuteError",
        "desc": "Check that an error from a method flows back to the top."
      },
      {
        "name": "TestExecuteGivesExecError",
        "desc": ""
      },
      {
        "name": "TestExecuteOnNewTemplate",
        "desc": ""
      },
      {
        "name": "TestExecutePanicDuringCall",
        "desc": "Check that panics during calls are recovered and returned as errors."
      },
      {
        "name": "TestFinalForPrintf",
        "desc": ""
      },
      {
        "name": "TestFunctionCheckDuringCall",
        "desc": ""
      },
      {
        "name": "TestGoodFuncNames",
        "desc": ""
      },
      {
        "name": "TestInterfaceValues",
        "desc": ""
      },
      {
        "name": "TestIsTrue",
        "desc": ""
      },
      {
        "name": "TestIssue19294",
        "desc": "Issue 19249 was a regression in 1.8 caused by the handling of empty templates added in that release, which got different answers depending on the order templates appeared in the internal map."
      },
      {
        "name": "TestIssue31810",
        "desc": "Issue 31810. Check that a parenthesized first argument behaves properly."
      },
      {
        "name": "TestIssue39807",
        "desc": "Issue 39807: data race in html/template \u0026 text/template"
      },
      {
        "name": "TestIssue43065",
        "desc": "Issue 43065, range over send only channel"
      },
      {
        "name": "TestIssue48215",
        "desc": "Issue 48215: embedded nil pointer causes panic. Fixed by adding FieldByIndexErr to the reflect package."
      },
      {
        "name": "TestJSEscaping",
        "desc": ""
      },
      {
        "name": "TestMaxExecDepth",
        "desc": ""
      },
      {
        "name": "TestMessageForExecuteEmpty",
        "desc": ""
      },
      {
        "name": "TestMissingMapKey",
        "desc": ""
      },
      {
        "name": "TestMultiExecute",
        "desc": ""
      },
      {
        "name": "TestMultiParse",
        "desc": ""
      },
      {
        "name": "TestNew",
        "desc": ""
      },
      {
        "name": "TestParse",
        "desc": ""
      },
      {
        "name": "TestParseFS",
        "desc": ""
      },
      {
        "name": "TestParseFiles",
        "desc": ""
      },
      {
        "name": "TestParseFilesWithData",
        "desc": ""
      },
      {
        "name": "TestParseGlob",
        "desc": ""
      },
      {
        "name": "TestParseGlobWithData",
        "desc": ""
      },
      {
        "name": "TestRedefinition",
        "desc": ""
      },
      {
        "name": "TestTemplateLookUp",
        "desc": "Issue 10910, 10926"
      },
      {
        "name": "TestTree",
        "desc": ""
      },
      {
        "name": "TestUnterminatedStringError",
        "desc": "Test that the error message for multiline unterminated string refers to the line number of the opening quote."
      },
      {
        "name": "URLQueryEscaper",
        "desc": "URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query."
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "addFuncs",
        "desc": "addFuncs adds to values the functions in funcs. It does no checking of the input - call addValueFuncs first."
      },
      {
        "name": "addValueFuncs",
        "desc": "addValueFuncs adds to values the functions in funcs, converting them to reflect.Values."
      },
      {
        "name": "and",
        "desc": "and computes the Boolean AND of its arguments, returning the first false argument it encounters, or the last argument."
      },
      {
        "name": "builtinFuncs",
        "desc": "builtinFuncsOnce lazily computes \u0026 caches the builtinFuncs map. TODO: revert this back to a global map once golang.org/issue/2559 is fixed."
      },
      {
        "name": "call",
        "desc": "call returns the result of evaluating the first argument as a function. The function must return 1 result, or 2 results, the second of which is an error."
      },
      {
        "name": "canBeNil",
        "desc": "canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero."
      },
      {
        "name": "canCompare",
        "desc": "canCompare reports whether v1 and v2 are both the same kind, or one is nil. Called only when dealing with nillable types, or there's about to be an error."
      },
      {
        "name": "count",
        "desc": "count returns a channel that will deliver n sequential 1-letter strings starting at \"a\""
      },
      {
        "name": "createValueFuncs",
        "desc": "createValueFuncs turns a FuncMap into a map[string]reflect.Value"
      },
      {
        "name": "dddArg",
        "desc": ""
      },
      {
        "name": "doublePercent",
        "desc": "doublePercent returns the string with %'s replaced by %%, if necessary, so it can be used safely inside a Printf format string."
      },
      {
        "name": "echo",
        "desc": ""
      },
      {
        "name": "emptyCall",
        "desc": ""
      },
      {
        "name": "eq",
        "desc": "eq evaluates the comparison a == b || a == c || ..."
      },
      {
        "name": "errRecover",
        "desc": "errRecover is the handler that turns panics into returns from the top level of Parse."
      },
      {
        "name": "evalArgs",
        "desc": "evalArgs formats the list of arguments into a string. It is therefore equivalent to  \tfmt.Sprint(args...)  except that each argument is indirected (if a pointer), as required, using the same rules as the default string evaluation during template execution."
      },
      {
        "name": "fVal1",
        "desc": ""
      },
      {
        "name": "fVal2",
        "desc": ""
      },
      {
        "name": "findFunction",
        "desc": "findFunction looks for a function in the template, and global map."
      },
      {
        "name": "funcNameTestFunc",
        "desc": ""
      },
      {
        "name": "ge",
        "desc": "ge evaluates the comparison a \u003e= b."
      },
      {
        "name": "goodFunc",
        "desc": "goodFunc reports whether the function or method has the right result signature."
      },
      {
        "name": "goodName",
        "desc": "goodName reports whether the function name is a valid identifier."
      },
      {
        "name": "gt",
        "desc": "gt evaluates the comparison a \u003e b."
      },
      {
        "name": "index",
        "desc": "index returns the result of indexing its first argument by the following arguments. Thus \"index x 1 2 3\" is, in Go syntax, x[1][2][3]. Each indexed item must be a map, slice, or array."
      },
      {
        "name": "indexArg",
        "desc": "indexArg checks if a reflect.Value can be used as an index, and converts it to int if possible."
      },
      {
        "name": "indirect",
        "desc": "indirect returns the item at the end of indirection, and a bool to indicate if it's nil. If the returned bool is true, the returned value's kind will be either a pointer or interface."
      },
      {
        "name": "indirectInterface",
        "desc": "indirectInterface returns the concrete value in an interface value, or else the zero reflect.Value. That is, if v represents the interface value x, the result is the same as reflect.ValueOf(x): the fact that x was an interface value is forgotten."
      },
      {
        "name": "initMaxExecDepth",
        "desc": ""
      },
      {
        "name": "intLike",
        "desc": ""
      },
      {
        "name": "isHexInt",
        "desc": ""
      },
      {
        "name": "isMissing",
        "desc": ""
      },
      {
        "name": "isNil",
        "desc": "isNil returns true if v is the zero reflect.Value, or nil of its type."
      },
      {
        "name": "isRuneInt",
        "desc": ""
      },
      {
        "name": "isTrue",
        "desc": ""
      },
      {
        "name": "jsIsSpecial",
        "desc": ""
      },
      {
        "name": "le",
        "desc": "le evaluates the comparison \u003c= b."
      },
      {
        "name": "length",
        "desc": "length returns the length of the item, with an error if it has no defined length."
      },
      {
        "name": "lt",
        "desc": "lt evaluates the comparison a \u003c b."
      },
      {
        "name": "makemap",
        "desc": ""
      },
      {
        "name": "mapOfThree",
        "desc": ""
      },
      {
        "name": "ne",
        "desc": "ne evaluates the comparison a != b."
      },
      {
        "name": "newInt",
        "desc": "Helpers for creation."
      },
      {
        "name": "newIntSlice",
        "desc": ""
      },
      {
        "name": "newString",
        "desc": ""
      },
      {
        "name": "newUnsafePointer",
        "desc": ""
      },
      {
        "name": "not",
        "desc": "not returns the Boolean negation of its argument."
      },
      {
        "name": "oneArg",
        "desc": ""
      },
      {
        "name": "or",
        "desc": "or computes the Boolean OR of its arguments, returning the first true argument it encounters, or the last argument."
      },
      {
        "name": "prepareArg",
        "desc": "prepareArg checks if value can be used as an argument of type argType, and converts an invalid value to appropriate zero if possible."
      },
      {
        "name": "printableValue",
        "desc": "printableValue returns the, possibly indirected, interface value inside v that is best for a call to formatted printer."
      },
      {
        "name": "rangeTestData",
        "desc": ""
      },
      {
        "name": "readFileFS",
        "desc": ""
      },
      {
        "name": "readFileOS",
        "desc": ""
      },
      {
        "name": "returnInt",
        "desc": "returnInt returns an int"
      },
      {
        "name": "safeCall",
        "desc": "safeCall runs fun.Call(args), and returns the resulting value and error, if any. If the call panics, the panic value is returned as an error."
      },
      {
        "name": "slice",
        "desc": "slice returns the result of slicing its first argument by the remaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2], while \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\" is x[1:2:3]. The first argument must be a string, slice, or array."
      },
      {
        "name": "stringer",
        "desc": ""
      },
      {
        "name": "testBadFuncName",
        "desc": ""
      },
      {
        "name": "testExecute",
        "desc": ""
      },
      {
        "name": "truth",
        "desc": ""
      },
      {
        "name": "twoArgs",
        "desc": ""
      },
      {
        "name": "typeOf",
        "desc": ""
      },
      {
        "name": "valueString",
        "desc": "valueString takes a string, not a pointer."
      },
      {
        "name": "vfunc",
        "desc": "vfunc takes a *V and a V"
      },
      {
        "name": "zeroArgs",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "Unwrap",
        "desc": ""
      },
      {
        "name": "Method0",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "GetU",
        "desc": "A few methods to test chaining."
      },
      {
        "name": "MAdd",
        "desc": ""
      },
      {
        "name": "Method0",
        "desc": "Simple methods with and without arguments."
      },
      {
        "name": "Method1",
        "desc": ""
      },
      {
        "name": "Method2",
        "desc": ""
      },
      {
        "name": "Method3",
        "desc": ""
      },
      {
        "name": "MyError",
        "desc": "MyError returns a value and an error according to its argument."
      },
      {
        "name": "AddParseTree",
        "desc": "AddParseTree associates the argument parse tree with the template t, giving it the specified name. If the template has not been defined, this tree becomes its definition. If it has been defined and already has that name, the existing definition is replaced; otherwise a new template is created, defined, and returned."
      },
      {
        "name": "Clone",
        "desc": "Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to [Template.Parse] in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made."
      },
      {
        "name": "DefinedTemplates",
        "desc": "DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. For generating an error message here and in [html/template]."
      },
      {
        "name": "Delims",
        "desc": "Delims sets the action delimiters to the specified strings, to be used in subsequent calls to [Template.Parse], [Template.ParseFiles], or [Template.ParseGlob]. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained."
      },
      {
        "name": "Execute",
        "desc": "Execute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.  If data is a [reflect.Value], the template applies to the concrete value that the reflect.Value holds, as in [fmt.Print]."
      },
      {
        "name": "ExecuteTemplate",
        "desc": "ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved."
      },
      {
        "name": "Funcs",
        "desc": "Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type or if the name cannot be used syntactically as a function in a template. It is legal to overwrite elements of the map. The return value is the template, so calls can be chained."
      },
      {
        "name": "Lookup",
        "desc": "Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition."
      },
      {
        "name": "Name",
        "desc": "Name returns the name of the template."
      },
      {
        "name": "New",
        "desc": "New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.  Because associated templates share underlying data, template construction cannot be done safely in parallel. Once the templates are constructed, they can be executed in parallel."
      },
      {
        "name": "Option",
        "desc": "Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.  Known options:  missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map.  \t\"missingkey=default\" or \"missingkey=invalid\" \t\tThe default behavior: Do nothing and continue execution. \t\tIf printed, the result of the index operation is the string \t\t\"\u003cno value\u003e\". \t\"missingkey=zero\" \t\tThe operation returns the zero value for the map type's element. \t\"missingkey=error\" \t\tExecution stops immediately with an error."
      },
      {
        "name": "Parse",
        "desc": "Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.  Templates can be redefined in successive calls to Parse. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body."
      },
      {
        "name": "ParseFS",
        "desc": "ParseFS is like [Template.ParseFiles] or [Template.ParseGlob] but reads from the file system fsys instead of the host operating system's file system. It accepts a list of glob patterns (see [path.Match]). (Note that most file names serve as glob patterns matching only themselves.)"
      },
      {
        "name": "ParseFiles",
        "desc": "ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base (see [filepath.Base]) names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.  When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results."
      },
      {
        "name": "ParseGlob",
        "desc": "ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of [filepath.Match], and the pattern must match at least one file. ParseGlob is equivalent to calling [Template.ParseFiles] with the list of files matched by the pattern.  When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results."
      },
      {
        "name": "Templates",
        "desc": "Templates returns a slice of defined templates associated with t."
      },
      {
        "name": "associate",
        "desc": "associate installs the new template into the group of templates associated with t. The two are already known to share the common structure. The boolean return value reports whether to store this tree as t.Tree."
      },
      {
        "name": "copy",
        "desc": "copy returns a shallow copy of t, with common set to the argument."
      },
      {
        "name": "execute",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "init guarantees that t has a valid common structure."
      },
      {
        "name": "setOption",
        "desc": ""
      },
      {
        "name": "TrueFalse",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "at",
        "desc": "at marks the state to be on node n, for error reporting."
      },
      {
        "name": "errorf",
        "desc": "errorf records an ExecError and terminates processing."
      },
      {
        "name": "evalArg",
        "desc": ""
      },
      {
        "name": "evalBool",
        "desc": ""
      },
      {
        "name": "evalCall",
        "desc": "evalCall executes a function or method call. If it's a method, fun already has the receiver bound, so it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0] as the function itself."
      },
      {
        "name": "evalChainNode",
        "desc": ""
      },
      {
        "name": "evalCommand",
        "desc": ""
      },
      {
        "name": "evalComplex",
        "desc": ""
      },
      {
        "name": "evalEmptyInterface",
        "desc": ""
      },
      {
        "name": "evalField",
        "desc": "evalField evaluates an expression like (.Field) or (.Field arg1 arg2). The 'final' argument represents the return value from the preceding value of the pipeline, if any."
      },
      {
        "name": "evalFieldChain",
        "desc": "evalFieldChain evaluates .X.Y.Z possibly followed by arguments. dot is the environment in which to evaluate arguments, while receiver is the value being walked along the chain."
      },
      {
        "name": "evalFieldNode",
        "desc": ""
      },
      {
        "name": "evalFloat",
        "desc": ""
      },
      {
        "name": "evalFunction",
        "desc": ""
      },
      {
        "name": "evalInteger",
        "desc": ""
      },
      {
        "name": "evalPipeline",
        "desc": "evalPipeline returns the value acquired by evaluating a pipeline. If the pipeline has a variable declaration, the variable will be pushed on the stack. Callers should therefore pop the stack after they are finished executing commands depending on the pipeline value."
      },
      {
        "name": "evalString",
        "desc": ""
      },
      {
        "name": "evalUnsignedInteger",
        "desc": ""
      },
      {
        "name": "evalVariableNode",
        "desc": ""
      },
      {
        "name": "idealConstant",
        "desc": "idealConstant is called to return the value of a number in a context where we don't know the type. In that case, the syntax of the number tells us its type, and we use Go rules to resolve. Note there is no such thing as a uint ideal constant in this situation - the value must be of int type."
      },
      {
        "name": "mark",
        "desc": "mark returns the length of the variable stack."
      },
      {
        "name": "notAFunction",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": "pop pops the variable stack up to the mark."
      },
      {
        "name": "printValue",
        "desc": "printValue writes the textual representation of the value to the output of the template."
      },
      {
        "name": "push",
        "desc": "push pushes a new variable on the stack."
      },
      {
        "name": "setTopVar",
        "desc": "setTopVar overwrites the top-nth variable on the stack. Used by range iterations."
      },
      {
        "name": "setVar",
        "desc": "setVar overwrites the last declared variable with the given name. Used by variable assignments."
      },
      {
        "name": "validateType",
        "desc": "validateType guarantees that the value is valid and assignable to the type."
      },
      {
        "name": "varValue",
        "desc": "varValue returns the value of the named variable."
      },
      {
        "name": "walk",
        "desc": "Walk functions step through the major pieces of the template structure, generating output as they go."
      },
      {
        "name": "walkIfOrWith",
        "desc": "walkIfOrWith walks an 'if' or 'with' node. The two control structures are identical in behavior except that 'with' sets dot."
      },
      {
        "name": "walkRange",
        "desc": ""
      },
      {
        "name": "walkTemplate",
        "desc": ""
      },
      {
        "name": "writeError",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "CustomError",
        "desc": ""
      },
      {
        "name": "ErrorWriter",
        "desc": ""
      },
      {
        "name": "ExecError",
        "desc": "ExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.)"
      },
      {
        "name": "FuncMap",
        "desc": "FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.  Errors returned by Execute wrap the underlying error; call [errors.As] to unwrap them.  When template execution invokes a function with an argument list, that list must be assignable to the function's parameter types. Functions meant to apply to arguments of arbitrary type can use parameters of type interface{} or of type [reflect.Value]. Similarly, functions meant to return a result of arbitrary type can return interface{} or [reflect.Value]."
      },
      {
        "name": "I",
        "desc": "A non-empty interface."
      },
      {
        "name": "S",
        "desc": ""
      },
      {
        "name": "T",
        "desc": "T has lots of interesting pieces to use to test execution."
      },
      {
        "name": "Template",
        "desc": "Template is the representation of a parsed template. The *parse.Tree field is exported only for use by [html/template] and should be treated as unexported by all other clients."
      },
      {
        "name": "Tree",
        "desc": ""
      },
      {
        "name": "U",
        "desc": ""
      },
      {
        "name": "V",
        "desc": ""
      },
      {
        "name": "W",
        "desc": ""
      },
      {
        "name": "cmpTest",
        "desc": ""
      },
      {
        "name": "common",
        "desc": "common holds the information shared by related templates."
      },
      {
        "name": "execTest",
        "desc": ""
      },
      {
        "name": "kind",
        "desc": ""
      },
      {
        "name": "missingKeyAction",
        "desc": "missingKeyAction defines how to respond to indexing a map with a key that is not present."
      },
      {
        "name": "missingValType",
        "desc": ""
      },
      {
        "name": "multiParseTest",
        "desc": ""
      },
      {
        "name": "option",
        "desc": ""
      },
      {
        "name": "state",
        "desc": "state represents the state of an execution. It's not part of the template so that multiple executions of the same template can execute in parallel."
      },
      {
        "name": "variable",
        "desc": "variable holds the dynamic value of a variable such as $, $x etc."
      },
      {
        "name": "writeError",
        "desc": "writeError is the wrapper type used internally when Execute has an error writing to its output. We strip the wrapper in errRecover. Note that this is not an implementation of error, so it cannot escape from the package as an error value."
      }
    ]
  },
  {
    "name": "text/template/parse",
    "desc": "Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use.",
    "functions": [
      {
        "name": "BenchmarkListString",
        "desc": ""
      },
      {
        "name": "BenchmarkParseLarge",
        "desc": ""
      },
      {
        "name": "BenchmarkVariableString",
        "desc": ""
      },
      {
        "name": "IsEmptyTree",
        "desc": "IsEmptyTree reports whether this tree (node) is empty of everything but space or comments."
      },
      {
        "name": "Parse",
        "desc": "Parse returns a map from template name to [Tree], created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error."
      },
      {
        "name": "TestBlock",
        "desc": ""
      },
      {
        "name": "TestDelims",
        "desc": ""
      },
      {
        "name": "TestDelimsAlphaNumeric",
        "desc": ""
      },
      {
        "name": "TestDelimsAndMarkers",
        "desc": ""
      },
      {
        "name": "TestErrorContextWithTreeCopy",
        "desc": ""
      },
      {
        "name": "TestErrors",
        "desc": ""
      },
      {
        "name": "TestIsEmpty",
        "desc": ""
      },
      {
        "name": "TestKeywordsAndFuncs",
        "desc": ""
      },
      {
        "name": "TestLex",
        "desc": ""
      },
      {
        "name": "TestLineNum",
        "desc": ""
      },
      {
        "name": "TestNumberParse",
        "desc": ""
      },
      {
        "name": "TestParse",
        "desc": ""
      },
      {
        "name": "TestParseCopy",
        "desc": "Same as TestParse, but we copy the node first"
      },
      {
        "name": "TestParseWithComments",
        "desc": ""
      },
      {
        "name": "TestPos",
        "desc": "The other tests don't check position, to make the test cases easier to construct. This one does."
      },
      {
        "name": "TestSkipFuncCheck",
        "desc": ""
      },
      {
        "name": "equal",
        "desc": ""
      },
      {
        "name": "hasLeftTrimMarker",
        "desc": ""
      },
      {
        "name": "hasRightTrimMarker",
        "desc": ""
      },
      {
        "name": "init",
        "desc": "init reduces maxStackDepth for WebAssembly due to its smaller stack size."
      },
      {
        "name": "isAlphaNumeric",
        "desc": "isAlphaNumeric reports whether r is an alphabetic, digit, or underscore."
      },
      {
        "name": "isSpace",
        "desc": "isSpace reports whether r is a space character."
      },
      {
        "name": "testParse",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Add",
        "desc": "Add adds the named field (which should start with a period) to the end of the chain."
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "append",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "SetPos",
        "desc": "SetPos sets the position. [NewIdentifier] is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?"
      },
      {
        "name": "SetTree",
        "desc": "SetTree sets the parent tree for the node. [NewIdentifier] is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?"
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "CopyList",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "append",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": "Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes."
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "simplifyComplex",
        "desc": "simplifyComplex pulls out any other types that are represented by the complex number. These all require that the imaginary part be zero."
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "CopyPipe",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "append",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Position",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": "Copy returns a copy of the [Tree]. Any parsing state is discarded."
      },
      {
        "name": "ErrorContext",
        "desc": "ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code."
      },
      {
        "name": "Parse",
        "desc": "Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (\"{{\" or \"}}\") is used. Embedded template definitions are added to the treeSet map."
      },
      {
        "name": "action",
        "desc": "Action:  \tcontrol \tcommand (\"|\" command)*  Left delim is past. Now get actions. First word could be a keyword such as range."
      },
      {
        "name": "add",
        "desc": "add adds tree to t.treeSet."
      },
      {
        "name": "backup",
        "desc": "backup backs the input stream up one token."
      },
      {
        "name": "backup2",
        "desc": "backup2 backs the input stream up two tokens. The zeroth token is already there."
      },
      {
        "name": "backup3",
        "desc": "backup3 backs the input stream up three tokens The zeroth token is already there."
      },
      {
        "name": "blockControl",
        "desc": "Block:  \t{{block stringValue pipeline}}  Block keyword is past. The name must be something that can evaluate to a string. The pipeline is mandatory."
      },
      {
        "name": "breakControl",
        "desc": "Break:  \t{{break}}  Break keyword is past."
      },
      {
        "name": "checkPipeline",
        "desc": ""
      },
      {
        "name": "clearActionLine",
        "desc": ""
      },
      {
        "name": "command",
        "desc": "command:  \toperand (space operand)*  space-separated arguments up to a pipeline character or right delimiter. we consume the pipe character but leave the right delim to terminate the action."
      },
      {
        "name": "continueControl",
        "desc": "Continue:  \t{{continue}}  Continue keyword is past."
      },
      {
        "name": "elseControl",
        "desc": "Else:  \t{{else}}  Else keyword is past."
      },
      {
        "name": "endControl",
        "desc": "End:  \t{{end}}  End keyword is past."
      },
      {
        "name": "error",
        "desc": "error terminates processing."
      },
      {
        "name": "errorf",
        "desc": "errorf formats the error and terminates processing."
      },
      {
        "name": "expect",
        "desc": "expect consumes the next token and guarantees it has the required type."
      },
      {
        "name": "expectOneOf",
        "desc": "expectOneOf consumes the next token and guarantees it has one of the required types."
      },
      {
        "name": "hasFunction",
        "desc": "hasFunction reports if a function name exists in the Tree's maps."
      },
      {
        "name": "ifControl",
        "desc": "If:  \t{{if pipeline}} itemList {{end}} \t{{if pipeline}} itemList {{else}} itemList {{end}}  If keyword is past."
      },
      {
        "name": "itemList",
        "desc": "itemList:  \ttextOrAction*  Terminates at {{end}} or {{else}}, returned separately."
      },
      {
        "name": "newAction",
        "desc": ""
      },
      {
        "name": "newBool",
        "desc": ""
      },
      {
        "name": "newBreak",
        "desc": ""
      },
      {
        "name": "newChain",
        "desc": ""
      },
      {
        "name": "newCommand",
        "desc": ""
      },
      {
        "name": "newComment",
        "desc": ""
      },
      {
        "name": "newContinue",
        "desc": ""
      },
      {
        "name": "newDot",
        "desc": ""
      },
      {
        "name": "newElse",
        "desc": ""
      },
      {
        "name": "newEnd",
        "desc": ""
      },
      {
        "name": "newField",
        "desc": ""
      },
      {
        "name": "newIf",
        "desc": ""
      },
      {
        "name": "newList",
        "desc": ""
      },
      {
        "name": "newNil",
        "desc": ""
      },
      {
        "name": "newNumber",
        "desc": ""
      },
      {
        "name": "newPipeline",
        "desc": ""
      },
      {
        "name": "newRange",
        "desc": ""
      },
      {
        "name": "newString",
        "desc": ""
      },
      {
        "name": "newTemplate",
        "desc": ""
      },
      {
        "name": "newText",
        "desc": ""
      },
      {
        "name": "newVariable",
        "desc": ""
      },
      {
        "name": "newWith",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "next returns the next token."
      },
      {
        "name": "nextNonSpace",
        "desc": "nextNonSpace returns the next non-space token."
      },
      {
        "name": "operand",
        "desc": "operand:  \tterm .Field*  An operand is a space-separated component of a command, a term possibly followed by field accesses. A nil return means the next item is not an operand."
      },
      {
        "name": "parse",
        "desc": "parse is the top-level parser for a template, essentially the same as itemList except it also parses {{define}} actions. It runs to EOF."
      },
      {
        "name": "parseControl",
        "desc": ""
      },
      {
        "name": "parseDefinition",
        "desc": "parseDefinition parses a {{define}} ...  {{end}} template definition and installs the definition in t.treeSet. The \"define\" keyword has already been scanned."
      },
      {
        "name": "parseLexer",
        "desc": "parseLexer is a local version of parse that lets us pass in the lexer instead of building it. We expect an error, so the tree set and funcs list are explicitly nil."
      },
      {
        "name": "parseTemplateName",
        "desc": ""
      },
      {
        "name": "peek",
        "desc": "peek returns but does not consume the next token."
      },
      {
        "name": "peekNonSpace",
        "desc": "peekNonSpace returns but does not consume the next non-space token."
      },
      {
        "name": "pipeline",
        "desc": "Pipeline:  \tdeclarations? command ('|' command)*"
      },
      {
        "name": "popVars",
        "desc": "popVars trims the variable list to the specified length"
      },
      {
        "name": "rangeControl",
        "desc": "Range:  \t{{range pipeline}} itemList {{end}} \t{{range pipeline}} itemList {{else}} itemList {{end}}  Range keyword is past."
      },
      {
        "name": "recover",
        "desc": "recover is the handler that turns panics into returns from the top level of Parse."
      },
      {
        "name": "startParse",
        "desc": "startParse initializes the parser, using the lexer."
      },
      {
        "name": "stopParse",
        "desc": "stopParse terminates parsing."
      },
      {
        "name": "templateControl",
        "desc": "Template:  \t{{template stringValue pipeline}}  Template keyword is past. The name must be something that can evaluate to a string."
      },
      {
        "name": "term",
        "desc": "term:  \tliteral (number, string, nil, boolean) \tfunction (identifier) \t. \t.Field \t$ \t'(' pipeline ')'  A term is a simple \"expression\". A nil return means the next item is not a term."
      },
      {
        "name": "textOrAction",
        "desc": "textOrAction:  \ttext | comment | action"
      },
      {
        "name": "unexpected",
        "desc": "unexpected complains about the token and terminates processing."
      },
      {
        "name": "useVar",
        "desc": "useVar returns a node for a variable reference. It errors if the variable is not defined."
      },
      {
        "name": "withControl",
        "desc": "With:  \t{{with pipeline}} itemList {{end}} \t{{with pipeline}} itemList {{else}} itemList {{end}}  If keyword is past."
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Type",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "Copy",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "tree",
        "desc": ""
      },
      {
        "name": "writeTo",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "accept",
        "desc": "accept consumes the next rune if it's from the valid set."
      },
      {
        "name": "acceptRun",
        "desc": "acceptRun consumes a run of runes from the valid set."
      },
      {
        "name": "atRightDelim",
        "desc": "atRightDelim reports whether the lexer is at a right delimiter, possibly preceded by a trim marker."
      },
      {
        "name": "atTerminator",
        "desc": "atTerminator reports whether the input is at valid termination character to appear after an identifier. Breaks .X.Y into two pieces. Also catches cases like \"$x+2\" not being acceptable without a space, in case we decide one day to implement arithmetic."
      },
      {
        "name": "backup",
        "desc": "backup steps back one rune."
      },
      {
        "name": "emit",
        "desc": "emit passes the trailing text as an item back to the parser."
      },
      {
        "name": "emitItem",
        "desc": "emitItem passes the specified item to the parser."
      },
      {
        "name": "errorf",
        "desc": "errorf returns an error token and terminates the scan by passing back a nil pointer that will be the next state, terminating l.nextItem."
      },
      {
        "name": "ignore",
        "desc": "ignore skips over the pending input before this point. It tracks newlines in the ignored text, so use it only for text that is skipped without calling l.next."
      },
      {
        "name": "next",
        "desc": "next returns the next rune in the input."
      },
      {
        "name": "nextItem",
        "desc": "nextItem returns the next item from the input. Called by the parser, not in the lexing goroutine."
      },
      {
        "name": "peek",
        "desc": "peek returns but does not consume the next rune in the input."
      },
      {
        "name": "scanNumber",
        "desc": ""
      },
      {
        "name": "thisItem",
        "desc": "thisItem returns the item at the current input point with the specified type and advances the input."
      }
    ],
    "types": [
      {
        "name": "ActionNode",
        "desc": "ActionNode holds an action (something bounded by delimiters). Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines."
      },
      {
        "name": "BoolNode",
        "desc": "BoolNode holds a boolean constant."
      },
      {
        "name": "BranchNode",
        "desc": "BranchNode is the common representation of if, range, and with."
      },
      {
        "name": "BreakNode",
        "desc": "BreakNode represents a {{break}} action."
      },
      {
        "name": "ChainNode",
        "desc": "ChainNode holds a term followed by a chain of field accesses (identifier starting with '.'). The names may be chained ('.x.y'). The periods are dropped from each ident."
      },
      {
        "name": "CommandNode",
        "desc": "CommandNode holds a command (a pipeline inside an evaluating action)."
      },
      {
        "name": "CommentNode",
        "desc": "CommentNode holds a comment."
      },
      {
        "name": "ContinueNode",
        "desc": "ContinueNode represents a {{continue}} action."
      },
      {
        "name": "DotNode",
        "desc": "DotNode holds the special identifier '.'."
      },
      {
        "name": "FieldNode",
        "desc": "FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident."
      },
      {
        "name": "IdentifierNode",
        "desc": "IdentifierNode holds an identifier."
      },
      {
        "name": "IfNode",
        "desc": "IfNode represents an {{if}} action and its commands."
      },
      {
        "name": "ListNode",
        "desc": "ListNode holds a sequence of nodes."
      },
      {
        "name": "Mode",
        "desc": "A mode value is a set of flags (or 0). Modes control parser behavior."
      },
      {
        "name": "NilNode",
        "desc": "NilNode holds the special identifier 'nil' representing an untyped nil constant."
      },
      {
        "name": "Node",
        "desc": "A Node is an element in the parse tree. The interface is trivial. The interface contains an unexported method so that only types local to this package can satisfy it."
      },
      {
        "name": "NodeType",
        "desc": "NodeType identifies the type of a parse tree node."
      },
      {
        "name": "NumberNode",
        "desc": "NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants."
      },
      {
        "name": "PipeNode",
        "desc": "PipeNode holds a pipeline with optional declaration"
      },
      {
        "name": "Pos",
        "desc": "Pos represents a byte position in the original input text from which this template was parsed."
      },
      {
        "name": "RangeNode",
        "desc": "RangeNode represents a {{range}} action and its commands."
      },
      {
        "name": "StringNode",
        "desc": "StringNode holds a string constant. The value has been \"unquoted\"."
      },
      {
        "name": "TemplateNode",
        "desc": "TemplateNode represents a {{template}} action."
      },
      {
        "name": "TextNode",
        "desc": "TextNode holds plain text."
      },
      {
        "name": "Tree",
        "desc": "Tree is the representation of a single parsed template."
      },
      {
        "name": "VariableNode",
        "desc": "VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name."
      },
      {
        "name": "WithNode",
        "desc": "WithNode represents a {{with}} action and its commands."
      },
      {
        "name": "elseNode",
        "desc": "elseNode represents an {{else}} action. Does not appear in the final tree."
      },
      {
        "name": "endNode",
        "desc": "endNode represents an {{end}} action. It does not appear in the final parse tree."
      },
      {
        "name": "isEmptyTest",
        "desc": ""
      },
      {
        "name": "item",
        "desc": "item represents a token or text string returned from the scanner."
      },
      {
        "name": "itemType",
        "desc": "itemType identifies the type of lex items."
      },
      {
        "name": "lexOptions",
        "desc": "lexOptions control behavior of the lexer. All default to false."
      },
      {
        "name": "lexTest",
        "desc": ""
      },
      {
        "name": "lexer",
        "desc": "lexer holds the state of the scanner."
      },
      {
        "name": "numberTest",
        "desc": ""
      },
      {
        "name": "parseTest",
        "desc": ""
      },
      {
        "name": "stateFn",
        "desc": "stateFn represents the state of the scanner as a function that returns the next state."
      }
    ]
  },
  {
    "name": "time",
    "desc": "Package time provides functionality for measuring and displaying time.  The calendrical calculations always assume a Gregorian calendar, with no leap seconds.  # Monotonic Clocks  Operating systems provide both a “wall clock,” which is subject to changes for clock synchronization, and a “monotonic clock,” which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by [time.Now] contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.  For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed:  \tstart := time.Now() \t... operation that takes 20 milliseconds ... \tt := time.Now() \telapsed := t.Sub(start)  Other idioms, such as [time.Since](start), [time.Until](deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.  The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package.  The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0).  If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings.  On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. The same applies to other functions and methods that subtract times, such as [Since], [Until], [Time.Before], [Time.After], [Time.Add], [Time.Equal] and [Time.Compare]. In some cases, you may need to strip the monotonic clock to get accurate results.  Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors [time.Date], [time.Parse], [time.ParseInLocation], and [time.Unix], as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading.  The monotonic clock reading exists only in [Time] values. It is not a part of [Duration] values or the Unix times returned by t.Unix and friends.  Note that the Go == operator compares not just the time instant but also the [Location] and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.  For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String().  # Timer Resolution  [Timer] resolution varies depending on the Go runtime, the operating system and the underlying hardware. On Unix, the resolution is ~1ms. On Windows version 1803 and newer, the resolution is ~0.5ms. On older Windows versions, the default resolution is ~16ms, but a higher resolution may be requested using [golang.org/x/sys/windows.TimeBeginPeriod].",
    "functions": [
      {
        "name": "After",
        "desc": "After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to [NewTimer](d).C.  Before Go 1.23, this documentation warned that the underlying [Timer] would not be recovered by the garbage collector until the timer fired, and that if efficiency was a concern, code should use NewTimer instead and call [Timer.Stop] if the timer is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced, unstopped timers. There is no reason to prefer NewTimer when After will do."
      },
      {
        "name": "CheckRuntimeTimerPeriodOverflow",
        "desc": "Test that a runtimeTimer with a period that would overflow when on expiration does not throw or cause other timers to hang.  This test has to be in internal_test.go since it fiddles with unexported data structures."
      },
      {
        "name": "ForceAndroidTzdataForTest",
        "desc": ""
      },
      {
        "name": "ForceAusFromTZIForTesting",
        "desc": ""
      },
      {
        "name": "ForceUSPacificForTesting",
        "desc": ""
      },
      {
        "name": "ForceUSPacificFromTZIForTesting",
        "desc": ""
      },
      {
        "name": "LoadFromEmbeddedTZData",
        "desc": ""
      },
      {
        "name": "ResetLocalOnceForTest",
        "desc": ""
      },
      {
        "name": "ResetZoneinfoForTesting",
        "desc": ""
      },
      {
        "name": "Sleep",
        "desc": "Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately."
      },
      {
        "name": "Tick",
        "desc": "Tick is a convenience wrapper for [NewTicker] providing access to the ticking channel only. Unlike NewTicker, Tick will return nil if d \u003c= 0.  Before Go 1.23, this documentation warned that the underlying [Ticker] would never be recovered by the garbage collector, and that if efficiency was a concern, code should use NewTicker instead and call [Ticker.Stop] when the ticker is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. There is no longer any reason to prefer NewTicker when Tick will do."
      },
      {
        "name": "ToEnglishName",
        "desc": ""
      },
      {
        "name": "TzsetRule",
        "desc": ""
      },
      {
        "name": "ZoneinfoForTesting",
        "desc": ""
      },
      {
        "name": "abbrev",
        "desc": "abbrev returns the abbreviations to use for the given zone z."
      },
      {
        "name": "androidLoadTzinfoFromTzdata",
        "desc": ""
      },
      {
        "name": "appendInt",
        "desc": "appendInt appends the decimal form of x to b and returns the result. If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's. Duplicates functionality in strconv, but avoids dependency."
      },
      {
        "name": "appendNano",
        "desc": "appendNano appends a fractional second, as nanoseconds, to b and returns the result. The nanosec must be within [0, 999999999]."
      },
      {
        "name": "atoi",
        "desc": "Duplicates functionality in strconv, but avoids dependency."
      },
      {
        "name": "byteString",
        "desc": "Make a string by stopping at the first NUL"
      },
      {
        "name": "closefd",
        "desc": ""
      },
      {
        "name": "commaOrPeriod",
        "desc": ""
      },
      {
        "name": "containsDotDot",
        "desc": "containsDotDot reports whether s contains \"..\"."
      },
      {
        "name": "cutspace",
        "desc": ""
      },
      {
        "name": "daysBefore",
        "desc": "daysBefore returns the number of days in a non-leap year before month m. daysBefore(December+1) returns 365."
      },
      {
        "name": "daysIn",
        "desc": ""
      },
      {
        "name": "digitsLen",
        "desc": ""
      },
      {
        "name": "disablePlatformSources",
        "desc": ""
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "extractCAPS",
        "desc": "extractCAPS extracts capital letters from description desc."
      },
      {
        "name": "fields",
        "desc": "Copied from strings to avoid a dependency."
      },
      {
        "name": "findZone",
        "desc": ""
      },
      {
        "name": "fmtFrac",
        "desc": "fmtFrac formats the fraction of v/10**prec (e.g., \".12345\") into the tail of buf, omitting trailing zeros. It omits the decimal point too when the fraction is 0. It returns the index where the output bytes begin and the value v/10**prec."
      },
      {
        "name": "fmtInt",
        "desc": "fmtInt formats v into the tail of buf. It returns the index where the output begins."
      },
      {
        "name": "get2",
        "desc": "get2 returns the little-endian 16-bit value in b."
      },
      {
        "name": "get4",
        "desc": "get4 returns the little-endian 32-bit value in b."
      },
      {
        "name": "getnum",
        "desc": "getnum parses s[0:1] or s[0:2] (fixed forces s[0:2]) as a decimal integer and returns the integer and the remainder of the string."
      },
      {
        "name": "getnum3",
        "desc": "getnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3]) as a decimal integer and returns the integer and the remainder of the string."
      },
      {
        "name": "goFunc",
        "desc": ""
      },
      {
        "name": "gorootZoneSource",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initLocal",
        "desc": ""
      },
      {
        "name": "initLocalFromTZI",
        "desc": ""
      },
      {
        "name": "initTestingZone",
        "desc": ""
      },
      {
        "name": "interrupt",
        "desc": "for testing: whatever interrupts a sleep"
      },
      {
        "name": "isDigit",
        "desc": "isDigit reports whether s[i] is in range and is a decimal digit."
      },
      {
        "name": "isLeap",
        "desc": ""
      },
      {
        "name": "isSpace",
        "desc": ""
      },
      {
        "name": "leadingFraction",
        "desc": "leadingFraction consumes the leading [0-9]* from s. It is used only for fractions, so does not return an error on overflow, it just stops accumulating precision."
      },
      {
        "name": "leadingInt",
        "desc": "leadingInt consumes the leading [0-9]* from s."
      },
      {
        "name": "legacyAbsClock",
        "desc": ""
      },
      {
        "name": "legacyTimeTimeAbs",
        "desc": ""
      },
      {
        "name": "lessThanHalf",
        "desc": "lessThanHalf reports whether x+x \u003c y but avoids overflow, assuming x and y are both positive (Duration is signed)."
      },
      {
        "name": "loadTzinfo",
        "desc": "loadTzinfo returns the time zone information of the time zone with the given name, from a given source. A source may be a timezone database directory, tzdata database file or an uncompressed zip file, containing the contents of such a directory."
      },
      {
        "name": "loadTzinfoFromDirOrZip",
        "desc": "loadTzinfoFromDirOrZip returns the contents of the file with the given name in dir. dir can either be an uncompressed zip file, or a directory."
      },
      {
        "name": "loadTzinfoFromZip",
        "desc": "loadTzinfoFromZip returns the contents of the file with the given name in the given uncompressed zip file."
      },
      {
        "name": "lookup",
        "desc": ""
      },
      {
        "name": "match",
        "desc": "match reports whether s1 and s2 match ignoring case. It is assumed s1 and s2 are the same length."
      },
      {
        "name": "matchZoneKey",
        "desc": "matchZoneKey checks if stdname and dstname match the corresponding key values \"MUI_Std\" and \"MUI_Dlt\" or \"Std\" and \"Dlt\" in the kname key stored under the open registry key zones."
      },
      {
        "name": "nextStdChunk",
        "desc": "nextStdChunk finds the first occurrence of a std string in layout and returns the text before, the std string, and the text after.  nextStdChunk should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - github.com/searKing/golang/go  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "norm",
        "desc": "norm returns nhi, nlo such that  \thi * base + lo == nhi * base + nlo \t0 \u003c= nlo \u003c base"
      },
      {
        "name": "now",
        "desc": "Provided by package runtime.  now returns the current real time, and is superseded by runtimeNow which returns the fake synctest clock when appropriate.  now should be an internal detail, but widely used packages access it using linkname. Notable members of the hall of shame include:   - gitee.com/quant1x/gox   - github.com/phuslu/log   - github.com/sethvargo/go-limiter   - github.com/ulule/limiter/v3  Do not remove or change the type signature. See go.dev/issue/67401."
      },
      {
        "name": "open",
        "desc": ""
      },
      {
        "name": "parseGMT",
        "desc": "parseGMT parses a GMT time zone. The input string is known to start \"GMT\". The function checks whether that is followed by a sign and a number in the range -23 through +23 excluding zero."
      },
      {
        "name": "parseNanoseconds",
        "desc": ""
      },
      {
        "name": "parseSignedOffset",
        "desc": "parseSignedOffset parses a signed timezone offset (e.g. \"+03\" or \"-04\"). The function checks for a signed number in the range -23 through +23 excluding zero. Returns length of the found offset string or 0 otherwise."
      },
      {
        "name": "parseTimeZone",
        "desc": "parseTimeZone parses a time zone string and returns its length. Time zones are human-generated and unpredictable. We can't do precise error checking. On the other hand, for a correct parse there must be a time zone at the beginning of the string, so it's almost always true that there's one there. We look at the beginning of the string for a run of upper-case letters. If there are more than 5, it's an error. If there are 4 or 5 and the last is a T, it's a time zone. If there are 3, it's a time zone. Otherwise, other than special cases, it's not a time zone. GMT is special because it can have an hour offset."
      },
      {
        "name": "preadn",
        "desc": ""
      },
      {
        "name": "pseudoUnix",
        "desc": "pseudoUnix returns the pseudo-Unix time (seconds since Jan 1 1970 *LOCAL TIME*) denoted by the system date+time d in the given year. It is up to the caller to convert this local time into a UTC-based time."
      },
      {
        "name": "quote",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "readFile",
        "desc": "readFile reads and returns the content of the named file. It is a trivial implementation of os.ReadFile, reimplemented here to avoid depending on io/ioutil or os. It returns an error if name exceeds maxFileSize bytes."
      },
      {
        "name": "registerLoadFromEmbeddedTZData",
        "desc": "registerLoadFromEmbeddedTZData is called by the time/tzdata package, if it is imported."
      },
      {
        "name": "resetTimer",
        "desc": ""
      },
      {
        "name": "runtimeIsBubbled",
        "desc": ""
      },
      {
        "name": "runtimeNano",
        "desc": "runtimeNano returns the current value of the runtime clock in nanoseconds. When called within a synctest.Run bubble, it returns the group's fake clock."
      },
      {
        "name": "runtimeNow",
        "desc": "runtimeNow returns the current time. When called within a synctest.Run bubble, it returns the group's fake clock."
      },
      {
        "name": "sendTime",
        "desc": "sendTime does a non-blocking send of the current time on c."
      },
      {
        "name": "separator",
        "desc": ""
      },
      {
        "name": "skip",
        "desc": "skip removes the given prefix from value, treating runs of space characters as equivalent."
      },
      {
        "name": "startsWithLowerCase",
        "desc": "startsWithLowerCase reports whether the string has a lower-case letter at the beginning. Its purpose is to prevent matching strings like \"Month\" when looking for \"Mon\"."
      },
      {
        "name": "stdFracSecond",
        "desc": "The \"std\" value passed to appendNano contains two packed fields: the number of digits after the decimal and the separator character (period or comma). These functions pack and unpack that variable."
      },
      {
        "name": "stopTimer",
        "desc": ""
      },
      {
        "name": "syncTimer",
        "desc": "syncTimer returns c as an unsafe.Pointer, for passing to newTimer. If the GODEBUG asynctimerchan has disabled the async timer chan code, then syncTimer always returns nil, to disable the special channel code paths in the runtime."
      },
      {
        "name": "testAbsDate",
        "desc": ""
      },
      {
        "name": "testAbsDaysSplit",
        "desc": ""
      },
      {
        "name": "testAbsYdaySplit",
        "desc": ""
      },
      {
        "name": "testDateToAbsDays",
        "desc": ""
      },
      {
        "name": "testDaysBefore",
        "desc": ""
      },
      {
        "name": "testDaysIn",
        "desc": ""
      },
      {
        "name": "toEnglishName",
        "desc": "toEnglishName searches the registry for an English name of a time zone whose zone names are stdname and dstname and returns the English name."
      },
      {
        "name": "tzruleTime",
        "desc": "tzruleTime takes a year, a rule, and a timezone offset, and returns the number of seconds since the start of the year that the rule takes effect."
      },
      {
        "name": "tzset",
        "desc": "tzset takes a timezone string like the one found in the TZ environment variable, the time of the last time zone transition expressed as seconds since January 1, 1970 00:00:00 UTC, and a time expressed the same way. We call this a tzset string since in C the function tzset reads TZ. The return values are as for lookup, plus ok which reports whether the parse succeeded."
      },
      {
        "name": "tzsetName",
        "desc": "tzsetName returns the timezone name at the start of the tzset string s, and the remainder of s, and reports whether the parsing is OK."
      },
      {
        "name": "tzsetNum",
        "desc": "tzsetNum parses a number from a tzset string. It returns the number, and the remainder of the string, and reports success. The number must be between min and max."
      },
      {
        "name": "tzsetOffset",
        "desc": "tzsetOffset returns the timezone offset at the start of the tzset string s, and the remainder of s, and reports whether the parsing is OK. The timezone offset is returned as a number of seconds."
      },
      {
        "name": "tzsetRule",
        "desc": "tzsetRule parses a rule from a tzset string. It returns the rule, and the remainder of the string, and reports success."
      },
      {
        "name": "when",
        "desc": "when is a helper function for setting the 'when' field of a runtimeTimer. It returns what the time will be, in nanoseconds, Duration d in the future. If d is negative, it is ignored. If the returned value would be less than zero because of an overflow, MaxInt64 is returned."
      },
      {
        "name": "Abs",
        "desc": "Abs returns the absolute value of d. As a special case, Duration([math.MinInt64]) is converted to Duration([math.MaxInt64]), reducing its magnitude by 1 nanosecond."
      },
      {
        "name": "Hours",
        "desc": "Hours returns the duration as a floating point number of hours."
      },
      {
        "name": "Microseconds",
        "desc": "Microseconds returns the duration as an integer microsecond count."
      },
      {
        "name": "Milliseconds",
        "desc": "Milliseconds returns the duration as an integer millisecond count."
      },
      {
        "name": "Minutes",
        "desc": "Minutes returns the duration as a floating point number of minutes."
      },
      {
        "name": "Nanoseconds",
        "desc": "Nanoseconds returns the duration as an integer nanosecond count."
      },
      {
        "name": "Round",
        "desc": "Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a [Duration], Round returns the maximum (or minimum) duration. If m \u003c= 0, Round returns d unchanged."
      },
      {
        "name": "Seconds",
        "desc": "Seconds returns the duration as a floating point number of seconds."
      },
      {
        "name": "String",
        "desc": "String returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s."
      },
      {
        "name": "Truncate",
        "desc": "Truncate returns the result of rounding d toward zero to a multiple of m. If m \u003c= 0, Truncate returns d unchanged."
      },
      {
        "name": "format",
        "desc": "format formats the representation of d into the end of buf and returns the offset of the first character."
      },
      {
        "name": "String",
        "desc": "String returns a descriptive name for the time zone information, corresponding to the name argument to [LoadLocation] or [FixedZone]."
      },
      {
        "name": "firstZoneUsed",
        "desc": "firstZoneUsed reports whether the first zone is used by some transition."
      },
      {
        "name": "get",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": "lookup returns information about the time zone in use at an instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.  The returned information gives the name of the zone (such as \"CET\"), the start and end times bracketing sec when that zone is in effect, the offset in seconds east of UTC (such as -5*60*60), and whether the daylight savings is being observed at that time."
      },
      {
        "name": "lookupFirstZone",
        "desc": "lookupFirstZone returns the index of the time zone to use for times before the first transition time, or when there are no transition times.  The reference implementation in localtime.c from https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz implements the following algorithm for these cases:  1. If the first zone is unused by the transitions, use it.  2. Otherwise, if there are transition times, and the first     transition is to a zone in daylight time, find the first     non-daylight-time zone before and closest to the first transition     zone.  3. Otherwise, use the first zone that is not daylight time, if     there is one.  4. Otherwise, use the first zone."
      },
      {
        "name": "lookupName",
        "desc": "lookupName returns information about the time zone with the given name (such as \"EST\") at the given pseudo-Unix time (what the given time of day would be in UTC)."
      },
      {
        "name": "String",
        "desc": "String returns the English name of the month (\"January\", \"February\", ...)."
      },
      {
        "name": "Error",
        "desc": "Error returns the string representation of a ParseError."
      },
      {
        "name": "Reset",
        "desc": "Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic."
      },
      {
        "name": "Stop",
        "desc": "Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\"."
      },
      {
        "name": "Add",
        "desc": "Add returns the time t+d."
      },
      {
        "name": "AddDate",
        "desc": "AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.  Note that dates are fundamentally coupled to timezones, and calendrical periods like days don't have fixed durations. AddDate uses the Location of the Time value to determine these durations. That means that the same AddDate arguments can produce a different shift in absolute time depending on the base Time value and its Location. For example, AddDate(0, 0, 1) applied to 12:00 on March 27 always returns 12:00 on March 28. At some locations and in some years this is a 24 hour shift. In others it's a 23 hour shift due to daylight savings time transitions.  AddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31."
      },
      {
        "name": "After",
        "desc": "After reports whether the time instant t is after u."
      },
      {
        "name": "AppendBinary",
        "desc": "AppendBinary implements the [encoding.BinaryAppender] interface."
      },
      {
        "name": "AppendFormat",
        "desc": "AppendFormat is like [Time.Format] but appends the textual representation to b and returns the extended buffer."
      },
      {
        "name": "AppendText",
        "desc": "AppendText implements the [encoding.TextAppender] interface. The time is formatted in RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is returned."
      },
      {
        "name": "Before",
        "desc": "Before reports whether the time instant t is before u."
      },
      {
        "name": "Clock",
        "desc": "Clock returns the hour, minute, and second within the day specified by t."
      },
      {
        "name": "Compare",
        "desc": "Compare compares the time instant t with u. If t is before u, it returns -1; if t is after u, it returns +1; if they're the same, it returns 0."
      },
      {
        "name": "Date",
        "desc": "Date returns the year, month, and day in which t occurs."
      },
      {
        "name": "Day",
        "desc": "Day returns the day of the month specified by t."
      },
      {
        "name": "Equal",
        "desc": "Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead."
      },
      {
        "name": "Format",
        "desc": "Format returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called [Layout] to see how to represent the layout format.  The executable example for [Time.Format] demonstrates the working of the layout string in detail and is a good reference."
      },
      {
        "name": "GoString",
        "desc": "GoString implements [fmt.GoStringer] and formats t to be printed in Go source code."
      },
      {
        "name": "GobDecode",
        "desc": "GobDecode implements the gob.GobDecoder interface."
      },
      {
        "name": "GobEncode",
        "desc": "GobEncode implements the gob.GobEncoder interface."
      },
      {
        "name": "Hour",
        "desc": "Hour returns the hour within the day specified by t, in the range [0, 23]."
      },
      {
        "name": "ISOWeek",
        "desc": "ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1."
      },
      {
        "name": "In",
        "desc": "In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.  In panics if loc is nil."
      },
      {
        "name": "IsDST",
        "desc": "IsDST reports whether the time in the configured location is in Daylight Savings Time."
      },
      {
        "name": "IsZero",
        "desc": "IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC."
      },
      {
        "name": "Local",
        "desc": "Local returns t with the location set to local time."
      },
      {
        "name": "Location",
        "desc": "Location returns the time zone information associated with t."
      },
      {
        "name": "MarshalBinary",
        "desc": "MarshalBinary implements the [encoding.BinaryMarshaler] interface."
      },
      {
        "name": "MarshalJSON",
        "desc": "MarshalJSON implements the [encoding/json.Marshaler] interface. The time is a quoted string in the RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported."
      },
      {
        "name": "MarshalText",
        "desc": "MarshalText implements the [encoding.TextMarshaler] interface. The output matches that of calling the [Time.AppendText] method.  See [Time.AppendText] for more information."
      },
      {
        "name": "Minute",
        "desc": "Minute returns the minute offset within the hour specified by t, in the range [0, 59]."
      },
      {
        "name": "Month",
        "desc": "Month returns the month of the year specified by t."
      },
      {
        "name": "Nanosecond",
        "desc": "Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999]."
      },
      {
        "name": "Round",
        "desc": "Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d \u003c= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.  Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location."
      },
      {
        "name": "Second",
        "desc": "Second returns the second offset within the minute specified by t, in the range [0, 59]."
      },
      {
        "name": "String",
        "desc": "String returns the time formatted using the format string  \t\"2006-01-02 15:04:05.999999999 -0700 MST\"  If the time has a monotonic clock reading, the returned string includes a final field \"m=±\u003cvalue\u003e\", where value is the monotonic clock reading formatted as a decimal number of seconds.  The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string."
      },
      {
        "name": "Sub",
        "desc": "Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a [Duration], the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d)."
      },
      {
        "name": "Truncate",
        "desc": "Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d \u003c= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.  Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location."
      },
      {
        "name": "UTC",
        "desc": "UTC returns t with the location set to UTC."
      },
      {
        "name": "Unix",
        "desc": "Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future."
      },
      {
        "name": "UnixMicro",
        "desc": "UnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t."
      },
      {
        "name": "UnixMilli",
        "desc": "UnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t."
      },
      {
        "name": "UnixNano",
        "desc": "UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t."
      },
      {
        "name": "UnmarshalBinary",
        "desc": "UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface."
      },
      {
        "name": "UnmarshalJSON",
        "desc": "UnmarshalJSON implements the [encoding/json.Unmarshaler] interface. The time must be a quoted string in the RFC 3339 format."
      },
      {
        "name": "UnmarshalText",
        "desc": "UnmarshalText implements the [encoding.TextUnmarshaler] interface. The time must be in the RFC 3339 format."
      },
      {
        "name": "Weekday",
        "desc": "Weekday returns the day of the week specified by t."
      },
      {
        "name": "Year",
        "desc": "Year returns the year in which t occurs."
      },
      {
        "name": "YearDay",
        "desc": "YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years."
      },
      {
        "name": "Zone",
        "desc": "Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC."
      },
      {
        "name": "ZoneBounds",
        "desc": "ZoneBounds returns the bounds of the time zone in effect at time t. The zone begins at start and the next zone begins at end. If the zone begins at the beginning of time, start will be returned as a zero Time. If the zone goes on forever, end will be returned as a zero Time. The Location of the returned times will be the same as t."
      },
      {
        "name": "absSec",
        "desc": "absSec returns the time t as an absolute seconds, adjusted by the zone offset. It is called when computing a presentation property like Month or Hour. We'd rather call it abs, but there are linknames to abs that make that problematic. See timeAbs below."
      },
      {
        "name": "addSec",
        "desc": "addSec adds d seconds to the time."
      },
      {
        "name": "appendFormat",
        "desc": ""
      },
      {
        "name": "appendFormatRFC3339",
        "desc": ""
      },
      {
        "name": "appendStrictRFC3339",
        "desc": ""
      },
      {
        "name": "appendTo",
        "desc": ""
      },
      {
        "name": "locabs",
        "desc": "locabs is a combination of the Zone and abs methods, extracting both return values from a single zone lookup."
      },
      {
        "name": "mono",
        "desc": "mono returns t's monotonic clock reading. It returns 0 for a missing reading. This function is used only for testing, so it's OK that technically 0 is a valid monotonic clock reading as well."
      },
      {
        "name": "nsec",
        "desc": "nsec returns the time's nanoseconds."
      },
      {
        "name": "sec",
        "desc": "sec returns the time's seconds since Jan 1 year 1."
      },
      {
        "name": "setLoc",
        "desc": "setLoc sets the location associated with the time."
      },
      {
        "name": "setMono",
        "desc": "setMono sets the monotonic clock reading in t. If t cannot hold a monotonic clock reading, because its wall time is too large, setMono is a no-op."
      },
      {
        "name": "stripMono",
        "desc": "stripMono strips the monotonic clock reading in t."
      },
      {
        "name": "unixSec",
        "desc": "unixSec returns the time's seconds since Jan 1 1970 (Unix time)."
      },
      {
        "name": "Reset",
        "desc": "Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.  For a func-based timer created with [AfterFunc](d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly.  For a chan-based timer created with NewTimer, as of Go 1.23, any receive from t.C after Reset has returned is guaranteed not to receive a time value corresponding to the previous timer settings; if the program has not received from t.C already and the timer is running, Reset is guaranteed to return true. Before Go 1.23, the only safe way to use Reset was to call [Timer.Stop] and explicitly drain the timer first. See the [NewTimer] documentation for more details."
      },
      {
        "name": "Stop",
        "desc": "Stop prevents the [Timer] from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped.  For a func-based timer created with [AfterFunc](d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.  For a chan-based timer created with NewTimer(d), as of Go 1.23, any receive from t.C after Stop has returned is guaranteed to block rather than receive a stale time value from before the Stop; if the program has not received from t.C already and the timer is running, Stop is guaranteed to return true. Before Go 1.23, the only safe way to use Stop was insert an extra \u003c-t.C if Stop returned false to drain a potential stale value. See the [NewTimer] documentation for more details."
      },
      {
        "name": "String",
        "desc": "String returns the English name of the day (\"Sunday\", \"Monday\", ...)."
      },
      {
        "name": "leap",
        "desc": "leap returns 1 if (century, cyear) is a leap year, 0 otherwise."
      },
      {
        "name": "year",
        "desc": "year returns the standard year for (century, cyear, janFeb)."
      },
      {
        "name": "date",
        "desc": "date converts days into standard year, month, day."
      },
      {
        "name": "split",
        "desc": "split splits days into century, cyear, ayday."
      },
      {
        "name": "weekday",
        "desc": "weekday returns the day of the week specified by days."
      },
      {
        "name": "yearYday",
        "desc": "yearYday converts days into the standard year and 1-based yday."
      },
      {
        "name": "month",
        "desc": "month returns the standard Month for (m, janFeb)"
      },
      {
        "name": "clock",
        "desc": "clock returns the hour, minute, and second within the day specified by abs."
      },
      {
        "name": "days",
        "desc": "days converts absolute seconds to absolute days."
      },
      {
        "name": "janFeb",
        "desc": "janFeb returns 1 if the March 1-based ayday is in January or February, 0 otherwise."
      },
      {
        "name": "split",
        "desc": "split splits ayday into absolute month and standard (1-based) day-in-month."
      },
      {
        "name": "yday",
        "desc": "yday returns the standard 1-based yday for (ayday, janFeb, leap)."
      },
      {
        "name": "big4",
        "desc": ""
      },
      {
        "name": "big8",
        "desc": ""
      },
      {
        "name": "byte",
        "desc": ""
      },
      {
        "name": "read",
        "desc": ""
      },
      {
        "name": "rest",
        "desc": "rest returns the rest of the data in the buffer."
      },
      {
        "name": "Error",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Duration",
        "desc": "A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years."
      },
      {
        "name": "Location",
        "desc": "A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant.  Location is used to provide a time zone in a printed Time value and for calculations involving intervals that may cross daylight savings time boundaries."
      },
      {
        "name": "Month",
        "desc": "A Month specifies a month of the year (January = 1, ...)."
      },
      {
        "name": "ParseError",
        "desc": "ParseError describes a problem parsing a time string."
      },
      {
        "name": "Rule",
        "desc": ""
      },
      {
        "name": "RuleKind",
        "desc": ""
      },
      {
        "name": "Ticker",
        "desc": "A Ticker holds a channel that delivers “ticks” of a clock at intervals."
      },
      {
        "name": "Time",
        "desc": "A Time represents an instant in time with nanosecond precision.  Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type [time.Time], not *time.Time.  A Time value can be used by multiple goroutines simultaneously except that the methods [Time.GobDecode], [Time.UnmarshalBinary], [Time.UnmarshalJSON] and [Time.UnmarshalText] are not concurrency-safe.  Time instants can be compared using the [Time.Before], [Time.After], and [Time.Equal] methods. The [Time.Sub] method subtracts two instants, producing a [Duration]. The [Time.Add] method adds a Time and a Duration, producing a Time.  The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the [Time.IsZero] method gives a simple way of detecting a time that has not been initialized explicitly.  Each time has an associated [Location]. The methods [Time.Local], [Time.UTC], and Time.In return a Time with a specific Location. Changing the Location of a Time value with these methods does not change the actual instant it represents, only the time zone in which to interpret it.  Representations of a Time value saved by the [Time.GobEncode], [Time.MarshalBinary], [Time.AppendBinary], [Time.MarshalJSON], [Time.MarshalText] and [Time.AppendText] methods store the [Time.Location]'s offset, but not the location name. They therefore lose information about Daylight Saving Time.  In addition to the required “wall clock” reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the “Monotonic Clocks” section in the package documentation for details.  Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading."
      },
      {
        "name": "Timer",
        "desc": "The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by [AfterFunc]. A Timer must be created with [NewTimer] or AfterFunc."
      },
      {
        "name": "Weekday",
        "desc": "A Weekday specifies a day of the week (Sunday = 0, ...)."
      },
      {
        "name": "abbr",
        "desc": ""
      },
      {
        "name": "absCentury",
        "desc": "An absCentury counts the number of centuries since the absolute zero instant."
      },
      {
        "name": "absCyear",
        "desc": "An absCyear counts the number of years since the start of a century."
      },
      {
        "name": "absDays",
        "desc": "An absDays counts the number of days since the absolute zero instant."
      },
      {
        "name": "absJanFeb",
        "desc": "An absJanFeb is a single bit (0 or 1) denoting whether a given day falls in January or February. That is a special case because the absolute years start in March (unlike normal calendar years)."
      },
      {
        "name": "absLeap",
        "desc": "An absLeap is a single bit (0 or 1) denoting whether a given year is a leap year."
      },
      {
        "name": "absMonth",
        "desc": "An absMonth counts the number of months since the start of a year. absMonth=0 denotes March."
      },
      {
        "name": "absSeconds",
        "desc": "An absSeconds counts the number of seconds since the absolute zero instant."
      },
      {
        "name": "absYday",
        "desc": "An absYday counts the number of days since the start of a year. Note that absolute years start on March 1."
      },
      {
        "name": "dataIO",
        "desc": "Simple I/O interface to binary blob of data."
      },
      {
        "name": "fileSizeError",
        "desc": ""
      },
      {
        "name": "rule",
        "desc": "rule is a rule read from a tzset string."
      },
      {
        "name": "ruleKind",
        "desc": "ruleKind is the kinds of rules that can be seen in a tzset string."
      },
      {
        "name": "testingT",
        "desc": ""
      },
      {
        "name": "zone",
        "desc": "A zone represents a single time zone such as CET."
      },
      {
        "name": "zoneTrans",
        "desc": "A zoneTrans represents a single time zone transition."
      }
    ]
  },
  {
    "name": "time/tzdata",
    "desc": "Package tzdata provides an embedded copy of the timezone database. If this package is imported anywhere in the program, then if the time package cannot find tzdata files on the system, it will use this embedded information.  Importing this package will increase the size of a program by about 450 KB.  This package should normally be imported by a program's main package, not by a library. Libraries normally shouldn't decide whether to include the timezone database in a program.  This package will be automatically imported if you build with -tags timetzdata.",
    "functions": [
      {
        "name": "get2s",
        "desc": "get2s returns the little-endian 16-bit value at the start of s."
      },
      {
        "name": "get4s",
        "desc": "get4s returns the little-endian 32-bit value at the start of s."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "loadFromEmbeddedTZData",
        "desc": "loadFromEmbeddedTZData returns the contents of the file with the given name in an uncompressed zip file, where the contents of the file can be found in embeddedTzdata. This is similar to time.loadTzinfoFromZip."
      },
      {
        "name": "registerLoadFromEmbeddedTZData",
        "desc": "registerLoadFromEmbeddedTZData is defined in package time."
      }
    ],
    "types": null
  },
  {
    "name": "unicode",
    "desc": "Package unicode provides data and functions to test some properties of Unicode code points.",
    "functions": [
      {
        "name": "In",
        "desc": "In reports whether the rune is a member of one of the ranges."
      },
      {
        "name": "Is",
        "desc": "Is reports whether the rune is in the specified table of ranges."
      },
      {
        "name": "IsControl",
        "desc": "IsControl reports whether the rune is a control character. The [C] ([Other]) Unicode category includes more code points such as surrogates; use [Is](C, r) to test for them."
      },
      {
        "name": "IsDigit",
        "desc": "IsDigit reports whether the rune is a decimal digit."
      },
      {
        "name": "IsGraphic",
        "desc": "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories [L], [M], [N], [P], [S], [Zs]."
      },
      {
        "name": "IsLetter",
        "desc": "IsLetter reports whether the rune is a letter (category [L])."
      },
      {
        "name": "IsLower",
        "desc": "IsLower reports whether the rune is a lower case letter."
      },
      {
        "name": "IsMark",
        "desc": "IsMark reports whether the rune is a mark character (category [M])."
      },
      {
        "name": "IsNumber",
        "desc": "IsNumber reports whether the rune is a number (category [N])."
      },
      {
        "name": "IsOneOf",
        "desc": "IsOneOf reports whether the rune is a member of one of the ranges. The function \"In\" provides a nicer signature and should be used in preference to IsOneOf."
      },
      {
        "name": "IsPrint",
        "desc": "IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories [L], [M], [N], [P], [S] and the ASCII space character. This categorization is the same as [IsGraphic] except that the only spacing character is ASCII space, U+0020."
      },
      {
        "name": "IsPunct",
        "desc": "IsPunct reports whether the rune is a Unicode punctuation character (category [P])."
      },
      {
        "name": "IsSpace",
        "desc": "IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is  \t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).  Other definitions of spacing characters are set by category Z and property [Pattern_White_Space]."
      },
      {
        "name": "IsSymbol",
        "desc": "IsSymbol reports whether the rune is a symbolic character."
      },
      {
        "name": "IsTitle",
        "desc": "IsTitle reports whether the rune is a title case letter."
      },
      {
        "name": "IsUpper",
        "desc": "IsUpper reports whether the rune is an upper case letter."
      },
      {
        "name": "SimpleFold",
        "desc": "SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune \u003e r if one exists, or else the smallest rune \u003e= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.  For example:  \tSimpleFold('A') = 'a' \tSimpleFold('a') = 'A'  \tSimpleFold('K') = 'k' \tSimpleFold('k') = '\\u212A' (Kelvin symbol, K) \tSimpleFold('\\u212A') = 'K'  \tSimpleFold('1') = '1'  \tSimpleFold(-2) = -2"
      },
      {
        "name": "To",
        "desc": "To maps the rune to the specified case: [UpperCase], [LowerCase], or [TitleCase]."
      },
      {
        "name": "ToLower",
        "desc": "ToLower maps the rune to lower case."
      },
      {
        "name": "ToTitle",
        "desc": "ToTitle maps the rune to title case."
      },
      {
        "name": "ToUpper",
        "desc": "ToUpper maps the rune to upper case."
      },
      {
        "name": "convertCase",
        "desc": "convertCase converts r to _case using CaseRange cr."
      },
      {
        "name": "is16",
        "desc": "is16 reports whether r is in the sorted slice of 16-bit ranges."
      },
      {
        "name": "is32",
        "desc": "is32 reports whether r is in the sorted slice of 32-bit ranges."
      },
      {
        "name": "isExcludingLatin",
        "desc": ""
      },
      {
        "name": "to",
        "desc": "to maps the rune using the specified case mapping. It additionally reports whether caseRange contained a mapping for r."
      },
      {
        "name": "ToLower",
        "desc": "ToLower maps the rune to lower case giving priority to the special mapping."
      },
      {
        "name": "ToTitle",
        "desc": "ToTitle maps the rune to title case giving priority to the special mapping."
      },
      {
        "name": "ToUpper",
        "desc": "ToUpper maps the rune to upper case giving priority to the special mapping."
      }
    ],
    "types": [
      {
        "name": "CaseRange",
        "desc": "CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas are the number to add to the code point to reach the code point for a different case for that character. They may be negative. If zero, it means the character is in the corresponding case. There is a special case representing sequences of alternating corresponding Upper and Lower pairs. It appears with a fixed Delta of  \t{UpperLower, UpperLower, UpperLower}  The constant UpperLower has an otherwise impossible delta value."
      },
      {
        "name": "Range16",
        "desc": "Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride."
      },
      {
        "name": "Range32",
        "desc": "Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be \u003e= 1\u003c\u003c16."
      },
      {
        "name": "RangeTable",
        "desc": "RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values \u003e= 0x10000 (1\u003c\u003c16)."
      },
      {
        "name": "SpecialCase",
        "desc": "SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings."
      },
      {
        "name": "d",
        "desc": ""
      },
      {
        "name": "foldPair",
        "desc": "caseOrbit is defined in tables.go as []foldPair. Right now all the entries fit in uint16, so use uint16. If that changes, compilation will fail (the constants in the composite literal will not fit in uint16) and the types here can change to uint32."
      }
    ]
  },
  {
    "name": "unicode/utf16",
    "desc": "Package utf16 implements encoding and decoding of UTF-16 sequences.",
    "functions": [
      {
        "name": "AppendRune",
        "desc": "AppendRune appends the UTF-16 encoding of the Unicode code point r to the end of p and returns the extended buffer. If the rune is not a valid Unicode code point, it appends the encoding of U+FFFD."
      },
      {
        "name": "Decode",
        "desc": "Decode returns the Unicode code point sequence represented by the UTF-16 encoding s."
      },
      {
        "name": "DecodeRune",
        "desc": "DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD."
      },
      {
        "name": "Encode",
        "desc": "Encode returns the UTF-16 encoding of the Unicode code point sequence s."
      },
      {
        "name": "EncodeRune",
        "desc": "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD."
      },
      {
        "name": "IsSurrogate",
        "desc": "IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair."
      },
      {
        "name": "RuneLen",
        "desc": "RuneLen returns the number of 16-bit words in the UTF-16 encoding of the rune. It returns -1 if the rune is not a valid value to encode in UTF-16."
      },
      {
        "name": "decode",
        "desc": "decode appends to buf the Unicode code point sequence represented by the UTF-16 encoding s and return the extended buffer."
      }
    ],
    "types": null
  },
  {
    "name": "unicode/utf8",
    "desc": "",
    "functions": [
      {
        "name": "BenchmarkAppendASCIIRune",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendInvalidRuneMaxPlusOne",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendInvalidRuneNegative",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendInvalidRuneSurrogate",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendJapaneseRune",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendMaxRune",
        "desc": ""
      },
      {
        "name": "BenchmarkAppendSpanishRune",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeASCIIRune",
        "desc": ""
      },
      {
        "name": "BenchmarkDecodeJapaneseRune",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeASCIIRune",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeInvalidRuneMaxPlusOne",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeInvalidRuneNegative",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeInvalidRuneSurrogate",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeJapaneseRune",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeMaxRune",
        "desc": ""
      },
      {
        "name": "BenchmarkEncodeSpanishRune",
        "desc": ""
      },
      {
        "name": "BenchmarkFullRune",
        "desc": ""
      },
      {
        "name": "BenchmarkRuneCountInStringTenASCIIChars",
        "desc": ""
      },
      {
        "name": "BenchmarkRuneCountInStringTenJapaneseChars",
        "desc": ""
      },
      {
        "name": "BenchmarkRuneCountTenASCIIChars",
        "desc": ""
      },
      {
        "name": "BenchmarkRuneCountTenJapaneseChars",
        "desc": ""
      },
      {
        "name": "BenchmarkValid100KASCIIChars",
        "desc": ""
      },
      {
        "name": "BenchmarkValidLongJapanese",
        "desc": ""
      },
      {
        "name": "BenchmarkValidLongMostlyASCII",
        "desc": ""
      },
      {
        "name": "BenchmarkValidString100KASCIIChars",
        "desc": ""
      },
      {
        "name": "BenchmarkValidStringLongJapanese",
        "desc": ""
      },
      {
        "name": "BenchmarkValidStringLongMostlyASCII",
        "desc": ""
      },
      {
        "name": "BenchmarkValidStringTenASCIIChars",
        "desc": ""
      },
      {
        "name": "BenchmarkValidStringTenJapaneseChars",
        "desc": ""
      },
      {
        "name": "BenchmarkValidTenASCIIChars",
        "desc": ""
      },
      {
        "name": "BenchmarkValidTenJapaneseChars",
        "desc": ""
      },
      {
        "name": "ExampleAppendRune",
        "desc": ""
      },
      {
        "name": "ExampleDecodeLastRune",
        "desc": ""
      },
      {
        "name": "ExampleDecodeLastRuneInString",
        "desc": ""
      },
      {
        "name": "ExampleDecodeRune",
        "desc": ""
      },
      {
        "name": "ExampleDecodeRuneInString",
        "desc": ""
      },
      {
        "name": "ExampleEncodeRune",
        "desc": ""
      },
      {
        "name": "ExampleEncodeRune_outOfRange",
        "desc": ""
      },
      {
        "name": "ExampleFullRune",
        "desc": ""
      },
      {
        "name": "ExampleFullRuneInString",
        "desc": ""
      },
      {
        "name": "ExampleRuneCount",
        "desc": ""
      },
      {
        "name": "ExampleRuneCountInString",
        "desc": ""
      },
      {
        "name": "ExampleRuneLen",
        "desc": ""
      },
      {
        "name": "ExampleRuneStart",
        "desc": ""
      },
      {
        "name": "ExampleValid",
        "desc": ""
      },
      {
        "name": "ExampleValidRune",
        "desc": ""
      },
      {
        "name": "ExampleValidString",
        "desc": ""
      },
      {
        "name": "TestAppendRune",
        "desc": ""
      },
      {
        "name": "TestConstants",
        "desc": "Validate the constants redefined from unicode."
      },
      {
        "name": "TestDecodeInvalidSequence",
        "desc": ""
      },
      {
        "name": "TestDecodeRune",
        "desc": ""
      },
      {
        "name": "TestDecodeSurrogateRune",
        "desc": ""
      },
      {
        "name": "TestEncodeRune",
        "desc": ""
      },
      {
        "name": "TestFullRune",
        "desc": ""
      },
      {
        "name": "TestNegativeRune",
        "desc": "Check that negative runes encode as U+FFFD."
      },
      {
        "name": "TestRuneCount",
        "desc": ""
      },
      {
        "name": "TestRuneCountNonASCIIAllocation",
        "desc": ""
      },
      {
        "name": "TestRuneLen",
        "desc": ""
      },
      {
        "name": "TestRuntimeConversion",
        "desc": "Check that a range loop, len([]rune(string)) optimization and []rune conversions visit the same runes. Not really a test of this package, but the assumption is used here and it's good to verify."
      },
      {
        "name": "TestSequencing",
        "desc": "Check that DecodeRune and DecodeLastRune correspond to the equivalent range loop."
      },
      {
        "name": "TestValid",
        "desc": ""
      },
      {
        "name": "TestValidRune",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "runtimeDecodeRune",
        "desc": ""
      },
      {
        "name": "runtimeRuneCount",
        "desc": ""
      },
      {
        "name": "testSequence",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "RuneCountTest",
        "desc": ""
      },
      {
        "name": "RuneLenTest",
        "desc": ""
      },
      {
        "name": "Utf8Map",
        "desc": ""
      },
      {
        "name": "ValidRuneTest",
        "desc": ""
      },
      {
        "name": "ValidTest",
        "desc": ""
      }
    ]
  },
  {
    "name": "unique",
    "desc": "The unique package provides facilities for canonicalizing (\"interning\") comparable values.",
    "functions": [
      {
        "name": "BenchmarkMake",
        "desc": ""
      },
      {
        "name": "BenchmarkMakeMany",
        "desc": ""
      },
      {
        "name": "BenchmarkMakeManyMany",
        "desc": ""
      },
      {
        "name": "TestCanonMap",
        "desc": ""
      },
      {
        "name": "TestCanonMapBadHash",
        "desc": ""
      },
      {
        "name": "TestCanonMapTruncHash",
        "desc": ""
      },
      {
        "name": "TestHandle",
        "desc": ""
      },
      {
        "name": "TestHandleUnsafeString",
        "desc": ""
      },
      {
        "name": "TestMakeAllocs",
        "desc": ""
      },
      {
        "name": "TestMakeCloneSeq",
        "desc": ""
      },
      {
        "name": "TestMakeClonesStrings",
        "desc": ""
      },
      {
        "name": "TestNestedHandle",
        "desc": ""
      },
      {
        "name": "benchmarkMake",
        "desc": ""
      },
      {
        "name": "buildArrayCloneSeq",
        "desc": "buildArrayCloneSeq populates a cloneSeq for an abi.Type that has Kind abi.Array."
      },
      {
        "name": "buildStructCloneSeq",
        "desc": "buildStructCloneSeq populates a cloneSeq for an abi.Type that has Kind abi.Struct."
      },
      {
        "name": "checkMapsFor",
        "desc": ""
      },
      {
        "name": "clone",
        "desc": "clone makes a copy of value, and may update string values found in value with a cloned version of those strings. The purpose of explicitly cloning strings is to avoid accidentally giving a large string a long lifetime.  Note that this will clone strings in structs and arrays found in value, and will clone value if it itself is a string. It will not, however, clone strings if value is of interface or slice type (that is, found via an indirection)."
      },
      {
        "name": "drainCleanupQueue",
        "desc": ""
      },
      {
        "name": "drainMaps",
        "desc": "drainMaps ensures that the internal maps are drained."
      },
      {
        "name": "expectMissing",
        "desc": ""
      },
      {
        "name": "expectPresent",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "newHeapBytes",
        "desc": ""
      },
      {
        "name": "newHeapString",
        "desc": ""
      },
      {
        "name": "runtime_blockUntilEmptyCleanupQueue",
        "desc": "Implemented in runtime.  Used only by tests."
      },
      {
        "name": "runtime_rand",
        "desc": "Pull in runtime.rand so that we don't need to take a dependency on math/rand/v2."
      },
      {
        "name": "testCanonMap",
        "desc": ""
      },
      {
        "name": "testCloneSeq",
        "desc": ""
      },
      {
        "name": "testHandle",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": "Value returns a shallow copy of the T value that produced the Handle. Value is safe for concurrent use by multiple goroutines."
      },
      {
        "name": "Load",
        "desc": ""
      },
      {
        "name": "LoadOrStore",
        "desc": ""
      },
      {
        "name": "cleanup",
        "desc": "cleanup deletes the entry corresponding to wp in the canon map, if it's still in the map. wp must have a Value method that returns nil by the time this function is called. hash must be the hash of the value that wp once pointed to (that is, the hash of *wp.Value())."
      },
      {
        "name": "expand",
        "desc": "expand takes oldEntry and newEntry whose hashes conflict from bit 64 down to hashShift and produces a subtree of indirect nodes to hold the two new entries. newHash is the hash of the value in the new entry."
      },
      {
        "name": "entry",
        "desc": ""
      },
      {
        "name": "hasWeakPointer",
        "desc": "hasWeakPointer returns true if the provided weak pointer can be found in the overflow chain."
      },
      {
        "name": "indirect",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": "lookup finds the entry in the overflow chain that has the provided key.  Returns the key's canonical pointer and the weak pointer for that canonical pointer."
      },
      {
        "name": "prune",
        "desc": "prune removes all entries in the overflow chain whose keys are nil.  The caller must hold the lock on e's parent node."
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "entry",
        "desc": ""
      },
      {
        "name": "indirect",
        "desc": ""
      },
      {
        "name": "entry",
        "desc": ""
      },
      {
        "name": "indirect",
        "desc": ""
      },
      {
        "name": "Load",
        "desc": ""
      },
      {
        "name": "LoadOrStore",
        "desc": ""
      },
      {
        "name": "cleanup",
        "desc": "cleanup deletes the entry corresponding to wp in the canon map, if it's still in the map. wp must have a Value method that returns nil by the time this function is called. hash must be the hash of the value that wp once pointed to (that is, the hash of *wp.Value())."
      },
      {
        "name": "expand",
        "desc": "expand takes oldEntry and newEntry whose hashes conflict from bit 64 down to hashShift and produces a subtree of indirect nodes to hold the two new entries. newHash is the hash of the value in the new entry."
      }
    ],
    "types": [
      {
        "name": "Handle",
        "desc": "Handle is a globally unique identity for some value of type T.  Two handles compare equal exactly if the two values used to create the handles would have also compared equal. The comparison of two handles is trivial and typically much more efficient than comparing the values used to create them."
      },
      {
        "name": "canonMap",
        "desc": "canonMap is a map of T -\u003e *T. The map controls the creation of a canonical *T, and elements of the map are automatically deleted when the canonical *T is no longer referenced."
      },
      {
        "name": "cloneSeq",
        "desc": "cloneSeq describes how to clone a value of a particular type."
      },
      {
        "name": "entry",
        "desc": "entry is a leaf node in the hash-trie."
      },
      {
        "name": "indirect",
        "desc": "indirect is an internal node in the hash-trie."
      },
      {
        "name": "node",
        "desc": "node is the header for a node. It's polymorphic and is actually either an entry or an indirect."
      },
      {
        "name": "testEface",
        "desc": ""
      },
      {
        "name": "testIntArray",
        "desc": ""
      },
      {
        "name": "testNestedHandle",
        "desc": ""
      },
      {
        "name": "testString",
        "desc": "Set up special types. Because the internal maps are sharded by type, this will ensure that we're not overlapping with other tests."
      },
      {
        "name": "testStringArray",
        "desc": ""
      },
      {
        "name": "testStringStruct",
        "desc": ""
      },
      {
        "name": "testStringStructArrayStruct",
        "desc": ""
      },
      {
        "name": "testStruct",
        "desc": ""
      },
      {
        "name": "testZeroSize",
        "desc": ""
      },
      {
        "name": "uniqueMap",
        "desc": ""
      }
    ]
  },
  {
    "name": "unsafe",
    "desc": "Package unsafe contains operations that step around the type safety of Go programs.  Packages that import unsafe may be non-portable and are not protected by the Go 1 compatibility guidelines.",
    "functions": [
      {
        "name": "Alignof",
        "desc": "Alignof takes an expression x of any type and returns the required alignment of a hypothetical variable v as if v was declared via var v = x. It is the largest value m such that the address of v is always zero mod m. It is the same as the value returned by [reflect.TypeOf](x).Align(). As a special case, if a variable s is of struct type and f is a field within that struct, then Alignof(s.f) will return the required alignment of a field of that type within a struct. This case is the same as the value returned by [reflect.TypeOf](s.f).FieldAlign(). The return value of Alignof is a Go constant if the type of the argument does not have variable size. (See the description of [Sizeof] for a definition of variable sized types.)"
      },
      {
        "name": "Offsetof",
        "desc": "Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. The return value of Offsetof is a Go constant if the type of the argument x does not have variable size. (See the description of [Sizeof] for a definition of variable sized types.)"
      },
      {
        "name": "Sizeof",
        "desc": "Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice; if x is an interface, Sizeof returns the size of the interface value itself, not the size of the value stored in the interface. For a struct, the size includes any padding introduced by field alignment. The return value of Sizeof is a Go constant if the type of the argument x does not have variable size. (A type has variable size if it is a type parameter or if it is an array or struct type with elements of variable size)."
      },
      {
        "name": "String",
        "desc": "String returns a string value whose underlying bytes start at ptr and whose length is len.  The len argument must be of integer type or an untyped constant. A constant len argument must be non-negative and representable by a value of type int; if it is an untyped constant it is given type int. At run time, if len is negative, or if ptr is nil and len is not zero, a run-time panic occurs.  Since Go strings are immutable, the bytes passed to String must not be modified as long as the returned string value exists."
      },
      {
        "name": "StringData",
        "desc": "StringData returns a pointer to the underlying bytes of str. For an empty string the return value is unspecified, and may be nil.  Since Go strings are immutable, the bytes returned by StringData must not be modified."
      }
    ],
    "types": [
      {
        "name": "ArbitraryType",
        "desc": "ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression."
      },
      {
        "name": "IntegerType",
        "desc": "IntegerType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents any arbitrary integer type."
      },
      {
        "name": "Pointer",
        "desc": "Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:   - A pointer value of any type can be converted to a Pointer.   - A Pointer can be converted to a pointer value of any type.   - A uintptr can be converted to a Pointer.   - A Pointer can be converted to a uintptr.  Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.  The following patterns involving Pointer are valid. Code not using these patterns is likely to be invalid today or to become invalid in the future. Even the valid patterns below come with important caveats.  Running \"go vet\" can help find uses of Pointer that do not conform to these patterns, but silence from \"go vet\" is not a guarantee that the code is valid.  (1) Conversion of a *T1 to Pointer to *T2.  Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type. An example is the implementation of math.Float64bits:  \tfunc Float64bits(f float64) uint64 { \t\treturn *(*uint64)(unsafe.Pointer(\u0026f)) \t}  (2) Conversion of a Pointer to a uintptr (but not back to Pointer).  Converting a Pointer to a uintptr produces the memory address of the value pointed at, as an integer. The usual use for such a uintptr is to print it.  Conversion of a uintptr back to Pointer is not valid in general.  A uintptr is an integer, not a reference. Converting a Pointer to a uintptr creates an integer value with no pointer semantics. Even if a uintptr holds the address of some object, the garbage collector will not update that uintptr's value if the object moves, nor will that uintptr keep the object from being reclaimed.  The remaining patterns enumerate the only valid conversions from uintptr to Pointer.  (3) Conversion of a Pointer to a uintptr and back, with arithmetic.  If p points into an allocated object, it can be advanced through the object by conversion to uintptr, addition of an offset, and conversion back to Pointer.  \tp = unsafe.Pointer(uintptr(p) + offset)  The most common use of this pattern is to access fields in a struct or elements of an array:  \t// equivalent to f := unsafe.Pointer(\u0026s.f) \tf := unsafe.Pointer(uintptr(unsafe.Pointer(\u0026s)) + unsafe.Offsetof(s.f))  \t// equivalent to e := unsafe.Pointer(\u0026x[i]) \te := unsafe.Pointer(uintptr(unsafe.Pointer(\u0026x[0])) + i*unsafe.Sizeof(x[0]))  It is valid both to add and to subtract offsets from a pointer in this way. It is also valid to use \u0026^ to round pointers, usually for alignment. In all cases, the result must continue to point into the original allocated object.  Unlike in C, it is not valid to advance a pointer just beyond the end of its original allocation:  \t// INVALID: end points outside allocated space. \tvar s thing \tend = unsafe.Pointer(uintptr(unsafe.Pointer(\u0026s)) + unsafe.Sizeof(s))  \t// INVALID: end points outside allocated space. \tb := make([]byte, n) \tend = unsafe.Pointer(uintptr(unsafe.Pointer(\u0026b[0])) + uintptr(n))  Note that both conversions must appear in the same expression, with only the intervening arithmetic between them:  \t// INVALID: uintptr cannot be stored in variable \t// before conversion back to Pointer. \tu := uintptr(p) \tp = unsafe.Pointer(u + offset)  Note that the pointer must point into an allocated object, so it may not be nil.  \t// INVALID: conversion of nil pointer \tu := unsafe.Pointer(nil) \tp := unsafe.Pointer(uintptr(u) + offset)  (4) Conversion of a Pointer to a uintptr when calling functions like [syscall.Syscall].  The Syscall functions in package syscall pass their uintptr arguments directly to the operating system, which then may, depending on the details of the call, reinterpret some of them as pointers. That is, the system call implementation is implicitly converting certain arguments back from uintptr to pointer.  If a pointer argument must be converted to uintptr for use as an argument, that conversion must appear in the call expression itself:  \tsyscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))  The compiler handles a Pointer converted to a uintptr in the argument list of a call to a function implemented in assembly by arranging that the referenced allocated object, if any, is retained and not moved until the call completes, even though from the types alone it would appear that the object is no longer needed during the call.  For the compiler to recognize this pattern, the conversion must appear in the argument list:  \t// INVALID: uintptr cannot be stored in variable \t// before implicit conversion back to Pointer during system call. \tu := uintptr(unsafe.Pointer(p)) \tsyscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))  (5) Conversion of the result of [reflect.Value.Pointer] or [reflect.Value.UnsafeAddr] from uintptr to Pointer.  Package reflect's Value methods named Pointer and UnsafeAddr return type uintptr instead of unsafe.Pointer to keep callers from changing the result to an arbitrary type without first importing \"unsafe\". However, this means that the result is fragile and must be converted to Pointer immediately after making the call, in the same expression:  \tp := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))  As in the cases above, it is invalid to store the result before the conversion:  \t// INVALID: uintptr cannot be stored in variable \t// before conversion back to Pointer. \tu := reflect.ValueOf(new(int)).Pointer() \tp := (*int)(unsafe.Pointer(u))  (6) Conversion of a [reflect.SliceHeader] or [reflect.StringHeader] Data field to or from Pointer.  As in the previous case, the reflect data structures SliceHeader and StringHeader declare the field Data as a uintptr to keep callers from changing the result to an arbitrary type without first importing \"unsafe\". However, this means that SliceHeader and StringHeader are only valid when interpreting the content of an actual slice or string value.  \tvar s string \thdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) // case 1 \thdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case) \thdr.Len = n  In this usage hdr.Data is really an alternate way to refer to the underlying pointer in the string header, not a uintptr variable itself.  In general, [reflect.SliceHeader] and [reflect.StringHeader] should be used only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices or strings, never as plain structs. A program should not declare or allocate variables of these struct types.  \t// INVALID: a directly-declared header will not hold Data as a reference. \tvar hdr reflect.StringHeader \thdr.Data = uintptr(unsafe.Pointer(p)) \thdr.Len = n \ts := *(*string)(unsafe.Pointer(\u0026hdr)) // p possibly already lost"
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/crypto/chacha20",
    "desc": "Package chacha20 implements the ChaCha20 and XChaCha20 encryption algorithms as specified in RFC 8439 and draft-irtf-cfrg-xchacha-01.",
    "functions": [
      {
        "name": "HChaCha20",
        "desc": "HChaCha20 uses the ChaCha20 core to generate a derived key from a 32 bytes key and a 16 bytes nonce. It returns an error if key or nonce have any other length. It is used as part of the XChaCha20 construction."
      },
      {
        "name": "addXor",
        "desc": "addXor reads a little endian uint32 from src, XORs it with (a + b) and places the result in little endian byte order in dst."
      },
      {
        "name": "chaCha20_ctr32_vsx",
        "desc": ""
      },
      {
        "name": "hChaCha20",
        "desc": ""
      },
      {
        "name": "quarterRound",
        "desc": "quarterRound is the core of ChaCha20. It shuffles the bits of 4 state words. It's executed 4 times for each of the 20 ChaCha20 rounds, operating on all 16 words each round, in columnar or diagonal groups of 4 at a time."
      },
      {
        "name": "xorKeyStreamVX",
        "desc": "xorKeyStreamVX is an assembly implementation of XORKeyStream. It must only be called when the vector facility is available. Implementation in asm_s390x.s."
      },
      {
        "name": "SetCounter",
        "desc": "SetCounter sets the Cipher counter. The next invocation of XORKeyStream will behave as if (64 * counter) bytes had been encrypted so far.  To prevent accidental counter reuse, SetCounter panics if counter is less than the current value.  Note that the execution time of XORKeyStream is not independent of the counter value."
      },
      {
        "name": "XORKeyStream",
        "desc": "XORKeyStream XORs each byte in the given slice with a byte from the cipher's key stream. Dst and src must overlap entirely or not at all.  If len(dst) \u003c len(src), XORKeyStream will panic. It is acceptable to pass a dst bigger than src, and in that case, XORKeyStream will only update dst[:len(src)] and will not touch the rest of dst.  Multiple calls to XORKeyStream behave as if the concatenation of the src buffers was passed in a single run. That is, Cipher maintains state and does not reset at each XORKeyStream call."
      },
      {
        "name": "xorKeyStreamBlocks",
        "desc": ""
      },
      {
        "name": "xorKeyStreamBlocksGeneric",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Cipher",
        "desc": "Cipher is a stateful instance of ChaCha20 or XChaCha20 using a particular key and nonce. A *Cipher implements the cipher.Stream interface."
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/crypto/chacha20poly1305",
    "desc": "Package chacha20poly1305 implements the ChaCha20-Poly1305 AEAD and its extended nonce variant XChaCha20-Poly1305, as specified in RFC 8439 and draft-irtf-cfrg-xchacha-01.",
    "functions": [
      {
        "name": "New",
        "desc": "New returns a ChaCha20-Poly1305 AEAD that uses the given 256-bit key."
      },
      {
        "name": "NewX",
        "desc": "NewX returns a XChaCha20-Poly1305 AEAD that uses the given 256-bit key.  XChaCha20-Poly1305 is a ChaCha20-Poly1305 variant that takes a longer nonce, suitable to be generated randomly without risk of collisions. It should be preferred when nonce uniqueness cannot be trivially ensured, or whenever nonces are randomly generated."
      },
      {
        "name": "chacha20Poly1305Open",
        "desc": ""
      },
      {
        "name": "chacha20Poly1305Seal",
        "desc": ""
      },
      {
        "name": "setupState",
        "desc": "setupState writes a ChaCha20 input matrix to state. See https://tools.ietf.org/html/rfc7539#section-2.3."
      },
      {
        "name": "sliceForAppend",
        "desc": "sliceForAppend takes a slice and a requested number of bytes. It returns a slice with the contents of the given slice followed by that many bytes and a second slice that aliases into it and contains only the extra bytes. If the original slice has sufficient capacity then no allocation is performed."
      },
      {
        "name": "writeUint64",
        "desc": ""
      },
      {
        "name": "writeWithPadding",
        "desc": ""
      },
      {
        "name": "NonceSize",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Overhead",
        "desc": ""
      },
      {
        "name": "Seal",
        "desc": ""
      },
      {
        "name": "open",
        "desc": ""
      },
      {
        "name": "openGeneric",
        "desc": ""
      },
      {
        "name": "seal",
        "desc": ""
      },
      {
        "name": "sealGeneric",
        "desc": ""
      },
      {
        "name": "NonceSize",
        "desc": ""
      },
      {
        "name": "Open",
        "desc": ""
      },
      {
        "name": "Overhead",
        "desc": ""
      },
      {
        "name": "Seal",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "chacha20poly1305",
        "desc": ""
      },
      {
        "name": "xchacha20poly1305",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/crypto/cryptobyte",
    "desc": "Package cryptobyte contains types that help with parsing and constructing length-prefixed, binary messages, including ASN.1 DER. (The asn1 subpackage contains useful ASN.1 constants.)  The String type is for parsing. It wraps a []byte slice and provides helper functions for consuming structures, value by value.  The Builder type is for constructing messages. It providers helper functions for appending values and also for appending length-prefixed submessages – without having to worry about calculating the length prefix ahead of time.  See the documentation and examples for the Builder and String types to get started.",
    "functions": [
      {
        "name": "asn1Signed",
        "desc": ""
      },
      {
        "name": "asn1Unsigned",
        "desc": ""
      },
      {
        "name": "checkASN1Integer",
        "desc": ""
      },
      {
        "name": "isValidOID",
        "desc": ""
      },
      {
        "name": "AddASN1",
        "desc": "AddASN1 appends an ASN.1 object. The object is prefixed with the given tag. Tags greater than 30 are not supported and result in an error (i.e. low-tag-number form only). The child builder passed to the BuilderContinuation can be used to build the content of the ASN.1 object."
      },
      {
        "name": "AddASN1BigInt",
        "desc": "AddASN1BigInt appends a DER-encoded ASN.1 INTEGER."
      },
      {
        "name": "AddASN1BitString",
        "desc": "AddASN1BitString appends a DER-encoded ASN.1 BIT STRING. This does not support BIT STRINGs that are not a whole number of bytes."
      },
      {
        "name": "AddASN1Boolean",
        "desc": ""
      },
      {
        "name": "AddASN1Enum",
        "desc": "AddASN1Enum appends a DER-encoded ASN.1 ENUMERATION."
      },
      {
        "name": "AddASN1GeneralizedTime",
        "desc": "AddASN1GeneralizedTime appends a DER-encoded ASN.1 GENERALIZEDTIME."
      },
      {
        "name": "AddASN1Int64",
        "desc": "AddASN1Int64 appends a DER-encoded ASN.1 INTEGER."
      },
      {
        "name": "AddASN1Int64WithTag",
        "desc": "AddASN1Int64WithTag appends a DER-encoded ASN.1 INTEGER with the given tag."
      },
      {
        "name": "AddASN1NULL",
        "desc": ""
      },
      {
        "name": "AddASN1ObjectIdentifier",
        "desc": ""
      },
      {
        "name": "AddASN1OctetString",
        "desc": "AddASN1OctetString appends a DER-encoded ASN.1 OCTET STRING."
      },
      {
        "name": "AddASN1UTCTime",
        "desc": "AddASN1UTCTime appends a DER-encoded ASN.1 UTCTime."
      },
      {
        "name": "AddASN1Uint64",
        "desc": "AddASN1Uint64 appends a DER-encoded ASN.1 INTEGER."
      },
      {
        "name": "AddBytes",
        "desc": "AddBytes appends a sequence of bytes to the byte string."
      },
      {
        "name": "AddUint16",
        "desc": "AddUint16 appends a big-endian, 16-bit value to the byte string."
      },
      {
        "name": "AddUint16LengthPrefixed",
        "desc": "AddUint16LengthPrefixed adds a big-endian, 16-bit length-prefixed byte sequence."
      },
      {
        "name": "AddUint24",
        "desc": "AddUint24 appends a big-endian, 24-bit value to the byte string. The highest byte of the 32-bit input value is silently truncated."
      },
      {
        "name": "AddUint24LengthPrefixed",
        "desc": "AddUint24LengthPrefixed adds a big-endian, 24-bit length-prefixed byte sequence."
      },
      {
        "name": "AddUint32",
        "desc": "AddUint32 appends a big-endian, 32-bit value to the byte string."
      },
      {
        "name": "AddUint32LengthPrefixed",
        "desc": "AddUint32LengthPrefixed adds a big-endian, 32-bit length-prefixed byte sequence."
      },
      {
        "name": "AddUint48",
        "desc": "AddUint48 appends a big-endian, 48-bit value to the byte string."
      },
      {
        "name": "AddUint64",
        "desc": "AddUint64 appends a big-endian, 64-bit value to the byte string."
      },
      {
        "name": "AddUint8",
        "desc": "AddUint8 appends an 8-bit value to the byte string."
      },
      {
        "name": "AddUint8LengthPrefixed",
        "desc": "AddUint8LengthPrefixed adds a 8-bit length-prefixed byte sequence."
      },
      {
        "name": "AddValue",
        "desc": "AddValue calls Marshal on v, passing a pointer to the builder to append to. If Marshal returns an error, it is set on the Builder so that subsequent appends don't have an effect."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns the bytes written by the builder or an error if one has occurred during building."
      },
      {
        "name": "BytesOrPanic",
        "desc": "BytesOrPanic returns the bytes written by the builder or panics if an error has occurred during building."
      },
      {
        "name": "MarshalASN1",
        "desc": "MarshalASN1 calls encoding_asn1.Marshal on its input and appends the result if successful or records an error if one occurred."
      },
      {
        "name": "SetError",
        "desc": "SetError sets the value to be returned as the error from Bytes. Writes performed after calling SetError are ignored."
      },
      {
        "name": "Unwrite",
        "desc": "Unwrite rolls back non-negative n bytes written directly to the Builder. An attempt by a child builder passed to a continuation to unwrite bytes from its parent will panic."
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "addASN1Signed",
        "desc": ""
      },
      {
        "name": "addBase128Int",
        "desc": ""
      },
      {
        "name": "addLengthPrefixed",
        "desc": ""
      },
      {
        "name": "callContinuation",
        "desc": ""
      },
      {
        "name": "flushChild",
        "desc": ""
      },
      {
        "name": "CopyBytes",
        "desc": "CopyBytes copies len(out) bytes into out and advances over them. It reports whether the copy operation was successful"
      },
      {
        "name": "Empty",
        "desc": "Empty reports whether the string does not contain any bytes."
      },
      {
        "name": "PeekASN1Tag",
        "desc": "PeekASN1Tag reports whether the next ASN.1 value on the string starts with the given tag."
      },
      {
        "name": "ReadASN1",
        "desc": "ReadASN1 reads the contents of a DER-encoded ASN.1 element (not including tag and length bytes) into out, and advances. The element must match the given tag. It reports whether the read was successful.  Tags greater than 30 are not supported (i.e. low-tag-number format only)."
      },
      {
        "name": "ReadASN1BitString",
        "desc": "ReadASN1BitString decodes an ASN.1 BIT STRING into out and advances. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1BitStringAsBytes",
        "desc": "ReadASN1BitStringAsBytes decodes an ASN.1 BIT STRING into out and advances. It is an error if the BIT STRING is not a whole number of bytes. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1Boolean",
        "desc": "ReadASN1Boolean decodes an ASN.1 BOOLEAN and converts it to a boolean representation into out and advances. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1Bytes",
        "desc": "ReadASN1Bytes reads the contents of a DER-encoded ASN.1 element (not including tag and length bytes) into out, and advances. The element must match the given tag. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1Element",
        "desc": "ReadASN1Element reads the contents of a DER-encoded ASN.1 element (including tag and length bytes) into out, and advances. The element must match the given tag. It reports whether the read was successful.  Tags greater than 30 are not supported (i.e. low-tag-number format only)."
      },
      {
        "name": "ReadASN1Enum",
        "desc": "ReadASN1Enum decodes an ASN.1 ENUMERATION into out and advances. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1GeneralizedTime",
        "desc": "ReadASN1GeneralizedTime decodes an ASN.1 GENERALIZEDTIME into out and advances. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1Int64WithTag",
        "desc": "ReadASN1Int64WithTag decodes an ASN.1 INTEGER with the given tag into out and advances. It reports whether the read was successful and resulted in a value that can be represented in an int64."
      },
      {
        "name": "ReadASN1Integer",
        "desc": "ReadASN1Integer decodes an ASN.1 INTEGER into out and advances. If out does not point to an integer, to a big.Int, or to a []byte it panics. Only positive and zero values can be decoded into []byte, and they are returned as big-endian binary values that share memory with s. Positive values will have no leading zeroes, and zero will be returned as a single zero byte. ReadASN1Integer reports whether the read was successful."
      },
      {
        "name": "ReadASN1ObjectIdentifier",
        "desc": "ReadASN1ObjectIdentifier decodes an ASN.1 OBJECT IDENTIFIER into out and advances. It reports whether the read was successful."
      },
      {
        "name": "ReadASN1UTCTime",
        "desc": "ReadASN1UTCTime decodes an ASN.1 UTCTime into out and advances. It reports whether the read was successful."
      },
      {
        "name": "ReadAnyASN1",
        "desc": "ReadAnyASN1 reads the contents of a DER-encoded ASN.1 element (not including tag and length bytes) into out, sets outTag to its tag, and advances. It reports whether the read was successful.  Tags greater than 30 are not supported (i.e. low-tag-number format only)."
      },
      {
        "name": "ReadAnyASN1Element",
        "desc": "ReadAnyASN1Element reads the contents of a DER-encoded ASN.1 element (including tag and length bytes) into out, sets outTag to is tag, and advances. It reports whether the read was successful.  Tags greater than 30 are not supported (i.e. low-tag-number format only)."
      },
      {
        "name": "ReadBytes",
        "desc": "ReadBytes reads n bytes into out and advances over them. It reports whether the read was successful."
      },
      {
        "name": "ReadOptionalASN1",
        "desc": "ReadOptionalASN1 attempts to read the contents of a DER-encoded ASN.1 element (not including tag and length bytes) tagged with the given tag into out. It stores whether an element with the tag was found in outPresent, unless outPresent is nil. It reports whether the read was successful."
      },
      {
        "name": "ReadOptionalASN1Boolean",
        "desc": "ReadOptionalASN1Boolean attempts to read an optional ASN.1 BOOLEAN explicitly tagged with tag into out and advances. If no element with a matching tag is present, it sets \"out\" to defaultValue instead. It reports whether the read was successful."
      },
      {
        "name": "ReadOptionalASN1Integer",
        "desc": "ReadOptionalASN1Integer attempts to read an optional ASN.1 INTEGER explicitly tagged with tag into out and advances. If no element with a matching tag is present, it writes defaultValue into out instead. Otherwise, it behaves like ReadASN1Integer."
      },
      {
        "name": "ReadOptionalASN1OctetString",
        "desc": "ReadOptionalASN1OctetString attempts to read an optional ASN.1 OCTET STRING explicitly tagged with tag into out and advances. If no element with a matching tag is present, it sets \"out\" to nil instead. It reports whether the read was successful."
      },
      {
        "name": "ReadUint16",
        "desc": "ReadUint16 decodes a big-endian, 16-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint16LengthPrefixed",
        "desc": "ReadUint16LengthPrefixed reads the content of a big-endian, 16-bit length-prefixed value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint24",
        "desc": "ReadUint24 decodes a big-endian, 24-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint24LengthPrefixed",
        "desc": "ReadUint24LengthPrefixed reads the content of a big-endian, 24-bit length-prefixed value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint32",
        "desc": "ReadUint32 decodes a big-endian, 32-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint48",
        "desc": "ReadUint48 decodes a big-endian, 48-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint64",
        "desc": "ReadUint64 decodes a big-endian, 64-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint8",
        "desc": "ReadUint8 decodes an 8-bit value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "ReadUint8LengthPrefixed",
        "desc": "ReadUint8LengthPrefixed reads the content of an 8-bit length-prefixed value into out and advances over it. It reports whether the read was successful."
      },
      {
        "name": "Skip",
        "desc": "Skip advances the String by n byte and reports whether it was successful."
      },
      {
        "name": "SkipASN1",
        "desc": "SkipASN1 reads and discards an ASN.1 element with the given tag. It reports whether the operation was successful."
      },
      {
        "name": "SkipOptionalASN1",
        "desc": "SkipOptionalASN1 advances s over an ASN.1 element with the given tag, or else leaves s unchanged. It reports whether the operation was successful."
      },
      {
        "name": "read",
        "desc": "read advances a String by n bytes and returns them. If less than n bytes remain, it returns nil."
      },
      {
        "name": "readASN1",
        "desc": ""
      },
      {
        "name": "readASN1BigInt",
        "desc": ""
      },
      {
        "name": "readASN1Bytes",
        "desc": ""
      },
      {
        "name": "readASN1Int64",
        "desc": ""
      },
      {
        "name": "readASN1Uint64",
        "desc": ""
      },
      {
        "name": "readBase128Int",
        "desc": ""
      },
      {
        "name": "readLengthPrefixed",
        "desc": ""
      },
      {
        "name": "readUnsigned",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "BuildError",
        "desc": "BuildError wraps an error. If a BuilderContinuation panics with this value, the panic will be recovered and the inner error will be returned from Builder.Bytes."
      },
      {
        "name": "Builder",
        "desc": "A Builder builds byte strings from fixed-length and length-prefixed values. Builders either allocate space as needed, or are ‘fixed’, which means that they write into a given buffer and produce an error if it's exhausted.  The zero value is a usable Builder that allocates space as needed.  Simple values are marshaled and appended to a Builder using methods on the Builder. Length-prefixed values are marshaled by providing a BuilderContinuation, which is a function that writes the inner contents of the value to a given Builder. See the documentation for BuilderContinuation for details."
      },
      {
        "name": "BuilderContinuation",
        "desc": "BuilderContinuation is a continuation-passing interface for building length-prefixed byte sequences. Builder methods for length-prefixed sequences (AddUint8LengthPrefixed etc) will invoke the BuilderContinuation supplied to them. The child builder passed to the continuation can be used to build the content of the length-prefixed sequence. For example:  \tparent := cryptobyte.NewBuilder() \tparent.AddUint8LengthPrefixed(func (child *Builder) { \t  child.AddUint8(42) \t  child.AddUint8LengthPrefixed(func (grandchild *Builder) { \t    grandchild.AddUint8(5) \t  }) \t})  It is an error to write more bytes to the child than allowed by the reserved length prefix. After the continuation returns, the child must be considered invalid, i.e. users must not store any copies or references of the child that outlive the continuation.  If the continuation panics with a value of type BuildError then the inner error will be returned as the error from Bytes. If the child panics otherwise then Bytes will repanic with the same value."
      },
      {
        "name": "MarshalingValue",
        "desc": "A MarshalingValue marshals itself into a Builder."
      },
      {
        "name": "String",
        "desc": "String represents a string of bytes. It provides methods for parsing fixed-length and length-prefixed values from it."
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/crypto/cryptobyte/asn1",
    "desc": "Package asn1 contains supporting types for parsing and building ASN.1 messages with the cryptobyte package.",
    "functions": [
      {
        "name": "Constructed",
        "desc": "Constructed returns t with the constructed class bit set."
      },
      {
        "name": "ContextSpecific",
        "desc": "ContextSpecific returns t with the context-specific class bit set."
      }
    ],
    "types": [
      {
        "name": "Tag",
        "desc": "Tag represents an ASN.1 identifier octet, consisting of a tag number (indicating a type) and class (such as context-specific or constructed).  Methods in the cryptobyte package only support the low-tag-number form, i.e. a single identifier octet with bits 7-8 encoding the class and bits 1-6 encoding the tag number."
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/net/dns/dnsmessage",
    "desc": "Package dnsmessage provides a mostly RFC 1035 compliant implementation of DNS message packing and unpacking.  The package also supports messages with Extension Mechanisms for DNS (EDNS(0)) as defined in RFC 6891.  This implementation is designed to minimize heap allocations and avoid unnecessary packing and unpacking as much as possible.",
    "functions": [
      {
        "name": "packBytes",
        "desc": "packBytes appends the wire format of field to msg."
      },
      {
        "name": "packClass",
        "desc": "packClass appends the wire format of field to msg."
      },
      {
        "name": "packText",
        "desc": "packText appends the wire format of field to msg."
      },
      {
        "name": "packType",
        "desc": "packType appends the wire format of field to msg."
      },
      {
        "name": "packUint16",
        "desc": "packUint16 appends the wire format of field to msg."
      },
      {
        "name": "packUint32",
        "desc": "packUint32 appends the wire format of field to msg."
      },
      {
        "name": "printBool",
        "desc": ""
      },
      {
        "name": "printByteSlice",
        "desc": ""
      },
      {
        "name": "printPaddedUint8",
        "desc": ""
      },
      {
        "name": "printString",
        "desc": ""
      },
      {
        "name": "printUint16",
        "desc": ""
      },
      {
        "name": "printUint32",
        "desc": ""
      },
      {
        "name": "printUint8Bytes",
        "desc": ""
      },
      {
        "name": "skipClass",
        "desc": ""
      },
      {
        "name": "skipName",
        "desc": ""
      },
      {
        "name": "skipResource",
        "desc": ""
      },
      {
        "name": "skipType",
        "desc": ""
      },
      {
        "name": "skipUint16",
        "desc": ""
      },
      {
        "name": "skipUint32",
        "desc": ""
      },
      {
        "name": "unpackBytes",
        "desc": ""
      },
      {
        "name": "unpackText",
        "desc": ""
      },
      {
        "name": "unpackUint16",
        "desc": ""
      },
      {
        "name": "unpackUint32",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the AAAAResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the AResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "AAAAResource",
        "desc": "AAAAResource adds a single AAAAResource."
      },
      {
        "name": "AResource",
        "desc": "AResource adds a single AResource."
      },
      {
        "name": "CNAMEResource",
        "desc": "CNAMEResource adds a single CNAMEResource."
      },
      {
        "name": "EnableCompression",
        "desc": "EnableCompression enables compression in the Builder.  Leaving compression disabled avoids compression related allocations, but can result in larger message sizes. Be careful with this mode as it can cause messages to exceed the UDP size limit.  According to RFC 1035, section 4.1.4, the use of compression is optional, but all implementations must accept both compressed and uncompressed DNS messages.  Compression should be enabled before any sections are added for best results."
      },
      {
        "name": "Finish",
        "desc": "Finish ends message building and generates a binary message."
      },
      {
        "name": "MXResource",
        "desc": "MXResource adds a single MXResource."
      },
      {
        "name": "NSResource",
        "desc": "NSResource adds a single NSResource."
      },
      {
        "name": "OPTResource",
        "desc": "OPTResource adds a single OPTResource."
      },
      {
        "name": "PTRResource",
        "desc": "PTRResource adds a single PTRResource."
      },
      {
        "name": "Question",
        "desc": "Question adds a single Question."
      },
      {
        "name": "SOAResource",
        "desc": "SOAResource adds a single SOAResource."
      },
      {
        "name": "SRVResource",
        "desc": "SRVResource adds a single SRVResource."
      },
      {
        "name": "StartAdditionals",
        "desc": "StartAdditionals prepares the builder for packing Additionals."
      },
      {
        "name": "StartAnswers",
        "desc": "StartAnswers prepares the builder for packing Answers."
      },
      {
        "name": "StartAuthorities",
        "desc": "StartAuthorities prepares the builder for packing Authorities."
      },
      {
        "name": "StartQuestions",
        "desc": "StartQuestions prepares the builder for packing Questions."
      },
      {
        "name": "TXTResource",
        "desc": "TXTResource adds a single TXTResource."
      },
      {
        "name": "UnknownResource",
        "desc": "UnknownResource adds a single UnknownResource."
      },
      {
        "name": "checkResourceSection",
        "desc": ""
      },
      {
        "name": "incrementSectionCount",
        "desc": ""
      },
      {
        "name": "startCheck",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the CNAMEResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "String",
        "desc": "String implements fmt.Stringer.String."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the MXResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "AppendPack",
        "desc": "AppendPack is like Pack but appends the full Message to b and returns the extended buffer."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "Pack",
        "desc": "Pack packs a full Message."
      },
      {
        "name": "Unpack",
        "desc": "Unpack parses a full Message."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the NSResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "String",
        "desc": "String implements fmt.Stringer.String.  Note: characters inside the labels are not escaped in any way."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the Name to msg.  Domain names are a sequence of counted strings split at the dots. They end with a zero-length string. Compression can be used to reuse domain suffixes.  The compression map will be updated with new domain suffixes. If compression is nil, compression will not be used."
      },
      {
        "name": "unpack",
        "desc": "unpack unpacks a domain name."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": ""
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the PTRResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "AAAAResource",
        "desc": "AAAAResource parses a single AAAAResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "AResource",
        "desc": "AResource parses a single AResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "Additional",
        "desc": "Additional parses a single Additional Resource."
      },
      {
        "name": "AdditionalHeader",
        "desc": "AdditionalHeader parses a single Additional ResourceHeader."
      },
      {
        "name": "AllAdditionals",
        "desc": "AllAdditionals parses all Additional Resources."
      },
      {
        "name": "AllAnswers",
        "desc": "AllAnswers parses all Answer Resources."
      },
      {
        "name": "AllAuthorities",
        "desc": "AllAuthorities parses all Authority Resources."
      },
      {
        "name": "AllQuestions",
        "desc": "AllQuestions parses all Questions."
      },
      {
        "name": "Answer",
        "desc": "Answer parses a single Answer Resource."
      },
      {
        "name": "AnswerHeader",
        "desc": "AnswerHeader parses a single Answer ResourceHeader."
      },
      {
        "name": "Authority",
        "desc": "Authority parses a single Authority Resource."
      },
      {
        "name": "AuthorityHeader",
        "desc": "AuthorityHeader parses a single Authority ResourceHeader."
      },
      {
        "name": "CNAMEResource",
        "desc": "CNAMEResource parses a single CNAMEResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "MXResource",
        "desc": "MXResource parses a single MXResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "NSResource",
        "desc": "NSResource parses a single NSResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "OPTResource",
        "desc": "OPTResource parses a single OPTResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "PTRResource",
        "desc": "PTRResource parses a single PTRResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "Question",
        "desc": "Question parses a single Question."
      },
      {
        "name": "SOAResource",
        "desc": "SOAResource parses a single SOAResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "SRVResource",
        "desc": "SRVResource parses a single SRVResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "SkipAdditional",
        "desc": "SkipAdditional skips a single Additional Resource.  It does not perform a complete validation of the resource header, which means it may return a nil error when the [AdditionalHeader] would actually return an error."
      },
      {
        "name": "SkipAllAdditionals",
        "desc": "SkipAllAdditionals skips all Additional Resources."
      },
      {
        "name": "SkipAllAnswers",
        "desc": "SkipAllAnswers skips all Answer Resources."
      },
      {
        "name": "SkipAllAuthorities",
        "desc": "SkipAllAuthorities skips all Authority Resources."
      },
      {
        "name": "SkipAllQuestions",
        "desc": "SkipAllQuestions skips all Questions."
      },
      {
        "name": "SkipAnswer",
        "desc": "SkipAnswer skips a single Answer Resource.  It does not perform a complete validation of the resource header, which means it may return a nil error when the [AnswerHeader] would actually return an error."
      },
      {
        "name": "SkipAuthority",
        "desc": "SkipAuthority skips a single Authority Resource.  It does not perform a complete validation of the resource header, which means it may return a nil error when the [AuthorityHeader] would actually return an error."
      },
      {
        "name": "SkipQuestion",
        "desc": "SkipQuestion skips a single Question."
      },
      {
        "name": "Start",
        "desc": "Start parses the header and enables the parsing of Questions."
      },
      {
        "name": "TXTResource",
        "desc": "TXTResource parses a single TXTResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "UnknownResource",
        "desc": "UnknownResource parses a single UnknownResource.  One of the XXXHeader methods must have been called before calling this method."
      },
      {
        "name": "checkAdvance",
        "desc": ""
      },
      {
        "name": "resource",
        "desc": ""
      },
      {
        "name": "resourceHeader",
        "desc": ""
      },
      {
        "name": "skipResource",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the Question to msg."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "String",
        "desc": "String implements fmt.Stringer.String."
      },
      {
        "name": "GoString",
        "desc": ""
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the Resource to msg."
      },
      {
        "name": "DNSSECAllowed",
        "desc": "DNSSECAllowed reports whether the DNSSEC OK bit is set."
      },
      {
        "name": "ExtendedRCode",
        "desc": "ExtendedRCode returns an extended RCode.  The provided rcode must be the RCode in DNS message header."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "SetEDNS0",
        "desc": "SetEDNS0 configures h for EDNS(0).  The provided extRCode must be an extended RCode."
      },
      {
        "name": "fixLen",
        "desc": "fixLen updates a packed ResourceHeader to include the length of the ResourceBody.  lenOff is the offset of the ResourceHeader.Length field in msg.  preLen is the length that msg was before the ResourceBody was packed."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the ResourceHeader to oldMsg.  lenOff is the offset in msg where the Length field was packed."
      },
      {
        "name": "unpack",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the SOAResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the SRVResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the TXTResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "String",
        "desc": "String implements fmt.Stringer.String."
      },
      {
        "name": "GoString",
        "desc": "GoString implements fmt.GoStringer.GoString."
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the UnknownResource to msg."
      },
      {
        "name": "realType",
        "desc": ""
      },
      {
        "name": "count",
        "desc": ""
      },
      {
        "name": "header",
        "desc": ""
      },
      {
        "name": "pack",
        "desc": "pack appends the wire format of the header to msg."
      },
      {
        "name": "unpack",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": "nestedError implements error.Error."
      }
    ],
    "types": [
      {
        "name": "AAAAResource",
        "desc": "An AAAAResource is an AAAA Resource record."
      },
      {
        "name": "AResource",
        "desc": "An AResource is an A Resource record."
      },
      {
        "name": "Builder",
        "desc": "A Builder allows incrementally packing a DNS message.  Example usage:  \tbuf := make([]byte, 2, 514) \tb := NewBuilder(buf, Header{...}) \tb.EnableCompression() \t// Optionally start a section and add things to that section. \t// Repeat adding sections as necessary. \tbuf, err := b.Finish() \t// If err is nil, buf[2:] will contain the built bytes."
      },
      {
        "name": "CNAMEResource",
        "desc": "A CNAMEResource is a CNAME Resource record."
      },
      {
        "name": "Class",
        "desc": "A Class is a type of network."
      },
      {
        "name": "Header",
        "desc": "Header is a representation of a DNS message header."
      },
      {
        "name": "MXResource",
        "desc": "An MXResource is an MX Resource record."
      },
      {
        "name": "Message",
        "desc": "Message is a representation of a DNS message."
      },
      {
        "name": "NSResource",
        "desc": "An NSResource is an NS Resource record."
      },
      {
        "name": "Name",
        "desc": "A Name is a non-encoded and non-escaped domain name. It is used instead of strings to avoid allocations."
      },
      {
        "name": "OPTResource",
        "desc": "An OPTResource is an OPT pseudo Resource record.  The pseudo resource record is part of the extension mechanisms for DNS as defined in RFC 6891."
      },
      {
        "name": "OpCode",
        "desc": "An OpCode is a DNS operation code."
      },
      {
        "name": "Option",
        "desc": "An Option represents a DNS message option within OPTResource.  The message option is part of the extension mechanisms for DNS as defined in RFC 6891."
      },
      {
        "name": "PTRResource",
        "desc": "A PTRResource is a PTR Resource record."
      },
      {
        "name": "Parser",
        "desc": "A Parser allows incrementally parsing a DNS message.  When parsing is started, the Header is parsed. Next, each Question can be either parsed or skipped. Alternatively, all Questions can be skipped at once. When all Questions have been parsed, attempting to parse Questions will return the [ErrSectionDone] error. After all Questions have been either parsed or skipped, all Answers, Authorities and Additionals can be either parsed or skipped in the same way, and each type of Resource must be fully parsed or skipped before proceeding to the next type of Resource.  Parser is safe to copy to preserve the parsing state.  Note that there is no requirement to fully skip or parse the message."
      },
      {
        "name": "Question",
        "desc": "A Question is a DNS query."
      },
      {
        "name": "RCode",
        "desc": "An RCode is a DNS response status code."
      },
      {
        "name": "Resource",
        "desc": "A Resource is a DNS resource record."
      },
      {
        "name": "ResourceBody",
        "desc": "A ResourceBody is a DNS resource record minus the header."
      },
      {
        "name": "ResourceHeader",
        "desc": "A ResourceHeader is the header of a DNS resource record. There are many types of DNS resource records, but they all share the same header."
      },
      {
        "name": "SOAResource",
        "desc": "An SOAResource is an SOA Resource record."
      },
      {
        "name": "SRVResource",
        "desc": "An SRVResource is an SRV Resource record."
      },
      {
        "name": "TXTResource",
        "desc": "A TXTResource is a TXT Resource record."
      },
      {
        "name": "Type",
        "desc": "A Type is a type of DNS request and response."
      },
      {
        "name": "UnknownResource",
        "desc": "An UnknownResource is a catch-all container for unknown record types."
      },
      {
        "name": "header",
        "desc": "header is the wire format for a DNS message header."
      },
      {
        "name": "nestedError",
        "desc": ""
      },
      {
        "name": "section",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/net/http/httpguts",
    "desc": "Package httpguts provides functions implementing various details of the HTTP specification.  This package is shared by the standard library (which vendors it) and x/net/http2. It comes with no API stability promise.",
    "functions": [
      {
        "name": "HeaderValuesContainsToken",
        "desc": "HeaderValuesContainsToken reports whether any string in values contains the provided token, ASCII case-insensitively."
      },
      {
        "name": "IsTokenRune",
        "desc": ""
      },
      {
        "name": "PunycodeHostPort",
        "desc": "PunycodeHostPort returns the IDNA Punycode version of the provided \"host\" or \"host:port\" string."
      },
      {
        "name": "ValidHeaderFieldName",
        "desc": "ValidHeaderFieldName reports whether v is a valid HTTP/1.x header name. HTTP/2 imposes the additional restriction that uppercase ASCII letters are not allowed.  RFC 7230 says:  \theader-field   = field-name \":\" OWS field-value OWS \tfield-name     = token \ttoken          = 1*tchar \ttchar = \"!\" / \"#\" / \"$\" / \"%\" / \"\u0026\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \t        \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA"
      },
      {
        "name": "ValidHeaderFieldValue",
        "desc": "ValidHeaderFieldValue reports whether v is a valid \"field-value\" according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :  \tmessage-header = field-name \":\" [ field-value ] \tfield-value    = *( field-content | LWS ) \tfield-content  = \u003cthe OCTETs making up the field-value \t                 and consisting of either *TEXT or combinations \t                 of token, separators, and quoted-string\u003e  http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :  \tTEXT           = \u003cany OCTET except CTLs, \t                  but including LWS\u003e \tLWS            = [CRLF] 1*( SP | HT ) \tCTL            = \u003cany US-ASCII control character \t                 (octets 0 - 31) and DEL (127)\u003e  RFC 7230 says:  \tfield-value    = *( field-content / obs-fold ) \tobj-fold       =  N/A to http2, and deprecated \tfield-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ] \tfield-vchar    = VCHAR / obs-text \tobs-text       = %x80-FF \tVCHAR          = \"any visible [USASCII] character\"  http2 further says: \"Similarly, HTTP/2 allows header field values that are not valid. While most of the values that can be encoded will not alter header field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII 0x0) might be exploited by an attacker if they are translated verbatim. Any request or response that contains a character not permitted in a header field value MUST be treated as malformed (Section 8.1.2.6). Valid characters are defined by the field-content ABNF rule in Section 3.2 of [RFC7230].\"  This function does not (yet?) properly handle the rejection of strings that begin or end with SP or HTAB."
      },
      {
        "name": "ValidHostHeader",
        "desc": "ValidHostHeader reports whether h is a valid host header."
      },
      {
        "name": "ValidTrailerHeader",
        "desc": "ValidTrailerHeader reports whether name is a valid header field name to appear in trailers. See RFC 7230, Section 4.1.2"
      },
      {
        "name": "headerValueContainsToken",
        "desc": "headerValueContainsToken reports whether v (assumed to be a 0#element, in the ABNF extension described in RFC 7230 section 7) contains token amongst its comma-separated tokens, ASCII case-insensitively."
      },
      {
        "name": "isASCII",
        "desc": ""
      },
      {
        "name": "isCTL",
        "desc": "isCTL reports whether b is a control byte, according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2  \tCTL            = \u003cany US-ASCII control character \t                 (octets 0 - 31) and DEL (127)\u003e"
      },
      {
        "name": "isLWS",
        "desc": "isLWS reports whether b is linear white space, according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2  \tLWS            = [CRLF] 1*( SP | HT )"
      },
      {
        "name": "isOWS",
        "desc": "isOWS reports whether b is an optional whitespace byte, as defined by RFC 7230 section 3.2.3."
      },
      {
        "name": "lowerASCII",
        "desc": "lowerASCII returns the ASCII lowercase version of b."
      },
      {
        "name": "tokenEqual",
        "desc": "tokenEqual reports whether t1 and t2 are equal, ASCII case-insensitively."
      },
      {
        "name": "trimOWS",
        "desc": "trimOWS returns x with all optional whitespace removes from the beginning and end."
      }
    ],
    "types": null
  },
  {
    "name": "vendor/golang.org/x/net/http/httpproxy",
    "desc": "Package httpproxy provides support for HTTP proxy determination based on environment variables, as provided by net/http's ProxyFromEnvironment function.  The API is not subject to the Go 1 compatibility promise and may change at any time.",
    "functions": [
      {
        "name": "canonicalAddr",
        "desc": "canonicalAddr returns url.Host but always with a \":port\" suffix"
      },
      {
        "name": "getEnvAny",
        "desc": ""
      },
      {
        "name": "hasPort",
        "desc": "Given a string of the form \"host\", \"host:port\", or \"[ipv6::address]:port\", return true if the string includes a port."
      },
      {
        "name": "idnaASCII",
        "desc": ""
      },
      {
        "name": "isASCII",
        "desc": ""
      },
      {
        "name": "parseProxy",
        "desc": ""
      },
      {
        "name": "ProxyFunc",
        "desc": "ProxyFunc returns a function that determines the proxy URL to use for a given request URL. Changing the contents of cfg will not affect proxy functions created earlier.  A nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY.  As a special case, if req.URL.Host is \"localhost\" or a loopback address (with or without a port number), then a nil URL and nil error will be returned."
      },
      {
        "name": "match",
        "desc": ""
      },
      {
        "name": "match",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "proxyForURL",
        "desc": ""
      },
      {
        "name": "useProxy",
        "desc": "useProxy reports whether requests to addr should use a proxy, according to the NO_PROXY or no_proxy environment variable. addr is always a canonicalAddr with a host and port."
      },
      {
        "name": "match",
        "desc": ""
      },
      {
        "name": "match",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Config",
        "desc": "Config holds configuration for HTTP proxy settings. See FromEnvironment for details."
      },
      {
        "name": "allMatch",
        "desc": "allMatch matches on all possible inputs"
      },
      {
        "name": "cidrMatch",
        "desc": ""
      },
      {
        "name": "config",
        "desc": "config holds the parsed configuration for HTTP proxy settings."
      },
      {
        "name": "domainMatch",
        "desc": ""
      },
      {
        "name": "ipMatch",
        "desc": ""
      },
      {
        "name": "matcher",
        "desc": "matcher represents the matching rule for a given value in the NO_PROXY list"
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/net/http2/hpack",
    "desc": "Package hpack implements HPACK, a compression format for efficiently representing HTTP header fields in the context of HTTP/2.  See http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09",
    "functions": [
      {
        "name": "AppendHuffmanString",
        "desc": "AppendHuffmanString appends s, as encoded in Huffman codes, to dst and returns the extended buffer."
      },
      {
        "name": "HuffmanDecode",
        "desc": "HuffmanDecode decodes the string in v and writes the expanded result to w, returning the number of bytes written to w and the Write call's return value. At most one Write call is made."
      },
      {
        "name": "HuffmanDecodeToString",
        "desc": "HuffmanDecodeToString decodes the string in v."
      },
      {
        "name": "HuffmanEncodeLength",
        "desc": "HuffmanEncodeLength returns the number of bytes required to encode s in Huffman codes. The result is round up to byte boundary."
      },
      {
        "name": "appendHpackString",
        "desc": "appendHpackString appends s, as encoded in \"String Literal\" representation, to dst and returns the extended buffer.  s will be encoded in Huffman codes only when it produces strictly shorter byte string."
      },
      {
        "name": "appendIndexed",
        "desc": "appendIndexed appends index i, as encoded in \"Indexed Header Field\" representation, to dst and returns the extended buffer."
      },
      {
        "name": "appendIndexedName",
        "desc": "appendIndexedName appends f and index i referring indexed name entry, as encoded in one of \"Literal Header field - Indexed Name\" representation variants, to dst and returns the extended buffer.  If f.Sensitive is true, \"Never Indexed\" representation is used. If f.Sensitive is false and indexing is true, \"Incremental Indexing\" representation is used."
      },
      {
        "name": "appendNewName",
        "desc": "appendNewName appends f, as encoded in one of \"Literal Header field - New Name\" representation variants, to dst and returns the extended buffer.  If f.Sensitive is true, \"Never Indexed\" representation is used. If f.Sensitive is false and indexing is true, \"Incremental Indexing\" representation is used."
      },
      {
        "name": "appendTableSize",
        "desc": "appendTableSize appends v, as encoded in \"Header Table Size Update\" representation, to dst and returns the extended buffer."
      },
      {
        "name": "appendVarInt",
        "desc": "appendVarInt appends i, as encoded in variable integer form using n bit prefix, to dst and returns the extended buffer.  See https://httpwg.org/specs/rfc7541.html#integer.representation"
      },
      {
        "name": "buildRootHuffmanNode",
        "desc": ""
      },
      {
        "name": "encodeTypeByte",
        "desc": "encodeTypeByte returns type byte. If sensitive is true, type byte for \"Never Indexed\" representation is returned. If sensitive is false and indexing is true, type byte for \"Incremental Indexing\" representation is returned. Otherwise, type byte for \"Without Indexing\" is returned."
      },
      {
        "name": "huffmanDecode",
        "desc": "huffmanDecode decodes v to buf. If maxLen is greater than 0, attempts to write more to buf than maxLen bytes will return ErrStringLength."
      },
      {
        "name": "readVarInt",
        "desc": "readVarInt reads an unsigned variable length integer off the beginning of p. n is the parameter as described in https://httpwg.org/specs/rfc7541.html#rfc.section.5.1.  n must always be between 1 and 8.  The returned remain buffer is either a smaller suffix of p, or err != nil. The error is errNeedMore if p doesn't contain a complete integer."
      },
      {
        "name": "Close",
        "desc": "Close declares that the decoding is complete and resets the Decoder to be reused again for a new header block. If there is any remaining data in the decoder's buffer, Close returns an error."
      },
      {
        "name": "DecodeFull",
        "desc": "DecodeFull decodes an entire block.  TODO: remove this method and make it incremental later? This is easier for debugging now."
      },
      {
        "name": "EmitEnabled",
        "desc": "EmitEnabled reports whether calls to the emitFunc provided to NewDecoder are currently enabled. The default is true."
      },
      {
        "name": "SetAllowedMaxDynamicTableSize",
        "desc": "SetAllowedMaxDynamicTableSize sets the upper bound that the encoded stream (via dynamic table size updates) may set the maximum size to."
      },
      {
        "name": "SetEmitEnabled",
        "desc": "SetEmitEnabled controls whether the emitFunc provided to NewDecoder should be called. The default is true.  This facility exists to let servers enforce MAX_HEADER_LIST_SIZE while still decoding and keeping in-sync with decoder state, but without doing unnecessary decompression or generating unnecessary garbage for header fields past the limit."
      },
      {
        "name": "SetEmitFunc",
        "desc": "SetEmitFunc changes the callback used when new header fields are decoded. It must be non-nil. It does not affect EmitEnabled."
      },
      {
        "name": "SetMaxDynamicTableSize",
        "desc": ""
      },
      {
        "name": "SetMaxStringLength",
        "desc": "SetMaxStringLength sets the maximum size of a HeaderField name or value string. If a string exceeds this length (even after any decompression), Write will return ErrStringLength. A value of 0 means unlimited and is the default from NewDecoder."
      },
      {
        "name": "Write",
        "desc": ""
      },
      {
        "name": "at",
        "desc": ""
      },
      {
        "name": "callEmit",
        "desc": ""
      },
      {
        "name": "decodeString",
        "desc": ""
      },
      {
        "name": "maxTableIndex",
        "desc": ""
      },
      {
        "name": "parseDynamicTableSizeUpdate",
        "desc": "(same invariants and behavior as parseHeaderFieldRepr)"
      },
      {
        "name": "parseFieldIndexed",
        "desc": "(same invariants and behavior as parseHeaderFieldRepr)"
      },
      {
        "name": "parseFieldLiteral",
        "desc": "(same invariants and behavior as parseHeaderFieldRepr)"
      },
      {
        "name": "parseHeaderFieldRepr",
        "desc": "returns errNeedMore if there isn't enough data available. any other error is fatal. consumes d.buf iff it returns nil. precondition: must be called with len(d.buf) \u003e 0"
      },
      {
        "name": "readString",
        "desc": "readString reads an hpack string from p.  It returns a reference to the encoded string data to permit deferring decode costs until after the caller verifies all data is present."
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "MaxDynamicTableSize",
        "desc": "MaxDynamicTableSize returns the current dynamic header table size."
      },
      {
        "name": "SetMaxDynamicTableSize",
        "desc": "SetMaxDynamicTableSize changes the dynamic header table size to v. The actual size is bounded by the value passed to SetMaxDynamicTableSizeLimit."
      },
      {
        "name": "SetMaxDynamicTableSizeLimit",
        "desc": "SetMaxDynamicTableSizeLimit changes the maximum value that can be specified in SetMaxDynamicTableSize to v. By default, it is set to 4096, which is the same size of the default dynamic header table size described in HPACK specification. If the current maximum dynamic header table size is strictly greater than v, \"Header Table Size Update\" will be done in the next WriteField call and the maximum dynamic header table size is truncated to v."
      },
      {
        "name": "WriteField",
        "desc": "WriteField encodes f into a single Write to e's underlying Writer. This function may also produce bytes for \"Header Table Size Update\" if necessary. If produced, it is done before encoding f."
      },
      {
        "name": "searchTable",
        "desc": "searchTable searches f in both stable and dynamic header tables. The static header table is searched first. Only when there is no exact match for both name and value, the dynamic header table is then searched. If there is no match, i is 0. If both name and value match, i is the matched index and nameValueMatch becomes true. If only name matches, i points to that index and nameValueMatch becomes false."
      },
      {
        "name": "shouldIndex",
        "desc": "shouldIndex reports whether f should be indexed."
      },
      {
        "name": "IsPseudo",
        "desc": "IsPseudo reports whether the header field is an http2 pseudo header. That is, it reports whether it starts with a colon. It is not otherwise guaranteed to be a valid pseudo header field, though."
      },
      {
        "name": "Size",
        "desc": "Size returns the size of an entry per RFC 7541 section 4.1."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "add",
        "desc": ""
      },
      {
        "name": "evict",
        "desc": "If we're too big, evict old stuff."
      },
      {
        "name": "setMaxSize",
        "desc": ""
      },
      {
        "name": "addEntry",
        "desc": "addEntry adds a new entry."
      },
      {
        "name": "evictOldest",
        "desc": "evictOldest evicts the n oldest entries in the table."
      },
      {
        "name": "idToIndex",
        "desc": "idToIndex converts a unique id to an HPACK index. See Section 2.3.3."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "len",
        "desc": "len reports the number of entries in the table."
      },
      {
        "name": "search",
        "desc": "search finds f in the table. If there is no match, i is 0. If both name and value match, i is the matched index and nameValueMatch becomes true. If only name matches, i points to that index and nameValueMatch becomes false.  The returned index is a 1-based HPACK index. For dynamic tables, HPACK says that index 1 should be the newest entry, but t.ents[0] is the oldest entry, meaning t.ents is reversed for dynamic tables. Hence, when t is a dynamic table, the return value i actually refers to the entry t.ents[t.len()-i].  All tables are assumed to be a dynamic tables except for the global staticTable.  See Section 2.3.3."
      },
      {
        "name": "indexed",
        "desc": ""
      },
      {
        "name": "sensitive",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Decoder",
        "desc": "A Decoder is the decoding context for incremental processing of header blocks."
      },
      {
        "name": "DecodingError",
        "desc": "A DecodingError is something the spec defines as a decoding error."
      },
      {
        "name": "Encoder",
        "desc": ""
      },
      {
        "name": "HeaderField",
        "desc": "A HeaderField is a name-value pair. Both the name and value are treated as opaque sequences of octets."
      },
      {
        "name": "InvalidIndexError",
        "desc": "An InvalidIndexError is returned when an encoder references a table entry before the static table or after the end of the dynamic table."
      },
      {
        "name": "dynamicTable",
        "desc": ""
      },
      {
        "name": "headerFieldTable",
        "desc": "headerFieldTable implements a list of HeaderFields. This is used to implement the static and dynamic tables."
      },
      {
        "name": "incomparable",
        "desc": "incomparable is a zero-width, non-comparable type. Adding it to a struct makes that struct also non-comparable, and generally doesn't add any size (as long as it's first)."
      },
      {
        "name": "indexType",
        "desc": ""
      },
      {
        "name": "node",
        "desc": ""
      },
      {
        "name": "pairNameValue",
        "desc": ""
      },
      {
        "name": "undecodedString",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/net/idna",
    "desc": "Package idna implements IDNA2008 using the compatibility processing defined by UTS (Unicode Technical Standard) #46, which defines a standard to deal with the transition from IDNA2003.  IDNA2008 (Internationalized Domain Names for Applications), is defined in RFC 5890, RFC 5891, RFC 5892, RFC 5893 and RFC 5894. UTS #46 is defined in https://www.unicode.org/reports/tr46. See https://unicode.org/cldr/utility/idna.jsp for a visualization of the differences between these two standards.  Package idna implements IDNA2008 using the compatibility processing defined by UTS (Unicode Technical Standard) #46, which defines a standard to deal with the transition from IDNA2003.  IDNA2008 (Internationalized Domain Names for Applications), is defined in RFC 5890, RFC 5891, RFC 5892, RFC 5893 and RFC 5894. UTS #46 is defined in https://www.unicode.org/reports/tr46. See https://unicode.org/cldr/utility/idna.jsp for a visualization of the differences between these two standards.",
    "functions": [
      {
        "name": "ToASCII",
        "desc": "ToASCII is a wrapper for Punycode.ToASCII."
      },
      {
        "name": "ToUnicode",
        "desc": "ToUnicode is a wrapper for Punycode.ToUnicode."
      },
      {
        "name": "adapt",
        "desc": "adapt is the bias adaptation function specified in section 6.1."
      },
      {
        "name": "apply",
        "desc": ""
      },
      {
        "name": "ascii",
        "desc": ""
      },
      {
        "name": "decode",
        "desc": "decode decodes a string as specified in section 6.2."
      },
      {
        "name": "decodeDigit",
        "desc": ""
      },
      {
        "name": "encode",
        "desc": "encode encodes a string as specified in section 6.3 and prepends prefix to the result.  The \"while h \u003c length(input)\" line in the specification becomes \"for remaining != 0\" in the Go code, because len(s) in Go is in bytes, not runes."
      },
      {
        "name": "encodeDigit",
        "desc": ""
      },
      {
        "name": "madd",
        "desc": "madd computes a + (b * c), detecting overflow."
      },
      {
        "name": "normalize",
        "desc": ""
      },
      {
        "name": "punyError",
        "desc": ""
      },
      {
        "name": "validateAndMap",
        "desc": ""
      },
      {
        "name": "validateFromPunycode",
        "desc": ""
      },
      {
        "name": "validateRegistration",
        "desc": ""
      },
      {
        "name": "String",
        "desc": "String reports a string with a description of the profile for debugging purposes. The string format may change with different versions."
      },
      {
        "name": "ToASCII",
        "desc": "ToASCII converts a domain or domain label to its ASCII form. For example, ToASCII(\"bücher.example.com\") is \"xn--bcher-kva.example.com\", and ToASCII(\"golang\") is \"golang\". If an error is encountered it will return an error and a (partially) processed result."
      },
      {
        "name": "ToUnicode",
        "desc": "ToUnicode converts a domain or domain label to its Unicode form. For example, ToUnicode(\"xn--bcher-kva.example.com\") is \"bücher.example.com\", and ToUnicode(\"golang\") is \"golang\". If an error is encountered it will return an error and a (partially) processed result."
      },
      {
        "name": "process",
        "desc": "process implements the algorithm described in section 4 of UTS #46, see https://www.unicode.org/reports/tr46."
      },
      {
        "name": "simplify",
        "desc": ""
      },
      {
        "name": "validateLabel",
        "desc": "validateLabel validates the criteria from Section 4.1. Item 1, 4, and 6 are already implicitly satisfied by the overall implementation."
      },
      {
        "name": "lookup",
        "desc": "lookup returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupString",
        "desc": "lookupString returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupStringUnsafe",
        "desc": "lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupUnsafe",
        "desc": "lookupUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupValue",
        "desc": "lookupValue determines the type of block n and looks up the value for b."
      },
      {
        "name": "appendMapping",
        "desc": "appendMapping appends the mapping for the respective rune. isMapped must be true. A mapping is a categorization of a rune as defined in UTS #46."
      },
      {
        "name": "category",
        "desc": ""
      },
      {
        "name": "isBidi",
        "desc": ""
      },
      {
        "name": "isMapped",
        "desc": ""
      },
      {
        "name": "isModifier",
        "desc": ""
      },
      {
        "name": "isViramaModifier",
        "desc": ""
      },
      {
        "name": "joinType",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "code",
        "desc": ""
      },
      {
        "name": "done",
        "desc": ""
      },
      {
        "name": "label",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "next sets the value to the next label. It skips the last label if it is empty."
      },
      {
        "name": "reset",
        "desc": ""
      },
      {
        "name": "result",
        "desc": ""
      },
      {
        "name": "set",
        "desc": ""
      },
      {
        "name": "Error",
        "desc": ""
      },
      {
        "name": "code",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": "lookup determines the type of block n and looks up the value for b. For n \u003c t.cutoff, the block is a simple lookup table. Otherwise, the block is a list of ranges with an accompanying value. Given a matching range r, the value for b is by r.value + (b - r.lo) * stride."
      }
    ],
    "types": [
      {
        "name": "Option",
        "desc": "An Option configures a Profile at creation time."
      },
      {
        "name": "Profile",
        "desc": "A Profile defines the configuration of a IDNA mapper."
      },
      {
        "name": "category",
        "desc": "A category corresponds to a category defined in the IDNA mapping table."
      },
      {
        "name": "idnaTrie",
        "desc": "idnaTrie. Total size: 28600 bytes (27.93 KiB). Checksum: 95575047b5d8fff."
      },
      {
        "name": "info",
        "desc": "info holds information from the IDNA mapping table for a single rune. It is the value returned by a trie lookup. In most cases, all information fits in a 16-bit value. For mappings, this value may contain an index into a slice with the mapped string. Such mappings can consist of the actual mapped value or an XOR pattern to be applied to the bytes of the UTF8 encoding of the input rune. This technique is used by the cases packages and reduces the table size significantly.  The per-rune values have the following format:  \tif mapped { \t  if inlinedXOR { \t    15..13 inline XOR marker \t    12..11 unused \t    10..3  inline XOR mask \t  } else { \t    15..3  index into xor or mapping table \t  } \t} else { \t    15..14 unused \t    13     mayNeedNorm \t    12..11 attributes \t    10..8  joining type \t     7..3  category type \t} \t   2  use xor pattern \t1..0  mapped category  See the definitions below for a more detailed description of the various bits."
      },
      {
        "name": "joinState",
        "desc": ""
      },
      {
        "name": "labelError",
        "desc": ""
      },
      {
        "name": "labelIter",
        "desc": "A labelIter allows iterating over domain name labels."
      },
      {
        "name": "options",
        "desc": ""
      },
      {
        "name": "runeError",
        "desc": ""
      },
      {
        "name": "sparseBlocks",
        "desc": ""
      },
      {
        "name": "valueRange",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/net/lif",
    "desc": "Package lif provides basic functions for the manipulation of logical network interfaces and interface addresses on Solaris.  The package supports Solaris 11 or above.",
    "functions": [
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "ioctl",
        "desc": ""
      },
      {
        "name": "isDupLink",
        "desc": ""
      },
      {
        "name": "parseLinkAddr",
        "desc": ""
      },
      {
        "name": "sysvicall6",
        "desc": ""
      },
      {
        "name": "Family",
        "desc": "Family implements the Family method of Addr interface."
      },
      {
        "name": "Family",
        "desc": "Family implements the Family method of Addr interface."
      },
      {
        "name": "fetch",
        "desc": ""
      },
      {
        "name": "PutUint16",
        "desc": ""
      },
      {
        "name": "PutUint32",
        "desc": ""
      },
      {
        "name": "PutUint64",
        "desc": ""
      },
      {
        "name": "Uint16",
        "desc": ""
      },
      {
        "name": "Uint32",
        "desc": ""
      },
      {
        "name": "Uint64",
        "desc": ""
      },
      {
        "name": "PutUint16",
        "desc": ""
      },
      {
        "name": "PutUint32",
        "desc": ""
      },
      {
        "name": "PutUint64",
        "desc": ""
      },
      {
        "name": "Uint16",
        "desc": ""
      },
      {
        "name": "Uint32",
        "desc": ""
      },
      {
        "name": "Uint64",
        "desc": ""
      },
      {
        "name": "close",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "Addr",
        "desc": "An Addr represents an address associated with packet routing."
      },
      {
        "name": "Inet4Addr",
        "desc": "An Inet4Addr represents an internet address for IPv4."
      },
      {
        "name": "Inet6Addr",
        "desc": "An Inet6Addr represents an internet address for IPv6."
      },
      {
        "name": "Link",
        "desc": "A Link represents logical data link information.  It also represents base information for logical network interface. On Solaris, each logical network interface represents network layer adjacency information and the interface has a only single network address or address pair for tunneling. It's usual that multiple logical network interfaces share the same logical data link."
      },
      {
        "name": "binaryBigEndian",
        "desc": ""
      },
      {
        "name": "binaryByteOrder",
        "desc": ""
      },
      {
        "name": "binaryLittleEndian",
        "desc": ""
      },
      {
        "name": "endpoint",
        "desc": ""
      },
      {
        "name": "lifIfinfoReq",
        "desc": ""
      },
      {
        "name": "lifconf",
        "desc": ""
      },
      {
        "name": "lifnum",
        "desc": ""
      },
      {
        "name": "lifreq",
        "desc": ""
      },
      {
        "name": "sockaddrStorage",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/net/nettest",
    "desc": "Package nettest provides utilities for network testing.",
    "functions": [
      {
        "name": "LocalPath",
        "desc": "LocalPath returns a local path that can be used for Unix-domain protocol testing."
      },
      {
        "name": "LoopbackInterface",
        "desc": "LoopbackInterface returns an available logical network interface for loopback test."
      },
      {
        "name": "MulticastSource",
        "desc": "MulticastSource returns a unicast IP address on ifi when ifi is an IP multicast-capable network interface.  The provided network must be \"ip\", \"ip4\" or \"ip6\"."
      },
      {
        "name": "NewLocalListener",
        "desc": "NewLocalListener returns a listener which listens to a loopback IP address or local file system path.  The provided network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\"."
      },
      {
        "name": "NewLocalPacketListener",
        "desc": "NewLocalPacketListener returns a packet listener which listens to a loopback IP address or local file system path.  The provided network must be \"udp\", \"udp4\", \"udp6\" or \"unixgram\"."
      },
      {
        "name": "RoutedInterface",
        "desc": "RoutedInterface returns a network interface that can route IP traffic and satisfies flags.  The provided network must be \"ip\", \"ip4\" or \"ip6\"."
      },
      {
        "name": "SupportsIPv4",
        "desc": "SupportsIPv4 reports whether the platform supports IPv4 networking functionality."
      },
      {
        "name": "SupportsIPv6",
        "desc": "SupportsIPv6 reports whether the platform supports IPv6 networking functionality."
      },
      {
        "name": "SupportsRawSocket",
        "desc": "SupportsRawSocket reports whether the current session is available to use raw sockets."
      },
      {
        "name": "TestConn",
        "desc": "TestConn tests that a net.Conn implementation properly satisfies the interface. The tests should not produce any false positives, but may experience false negatives. Thus, some issues may only be detected when the test is run multiple times. For maximal effectiveness, run the tests under the race detector."
      },
      {
        "name": "TestableAddress",
        "desc": "TestableAddress reports whether address of network is testable on the current platform configuration."
      },
      {
        "name": "TestableNetwork",
        "desc": "TestableNetwork reports whether network is testable on the current platform configuration.  See func Dial of the standard library for the supported networks."
      },
      {
        "name": "checkForTimeoutError",
        "desc": "checkForTimeoutError checks that the error satisfies the Error interface and that Timeout returns true."
      },
      {
        "name": "chunkedCopy",
        "desc": "chunkedCopy copies from r to w in fixed-width chunks to avoid causing a Write that exceeds the maximum packet size for packet-based connections like \"unixpacket\". We assume that the maximum packet size is at least 1024."
      },
      {
        "name": "hasRoutableIP",
        "desc": ""
      },
      {
        "name": "probeStack",
        "desc": ""
      },
      {
        "name": "resyncConn",
        "desc": "resyncConn resynchronizes the connection into a sane state. It assumes that everything written into c is echoed back to itself. It assumes that 0xff is not currently on the wire or in the read buffer."
      },
      {
        "name": "routableIP",
        "desc": ""
      },
      {
        "name": "supportsRawSocket",
        "desc": ""
      },
      {
        "name": "testBasicIO",
        "desc": "testBasicIO tests that the data sent on c1 is properly received on c2."
      },
      {
        "name": "testCloseTimeout",
        "desc": "testCloseTimeout tests that calling Close immediately times out pending Read and Write operations."
      },
      {
        "name": "testConcurrentMethods",
        "desc": "testConcurrentMethods tests that the methods of net.Conn can safely be called concurrently."
      },
      {
        "name": "testFutureTimeout",
        "desc": "testFutureTimeout tests that a future deadline will eventually time out Read and Write operations."
      },
      {
        "name": "testPastTimeout",
        "desc": "testPastTimeout tests that a deadline set in the past immediately times out Read and Write requests."
      },
      {
        "name": "testPingPong",
        "desc": "testPingPong tests that the two endpoints can synchronously send data to each other in a typical request-response pattern."
      },
      {
        "name": "testPresentTimeout",
        "desc": "testPresentTimeout tests that a past deadline set while there are pending Read and Write operations immediately times out those operations."
      },
      {
        "name": "testRacyRead",
        "desc": "testRacyRead tests that it is safe to mutate the input Read buffer immediately after cancelation has occurred."
      },
      {
        "name": "testRacyWrite",
        "desc": "testRacyWrite tests that it is safe to mutate the input Write buffer immediately after cancelation has occurred."
      },
      {
        "name": "testReadTimeout",
        "desc": "testReadTimeout tests that Read timeouts do not affect Write."
      },
      {
        "name": "testRoundtrip",
        "desc": "testRoundtrip writes something into c and reads it back. It assumes that everything written into c is echoed back to itself."
      },
      {
        "name": "testWriteTimeout",
        "desc": "testWriteTimeout tests that Write timeouts do not affect Read."
      },
      {
        "name": "timeoutWrapper",
        "desc": ""
      },
      {
        "name": "unixStrmDgramEnabled",
        "desc": ""
      }
    ],
    "types": [
      {
        "name": "MakePipe",
        "desc": "MakePipe creates a connection between two endpoints and returns the pair as c1 and c2, such that anything written to c1 is read by c2 and vice-versa. The stop function closes all resources, including c1, c2, and the underlying net.Listener (if there is one), and should not be nil."
      },
      {
        "name": "connTester",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/sys/cpu",
    "desc": "Package cpu implements processor feature detection for various CPU architectures.",
    "functions": [
      {
        "name": "archInit",
        "desc": ""
      },
      {
        "name": "bitIsSet",
        "desc": "bitIsSet reports whether the bit at index is set. The bit index is in big endian order, so bit index 0 is the leftmost bit."
      },
      {
        "name": "callgetsystemcfg",
        "desc": ""
      },
      {
        "name": "cfgIsSet",
        "desc": ""
      },
      {
        "name": "cpuid",
        "desc": "cpuid is implemented in cpu_gc_x86.s for gc compiler and in cpu_gccgo.c for gccgo."
      },
      {
        "name": "darwinKernelVersionCheck",
        "desc": "Ensure Darwin kernel version is at least major.minor.patch, avoiding dependencies"
      },
      {
        "name": "darwinOSRelease",
        "desc": "adapted from unix.Uname() at x/sys/unix/syscall_darwin.go L419"
      },
      {
        "name": "darwinSupportsAVX512",
        "desc": "darwinSupportsAVX512 checks Darwin kernel for AVX512 support via sysctl call (see issue 43089). It also restricts AVX512 support for Darwin to kernel version 21.3.0 (MacOS 12.2.0) or later (see issue 49233).  Background: Darwin implements a special mechanism to economize on thread state when AVX512 specific registers are not in use. This scheme minimizes state when preempting threads that haven't yet used any AVX512 instructions, but adds special requirements to check for AVX512 hardware support at runtime (e.g. via sysctl call or commpage inspection). See issue 43089 and link below for full background: https://github.com/apple-oss-distributions/xnu/blob/xnu-11215.1.10/osfmk/i386/fpu.c#L214-L240  Additionally, all versions of the Darwin kernel from 19.6.0 through 21.2.0 (corresponding to MacOS 10.15.6 - 12.1) have a bug that can cause corruption of the AVX512 mask registers (K0-K7) upon signal return. For this reason AVX512 is considered unsafe to use on Darwin for kernel versions prior to 21.3.0, where a fix has been confirmed. See issue 49233 for full background."
      },
      {
        "name": "darwinSysctlEnabled",
        "desc": "adapted from internal/cpu/cpu_arm64_darwin.go"
      },
      {
        "name": "doinit",
        "desc": ""
      },
      {
        "name": "extractBits",
        "desc": ""
      },
      {
        "name": "gccgoGetCpuidCount",
        "desc": ""
      },
      {
        "name": "gccgoGetsystemcfg",
        "desc": ""
      },
      {
        "name": "gccgoXgetbv",
        "desc": ""
      },
      {
        "name": "getAuxv",
        "desc": ""
      },
      {
        "name": "get_cpucfg",
        "desc": ""
      },
      {
        "name": "getisar0",
        "desc": ""
      },
      {
        "name": "getisar1",
        "desc": ""
      },
      {
        "name": "getpfr0",
        "desc": ""
      },
      {
        "name": "getsystemcfg",
        "desc": ""
      },
      {
        "name": "getzfr0",
        "desc": ""
      },
      {
        "name": "haveAsmFunctions",
        "desc": "haveAsmFunctions reports whether the other functions in this file can be safely called."
      },
      {
        "name": "hwcIsSet",
        "desc": ""
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initOptions",
        "desc": ""
      },
      {
        "name": "initS390Xbase",
        "desc": ""
      },
      {
        "name": "isSet",
        "desc": ""
      },
      {
        "name": "linuxKernelCanEmulateCPUID",
        "desc": "linuxKernelCanEmulateCPUID reports whether we're running on Linux 4.11+. Ideally we'd like to ask the question about whether the current kernel contains https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=77c97b4ee21290f5f083173d957843b615abbff2 but the version number will have to do."
      },
      {
        "name": "nametomib",
        "desc": ""
      },
      {
        "name": "parseARM64SVERegister",
        "desc": ""
      },
      {
        "name": "parseARM64SystemRegisters",
        "desc": ""
      },
      {
        "name": "parseRelease",
        "desc": "parseRelease parses a dot-separated version number. It follows the semver syntax, but allows the minor and patch versions to be elided.  This is a copy of the Go runtime's parseRelease from https://golang.org/cl/209597."
      },
      {
        "name": "processOptions",
        "desc": ""
      },
      {
        "name": "rawSyscall6",
        "desc": "Implemented in runtime/syscall_aix.go."
      },
      {
        "name": "readARM64Registers",
        "desc": ""
      },
      {
        "name": "readHWCAP",
        "desc": ""
      },
      {
        "name": "readLinuxProcCPUInfo",
        "desc": ""
      },
      {
        "name": "riscvHWProbe",
        "desc": "riscvHWProbe is a simplified version of the generated wrapper function found in golang.org/x/sys/unix/zsyscall_linux_riscv64.go. We simplify it by removing the cpuCount and cpus parameters which we do not need. We always want to pass 0 for these parameters here so the kernel only reports the extensions that are present on all cores."
      },
      {
        "name": "runtime_getAuxv",
        "desc": ""
      },
      {
        "name": "setMinimalFeatures",
        "desc": "setMinimalFeatures fakes the minimal ARM64 features expected by TestARM64minimalFeatures."
      },
      {
        "name": "syscall6",
        "desc": ""
      },
      {
        "name": "syscall_syscall6",
        "desc": "Implemented in the runtime package (runtime/sys_openbsd3.go)"
      },
      {
        "name": "sysctl",
        "desc": "from x/sys/unix/zsyscall_darwin_amd64.go L791-807"
      },
      {
        "name": "sysctlUint64",
        "desc": ""
      },
      {
        "name": "sysctlbyname",
        "desc": "adapted from runtime/sys_darwin.go in the pattern of sysctl() above, as defined in x/sys/unix"
      },
      {
        "name": "xgetbv",
        "desc": "xgetbv with ecx = 0 is implemented in cpu_gc_x86.s for gc compiler and in cpu_gccgo.c for gccgo."
      },
      {
        "name": "Uint32",
        "desc": ""
      },
      {
        "name": "Uint64",
        "desc": ""
      },
      {
        "name": "Has",
        "desc": "Has reports whether the given facilities are present."
      },
      {
        "name": "Uint32",
        "desc": ""
      },
      {
        "name": "Uint64",
        "desc": ""
      },
      {
        "name": "Has",
        "desc": "Has reports whether the given functions are present."
      }
    ],
    "types": [
      {
        "name": "CacheLinePad",
        "desc": "CacheLinePad is used to pad structs to avoid false sharing."
      },
      {
        "name": "Errno",
        "desc": ""
      },
      {
        "name": "_C_int",
        "desc": ""
      },
      {
        "name": "aarch64SysctlCPUID",
        "desc": "aarch64SysctlCPUID is struct aarch64_sysctl_cpu_id from NetBSD's \u003caarch64/armreg.h\u003e"
      },
      {
        "name": "bigEndian",
        "desc": ""
      },
      {
        "name": "byteOrder",
        "desc": "byteOrder is a subset of encoding/binary.ByteOrder."
      },
      {
        "name": "errno",
        "desc": ""
      },
      {
        "name": "facility",
        "desc": "facility is a bit index for the named facility."
      },
      {
        "name": "facilityList",
        "desc": "facilityList contains the result of an STFLE call. Bits are numbered in big endian order so the leftmost bit (the MSB) is at index 0."
      },
      {
        "name": "function",
        "desc": "function is the code for the named cryptographic function."
      },
      {
        "name": "littleEndian",
        "desc": ""
      },
      {
        "name": "option",
        "desc": "Option names should be lower case. e.g. avx instead of AVX."
      },
      {
        "name": "queryResult",
        "desc": "queryResult contains the result of a Query function call. Bits are numbered in big endian order so the leftmost bit (the MSB) is at index 0."
      },
      {
        "name": "riscvHWProbePairs",
        "desc": "riscvHWProbePairs is copied from golang.org/x/sys/unix/ztypes_linux_riscv64.go."
      },
      {
        "name": "syscallFunc",
        "desc": ""
      },
      {
        "name": "sysctlNode",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/text/secure/bidirule",
    "desc": "Package bidirule implements the Bidi Rule defined by RFC 5893.  This package is under development. The API may change without notice and without preserving backward compatibility.",
    "functions": [
      {
        "name": "Direction",
        "desc": "Direction reports the direction of the given label as defined by RFC 5893. The Bidi Rule does not have to be applied to labels of the category LeftToRight."
      },
      {
        "name": "DirectionString",
        "desc": "DirectionString reports the direction of the given label as defined by RFC 5893. The Bidi Rule does not have to be applied to labels of the category LeftToRight."
      },
      {
        "name": "Valid",
        "desc": "Valid reports whether b conforms to the BiDi rule."
      },
      {
        "name": "ValidString",
        "desc": "ValidString reports whether s conforms to the BiDi rule."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": "Reset implements transform.Transformer."
      },
      {
        "name": "Span",
        "desc": "Span returns the first n bytes of src that conform to the Bidi rule."
      },
      {
        "name": "Transform",
        "desc": "Transform implements transform.Transformer. This Transformer has state and needs to be reset between uses."
      },
      {
        "name": "advance",
        "desc": ""
      },
      {
        "name": "advanceString",
        "desc": ""
      },
      {
        "name": "isFinal",
        "desc": ""
      },
      {
        "name": "isRTL",
        "desc": "A rule can only be violated for \"Bidi Domain names\", meaning if one of the following categories has been observed."
      }
    ],
    "types": [
      {
        "name": "Transformer",
        "desc": "Transformer implements transform.Transform."
      },
      {
        "name": "ruleState",
        "desc": ""
      },
      {
        "name": "ruleTransition",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/text/transform",
    "desc": "Package transform provides reader and writer wrappers that transform the bytes passing through as well as various transformations. Example transformations provided by other packages include normalization and conversion between character sets.",
    "functions": [
      {
        "name": "Append",
        "desc": "Append appends the result of converting src[:n] using t to dst, where n \u003c= len(src), If err == nil, n will be len(src). It calls Reset on t."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns a new byte slice with the result of converting b[:n] using t, where n \u003c= len(b). If err == nil, n will be len(b). It calls Reset on t."
      },
      {
        "name": "String",
        "desc": "String returns a string with the result of converting s[:n] using t, where n \u003c= len(s). If err == nil, n will be len(s). It calls Reset on t."
      },
      {
        "name": "doAppend",
        "desc": ""
      },
      {
        "name": "grow",
        "desc": "grow returns a new []byte that is longer than b, and copies the first n bytes of b to the start of the new slice."
      },
      {
        "name": "Reset",
        "desc": "Reset implements the Reset method of the Transformer interface."
      },
      {
        "name": "Read",
        "desc": "Read implements the io.Reader interface."
      },
      {
        "name": "Close",
        "desc": "Close implements the io.Closer interface."
      },
      {
        "name": "Write",
        "desc": "Write implements the io.Writer interface. If there are not enough bytes available to complete a Transform, the bytes will be buffered for the next write. Call Close to convert the remaining bytes."
      },
      {
        "name": "Reset",
        "desc": "Reset resets the state of Chain. It calls Reset on all the Transformers."
      },
      {
        "name": "Transform",
        "desc": "Transform applies the transformers of c in sequence."
      },
      {
        "name": "fatalError",
        "desc": ""
      },
      {
        "name": "Transform",
        "desc": ""
      },
      {
        "name": "dst",
        "desc": ""
      },
      {
        "name": "src",
        "desc": ""
      },
      {
        "name": "Span",
        "desc": ""
      },
      {
        "name": "Transform",
        "desc": ""
      },
      {
        "name": "Reset",
        "desc": ""
      },
      {
        "name": "Transform",
        "desc": "Transform implements the Transformer interface."
      }
    ],
    "types": [
      {
        "name": "NopResetter",
        "desc": "NopResetter can be embedded by implementations of Transformer to add a nop Reset method."
      },
      {
        "name": "Reader",
        "desc": "Reader wraps another io.Reader by transforming the bytes read."
      },
      {
        "name": "SpanningTransformer",
        "desc": "SpanningTransformer extends the Transformer interface with a Span method that determines how much of the input already conforms to the Transformer."
      },
      {
        "name": "Transformer",
        "desc": "Transformer transforms bytes."
      },
      {
        "name": "Writer",
        "desc": "Writer wraps another io.Writer by transforming the bytes read. The user needs to call Close to flush unwritten bytes that may be buffered."
      },
      {
        "name": "chain",
        "desc": "chain is a sequence of links. A chain with N Transformers has N+1 links and N+1 buffers. Of those N+1 buffers, the first and last are the src and dst buffers given to chain.Transform and the middle N-1 buffers are intermediate buffers owned by the chain. The i'th link transforms bytes from the i'th buffer chain.link[i].b at read offset chain.link[i].p to the i+1'th buffer chain.link[i+1].b at write offset chain.link[i+1].n, for i in [0, N)."
      },
      {
        "name": "discard",
        "desc": ""
      },
      {
        "name": "link",
        "desc": ""
      },
      {
        "name": "nop",
        "desc": ""
      },
      {
        "name": "removeF",
        "desc": ""
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/text/unicode/bidi",
    "desc": "Package bidi contains functionality for bidirectional text support.  See https://www.unicode.org/reports/tr9.  NOTE: UNDER CONSTRUCTION. This API may change in backwards incompatible ways and without notice.",
    "functions": [
      {
        "name": "AppendReverse",
        "desc": "AppendReverse reverses the order of characters of in, appends them to out, and returns the result. Modifiers will still follow the runes they modify. Brackets are replaced with their counterparts."
      },
      {
        "name": "ReverseString",
        "desc": "ReverseString reverses the order of characters in s and returns a new string. Modifiers will still follow the runes they modify. Brackets are replaced with their counterparts."
      },
      {
        "name": "computeMultilineReordering",
        "desc": "Return multiline reordering array for a given level array. Reordering does not occur across a line break."
      },
      {
        "name": "computeReordering",
        "desc": "Return reordering array for a given level array. This reorders a single line. The reordering is a visual to logical map. For example, the leftmost char is string.charAt(order[0]). Rule L2."
      },
      {
        "name": "isRemovedByX9",
        "desc": "isRemovedByX9 reports whether the type is one of the types removed in X9."
      },
      {
        "name": "isWhitespace",
        "desc": "isWhitespace reports whether the type is considered a whitespace type for the line break rules."
      },
      {
        "name": "resolvePairedBrackets",
        "desc": "resolvePairedBrackets runs the paired bracket part of the UBA algorithm.  For each rune, it takes the indexes into the original string, the class the bracket type (in pairTypes) and the bracket identifier (pairValues). It also takes the direction type for the start-of-sentence and the embedding level.  The identifiers for bracket types are the rune of the canonicalized opening bracket for brackets (open or close) or 0 for runes that are not brackets."
      },
      {
        "name": "setLevels",
        "desc": ""
      },
      {
        "name": "setTypes",
        "desc": ""
      },
      {
        "name": "validateLineBreaks",
        "desc": ""
      },
      {
        "name": "validateParagraphEmbeddingLevel",
        "desc": ""
      },
      {
        "name": "validatePbTypes",
        "desc": ""
      },
      {
        "name": "validatePbValues",
        "desc": ""
      },
      {
        "name": "validateTypes",
        "desc": ""
      },
      {
        "name": "in",
        "desc": "in returns if x is equal to any of the values in set."
      },
      {
        "name": "Direction",
        "desc": "Direction reports the directionality of the runs.  The direction may be LeftToRight, RightToLeft, Mixed, or Neutral."
      },
      {
        "name": "NumRuns",
        "desc": "NumRuns returns the number of runs."
      },
      {
        "name": "Run",
        "desc": "Run returns the ith run within the ordering."
      },
      {
        "name": "Direction",
        "desc": "Direction returns the direction of the text of this paragraph.  The direction may be LeftToRight, RightToLeft, Mixed, or Neutral."
      },
      {
        "name": "IsLeftToRight",
        "desc": "IsLeftToRight reports whether the principle direction of rendering for this paragraphs is left-to-right. If this returns false, the principle direction of rendering is right-to-left."
      },
      {
        "name": "Line",
        "desc": "Line computes the visual ordering of runs for a single line starting and ending at the given positions in the original text."
      },
      {
        "name": "Order",
        "desc": "Order computes the visual ordering of all the runs in a Paragraph."
      },
      {
        "name": "RunAt",
        "desc": "RunAt reports the Run at the given position of the input text.  This method can be used for computing line breaks on paragraphs."
      },
      {
        "name": "SetBytes",
        "desc": "SetBytes configures p for the given paragraph text. It replaces text previously set by SetBytes or SetString. If b contains a paragraph separator it will only process the first paragraph and report the number of bytes consumed from b including this separator. Error may be non-nil if options are given."
      },
      {
        "name": "SetString",
        "desc": "SetString configures s for the given paragraph text. It replaces text previously set by SetBytes or SetString. If s contains a paragraph separator it will only process the first paragraph and report the number of bytes consumed from s including this separator. Error may be non-nil if options are given."
      },
      {
        "name": "prepareInput",
        "desc": "Initialize the p.pairTypes, p.pairValues and p.types from the input previously set by p.SetBytes() or p.SetString(). Also limit the input up to (and including) a paragraph separator (bidi class B).  The function p.Order() needs these values to be set, so this preparation could be postponed. But since the SetBytes and SetStrings functions return the length of the input up to the paragraph separator, the whole input needs to be processed anyway and should not be done twice.  The function has the same return values as SetBytes() / SetString()"
      },
      {
        "name": "Class",
        "desc": "Class returns the Bidi class for p."
      },
      {
        "name": "IsBracket",
        "desc": "IsBracket reports whether the rune is a bracket."
      },
      {
        "name": "IsOpeningBracket",
        "desc": "IsOpeningBracket reports whether the rune is an opening bracket. IsBracket must return true."
      },
      {
        "name": "reverseBracket",
        "desc": "TODO: find a better API and expose."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns the text of the run in its original order."
      },
      {
        "name": "Direction",
        "desc": "Direction reports the direction of the run."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the position of the Run within the text passed to SetBytes or SetString of the originating Paragraph value."
      },
      {
        "name": "String",
        "desc": "String returns the text of the run in its original order."
      },
      {
        "name": "lookup",
        "desc": "lookup returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupString",
        "desc": "lookupString returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupStringUnsafe",
        "desc": "lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupUnsafe",
        "desc": "lookupUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupValue",
        "desc": "lookupValue determines the type of block n and looks up the value for b."
      },
      {
        "name": "String",
        "desc": ""
      },
      {
        "name": "assignBracketType",
        "desc": "assignBracketType implements rule N0 for a single bracket pair."
      },
      {
        "name": "classBeforePair",
        "desc": "classBeforePair determines which strong types are present before a Bracket Pair. Return R or L if strong type found, otherwise ON."
      },
      {
        "name": "classifyPairContent",
        "desc": "classifyPairContent reports the strong types contained inside a Bracket Pair, assuming the given embedding direction.  It returns ON if no strong type is found. If a single strong type is found, it returns this type. Otherwise it returns the embedding direction.  TODO: use separate type for \"strong\" directionality."
      },
      {
        "name": "getStrongTypeN0",
        "desc": "getStrongTypeN0 maps character's directional code to strong type as required by rule N0.  TODO: have separate type for \"strong\" directionality."
      },
      {
        "name": "locateBrackets",
        "desc": "locateBrackets locates matching bracket pairs according to BD16.  This implementation uses a linked list instead of a stack, because, while elements are added at the front (like a push) they are not generally removed in atomic 'pop' operations, reducing the benefit of the stack archetype."
      },
      {
        "name": "matchOpener",
        "desc": "matchOpener reports whether characters at given positions form a matching bracket pair."
      },
      {
        "name": "resolveBrackets",
        "desc": "resolveBrackets implements rule N0 for a list of pairs."
      },
      {
        "name": "setBracketsToType",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "Less",
        "desc": ""
      },
      {
        "name": "Swap",
        "desc": ""
      },
      {
        "name": "depth",
        "desc": ""
      },
      {
        "name": "empty",
        "desc": ""
      },
      {
        "name": "lastDirectionalIsolateStatus",
        "desc": ""
      },
      {
        "name": "lastDirectionalOverrideStatus",
        "desc": ""
      },
      {
        "name": "lastEmbeddingLevel",
        "desc": ""
      },
      {
        "name": "pop",
        "desc": ""
      },
      {
        "name": "push",
        "desc": ""
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "applyLevelsAndTypes",
        "desc": "Applies the levels and types resolved in rules W1-I2 to the resultLevels array."
      },
      {
        "name": "assertOnly",
        "desc": "Algorithm validation. Assert that all values in types are in the provided set."
      },
      {
        "name": "findRunLimit",
        "desc": "Return the limit of the run consisting only of the types in validSet starting at index. This checks the value at index, and will return index if that value is not in validSet."
      },
      {
        "name": "resolveImplicitLevels",
        "desc": "7) resolving implicit embedding levels Rules I1, I2."
      },
      {
        "name": "resolveNeutralTypes",
        "desc": "6) resolving neutral types Rules N1-N2."
      },
      {
        "name": "resolveWeakTypes",
        "desc": "Resolving weak types Rules W1-W7.  Note that some weak types (EN, AN) remain after this processing is complete."
      },
      {
        "name": "Len",
        "desc": ""
      },
      {
        "name": "assignLevelsToCharactersRemovedByX9",
        "desc": "Assign level information to characters removed by rule X9. This is for ease of relating the level information to the original input data. Note that the levels assigned to these codes are arbitrary, they're chosen so as to avoid breaking level runs."
      },
      {
        "name": "determineExplicitEmbeddingLevels",
        "desc": "Determine explicit levels using rules X1 - X8"
      },
      {
        "name": "determineIsolatingRunSequences",
        "desc": "Definition BD13. Determine isolating run sequences."
      },
      {
        "name": "determineLevelRuns",
        "desc": "determineLevelRuns returns an array of level runs. Each level run is described as an array of indexes into the input string.  Determines the level runs. Rule X9 will be applied in determining the runs, in the way that makes sure the characters that are supposed to be removed are not included in the runs."
      },
      {
        "name": "determineMatchingIsolates",
        "desc": "determineMatchingIsolates determines the matching PDI for each isolate initiator and vice versa.  Definition BD9.  At the end of this function:    - The member variable matchingPDI is set to point to the index of the     matching PDI character for each isolate initiator character. If there is     no matching PDI, it is set to the length of the input text. For other     characters, it is set to -1.   - The member variable matchingIsolateInitiator is set to point to the     index of the matching isolate initiator character for each PDI character.     If there is no matching isolate initiator, or the character is not a PDI,     it is set to -1."
      },
      {
        "name": "determineParagraphEmbeddingLevel",
        "desc": "determineParagraphEmbeddingLevel reports the resolved paragraph direction of the substring limited by the given range [start, end).  Determines the paragraph level based on rules P2, P3. This is also used in rule X5c to find if an FSI should resolve to LRI or RLI."
      },
      {
        "name": "getLevels",
        "desc": "getLevels computes levels array breaking lines at offsets in linebreaks. Rule L1.  The linebreaks array must include at least one value. The values must be in strictly increasing order (no duplicates) between 1 and the length of the text, inclusive. The last value must be the length of the text."
      },
      {
        "name": "getReordering",
        "desc": "getReordering returns the reordering of lines from a visual index to a logical index for line breaks at the given offsets.  Lines are concatenated from left to right. So for example, the fifth character from the left on the third line is  \tgetReordering(linebreaks)[linebreaks[1] + 4]  (linebreaks[1] is the position after the last character of the second line, which is also the index of the first character on the third line, and adding four gets the fifth character from the left).  The linebreaks array must include at least one value. The values must be in strictly increasing order (no duplicates) between 1 and the length of the text, inclusive. The last value must be the length of the text."
      },
      {
        "name": "isolatingRunSequence",
        "desc": "Rule X10, second bullet: Determine the start-of-sequence (sos) and end-of-sequence (eos) types, either L or R, for each isolating run sequence."
      },
      {
        "name": "run",
        "desc": "The algorithm. Does not include line-based processing (Rules L1, L2). These are applied later in the line-based phase of the algorithm."
      }
    ],
    "types": [
      {
        "name": "Class",
        "desc": "Class is the Unicode BiDi class. Each rune has a single class."
      },
      {
        "name": "Direction",
        "desc": "A Direction indicates the overall flow of text."
      },
      {
        "name": "Option",
        "desc": "An Option is an option for Bidi processing."
      },
      {
        "name": "Ordering",
        "desc": "An Ordering holds the computed visual order of runs of a Paragraph. Calling SetBytes or SetString on the originating Paragraph invalidates an Ordering. The methods of an Ordering should only be called by one goroutine at a time."
      },
      {
        "name": "Paragraph",
        "desc": "A Paragraph holds a single Paragraph for Bidi processing."
      },
      {
        "name": "Properties",
        "desc": "Properties provides access to BiDi properties of runes."
      },
      {
        "name": "Run",
        "desc": "A Run is a continuous sequence of characters of a single direction."
      },
      {
        "name": "bidiTrie",
        "desc": "bidiTrie. Total size: 15744 bytes (15.38 KiB). Checksum: b4c3b70954803b86."
      },
      {
        "name": "bracketPair",
        "desc": "bracketPair holds a pair of index values for opening and closing bracket location of a bracket pair."
      },
      {
        "name": "bracketPairer",
        "desc": ""
      },
      {
        "name": "bracketPairs",
        "desc": "bracketPairs is a slice of bracketPairs with a sort.Interface implementation."
      },
      {
        "name": "bracketType",
        "desc": "Bidi_Paired_Bracket_Type BD14. An opening paired bracket is a character whose Bidi_Paired_Bracket_Type property value is Open.  BD15. A closing paired bracket is a character whose Bidi_Paired_Bracket_Type property value is Close."
      },
      {
        "name": "directionalStatusStack",
        "desc": "This stack will store the embedding levels and override and isolated statuses"
      },
      {
        "name": "isolatingRunSequence",
        "desc": ""
      },
      {
        "name": "level",
        "desc": "level is the embedding level of a character. Even embedding levels indicate left-to-right order and odd levels indicate right-to-left order. The special level of -1 is reserved for undefined order."
      },
      {
        "name": "options",
        "desc": ""
      },
      {
        "name": "paragraph",
        "desc": "A paragraph contains the state of a paragraph."
      }
    ]
  },
  {
    "name": "vendor/golang.org/x/text/unicode/norm",
    "desc": "Package norm contains types and functions for normalizing Unicode strings.",
    "functions": [
      {
        "name": "appendFlush",
        "desc": "appendFlush appends the normalized segment to rb.out."
      },
      {
        "name": "appendQuick",
        "desc": ""
      },
      {
        "name": "buildRecompMap",
        "desc": ""
      },
      {
        "name": "cmpNormalBytes",
        "desc": ""
      },
      {
        "name": "combine",
        "desc": "combine returns the combined rune or 0 if it doesn't exist.  The caller is responsible for calling recompMapOnce.Do(buildRecompMap) sometime before this is called."
      },
      {
        "name": "decomposeHangul",
        "desc": "decomposeHangul writes the decomposed Hangul to buf and returns the number of bytes written.  len(buf) should be at least 9."
      },
      {
        "name": "decomposeSegment",
        "desc": "decomposeSegment scans the first segment in src into rb. It inserts 0x034f (Grapheme Joiner) when it encounters a sequence of more than 30 non-starters and returns the number of bytes consumed from src or iShortDst or iShortSrc."
      },
      {
        "name": "decomposeToLastBoundary",
        "desc": "decomposeToLastBoundary finds an open segment at the end of the buffer and scans it into rb. Returns the buffer minus the last segment."
      },
      {
        "name": "doAppend",
        "desc": ""
      },
      {
        "name": "doAppendInner",
        "desc": ""
      },
      {
        "name": "doNormComposed",
        "desc": ""
      },
      {
        "name": "doNormDecomposed",
        "desc": ""
      },
      {
        "name": "flushTransform",
        "desc": ""
      },
      {
        "name": "isHangul",
        "desc": ""
      },
      {
        "name": "isHangulString",
        "desc": ""
      },
      {
        "name": "isHangulWithoutJamoT",
        "desc": ""
      },
      {
        "name": "isJamoVT",
        "desc": "Caller must ensure len(b) \u003e= 2."
      },
      {
        "name": "lastBoundary",
        "desc": ""
      },
      {
        "name": "nextASCIIBytes",
        "desc": ""
      },
      {
        "name": "nextASCIIString",
        "desc": ""
      },
      {
        "name": "nextCGJCompose",
        "desc": ""
      },
      {
        "name": "nextCGJDecompose",
        "desc": ""
      },
      {
        "name": "nextComposed",
        "desc": "nextComposed is the implementation of Next for forms NFC and NFKC."
      },
      {
        "name": "nextDecomposed",
        "desc": "nextDecomposed is the implementation of Next for forms NFD and NFKD."
      },
      {
        "name": "nextDone",
        "desc": ""
      },
      {
        "name": "nextHangul",
        "desc": ""
      },
      {
        "name": "nextMulti",
        "desc": "nextMulti is used for iterating over multi-segment decompositions for decomposing normal forms."
      },
      {
        "name": "nextMultiNorm",
        "desc": "nextMultiNorm is used for iterating over multi-segment decompositions for composing normal forms."
      },
      {
        "name": "patchTail",
        "desc": "patchTail fixes a case where a rune may be incorrectly normalized if it is followed by illegal continuation bytes. It returns the patched buffer and whether the decomposition is still in progress."
      },
      {
        "name": "Append",
        "desc": "Append returns f(append(out, b...)). The buffer out must be nil, empty, or equal to f(out)."
      },
      {
        "name": "AppendString",
        "desc": "AppendString returns f(append(out, []byte(s))). The buffer out must be nil, empty, or equal to f(out)."
      },
      {
        "name": "Bytes",
        "desc": "Bytes returns f(b). May return b if f(b) = b."
      },
      {
        "name": "FirstBoundary",
        "desc": "FirstBoundary returns the position i of the first boundary in b or -1 if b contains no boundary."
      },
      {
        "name": "FirstBoundaryInString",
        "desc": "FirstBoundaryInString returns the position i of the first boundary in s or -1 if s contains no boundary."
      },
      {
        "name": "IsNormal",
        "desc": "IsNormal returns true if b == f(b)."
      },
      {
        "name": "IsNormalString",
        "desc": "IsNormalString returns true if s == f(s)."
      },
      {
        "name": "LastBoundary",
        "desc": "LastBoundary returns the position i of the last boundary in b or -1 if b contains no boundary."
      },
      {
        "name": "NextBoundary",
        "desc": "NextBoundary reports the index of the boundary between the first and next segment in b or -1 if atEOF is false and there are not enough bytes to determine this boundary."
      },
      {
        "name": "NextBoundaryInString",
        "desc": "NextBoundaryInString reports the index of the boundary between the first and next segment in b or -1 if atEOF is false and there are not enough bytes to determine this boundary."
      },
      {
        "name": "Properties",
        "desc": "Properties returns properties for the first rune in s."
      },
      {
        "name": "PropertiesString",
        "desc": "PropertiesString returns properties for the first rune in s."
      },
      {
        "name": "QuickSpan",
        "desc": "QuickSpan returns a boundary n such that b[0:n] == f(b[0:n]). It is not guaranteed to return the largest such n."
      },
      {
        "name": "QuickSpanString",
        "desc": "QuickSpanString returns a boundary n such that s[0:n] == f(s[0:n]). It is not guaranteed to return the largest such n."
      },
      {
        "name": "Reader",
        "desc": "Reader returns a new reader that implements Read by reading data from r and returning f(data)."
      },
      {
        "name": "Reset",
        "desc": "Reset implements the Reset method of the transform.Transformer interface."
      },
      {
        "name": "Span",
        "desc": "Span implements transform.SpanningTransformer. It returns a boundary n such that b[0:n] == f(b[0:n]). It is not guaranteed to return the largest such n."
      },
      {
        "name": "SpanString",
        "desc": "SpanString returns a boundary n such that s[0:n] == f(s[0:n]). It is not guaranteed to return the largest such n."
      },
      {
        "name": "String",
        "desc": "String returns f(s)."
      },
      {
        "name": "Transform",
        "desc": "Transform implements the Transform method of the transform.Transformer interface. It may need to write segments of up to MaxSegmentSize at once. Users should either catch ErrShortDst and allow dst to grow or have dst be at least of size MaxTransformChunkSize to be guaranteed of progress."
      },
      {
        "name": "Writer",
        "desc": "Writer returns a new writer that implements Write(b) by writing f(b) to w. The returned writer may use an internal buffer to maintain state across Write calls. Calling its Close method writes any buffered data to w."
      },
      {
        "name": "doAppend",
        "desc": ""
      },
      {
        "name": "firstBoundary",
        "desc": ""
      },
      {
        "name": "nextBoundary",
        "desc": ""
      },
      {
        "name": "transform",
        "desc": "transform implements the transform.Transformer interface. It is only called when quickSpan does not pass for a given string."
      },
      {
        "name": "Done",
        "desc": "Done returns true if there is no more input to process."
      },
      {
        "name": "Init",
        "desc": "Init initializes i to iterate over src after normalizing it to Form f."
      },
      {
        "name": "InitString",
        "desc": "InitString initializes i to iterate over src after normalizing it to Form f."
      },
      {
        "name": "Next",
        "desc": "Next returns f(i.input[i.Pos():n]), where n is a boundary of i.input. For any input a and b for which f(a) == f(b), subsequent calls to Next will return the same segments. Modifying runes are grouped together with the preceding starter, if such a starter exists. Although not guaranteed, n will typically be the smallest possible n."
      },
      {
        "name": "Pos",
        "desc": "Pos returns the byte position at which the next call to Next will commence processing."
      },
      {
        "name": "Seek",
        "desc": "Seek sets the segment to be returned by the next call to Next to start at position p.  It is the responsibility of the caller to set p to the start of a segment."
      },
      {
        "name": "returnSlice",
        "desc": "returnSlice returns a slice of the underlying input type as a byte slice. If the underlying is of type []byte, it will simply return a slice. If the underlying is of type string, it will copy the slice to the buffer and return that."
      },
      {
        "name": "setDone",
        "desc": ""
      },
      {
        "name": "BoundaryAfter",
        "desc": "BoundaryAfter returns true if runes cannot combine with or otherwise interact with this or previous runes."
      },
      {
        "name": "BoundaryBefore",
        "desc": "BoundaryBefore returns true if this rune starts a new segment and cannot combine with any rune on the left."
      },
      {
        "name": "CCC",
        "desc": "CCC returns the canonical combining class of the underlying rune."
      },
      {
        "name": "Decomposition",
        "desc": "Decomposition returns the decomposition for the underlying rune or nil if there is none."
      },
      {
        "name": "LeadCCC",
        "desc": "LeadCCC returns the CCC of the first rune in the decomposition. If there is no decomposition, LeadCCC equals CCC."
      },
      {
        "name": "Size",
        "desc": "Size returns the length of UTF-8 encoding of the rune."
      },
      {
        "name": "TrailCCC",
        "desc": "TrailCCC returns the CCC of the last rune in the decomposition. If there is no decomposition, TrailCCC equals CCC."
      },
      {
        "name": "combinesBackward",
        "desc": ""
      },
      {
        "name": "combinesForward",
        "desc": ""
      },
      {
        "name": "hasDecomposition",
        "desc": ""
      },
      {
        "name": "isInert",
        "desc": ""
      },
      {
        "name": "isYesC",
        "desc": ""
      },
      {
        "name": "isYesD",
        "desc": ""
      },
      {
        "name": "multiSegment",
        "desc": ""
      },
      {
        "name": "nLeadingNonStarters",
        "desc": ""
      },
      {
        "name": "nTrailingNonStarters",
        "desc": ""
      },
      {
        "name": "quickSpan",
        "desc": "quickSpan returns a boundary n such that src[0:n] == f(src[0:n]) and whether any non-normalized parts were found. If atEOF is false, n will not point past the last segment if this segment might be become non-normalized by appending other runes."
      },
      {
        "name": "_byte",
        "desc": ""
      },
      {
        "name": "appendSlice",
        "desc": ""
      },
      {
        "name": "charinfoNFC",
        "desc": ""
      },
      {
        "name": "charinfoNFKC",
        "desc": ""
      },
      {
        "name": "copySlice",
        "desc": ""
      },
      {
        "name": "hangul",
        "desc": ""
      },
      {
        "name": "setBytes",
        "desc": ""
      },
      {
        "name": "setString",
        "desc": ""
      },
      {
        "name": "skipASCII",
        "desc": ""
      },
      {
        "name": "skipContinuationBytes",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": "lookup returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupString",
        "desc": "lookupString returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupStringUnsafe",
        "desc": "lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupUnsafe",
        "desc": "lookupUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupValue",
        "desc": "lookupValue determines the type of block n and looks up the value for b."
      },
      {
        "name": "lookup",
        "desc": "lookup returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupString",
        "desc": "lookupString returns the trie value for the first UTF-8 encoding in s and the width in bytes of this encoding. The size will be 0 if s does not hold enough bytes to complete the encoding. len(s) must be greater than 0."
      },
      {
        "name": "lookupStringUnsafe",
        "desc": "lookupStringUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupUnsafe",
        "desc": "lookupUnsafe returns the trie value for the first UTF-8 encoding in s. s must start with a full and valid UTF-8 encoded rune."
      },
      {
        "name": "lookupValue",
        "desc": "lookupValue determines the type of block n and looks up the value for b."
      },
      {
        "name": "Read",
        "desc": "Read implements the standard read interface."
      },
      {
        "name": "Close",
        "desc": "Close forces data that remains in the buffer to be written."
      },
      {
        "name": "Write",
        "desc": "Write implements the standard write interface.  If the last characters are not at a normalization boundary, the bytes will be buffered for the next write. The remaining bytes will be written on close."
      },
      {
        "name": "appendRune",
        "desc": "appendRune inserts a rune at the end of the buffer. It is used for Hangul."
      },
      {
        "name": "assignRune",
        "desc": "assignRune sets a rune at position pos. It is used for Hangul and recomposition."
      },
      {
        "name": "bytesAt",
        "desc": "bytesAt returns the UTF-8 encoding of the rune at position n. It is used for Hangul and recomposition."
      },
      {
        "name": "combineHangul",
        "desc": "combineHangul algorithmically combines Jamo character components into Hangul. See https://unicode.org/reports/tr15/#Hangul for details on combining Hangul."
      },
      {
        "name": "compose",
        "desc": "compose recombines the runes in the buffer. It should only be used to recompose a single segment, as it will not handle alternations between Hangul and non-Hangul characters correctly."
      },
      {
        "name": "decomposeHangul",
        "desc": "decomposeHangul algorithmically decomposes a Hangul rune into its Jamo components. See https://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul."
      },
      {
        "name": "doFlush",
        "desc": ""
      },
      {
        "name": "flush",
        "desc": "flush appends the normalized segment to out and resets rb."
      },
      {
        "name": "flushCopy",
        "desc": "flushCopy copies the normalized segment to buf and resets rb. It returns the number of bytes written to buf."
      },
      {
        "name": "init",
        "desc": ""
      },
      {
        "name": "initString",
        "desc": ""
      },
      {
        "name": "insertCGJ",
        "desc": "insertCGJ inserts a Combining Grapheme Joiner (0x034f) into rb."
      },
      {
        "name": "insertDecomposed",
        "desc": "insertDecomposed inserts an entry in to the reorderBuffer for each rune in dcomp. dcomp must be a sequence of decomposed UTF-8-encoded runes. It flushes the buffer on each new segment start."
      },
      {
        "name": "insertFlush",
        "desc": "insertFlush inserts the given rune in the buffer ordered by CCC. If a decomposition with multiple segments are encountered, they leading ones are flushed. It returns a non-zero error code if the rune was not inserted."
      },
      {
        "name": "insertOrdered",
        "desc": "insertOrdered inserts a rune in the buffer, ordered by Canonical Combining Class. It returns false if the buffer is not large enough to hold the rune. It is used internally by insert and insertString only."
      },
      {
        "name": "insertSingle",
        "desc": "insertSingle inserts an entry in the reorderBuffer for the rune at position i. info is the runeInfo for the rune at position i."
      },
      {
        "name": "insertUnsafe",
        "desc": "insertUnsafe inserts the given rune in the buffer ordered by CCC. It is assumed there is sufficient space to hold the runes. It is the responsibility of the caller to ensure this. This can be done by checking the state returned by the streamSafe type."
      },
      {
        "name": "reset",
        "desc": "reset discards all characters from the buffer."
      },
      {
        "name": "runeAt",
        "desc": "runeAt returns the rune at position n. It is used for Hangul and recomposition."
      },
      {
        "name": "setFlusher",
        "desc": ""
      },
      {
        "name": "lookup",
        "desc": "lookup determines the type of block n and looks up the value for b. For n \u003c t.cutoff, the block is a simple lookup table. Otherwise, the block is a list of ranges with an accompanying value. Given a matching range r, the value for b is by r.value + (b - r.lo) * stride."
      },
      {
        "name": "backwards",
        "desc": "backwards is used for checking for overflow and segment starts when traversing a string backwards. Users do not need to call first for the first rune. The state of the streamSafe retains the count of the non-starters loaded."
      },
      {
        "name": "first",
        "desc": "first inserts the first rune of a segment. It is a faster version of next if it is known p represents the first rune in a segment."
      },
      {
        "name": "isMax",
        "desc": ""
      },
      {
        "name": "next",
        "desc": "insert returns a ssState value to indicate whether a rune represented by p can be inserted."
      }
    ],
    "types": [
      {
        "name": "Form",
        "desc": "A Form denotes a canonical representation of Unicode code points. The Unicode-defined normalization and equivalence forms are:  \tNFC   Unicode Normalization Form C \tNFD   Unicode Normalization Form D \tNFKC  Unicode Normalization Form KC \tNFKD  Unicode Normalization Form KD  For a Form f, this documentation uses the notation f(x) to mean the bytes or string x converted to the given form. A position n in x is called a boundary if conversion to the form can proceed independently on both sides:  \tf(x) == append(f(x[0:n]), f(x[n:])...)  References: https://unicode.org/reports/tr15/ and https://unicode.org/notes/tn5/."
      },
      {
        "name": "Iter",
        "desc": "An Iter iterates over a string or byte slice, while normalizing it to a given Form."
      },
      {
        "name": "Properties",
        "desc": "Properties provides access to normalization properties of a rune."
      },
      {
        "name": "formInfo",
        "desc": "formInfo holds Form-specific functions and tables."
      },
      {
        "name": "input",
        "desc": ""
      },
      {
        "name": "insertErr",
        "desc": "insertErr is an error code returned by insert. Using this type instead of error improves performance up to 20% for many of the benchmarks."
      },
      {
        "name": "iterFunc",
        "desc": ""
      },
      {
        "name": "lookupFunc",
        "desc": "functions dispatchable per form"
      },
      {
        "name": "nfcTrie",
        "desc": "nfcTrie. Total size: 10332 bytes (10.09 KiB). Checksum: 51cc525b297fc970."
      },
      {
        "name": "nfkcTrie",
        "desc": "nfkcTrie. Total size: 16994 bytes (16.60 KiB). Checksum: c3ed54ee046f3c46."
      },
      {
        "name": "normReader",
        "desc": ""
      },
      {
        "name": "normWriter",
        "desc": ""
      },
      {
        "name": "qcInfo",
        "desc": "We pack quick check data in 4 bits:  \t5:    Combines forward  (0 == false, 1 == true) \t4..3: NFC_QC Yes(00), No (10), or Maybe (11) \t2:    NFD_QC Yes (0) or No (1). No also means there is a decomposition. \t1..0: Number of trailing non-starters.  When all 4 bits are zero, the character is inert, meaning it is never influenced by normalization."
      },
      {
        "name": "reorderBuffer",
        "desc": "reorderBuffer is used to normalize a single segment.  Characters inserted with insert are decomposed and reordered based on CCC. The compose method can be used to recombine characters.  Note that the byte buffer does not hold the UTF-8 characters in order.  Only the rune array is maintained in sorted order. flush writes the resulting segment to a byte array."
      },
      {
        "name": "sparseBlocks",
        "desc": ""
      },
      {
        "name": "ssState",
        "desc": "ssState is used for reporting the segment state after inserting a rune. It is returned by streamSafe.next."
      },
      {
        "name": "streamSafe",
        "desc": "streamSafe implements the policy of when a CGJ should be inserted."
      },
      {
        "name": "valueRange",
        "desc": ""
      }
    ]
  },
  {
    "name": "weak",
    "desc": "Package weak provides ways to safely reference memory weakly, that is, without preventing its reclamation.",
    "functions": [
      {
        "name": "runtime_makeStrongFromWeak",
        "desc": ""
      },
      {
        "name": "runtime_registerWeakPointer",
        "desc": ""
      },
      {
        "name": "Value",
        "desc": "Value returns the original pointer used to create the weak pointer. It returns nil if the value pointed to by the original pointer was reclaimed by the garbage collector. If a weak pointer points to an object with a finalizer, then Value will return nil as soon as the object's finalizer is queued for execution."
      }
    ],
    "types": [
      {
        "name": "Pointer",
        "desc": "Pointer is a weak pointer to a value of type T.  Just like regular pointers, Pointer may reference any part of an object, such as a field of a struct or an element of an array. Objects that are only pointed to by weak pointers are not considered reachable, and once the object becomes unreachable, [Pointer.Value] may return nil.  The primary use-cases for weak pointers are for implementing caches, canonicalization maps (like the unique package), and for tying together the lifetimes of separate values (for example, through a map with weak keys).  Two Pointer values compare equal if and only if the pointers from which they were created compare equal. This property is maintained even after the object referenced by the pointer used to create a weak reference is reclaimed. If multiple weak pointers are made to different offsets within the same object (for example, pointers to different fields of the same struct), those pointers will not compare equal. In other words, weak pointers map to objects and offsets within those objects, not plain addresses. If a weak pointer is created from an object that becomes unreachable, but is then resurrected due to a finalizer, that weak pointer will not compare equal with weak pointers created after the resurrection.  Calling [Make] with a nil pointer returns a weak pointer whose [Pointer.Value] always returns nil. The zero value of a Pointer behaves as if it were created by passing nil to [Make] and compares equal with such pointers.  [Pointer.Value] is not guaranteed to eventually return nil. [Pointer.Value] may return nil as soon as the object becomes unreachable. Values stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. A function argument or receiver may become unreachable at the last point where the function mentions it. To ensure [Pointer.Value] does not return nil, pass a pointer to the object to the [runtime.KeepAlive] function after the last point where the object must remain reachable.  Note that because [Pointer.Value] is not guaranteed to eventually return nil, even after an object is no longer referenced, the runtime is allowed to perform a space-saving optimization that batches objects together in a single allocation slot. The weak pointer for an unreferenced object in such an allocation may never become nil if it always exists in the same batch as a referenced object. Typically, this batching only happens for tiny (on the order of 16 bytes or less) and pointer-free objects."
      }
    ]
  }
]
