{
  "archive/tar": "[zh]包 tar：tar 包实现了对 tar 归档文件的访问。\n\n磁带归档（tar）是一种用于存储一系列文件的文件格式，\n可按流式方式读取和写入。\n本包旨在支持该格式的大多数变体，\n包括 GNU 和 BSD tar 工具生成的格式。",
  "archive/zip": "[zh]包 zip：zip 包提供了对读写 ZIP 归档文件的支持。\n\n详情参见 [ZIP 规范]。\n\n本包不支持分卷压缩。\n\n关于 ZIP64 的说明：\n\n为了保持向后兼容，FileHeader 同时包含 32 位和 64 位的大小字段。64 位字段始终包含正确的值，对于普通归档文件，这两个字段的值相同。对于需要 ZIP64 格式的文件，32 位字段将为 0xffffffff，此时必须使用 64 位字段。\n\n[ZIP 规范]: https://support.pkware.com/pkzip/appnote",
  "bufio": "[zh]包 bufio：bufio 包实现了带缓冲的 I/O。它包装了一个 io.Reader 或 io.Writer 对象，创建另一个同样实现该接口的对象（Reader 或 Writer），并提供缓冲功能以及一些文本 I/O 的辅助方法。",
  "bytes": "[zh]包 bytes：bytes 包实现了用于操作字节切片的函数。\n它类似于 [strings] 包提供的功能。",
  "cmp": "[zh]包 cmp：cmp 包提供与比较有序值相关的类型和函数。",
  "compress/bzip2": "[zh]包 bzip2：bzip2 包实现了 bzip2 解压缩。",
  "compress/flate": "[zh]包 flate：flate 包实现了 RFC 1951 中描述的 DEFLATE 压缩数据格式。[compress/gzip] 和 [compress/zlib] 包提供了对基于 DEFLATE 的文件格式的访问。",
  "compress/gzip": "[zh]包 gzip：gzip 包实现了 RFC 1952 规范中定义的 gzip 格式压缩文件的读写。",
  "compress/lzw": "[zh]包 lzw：包 lzw 实现了 Lempel-Ziv-Welch 压缩数据格式，该格式描述于 T. A. Welch 的论文《一种高性能数据压缩技术》（Computer, 17(6) (1984 年 6 月), 第 8-19 页）。\n\n具体而言，它实现了 GIF 和 PDF 文件格式所使用的 LZW 算法，即支持宽度可变的最多 12 位编码，并且前两个非字面量编码分别为清除码和文件结束码。\n\nTIFF 文件格式使用了一种类似但不兼容的 LZW 算法版本。参见 [golang.org/x/image/tiff/lzw] 包以获取实现。",
  "compress/zlib": "[zh]包 zlib：本包实现了 RFC 1950 规范中定义的 zlib 格式压缩数据的读写。\n\n该实现提供了在读取时解压缩和在写入时压缩的过滤器。例如，将压缩数据写入缓冲区：\n\n\tvar b bytes.Buffer\n\tw := zlib.NewWriter(\u0026b)\n\tw.Write([]byte(\"hello, world\\n\"))\n\tw.Close()\n\n以及从中读取数据：\n\n\tr, err := zlib.NewReader(\u0026b)\n\tio.Copy(os.Stdout, r)\n\tr.Close()",
  "container/heap": "[zh]包 heap：heap 包为实现 heap.Interface 的任意类型提供堆操作。堆是一种树形结构，其特性是每个节点都是其子树中的最小值节点。\n\n树中的最小元素位于根节点，索引为 0。\n\n堆是实现优先队列的常用方式。要构建优先队列，可通过将（负）优先级作为 Less 方法的排序依据来实现 Heap 接口，使得 Push 添加元素，而 Pop 移除队列中优先级最高的元素。示例中包含了此类实现；文件 example_pq_test.go 含有完整源码。",
  "container/list": "[zh]包 list：list 包实现了双向链表。\n\n遍历列表的方法（其中 l 是一个 *List）：\n\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\t// 对 e.Value 执行操作\n\t}",
  "container/ring": "[zh]包 ring：ring 包实现了对循环链表的操作。",
  "context": "[zh]包 context：context 包定义了 Context 类型，该类型用于跨越 API 边界和进程之间传递截止时间、取消信号以及其他请求作用域内的值。\n\n服务器的传入请求应创建一个 [Context]，而对服务器的传出调用则应接收一个 Context。它们之间的函数调用链必须传播该 Context，可选择使用 [WithCancel]、[WithDeadline]、[WithTimeout] 或 [WithValue] 创建派生 Context 来替换原 Context。\n\n可以取消 Context 以表明代表其执行的工作应停止。带有截止时间的 Context 会在截止时间到达后被取消。当一个 Context 被取消时，所有从其派生的 Context 也会被取消。\n\n[WithCancel]、[WithDeadline] 和 [WithTimeout] 函数接收一个 Context（父级），并返回一个派生的 Context（子级）和一个 [CancelFunc]。直接调用 CancelFunc 会取消子级及其后代，移除父级对子级的引用，并停止任何关联的定时器。若未调用 CancelFunc，则会导致子级及其后代一直泄漏，直到父级被取消。go vet 工具会检查是否在所有控制流路径上都使用了 CancelFunc。\n\n[WithCancelCause]、[WithDeadlineCause] 和 [WithTimeoutCause] 函数返回一个 [CancelCauseFunc]，该函数接收一个错误并将其记录为取消原因。在已取消的 Context 或其任意后代上调用 [Cause] 可获取该原因。如果未指定原因，则 Cause(ctx) 返回值与 ctx.Err() 相同。\n\n使用 Context 的程序应遵循以下规则，以保持跨包接口的一致性，并使静态分析工具能够检查 Context 的传播：\n\n不要将 Context 存储在结构体类型中；而应显式地将 Context 传递给每个需要它的函数。这一点在 https://go.dev/blog/context-and-structs 中有进一步讨论。Context 应作为第一个参数，通常命名为 ctx：\n\n\tfunc DoSomething(ctx context.Context, arg Arg) error {\n\t\t// ... 使用 ctx ...\n\t}\n\n即使函数允许，也不要传递 nil [Context]。如果不确定使用哪个 Context，请使用 [context.TODO]。\n\n仅将 Context 的 Value 用于在进程和 API 间传输的请求作用域数据，不要用于向函数传递可选参数。\n\n同一个 Context 可以传递给在不同 goroutine 中运行的函数；Context 可被多个 goroutine 同时安全使用。\n\n示例代码见 https://go.dev/blog/context，展示了一个使用 Context 的服务器。",
  "crypto": "[zh]包 crypto：crypto 包收集了常见的密码学常量。",
  "crypto/aes": "[zh]包 aes：本包实现了美国联邦信息处理标准出版物 197 定义的 AES 加密算法（原名 Rijndael）。\n\n本包中的 AES 操作未使用恒定时间算法实现。例外情况是，在启用了硬件 AES 支持的系统上运行时，这些操作为恒定时间。例如使用 AES-NI 扩展的 amd64 系统，以及使用消息安全辅助扩展的 s390x 系统。在这些系统上，当 NewCipher 的结果传递给 cipher.NewGCM 时，GCM 使用的 GHASH 操作也为恒定时间。",
  "crypto/cipher": "[zh]包 cipher：cipher 包实现了标准的分组密码模式，可封装底层的分组密码实现。\n参见 https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\n和 NIST 特别出版物 800-38A。",
  "crypto/des": "[zh]包 des：该包实现了美国联邦信息处理标准出版物 46-3 中定义的数据加密标准（DES）和三重数据加密算法（TDEA）。\n\nDES 在密码学上已被攻破，不应在安全应用中使用。",
  "crypto/dsa": "[zh]包 dsa：包 dsa 实现了 FIPS 186-3 中定义的数字签名算法。\n\n本包中的 DSA 操作未使用常数时间算法实现。\n\n已弃用：DSA 是一种遗留算法，应改用现代替代方案，\n例如 Ed25519（由包 crypto/ed25519 实现）。使用 1024 位模数（L1024N160 参数）的密钥在密码学上较弱，\n而更大的密钥又未得到广泛支持。请注意，FIPS 186-5 已不再批准 DSA 用于签名生成。",
  "crypto/ecdh": "[zh]包 ecdh：包 ecdh 实现了基于 NIST 曲线和 Curve25519 的椭圆曲线迪菲-赫尔曼（Elliptic Curve Diffie-Hellman）。",
  "crypto/ecdsa": "[zh]包 ecdsa：包 ecdsa 实现了 [FIPS 186-5] 中定义的椭圆曲线数字签名算法。\n\n本包生成的签名是非确定性的，但会将熵值与私钥和消息混合，即使在随机源失效的情况下也能达到相同的安全级别。\n\n涉及私钥的操作均使用常数时间算法实现，前提是使用由 [elliptic.P224]、[elliptic.P256]、[elliptic.P384] 或 [elliptic.P521] 返回的 [elliptic.Curve]。  \n\n[FIPS 186-5]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf",
  "crypto/ed25519": "[zh]包 ed25519：ed25519 包实现了 Ed25519 签名算法。参见 https://ed25519.cr.yp.to/。\n\n这些函数也与 RFC 8032 中定义的“Ed25519”函数兼容。但与 RFC 8032 的定义不同，本包的私钥表示形式包含一个公钥后缀，以使使用同一密钥的多次签名操作更高效。本包将 RFC 8032 中的私钥称为“种子”。\n\n涉及私钥的操作均使用常数时间算法实现。",
  "crypto/elliptic": "[zh]包 elliptic：该包实现了定义在素数域上的标准 NIST P-224、P-256、P-384 和 P-521 椭圆曲线。\n\n除用于 [crypto/ecdsa] 所必需的 [P224]、[P256]、[P384] 和 [P521] 值外，不推荐直接使用此包。大多数其他用途应迁移到更高效且更安全的 [crypto/ecdh]，或使用第三方模块实现底层功能。",
  "crypto/fips140": "[zh]包 fips140",
  "crypto/hkdf": "[zh]包 hkdf：包 hkdf 实现了基于 HMAC 的提取和扩展密钥派生函数（HKDF），定义见 RFC 5869。\n\nHKDF 是一种密码学密钥派生函数（KDF），旨在将有限的输入密钥材料扩展为一个或多个密码学强度高的秘密密钥。",
  "crypto/hmac": "[zh]包 hmac：本包基于美国联邦信息处理标准出版物 198（FIPS PUB 198）实现密钥哈希消息认证码（HMAC）。  \nHMAC 是一种使用密钥对消息进行签名的加密哈希。接收方通过使用相同密钥重新计算哈希来验证其真实性。\n\n接收方应谨慎使用 Equal 函数比较 MAC，以避免计时侧信道攻击：\n\n\t// ValidMAC 报告 messageMAC 是否为消息的有效 HMAC 标签。\n\tfunc ValidMAC(message, messageMAC, key []byte) bool {\n\t\tmac := hmac.New(sha256.New, key)\n\t\tmac.Write(message)\n\t\texpectedMAC := mac.Sum(nil)\n\t\treturn hmac.Equal(messageMAC, expectedMAC)\n\t}",
  "crypto/internal/boring": "[zh]包 boring：包 boring 提供对 BoringCrypto 实现函数的访问。  \n通过检查常量 Enabled 可确定 BoringCrypto 是否可用。  \n如果 BoringCrypto 不可用，该包中的所有函数都会引发 panic。",
  "crypto/internal/boring/bbig": "[zh]包 bbig",
  "crypto/internal/boring/bcache": "[zh]包 bcache：bcache 包为 BoringCrypto 实现了一个支持垃圾回收的缓存（参见 [Cache]）。",
  "crypto/internal/boring/sig": "[zh]包 sig：包 sig 包含可调用的“代码签名”，调用后会导致特定的代码序列被链接到最终的二进制文件中。这些函数本身为空操作。",
  "crypto/internal/cryptotest": "[zh]包 cryptotest",
  "crypto/internal/entropy": "[zh]包 entropy：该包为 FIPS 140-3 模块提供被动熵源。仅在 FIPS 模式下由 [crypto/internal/fips140/drbg.Read] 使用。\n\n此实现符合 IG 9.3.A、附加说明 12 的要求，该要求在 2026 年 1 月 1 日之前允许新模块满足 [较早版本] 的决议 2(b)：\n“包含经批准的 DRBG 的软件模块，该 DRBG 接收来自[...]模块运行环境物理边界内部的熵的 LOAD 命令（或其逻辑等效操作）[...]。”\n\n拥有自有 SP 800-90B 熵源的发行版应使用其自身实现替换此包。\n\n[较早版本]: https://csrc.nist.gov/CSRC/media/Projects/cryptographic-module-validation-program/documents/IG%209.3.A%20Resolution%202b%5BMarch%2026%202024%5D.pdf",
  "crypto/internal/fips140": "[zh]包 fips140",
  "crypto/internal/fips140/aes": "[zh]包 aes",
  "crypto/internal/fips140/aes/gcm": "[zh]包 gcm",
  "crypto/internal/fips140/alias": "[zh]包别名：包 alias 实现了内存别名测试。\n此代码也存在于 golang.org/x/crypto/internal/alias。",
  "crypto/internal/fips140/bigmod": "[zh]包 bigmod",
  "crypto/internal/fips140/check": "[zh]包 check：包 check 实现了 FIPS 140 的加载时代码和数据验证。\n除 hmac 和 sha256 外，每个提供加密功能的 FIPS 包都必须导入 crypto/internal/fips140/check，以确保在包全局变量初始化之前完成验证。\nhmac 和 sha256 包被本包所使用，因此它们不能导入本包。\n相反，这些包必须确保在 init 期间不修改全局变量。\n（如有必要，可在检查完成后由 check 调用这些包中的 PostCheck 函数。）",
  "crypto/internal/fips140/check/checktest": "[zh]包 checktest：checktest 包定义了一些代码和数据，供 crypto/internal/fips140/check 测试使用。",
  "crypto/internal/fips140/drbg": "[zh]包 drbg：drbg 包提供可供 FIPS 代码使用的加密安全随机字节。在 FIPS 模式下，它使用 SP 800-90A Rev. 1 确定性随机比特生成器（DRBG）；否则，使用操作系统的随机数生成器。",
  "crypto/internal/fips140/ecdh": "[zh]包 ecdh",
  "crypto/internal/fips140/ecdsa": "[zh]包 ecdsa",
  "crypto/internal/fips140/ed25519": "[zh]ed25519 包",
  "crypto/internal/fips140/edwards25519": "[zh]包 edwards25519：edwards25519 包实现了扭曲爱德华兹曲线\n\n\t-x² + y² = 1 + -(121665/121666)·x²·y²\n\n的群运算逻辑。该曲线更广为人知的是作为 Curve25519 对应的爱德华兹曲线，也是 Ed25519 签名方案所使用的曲线。\n\n大多数用户不需要此包，而应使用 crypto/ed25519 实现签名，使用 golang.org/x/crypto/curve25519 实现 Diffie-Hellman 密钥交换，或使用 github.com/gtank/ristretto255 实现素数阶群运算。\n\n然而，确实需要与底层 edwards25519 操作交互的开发者可以使用 filippo.io/edwards25519，它是本包的扩展版本，已重新打包为可导入模块。\n\n（请注意，filippo.io/edwards25519 和 github.com/gtank/ristretto255 并非由 Go 团队维护，也不在 Go 1 兼容性承诺范围内。）",
  "crypto/internal/fips140/edwards25519/field": "[zh]包 field：包 field 实现了对 2^255-19 的快速算术运算。",
  "crypto/internal/fips140/hkdf": "[zh]包 hkdf",
  "crypto/internal/fips140/hmac": "[zh]包 hmac：hmac 包根据 [FIPS 198-1] 实现 HMAC。\n\n[FIPS 198-1]: https://doi.org/10.6028/NIST.FIPS.198-1",
  "crypto/internal/fips140/mlkem": "[zh]包 mlkem：包 mlkem 实现了抗量子密钥封装方法 ML-KEM（原名 Kyber），符合 [NIST FIPS 203] 规范。\n\n[NIST FIPS 203]: https://doi.org/10.6028/NIST.FIPS.203",
  "crypto/internal/fips140/nistec": "[zh]包 nistec：包 nistec 实现了 NIST SP 800-186 中定义的椭圆曲线。\n\n该包使用 fiat-crypto 或专用汇编语言以及 Go 代码进行后端域运算（而非 math/big），并提供了常数时间、无堆分配、基于字节切片的安全 API。群运算尽可能采用现代且安全的完全加法公式。无穷远点的处理和编码遵循 SEC 1 第 2.0 版，且无法表示无效的曲线点。",
  "crypto/internal/fips140/nistec/fiat": "[zh]包 fiat",
  "crypto/internal/fips140/pbkdf2": "[zh]包 pbkdf2",
  "crypto/internal/fips140/rsa": "[zh]包 rsa",
  "crypto/internal/fips140/sha256": "[zh]包 sha256：包 sha256 实现了 FIPS 180-4 中定义的 SHA-224 和 SHA-256 哈希算法。",
  "crypto/internal/fips140/sha3": "[zh]包 sha3：本包实现了 [FIPS 202] 定义的 SHA-3 固定输出长度哈希函数和 SHAKE 可变输出长度函数，以及 [SP 800-185] 定义的 cSHAKE 可扩展输出长度函数。\n\n[FIPS 202]: https://doi.org/10.6028/NIST.FIPS.202  \n[SP 800-185]: https://doi.org/10.6028/NIST.SP.800-185",
  "crypto/internal/fips140/sha512": "[zh]包 sha512 实现了 FIPS 180-4 中定义的 SHA-384、SHA-512、SHA-512/224 和 SHA-512/256 哈希算法。",
  "crypto/internal/fips140/ssh": "[zh]包 ssh：本包实现了 RFC 4253 第 7.2 节规定的 SSH KDF，符合 SP 800-135 Rev. 1 的要求。",
  "crypto/internal/fips140/subtle": "[zh]包 subtle",
  "crypto/internal/fips140/tls12": "[zh]包 tls12",
  "crypto/internal/fips140/tls13": "[zh]包 tls13：包 tls13 实现了 RFC 8446 第 7.1 节规定的 TLS 1.3 密钥计划，并符合 FIPS 140-3 IG 2.4.B 解决方案 7 的要求。",
  "crypto/internal/fips140cache": "[zh]包 fips140cache：fips140cache 包提供一个弱映射，将值的生存期与键的生存期关联。\n\n它可以用于将预计算的值（例如内部/fips140 的 PrivateKey 值，在 FIPS 140-3 模式下可能需要昂贵的成对一致性测试）与没有私有字段的类型（例如 ed25519.PrivateKey），或由于可能被并发复制而无法安全修改的类型（例如 ecdsa.PrivateKey）相关联。",
  "crypto/internal/fips140deps": "[zh]包 fipsdeps：包 fipsdeps 包含用于暴露给 FIPS 模块的内部 API 的包装包。由于模块在验证后即被冻结，并会在后续多个版本中得到支持，因此 crypto/internal/fips140deps/... 所暴露的 API 在使用它们的模块仍受支持期间不得更改。",
  "crypto/internal/fips140deps/byteorder": "[zh]包 byteorder",
  "crypto/internal/fips140deps/cpu": "[zh]包 cpu",
  "crypto/internal/fips140deps/godebug": "[zh]包 godebug",
  "crypto/internal/fips140hash": "[zh]包 fips140hash",
  "crypto/internal/fips140only": "[zh]包 fips140only",
  "crypto/internal/fips140test": "[zh]包 fipstest",
  "crypto/internal/hpke": "[zh]包 hpke",
  "crypto/internal/impl": "[zh]包 impl：包 impl 是密码学原语的可选实现的注册表，用于测试时选择使用。",
  "crypto/internal/randutil": "[zh]包 randutil：randutil 包包含各种加密包使用的内部随机性工具。",
  "crypto/internal/sysrand": "[zh]包 sysrand：包 rand 提供来自操作系统的加密安全的随机字节。",
  "crypto/internal/sysrand/internal/seccomp": "[zh]包 seccomp",
  "crypto/md5": "[zh]包 md5：md5 包实现了 RFC 1321 中定义的 MD5 哈希算法。\n\nMD5 在密码学上已被攻破，不应在安全应用中使用。",
  "crypto/mlkem": "[zh]包 mlkem：包 mlkem 实现了抗量子密钥封装方法 ML-KEM（原名 Kyber），符合 [NIST FIPS 203] 规范。\n\n大多数应用应使用由 [DecapsulationKey768] 和 [EncapsulationKey768] 实现的 ML-KEM-768 参数集。\n\n[NIST FIPS 203]: https://doi.org/10.6028/NIST.FIPS.203",
  "crypto/pbkdf2": "[zh]包 pbkdf2：pbkdf2 包实现了 RFC 8018（PKCS #5 v2.1）中定义的密钥派生函数 PBKDF2。\n\n当基于密码或任何其他非完全随机数据加密数据时，密钥派生函数非常有用。它使用伪随机函数根据密码派生出安全的加密密钥。",
  "crypto/rand": "[zh]包 rand：rand 包实现了密码学安全的随机数生成器。",
  "crypto/rc4": "[zh]包 rc4：包 rc4 实现了 Bruce Schneier 的《应用密码学》中定义的 RC4 加密算法。\n\nRC4 在密码学上已被攻破，不应在安全应用中使用。",
  "crypto/rsa": "[zh]包 rsa：包 rsa 实现了 PKCS #1 和 RFC 8017 中规定的 RSA 加密。\n\nRSA 是一种基本的单一运算，本包使用该运算实现公钥加密或公钥签名。\n\nRSA 用于加密和签名的原始规范是 PKCS #1，默认情况下“RSA 加密”和“RSA 签名”均指 PKCS #1 版本 1.5。然而，该规范存在缺陷，新设计应尽可能使用版本 2，通常简称为 OAEP 和 PSS。\n\n本包包含两组接口。在不需要更抽象接口的情况下，提供了使用 v1.5/OAEP 进行加密/解密以及使用 v1.5/PSS 进行签名/验证的函数。如果需要对公钥原语进行抽象，PrivateKey 类型实现了 crypto 包中的 Decrypter 和 Signer 接口。\n\n涉及私钥的操作均使用恒定时间算法实现，但 [GenerateKey] 及某些涉及已弃用的多素数密钥的操作除外。\n\n# 最小密钥长度\n\n[GenerateKey] 在请求小于 1024 位的密钥时返回错误，所有 Sign、Verify、Encrypt 和 Decrypt 方法在使用小于 1024 位的密钥时也会返回错误。此类密钥不安全，不应使用。\n\nrsa1024min=0 GODEBUG 设置可抑制此错误，但我们建议仅在必要时用于测试。测试可通过 [testing.T.Setenv] 设置此选项，或在 *_test.go 源文件中包含 \"//go:debug rsa1024min=0\"。\n\n或者，参见 [GenerateKey (TestKey)] 示例以获取预先生成的仅用于测试的 2048 位密钥。\n\n[GenerateKey (TestKey)]: https://pkg.go.dev/crypto/rsa#example-GenerateKey-TestKey",
  "crypto/sha1": "[zh]包 sha1：包 sha1 实现了 RFC 3174 中定义的 SHA-1 哈希算法。\n\nSHA-1 在密码学上已被攻破，不应在安全应用中使用。",
  "crypto/sha256": "[zh]包 sha256：包 sha256 实现了 FIPS 180-4 中定义的 SHA224 和 SHA256 哈希算法。",
  "crypto/sha3": "[zh]包 sha3：sha3 包实现了 FIPS 202 中定义的 SHA-3 哈希算法以及可扩展输出函数 SHAKE。",
  "crypto/sha512": "[zh]包 sha512 实现了 FIPS 180-4 中定义的 SHA-384、SHA-512、SHA-512/224 和 SHA-512/256 哈希算法。\n\n此包返回的所有 hash.Hash 实现均额外实现了 encoding.BinaryMarshaler 和 encoding.BinaryUnmarshaler，用于对哈希的内部状态进行序列化和反序列化。",
  "crypto/subtle": "[zh]包 subtle：subtle 包实现了在密码学代码中常有用处但需谨慎使用才能正确使用的函数。",
  "crypto/tls": "[zh]包 tls：本包部分实现了 RFC 5246 中规定的 TLS 1.2，以及 RFC 8446 中规定的 TLS 1.3。\n\n# FIPS 140-3 模式\n\n当程序处于 [FIPS 140-3 模式] 时，本包的行为如同仅实现了 SP 800-140C 和 SP 800-140D 批准的协议版本、密码套件、签名算法、证书公钥类型和大小，以及密钥交换和派生算法。其他未被批准的算法将被静默忽略且不进行协商，或被拒绝。此集合可能取决于通过 GOFIPS140 选定的 FIPS 140-3 Go 加密模块所支持的算法，并可能随 Go 版本变化。\n\n[FIPS 140-3 模式]: https://go.dev/doc/security/fips140",
  "crypto/tls/internal/fips140tls": "[zh]包 fips140tls：包 fips140tls 控制 crypto/tls 是否需要 FIPS 批准的设置。",
  "crypto/x509": "[zh]包 x509：包 x509 实现了 X.509 标准的一个子集。\n\n它支持解析和生成证书、证书签名请求、证书吊销列表，以及编码后的公钥和私钥。提供了一个证书验证器，并包含证书链构建功能。\n\n该包针对 IETF（RFC 2459/3280/5280）定义的 X.509 技术规范，并遵循 CA/浏览器论坛基线要求的进一步限制。对于这些规范之外的功能支持有限，因为该包的主要目标是与公开信任的 TLS 证书生态系统及其策略和约束保持兼容。\n\n在 macOS 和 Windows 上，证书验证由系统 API 处理，但该包力求在不同操作系统上应用一致的验证规则。",
  "crypto/x509/internal/macos": "[zh]包 macOS：macOS 包为 Core Foundation 和 Security.framework 提供了无需 cgo 的封装，类似于 syscall 包提供对 libSystem.dylib 的访问。",
  "crypto/x509/pkix": "[zh]包 pkix：pkix 包含用于 X.509 证书、CRL 和 OCSP 的 ASN.1 解析与序列化的共享低层结构。",
  "database/sql": "[zh]包 sql：sql 包为 SQL（或类 SQL）数据库提供了通用接口。\n\nsql 包必须与数据库驱动程序一起使用。  \n驱动程序列表见 https://golang.org/s/sqldrivers。\n\n不支持上下文取消的驱动程序将在查询完成前一直阻塞，不会返回。\n\n有关使用示例，请参见 wiki 页面：  \nhttps://golang.org/s/sqlwiki。",
  "database/sql/driver": "[zh]包 driver：driver 包定义了由 database/sql 包使用的数据库驱动程序需实现的接口。\n\n大多数代码应当使用 [database/sql] 包。\n\n驱动程序接口随着时间演进。驱动应实现 [Connector] 和 [DriverContext] 接口。\nConnector.Connect 和 Driver.Open 方法不应返回 [ErrBadConn]。\n[ErrBadConn] 仅应在 [Validator]、[SessionResetter] 或查询方法中，当连接已处于无效（例如已关闭）状态时返回。\n\n所有 [Conn] 实现都应实现以下接口：\n[Pinger]、[SessionResetter] 和 [Validator]。\n\n若支持命名参数或上下文，驱动的 [Conn] 应实现：\n[ExecerContext]、[QueryerContext]、[ConnPrepareContext] 和 [ConnBeginTx]。\n\n为支持自定义数据类型，应实现 [NamedValueChecker]。[NamedValueChecker]\n还允许通过在 CheckNamedValue 中返回 [ErrRemoveArgument]，使查询接受每查询选项作为参数。\n\n若支持多个结果集，[Rows] 应实现 [RowsNextResultSet]。\n若驱动能够描述返回结果中的类型信息，则应实现以下接口：\n[RowsColumnTypeScanType]、[RowsColumnTypeDatabaseTypeName]、[RowsColumnTypeLength]、\n[RowsColumnTypeNullable] 和 [RowsColumnTypePrecisionScale]。单个行值也可能返回 [Rows] 类型，其可能表示数据库游标值。\n\n若 [Conn] 实现了 [Validator]，则在将连接返回连接池之前会调用 IsValid 方法。\n若连接池中的条目实现了 [SessionResetter]，则在重新使用该连接执行下一个查询前会调用 ResetSession。\n若连接未被归还至连接池而直接重用，则在重用前调用 ResetSession，但不调用 IsValid。",
  "debug/buildinfo": "[zh]包 buildinfo：buildinfo 包提供了对嵌入 Go 二进制文件中关于其构建方式的信息的访问。这包括 Go 工具链版本以及所使用的模块集合（针对以模块模式构建的二进制文件）。\n\n当前运行二进制文件的构建信息可通过 runtime/debug.ReadBuildInfo 获取。",
  "debug/dwarf": "[zh]包 dwarf：dwarf 包提供了对从可执行文件加载的 DWARF 调试信息的访问，该格式定义于 DWARF 2.0 标准，详见 http://dwarfstd.org/doc/dwarf-2.0.0.pdf。\n\n# 安全性\n\n此包未针对对抗性输入进行加固设计，不在 https://go.dev/security/policy 的覆盖范围内。特别是，在解析目标文件时仅执行基本验证。因此，在解析不可信输入时应格外小心，因为解析格式错误的文件可能会消耗大量资源，或导致 panic。",
  "debug/elf": "[zh]包 elf：elf 包实现了对 ELF 目标文件的访问。\n\n# 安全性\n\n该包未针对对抗性输入进行安全加固，不在 https://go.dev/security/policy 的覆盖范围内。特别是，在解析目标文件时仅执行基本验证。因此，解析不可信输入时应谨慎，因为解析格式错误的文件可能会消耗大量资源，或导致 panic。",
  "debug/gosym": "[zh]包 gosym：gosym 包实现了对由 gc 编译器生成的 Go 二进制文件中嵌入的 Go 符号表和行号表的访问。",
  "debug/macho": "[zh]包 macho：macho 包实现了对 Mach-O 目标文件的访问。\n\n# 安全性\n\n本包未设计用于抵御恶意输入的攻击，不在 https://go.dev/security/policy 的安全策略范围内。特别是，在解析目标文件时仅进行基本的验证。因此，解析不可信输入时应谨慎，因为解析格式错误的文件可能会消耗大量资源，或导致程序崩溃。",
  "debug/pe": "[zh]包 pe：pe 包实现了对 PE（微软 Windows 可移植可执行）文件的访问。\n\n# 安全性\n\n本包未针对对抗性输入进行安全加固，不在 https://go.dev/security/policy 的覆盖范围内。特别是，在解析目标文件时仅执行基本验证。因此，解析不可信输入时应谨慎，因为解析格式错误的文件可能会消耗大量资源，或导致 panic。",
  "debug/plan9obj": "[zh]包 plan9obj：plan9obj 包实现了对 Plan 9 a.out 目标文件的访问。\n\n# 安全性\n\n此包未设计用于抵御恶意输入，不在 https://go.dev/security/policy 的保护范围内。特别是，在解析目标文件时仅进行基本验证。因此，解析不可信输入时应谨慎，因为解析格式错误的文件可能会消耗大量资源，或导致 panic。",
  "embed": "[zh]包 embed：embed 包提供对嵌入到正在运行的 Go 程序中的文件的访问。\n\n导入 \"embed\" 的 Go 源文件可以使用 //go:embed 指令，在编译时从包目录或子目录读取文件内容，初始化类型为 string、[]byte 或 [FS] 的变量。\n\n例如，以下是将名为 hello.txt 的文件嵌入并在运行时打印其内容的三种方式。\n\n将一个文件嵌入字符串：\n\n\timport _ \"embed\"\n\n\t//go:embed hello.txt\n\tvar s string\n\tprint(s)\n\n将一个文件嵌入字节切片：\n\n\timport _ \"embed\"\n\n\t//go:embed hello.txt\n\tvar b []byte\n\tprint(string(b))\n\n将一个或多个文件嵌入文件系统：\n\n\timport \"embed\"\n\n\t//go:embed hello.txt\n\tvar f embed.FS\n\tdata, _ := f.ReadFile(\"hello.txt\")\n\tprint(string(data))\n\n# 指令\n\n位于变量声明上方的 //go:embed 指令指定要嵌入的文件，使用一个或多个 path.Match 模式。\n\n该指令必须紧接在单个变量声明行之前。指令与声明之间只允许空行和以 '//' 开头的行注释。\n\n变量的类型必须是字符串类型、字节类型的切片，或 [FS]（或 [FS] 的别名）。\n\n例如：\n\n\tpackage server\n\n\timport \"embed\"\n\n\t// content 保存我们的静态 Web 服务器内容。\n\t//go:embed image/* template/*\n\t//go:embed html/index.html\n\tvar content embed.FS\n\nGo 构建系统会识别这些指令，并安排将声明的变量（如上例中的 content）用文件系统中匹配的文件填充。\n\n//go:embed 指令可接受多个以空格分隔的模式以简化书写，也可重复使用，以避免在模式较多时出现过长的行。模式相对于包含源文件的包目录进行解释。路径分隔符为正斜杠，即使在 Windows 系统上也是如此。模式不能包含 '.' 或 '..' 或空路径元素，也不能以斜杠开头或结尾。要匹配当前目录中的所有内容，请使用 '*' 而非 '.'。为支持文件名中包含空格的情况，模式可以写成 Go 双引号或反引号字符串字面量。\n\n如果模式命名了一个目录，则从该目录根开始的整个子树中的所有文件都会被嵌入（递归），但名称以 '.' 或 '_' 开头的文件除外。因此，上述示例中的变量几乎等价于：\n\n\t// content 是我们的静态 Web 服务器内容。\n\t//go:embed image template html/index.html\n\tvar content embed.FS\n\n区别在于 'image/*' 会嵌入 'image/.tempfile'，而 'image' 不会。两者都不会嵌入 'image/dir/.tempfile'。\n\n如果模式以前缀 'all:' 开头，则遍历目录的规则会被修改，包含以 '.' 或 '_' 开头的文件。例如，'all:image' 会同时嵌入 'image/.tempfile' 和 'image/dir/.tempfile'。\n\n//go:embed 指令可用于导出和非导出变量，具体取决于包是否希望将数据提供给其他包使用。它只能用于包级变量，不能用于局部变量。\n\n模式不得匹配包所在模块之外的文件，例如 '.git/*'、符号链接、'vendor/' 或包含 go.mod 的任何目录（这些是独立模块）。模式不得匹配文件名包含特殊标点字符 \" * \u003c \u003e ? ` ' | / \\ 和 : 的文件。对空目录的匹配将被忽略。此后，每条 //go:embed 行中的每个模式必须至少匹配一个文件或非空目录。\n\n如果任意模式无效或匹配结果无效，构建将失败。\n\n# 字符串和字节\n\n对于类型为 string 或 []byte 的变量，其 //go:embed 行只能有一个模式，且该模式只能匹配单个文件。字符串或字节切片将用该文件的内容初始化。\n\n即使使用 string 或 []byte 类型，//go:embed 指令也需要导入 \"embed\"。在不引用 [embed.FS] 的源文件中，应使用空白导入（import _ \"embed\"）。\n\n# 文件系统\n\n对于嵌入单个文件，通常使用 string 或 []byte 类型的变量最为合适。[FS] 类型支持嵌入文件树，例如上述示例中的静态 Web 服务器内容目录。\n\nFS 实现了 [io/fs] 包的 [FS] 接口，因此可与任何理解文件系统的包一起使用，包括 [net/http]、[text/template] 和 [html/template]。\n\n例如，基于上述示例中的 content 变量，我们可以编写：\n\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(content))))\n\n\ttemplate.ParseFS(content, \"*.tmpl\")\n\n# 工具\n\n为了支持分析 Go 包的工具，//go:embed 行中发现的模式可在 “go list” 输出中获取。参见 “go help list” 输出中的 EmbedPatterns、TestEmbedPatterns 和 XTestEmbedPatterns 字段。",
  "embed/internal/embedtest": "[zh]包 embedtest",
  "encoding": "[zh]包 encoding：encoding 包定义了由其他包共享的接口，这些包用于在字节级和文本表示形式之间转换数据。\n检查这些接口的包包括 encoding/gob、encoding/json 和 encoding/xml。因此，实现一次接口即可使某个类型在多种编码中可用。\n标准库中实现这些接口的类型包括 time.Time 和 net.IP。\n这些接口成对出现，分别用于生成和解析编码后的数据。\n\n为现有类型添加编码/解码方法可能构成破坏性变更，因为它们可能被用于与使用不同库版本编写的程序进行通信时的序列化。\nGo 项目维护的包的策略是，仅当不存在现有且合理的序列化方式时，才允许添加序列化函数。",
  "encoding/ascii85": "[zh]包 ascii85：实现用于 btoa 工具以及 Adobe 的 PostScript 和 PDF 文档格式中的 ascii85 数据编码。",
  "encoding/asn1": "[zh]包 asn1：asn1 包实现了 ITU-T Rec X.690 中定义的 DER 编码 ASN.1 数据结构的解析。\n\n另见《ASN.1、BER 和 DER 子集的通俗指南》，\nhttp://luca.ntop.org/Teaching/Appunti/asn1.html。",
  "encoding/base32": "[zh]包 base32：base32 包实现了 RFC 4648 规范中定义的 base32 编码。",
  "encoding/base64": "[zh]包 base64：base64 包实现了 RFC 4648 规范中定义的 base64 编码。",
  "encoding/binary": "[zh]包 binary：binary 包实现了数字与字节序列之间的简单转换，以及变长整数（varints）的编码和解码。\n\n数值通过读取和写入固定大小的值进行转换。固定大小的值是指固定长度的算术类型（如 bool、int8、uint8、int16、float32、complex64 等），或是仅包含固定大小值的数组或结构体。\n\n变长整数函数使用变长编码方式对单个整数值进行编码和解码；数值越小，所需字节数越少。具体规范见：\nhttps://developers.google.com/protocol-buffers/docs/encoding。\n\n本包以简洁性优先于效率。对于需要高性能序列化的客户端，尤其是处理大型数据结构时，应考虑更高级的解决方案，例如 [encoding/gob] 包或 [google.golang.org/protobuf] 协议缓冲区库。",
  "encoding/csv": "[zh]包 csv：csv 包用于读取和写入逗号分隔值（CSV）文件。\n存在多种类型的 CSV 文件；本包支持 RFC 4180 中定义的格式，\n但 [Writer] 默认使用 LF 而非 CRLF 作为换行符。\n\n一个 CSV 文件包含零个或多个记录，每个记录包含一个或多个字段。\n每条记录以换行符分隔。最后一条记录末尾可选择性地包含换行符。\n\n\tfield1,field2,field3\n\n空白字符视作字段的一部分。\n\n换行符前的回车符将被静默移除。\n\n空行将被忽略。仅包含空白字符（不包括结尾换行符）的行不被视为空行。\n\n以引号字符 \" 开始并结束的字段称为引用字段（quoted-field）。起始和结束的引号不属于字段内容。\n\n例如：\n\n\tnormal string,\"quoted-field\"\n\n解析为字段\n\n\t{`normal string`, `quoted-field`}\n\n在引用字段中，一个引号字符后紧跟另一个引号字符时，表示该引号为字段内的单个引号。\n\n\t\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\n解析为\n\n\t{`the \"word\" is true`, `a \"quoted-field\"`}\n\n引用字段中可包含换行符和逗号。\n\n\t\"Multi-line\n\tfield\",\"comma is ,\"\n\n解析为\n\n\t{`Multi-line\n\tfield`, `comma is ,`}",
  "encoding/hex": "[zh]包 hex：hex 包实现了十六进制的编码和解码。",
  "encoding/json": "[zh]包 json：本包实现了 RFC 7159 中定义的 JSON 编码与解码。  \nJSON 与 Go 值之间的映射关系在 Marshal 和 Unmarshal 函数的文档中描述。\n\n有关此包的介绍，请参阅“JSON 和 Go”：  \nhttps://golang.org/doc/articles/json_and_go.html\n\n# 安全性考虑\n\nJSON 标准（RFC 7159）对解析器行为的许多定义较为宽松。因此，许多 JSON 解析器在各种场景下的行为各不相同。这些解析器之间的差异意味着使用多个独立 JSON 解析器实现的系统可能会以不同方式解析同一 JSON 对象。\n\n依赖 JSON 对象被一致解析以实现安全目的的系统应谨慎理解本解析器的行为，并了解这些行为可能与其他解析器实现产生的互操作性问题。\n\n由于 Go 的向后兼容性承诺（https://go.dev/doc/go1compat），本包存在一些可能导致互操作性问题的行为，但无法更改。特别是以下解析行为可能引发问题：\n\n  - 如果 JSON 对象包含重复的键，则按键出现的顺序处理，后出现的值将替换或合并到先前的值中，具体取决于字段类型（特别是映射和结构体的值会被合并，而其他类型则被替换）。\n  - 将 JSON 对象解析为 Go 结构体时，键的匹配不区分大小写。\n  - 将 JSON 对象解析为 Go 结构体时，JSON 对象中的未知键将被忽略（除非使用了 [Decoder] 并调用了 [Decoder.DisallowUnknownFields]）。\n  - JSON 字符串中的无效 UTF-8 字节将被 Unicode 替换字符替代。\n  - 解组大型 JSON 数字整数到浮点类型时会丢失精度。",
  "encoding/pem": "[zh]包 pem：实现源于隐私增强邮件（Privacy Enhanced Mail）的 PEM 数据编码。如今 PEM 编码最常见的用途是 TLS 密钥和证书。参见 RFC 1421。",
  "encoding/xml": "[zh]包 xml：xml 包实现了一个简单的 XML 1.0 解析器，支持 XML 命名空间。",
  "errors": "[zh]包 errors：errors 包实现了操作错误的函数。\n\n[New] 函数创建仅包含文本消息的错误。\n\n如果一个错误 e 的类型具有以下方法之一，则称 e 包装了另一个错误：\n\n\tUnwrap() error\n\tUnwrap() []error\n\n如果 e.Unwrap() 返回一个非 nil 的错误 w 或包含 w 的切片，则称 e 包装了 w。\n若 e.Unwrap() 返回 nil 错误，表示 e 不包装任何错误。Unwrap 方法返回包含 nil 错误值的 []error 是无效的。\n\n创建包装错误的简便方法是调用 [fmt.Errorf] 并对错误参数使用 %w 动词：\n\n\twrapsErr := fmt.Errorf(\"... %w ...\", ..., err, ...)\n\n连续解包一个错误会形成一棵树。[Is] 和 [As] 函数通过先检查错误本身，再依次检查其每个子节点的树（前序、深度优先遍历）来检查错误的树结构。\n\n详见 https://go.dev/blog/go1.13-errors 以深入了解包装的设计理念及使用时机。\n\n[Is] 检查其第一个参数的错误树，查找与第二个参数匹配的错误。若找到匹配项则返回 true。应优先使用 [Is] 而非简单的等值比较：\n\n\tif errors.Is(err, fs.ErrExist)\n\n优于\n\n\tif err == fs.ErrExist\n\n因为前者在 err 包装了 [io/fs.ErrExist] 时仍能成功。\n\n[As] 检查其第一个参数的错误树，查找能否将其赋值给第二个参数，该参数必须是一个指针。若成功，则执行赋值并返回 true；否则返回 false。如下形式：\n\n\tvar perr *fs.PathError\n\tif errors.As(err, \u0026perr) {\n\t\tfmt.Println(perr.Path)\n\t}\n\n优于\n\n\tif perr, ok := err.(*fs.PathError); ok {\n\t\tfmt.Println(perr.Path)\n\t}\n\n因为前者在 err 包装了 [*io/fs.PathError] 时仍能成功。",
  "expvar": "[zh]包 expvar：expvar 包为公共变量（例如服务器中的操作计数器）提供了标准化的接口。它通过 HTTP 在 /debug/vars 路径以 JSON 格式公开这些变量。从 Go 1.22 开始，/debug/vars 请求必须使用 GET 方法。\n\n对这些公共变量进行设置或修改的操作是原子的。\n\n除了注册 HTTP 处理程序外，该包还注册以下变量：\n\n\tcmdline   os.Args\n\tmemstats  runtime.Memstats\n\n此包有时仅为了注册其 HTTP 处理程序和上述变量而被导入。要以这种方式使用，需将该包链接到程序中：\n\n\timport _ \"expvar\"",
  "flag": "[zh]包 flag：flag 包实现了命令行标志的解析。\n\n# 用法\n\n使用 [flag.String]、[Bool]、[Int] 等函数定义标志。\n\n以下声明一个整型标志 -n，存储在指针 nFlag 中，类型为 *int：\n\n\timport \"flag\"\n\tvar nFlag = flag.Int(\"n\", 1234, \"help message for flag n\")\n\n你也可以使用 Var() 函数将标志绑定到变量。\n\n\tvar flagvar int\n\tfunc init() {\n\t\tflag.IntVar(\u0026flagvar, \"flagname\", 1234, \"help message for flagname\")\n\t}\n\n或者创建满足 Value 接口（需使用指针接收者）的自定义标志，并通过以下方式关联到标志解析：\n\n\tflag.Var(\u0026flagVal, \"name\", \"help message for flagname\")\n\n对于此类标志，默认值即为变量的初始值。\n\n在所有标志定义完成后，调用\n\n\tflag.Parse()\n\n以将命令行参数解析到已定义的标志中。\n\n之后可直接使用这些标志。若使用标志本身，它们均为指针；若绑定到了变量，则为值。\n\n\tfmt.Println(\"ip has value \", *ip)\n\tfmt.Println(\"flagvar has value \", flagvar)\n\n解析后，标志后的参数可通过切片 [flag.Args] 访问，或通过 [flag.Arg](i) 单独访问。\n参数索引范围为 0 到 [flag.NArg]-1。\n\n# 命令行标志语法\n\n允许以下形式：\n\n\t-flag\n\t--flag   // 双破折号也是允许的\n\t-flag=x\n\t-flag x  // 仅适用于非布尔标志\n\n可使用一个或两个连字符，二者等价。\n布尔标志不允许最后一种形式，因为当存在名为 0、false 等的文件时，如下命令的含义会改变：\n\n\tcmd -x *\n\n必须使用 -flag=false 形式来关闭布尔标志。\n\n标志解析在第一个非标志参数前停止（\"-\" 是非标志参数），或在终止符 \"--\" 后停止。\n\n整数标志接受 1234、0664、0x1234 格式，且可以为负数。\n布尔标志可接受：\n\n\t1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\n\nDuration 标志接受任何对 time.ParseDuration 有效的输入。\n\n默认的命令行标志集合由顶层函数控制。[FlagSet] 类型允许定义独立的标志集合，\n例如用于实现命令行界面中的子命令。[FlagSet] 的方法与顶层命令行标志集的函数类似。",
  "go/ast": "[zh]包 ast：ast 包声明了用于表示 Go 包语法树的类型。\n\n语法树可以直接构造，但通常由解析器从 Go 源代码生成；参见 go/parser 包中的 ParseFile 函数。",
  "go/build": "[zh]包 build：build 包用于收集 Go 包的相关信息。\n\n# 构建约束\n\n构建约束（也称为构建标签）是决定文件是否应包含在包中的条件。构建约束通过以如下开头的行注释指定：\n\n\t//go:build\n\n构建约束也可体现在文件名中\n（例如，source_windows.go 只有在目标操作系统为 Windows 时才会被包含）。\n\n详情参见 'go help buildconstraint'\n(https://pkg.go.dev/cmd/go#hdr-Build_constraints)。\n\n# Go 路径\n\nGo 路径是一个包含 Go 源代码的目录树列表，用于解析在标准 Go 树中找不到的导入。默认路径为 GOPATH 环境变量的值，其格式依操作系统而定\n（在 Unix 系统上，该变量为冒号分隔的字符串；\n在 Windows 上，为分号分隔的字符串；\n在 Plan 9 上，为列表）。\n\nGo 路径中列出的每个目录必须具有规定的结构：\n\nsrc/ 目录存放源代码。src 下的路径决定了导入路径或可执行文件名称。\n\npkg/ 目录存放已安装的包对象。与 Go 树类似，每个目标操作系统和体系结构组合都有其独立的 pkg 子目录\n（如 pkg/GOOS_GOARCH）。\n\n如果 DIR 是 Go 路径中列出的目录，则源码位于 DIR/src/foo/bar 的包可以被导入为 \"foo/bar\"，其编译后的形式将安装到 \"DIR/pkg/GOOS_GOARCH/foo/bar.a\"\n（对于 gccgo，则为 \"DIR/pkg/gccgo/foo/libbar.a\"）。\n\nbin/ 目录存放已编译的命令。每个命令以其源码目录的最后一个元素命名，而非整个路径。也就是说，源码位于 DIR/src/foo/quux 的命令将被安装到 DIR/bin/quux，而不是 DIR/bin/foo/quux。去掉 foo/ 是为了让你可以将 DIR/bin 添加到 PATH 中，从而直接使用已安装的命令。\n\n以下是一个目录结构示例：\n\n\tGOPATH=/home/user/gocode\n\n\t/home/user/gocode/\n\t    src/\n\t        foo/\n\t            bar/               (包 bar 的 Go 代码)\n\t                x.go\n\t            quux/              (包 main 的 Go 代码)\n\t                y.go\n\t    bin/\n\t        quux                   (已安装的命令)\n\t    pkg/\n\t        linux_amd64/\n\t            foo/\n\t                bar.a          (已安装的包对象)\n\n# 二进制形式包\n\n在 Go 1.12 及更早版本中，可以仅分发包的二进制形式而不包含用于编译该包的源代码。此类包随附一个未被构建约束排除的源文件，且该文件包含 \"//go:binary-only-package\" 注释。与构建约束类似，此注释位于文件顶部，前面只能有空行和其他行注释，并在其后紧跟一个空行，以与包文档分隔。不同于构建约束的是，此注释仅在非测试的 Go 源文件中被识别。\n\n因此，一个二进制形式包的最小源代码为：\n\n\t//go:binary-only-package\n\n\tpackage mypkg\n\n源代码中可包含额外的 Go 代码。这些代码不会被编译，但会被 godoc 等工具处理，可能作为面向用户的文档有用。\n\n\"go build\" 及其他命令不再支持二进制形式包。\n[Import] 和 [ImportDir] 在处理包含此类注释的包时仍会设置 BinaryOnly 标志，供工具和错误消息使用。",
  "go/build/constraint": "[zh]包 constraint：constraint 包实现了构建约束行的解析与求值。  \n关于构建约束本身的文档，请参见 https://golang.org/cmd/go/#hdr-Build_constraints。\n\n该包支持解析原有的 “// +build” 语法以及 Go 1.17 引入的 “//go:build” 语法。  \n有关 “//go:build” 语法的详细信息，请参见 https://golang.org/design/draft-gobuild。",
  "go/constant": "[zh]包 constant：包 constant 实现了表示无类型 Go 常量的值及其对应操作。\n\n当由于错误导致值未知时，可使用特殊的 Unknown 值。对未知值进行的操作会生成未知值，除非另有规定。",
  "go/doc": "[zh]包 doc：包 doc 从 Go 抽象语法树（AST）中提取源代码文档。",
  "go/doc/comment": "[zh]包注释：包 comment 实现了 Go 文档注释（documentation comments）的解析与重新格式化，这些注释位于包、常量、函数、类型或变量的顶层声明之前。\n\nGo 文档注释语法是 Markdown 的简化子集，支持链接、标题、段落、列表（不支持嵌套）以及预格式化的文本块。语法细节详见 https://go.dev/doc/comment。\n\n要解析与文档注释关联的文本（去除注释标记后），可使用 [Parser]：\n\n\tvar p comment.Parser\n\tdoc := p.Parse(text)\n\n结果为一个 [*Doc]。要将其重新格式化为文档注释、HTML、Markdown 或纯文本，可使用 [Printer]：\n\n\tvar pr comment.Printer\n\tos.Stdout.Write(pr.Text(doc))\n\n[Parser] 和 [Printer] 类型是结构体，其字段可修改以自定义操作行为。详细信息请参阅对应类型的文档。\n\n对于需要更精细控制重新格式化的使用场景，可通过检查已解析的语法结构本身来实现自定义逻辑。有关概述及更多类型的链接，请参阅 [Doc]、[Block]、[Text] 的文档。",
  "go/format": "[zh]包 format：format 包实现了 Go 源码的标准格式化。\n\n请注意，Go 源代码的格式化会随着时间变化，因此依赖一致格式化的工具应当执行特定版本的 gofmt 二进制文件，而不是使用此包。这样可以确保格式化结果稳定，且在 gofmt 发生变更时无需重新编译工具。\n\n例如，直接使用此包的预提交检查会因开发者使用的 Go 版本不同而表现不一致，导致检查本身具有内在的脆弱性。",
  "go/importer": "[zh]包 importer：importer 包提供了对导出数据导入器的访问。\n\n这些函数大多已弃用，起源于 Go 1.11 版本引入模块之前。除依赖标准库的小型程序在测试用例中使用外，不应再依赖这些函数。如需可靠的支持模块的类型信息加载，请使用 golang.org/x/tools/go/packages 中的 packages.Load 函数。",
  "go/internal/gccgoimporter": "[zh]包 gccgoimporter：gccgoimporter 包为 gccgo 生成的目标文件实现 Import。",
  "go/internal/gcimporter": "[zh]包 gcimporter：gcimporter 包为 gc 生成的目标文件实现 Import。",
  "go/internal/srcimporter": "[zh]包 srcimporter：srcimporter 包实现直接从源文件导入，而非从已安装的包中导入。",
  "go/parser": "[zh]包 parser：parser 包实现了 Go 源文件的解析器。\n\n[ParseFile] 函数从字符串、[]byte 或 io.Reader 中读取文件输入，并生成表示该文件完整抽象语法树的 [ast.File]。\n\n[ParseExprFrom] 函数读取单个源级表达式，并生成该表达式的语法树 [ast.Expr]。\n\n为简化处理并提高在存在语法错误时的健壮性，该解析器接受的语言范围比 Go 语言规范所允许的更广。例如，在方法声明中，接收者被当作普通参数列表处理，因此可能包含多个条目，而规范仅允许恰好一个。因此，AST 中对应的字段（ast.FuncDecl.Recv）不限制为仅一个条目。\n\n需要解析一个或多个完整的 Go 源代码包的应用程序可能会发现，使用 [golang.org/x/tools/go/packages] 包中的 Load 函数比直接与解析器交互更为方便。",
  "go/printer": "[zh]包 printer：printer 包实现了 AST 节点的打印。",
  "go/scanner": "[zh]包 scanner：scanner 包为 Go 源码文本实现了一个扫描器。\n它将一个 []byte 作为源，然后通过重复调用 Scan 方法进行分词。",
  "go/token": "[zh]包 token：token 包定义了表示 Go 编程语言词法标记的常量，以及对标记的基本操作（打印、谓词）。",
  "go/types": "[zh]包 types：包 types 定义了数据类型，并实现了 Go 包的类型检查算法。使用 [Config.Check] 对包进行类型检查。或者，使用 [NewChecker] 创建一个新的类型检查器，并通过调用 [Checker.Files] 增量地执行检查。\n\n类型检查包含多个相互关联的阶段：\n\n名称解析将程序中的每个标识符（[ast.Ident]）映射到其所表示的符号（[Object]）。使用 [Info] 的 Defs 和 Uses 字段，或 [Info.ObjectOf] 方法来查找标识符对应的符号，并使用 [Info] 的 Implicits 字段查找某些其他语法节点对应的符号。\n\n常量折叠计算每一个编译期常量表达式（[ast.Expr]）的精确常量值（[constant.Value]）。使用 [Info] 的 Types 字段获取表达式的常量折叠结果。\n\n类型推导计算每个表达式（[ast.Expr]）的类型（[Type]），并检查其是否符合语言规范。使用 [Info] 的 Types 字段获取类型推导的结果。\n\n需要对一个或多个完整的 Go 源码包进行类型检查的应用程序，可能更方便的做法不是直接调用类型检查器，而是使用 [golang.org/x/tools/go/packages] 包中的 Load 函数。\n\n教程详见 https://go.dev/s/types-tutorial。",
  "go/version": "[zh]包 version：version 包提供了对 [Go 版本] 的操作，这些版本采用 [Go 工具链名称语法]，例如 \"go1.20\"、\"go1.21.0\"、\"go1.22rc2\" 和 \"go1.23.4-bigcorp\"。\n\n[Go 版本]: https://go.dev/doc/toolchain#version\n[Go 工具链名称语法]: https://go.dev/doc/toolchain#name",
  "hash": "[zh]包 hash：hash 包提供了哈希函数的接口。",
  "hash/adler32": "[zh]包 adler32：adler32 包实现了 Adler-32 校验和。\n\n其定义见 RFC 1950：\n\n\tAdler-32 由每字节累加的两个和组成：s1 是所有字节的和，s2 是所有 s1 值的和。两个和均对 65521 取模。s1 初始值为 1，s2 初始值为 0。Adler-32 校验和以 s2*65536 + s1 的形式存储，按最高位字节在前（网络）顺序。",
  "hash/crc32": "[zh]包 crc32：crc32 包实现了 32 位循环冗余校验（CRC-32）校验和。相关信息请参见 https://en.wikipedia.org/wiki/Cyclic_redundancy_check。\n\n多项式采用 LSB 优先形式表示，也称为反转表示法。\n\n更多信息请参见 https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials。",
  "hash/crc64": "[zh]包 crc64 实现了64位循环冗余校验（CRC-64）校验和。更多信息请参见 https://en.wikipedia.org/wiki/Cyclic_redundancy_check。",
  "hash/fnv": "[zh]包 fnv：本包实现了由 Glenn Fowler、Landon Curt Noll 和 Phong Vo 创建的 FNV-1 和 FNV-1a 非加密哈希函数。\n参见\nhttps://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function。\n\n本包返回的所有 hash.Hash 实现均同时实现了 encoding.BinaryMarshaler 和 encoding.BinaryUnmarshaler，\n用于对哈希的内部状态进行序列化和反序列化。",
  "hash/maphash": "[zh]包 maphash：maphash 包提供对字节序列和可比较值的哈希函数。  \n这些哈希函数旨在用于实现哈希表或其它需要将任意字符串或字节序列映射到无符号 64 位整数均匀分布的数据结构。  \n每个不同的哈希表或数据结构实例都应使用其自身的 [Seed]。\n\n这些哈希函数不具备密码学安全性。  \n（密码学用途请参见 crypto/sha256 和 crypto/sha512。）",
  "html": "[zh]包 html：html 包提供了用于转义和反转义 HTML 文本的函数。",
  "image": "[zh]包 image：image 包实现了一个基本的二维图像库。\n\n核心接口是 [Image]。[Image] 包含颜色，颜色由 image/color 包定义。\n\n[Image] 接口的值可通过调用 [NewRGBA] 和 [NewPaletted] 等函数创建，或通过对包含 GIF、JPEG 或 PNG 等格式图像数据的 [io.Reader] 调用 [Decode] 创建。解码特定图像格式需要预先注册解码函数。注册通常作为初始化对应格式包的副作用自动完成，因此要解码 PNG 图像，只需在程序主包中包含：\n\n\timport _ \"image/png\"\n\n其中 _ 表示仅出于初始化副作用而导入包。\n\n更多细节请参见《Go 图像包》：\nhttps://golang.org/doc/articles/image_package.html\n\n# 安全性考虑\n\nimage 包可用于解析任意大的图像，可能导致内存不足的机器资源耗尽。在处理任意图像时，应先调用 [DecodeConfig]，再调用 [Decode]，以便程序可根据返回的头部信息判断该图像是否可在可用资源下安全解码。对于 [DecodeConfig] 返回的头部所定义的极大图像，调用 [Decode] 产生如此大图像不被视为安全问题，无论该图像本身是否损坏。若 [DecodeConfig] 返回的头部与 [Decode] 返回的图像不一致，可能构成安全问题，应根据 [Go 安全政策](https://go.dev/security/policy) 进行报告。",
  "image/color": "[zh]包 color：color 包实现了一个基本的颜色库。",
  "image/color/palette": "[zh]包 palette：palette 包提供标准的颜色调色板。",
  "image/draw": "[zh]包 draw：draw 包提供图像合成函数。\n\n有关此包的介绍，请参见“Go image/draw 包”：\nhttps://golang.org/doc/articles/image_draw.html",
  "image/gif": "[zh]包 gif：gif 包实现了 GIF 图像的解码器和编码器。\n\nGIF 规范位于 https://www.w3.org/Graphics/GIF/spec-gif89a.txt。",
  "image/internal/imageutil": "[zh]包 imageutil：imageutil 包包含与图像相关的包所共享的代码。",
  "image/jpeg": "[zh]包 jpeg：jpeg 包实现了 JPEG 图像的解码器和编码器。\n\nJPEG 定义于 ITU-T T.81：https://www.w3.org/Graphics/JPEG/itu-t81.pdf。",
  "image/png": "[zh]包 png：Package png 实现了 PNG 图像的解码器和编码器。\n\nPNG 规范位于 https://www.w3.org/TR/PNG/。",
  "index/suffixarray": "[zh]包 suffixarray：suffixarray 包通过内存中的后缀数组实现对子字符串的对数时间搜索。\n\n使用示例：\n\n\t// 为某些数据创建索引\n\tindex := suffixarray.New(data)\n\n\t// 查找字节切片 s\n\toffsets1 := index.Lookup(s, -1) // s 在 data 中出现的所有索引列表\n\toffsets2 := index.Lookup(s, 3)  // s 在 data 中出现的最多 3 个索引的列表",
  "internal/abi": "[zh]包 abi",
  "internal/asan": "[zh]包 asan：包 asan 包含用于手动为地址 sanitizer 插桩代码的辅助函数。\nruntime 包仅在 asan 构建时有意导出这些函数；此包无条件导出它们，但在没有 \"asan\" 构建标签时，这些函数为空操作。",
  "internal/buildcfg": "[zh]包 buildcfg：buildcfg 包提供了对当前环境所描述的构建配置的访问。供构建工具（如 cmd/go 或 cmd/compile）以及设置 go/build 的 Default 上下文时使用。\n\n注意，它并不提供对用于构建当前运行二进制文件的构建配置的访问。对于该用途，请使用 runtime.GOOS 等以及 internal/goexperiment。",
  "internal/bytealg": "[zh]包 bytealg",
  "internal/byteorder": "[zh]包 byteorder：byteorder 包提供了从字节切片解码和编码小端和大端整数类型的功能。",
  "internal/cfg": "[zh]包 cfg：cfg 包包含 Go 命令和 internal/testenv 共享的配置。  \n不需要在 cmd/go 外部暴露的定义应放在 cmd/go/internal/cfg 中，而非此包。",
  "internal/chacha8rand": "[zh]包 chacha8rand：chacha8rand 包实现了一个基于 ChaCha8 的伪随机数生成器。它被运行时和 math/rand/v2 共同使用，且必须具有最少的依赖。",
  "internal/copyright": "[zh]包 copyright",
  "internal/coverage": "[zh]包 coverage",
  "internal/coverage/calloc": "[zh]包 calloc",
  "internal/coverage/cfile": "[zh]包 cfile：cfile 包实现覆盖率文件的管理。\n它提供了 runtime/coverage 中导出的功能，以及通过 testing/internal/testdeps 被 testing 包直接使用的附加功能。",
  "internal/coverage/cformat": "[zh]包 cformat",
  "internal/coverage/cmerge": "[zh]包 cmerge",
  "internal/coverage/decodecounter": "[zh]包 decodecounter",
  "internal/coverage/decodemeta": "[zh]包 decodemeta",
  "internal/coverage/encodecounter": "[zh]包 encodecounter",
  "internal/coverage/encodemeta": "[zh]包 encodemeta",
  "internal/coverage/pods": "[zh]包 pods",
  "internal/coverage/rtcov": "[zh]包 rtcov",
  "internal/coverage/slicereader": "[zh]包 slicereader",
  "internal/coverage/slicewriter": "[zh]包 slicewriter",
  "internal/coverage/stringtab": "[zh]包 stringtab",
  "internal/coverage/test": "[zh]包 test",
  "internal/coverage/uleb128": "[zh]包 uleb128",
  "internal/cpu": "[zh]包 cpu：cpu 包实现了 Go 标准库所用的处理器特性检测。",
  "internal/dag": "[zh]包 dag：dag 包实现了一种用于表达有向无环图的语言。\n\n规则的一般语法为：\n\n\ta, b \u003c c, d;\n\n表示在偏序关系中，c 和 d 位于 a 和 b 之后（即从 c 和 d 分别有边指向 a 和 b），\n但 a 与 b 之间以及 c 与 d 之间没有相对顺序。\n\n规则可以链式书写，例如：\n\n\te \u003c f, g \u003c h;\n\n等价于\n\n\te \u003c f, g;\n\tf, g \u003c h;\n\n除特殊底元素 \"NONE\" 外，每个名称必须且只能出现在某条规则的右侧一次。\n该规则即定义了该名称的合法后继。\n此定义必须出现在该名称作为规则左侧项被使用之前。（即规则本身需按照偏序排列，以便人类阅读。）\n\n否定断言用于验证偏序关系：\n\n\ti !\u003c j\n\n表示 i \u003c j 必须不成立。否定断言可出现在规则中的任意位置，即使在 i 和 j 被定义之前也可出现。\n\n注释以 # 开始。",
  "internal/diff": "[zh]包 diff",
  "internal/exportdata": "[zh]包 exportdata：exportdata 包实现了用于查找和读取 gc 生成的目标文件的常用工具。",
  "internal/filepathlite": "[zh]包 filepathlite：filepathlite 包实现了 path/filepath 的一个子集，仅使用可被 \"os\" 导入的包。\n\n这些函数的测试位于 path/filepath 中。",
  "internal/fmtsort": "[zh]包 fmtsort：fmtsort 包为映射提供了一种通用的稳定排序机制，供 fmt 和 text/template 包使用。该机制不保证高效，且仅适用于可作为映射键的有效类型。",
  "internal/fuzz": "[zh]包 fuzz：包 fuzz 为使用 \"go test\" 构建的测试以及使用 testing 包中模糊测试功能的程序提供常见的模糊测试功能。",
  "internal/goarch": "[zh]包 goarch：goarch 包含特定于 GOARCH 的常量。",
  "internal/godebug": "[zh]包 godebug：godebug 包使 $GODEBUG 环境变量中的设置可用于其他包。这些设置通常用于兼容性调整，当我们需要更改默认行为但希望允许用户选择恢复为原始行为时使用。例如 GODEBUG=http2server=0 会禁用 net/http 服务器中的 HTTP/2 支持。\n\n在典型用法中，代码应将 Setting 声明为全局变量，然后每次需要当前设置值时调用 Value：\n\n\tvar http2server = godebug.New(\"http2server\")\n\n\tfunc ServeConn(c net.Conn) {\n\t\tif http2server.Value() == \"0\" {\n\t\t\t禁用 HTTP/2\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n\n每当非默认设置导致程序行为发生变化时，代码必须调用 [Setting.IncNonDefault] 以增加一个可由 [runtime/metrics.Read] 报告的计数器。该调用仅应在程序执行非默认行为时发生，而不仅仅是在设置被设为非默认值时。这种情况偶尔（但极为罕见）不可行，此时 internal/godebugs 表中的条目必须设置 Opaque: true，且 doc/godebug.md 中的文档应注明指标不可用。\n\n按照惯例，表示 godebug 的全局变量应以 godebug 本身的名称命名，不改变大小写：\n\n\tvar gotypesalias = godebug.New(\"gotypesalias\") // 此种方式\n\tvar goTypesAlias = godebug.New(\"gotypesalias\") // 非此种方式\n\ninternal/godebugs 中检查 IncNonDefault 使用情况的测试要求采用此命名约定。\n\n注意，与 IncNonDefault 一起使用的计数器必须添加到其他包中的各种表中。详见 [Setting.IncNonDefault] 文档。",
  "internal/godebugs": "[zh]包 godebugs：godebugs 包提供了一个已知 GODEBUG 配置项的表格，供多个其他包使用，包括 internal/godebug、runtime、runtime/metrics 和 cmd/go/internal/load。",
  "internal/goexperiment": "[zh]包 goexperiment：goexperiment 包实现了对工具链实验的支持。\n\n工具链实验由 GOEXPERIMENT 环境变量控制。GOEXPERIMENT 是一个以逗号分隔的实验名称列表。GOEXPERIMENT 可在运行 make.bash 时设置，这将设定使用该工具链构建的二进制文件的默认实验；也可以在构建时设置。GOEXPERIMENT 还可设为 \"none\"，以禁用在 make.bash 时启用的任何实验。\n\n实验通过以下方式向构建过程暴露：\n\n  - 若启用了实验 x（小写），则设置构建标签 goexperiment.x。\n\n  - 对于每个实验 x（驼峰命名），本包包含一个布尔常量 x 和一个整型常量 xInt。\n\n  - 在运行时汇编中，若启用了实验 x（小写），则定义宏 GOEXPERIMENT_x。\n\n在工具链中，应通过 objabi.Experiment 获取当前构建所启用的实验集合。\n\n若启用的实验集合与默认实验不同，则会将其包含在 [runtime.Version]() 的输出以及 \"go version \u003cbinary\u003e\" 中。\n\n有关当前工具链支持的实验列表，请参阅 \"go doc goexperiment.Flags\"。\n\n注意，此包定义了实验集合（在 [Flags] 中），并记录了编译此包时启用的实验（作为布尔值和整型常量）。\n\n尤其需要注意的是，此包本身不会根据 GOEXPERIMENT 环境变量在运行时改变行为。用于构建过程中解析 GOEXPERIMENT 变量的代码位于独立的包 [internal/buildcfg] 中。",
  "internal/goos": "[zh]包 goos：包 goos 包含特定于 GOOS 的常量。",
  "internal/goroot": "[zh]包 goroot",
  "internal/gover": "[zh]包 gover：gover 包提供对 Go 工具链版本（如 1.21.0 和 1.21rc1）的支持。\n（由于历史原因，Go 的工具链未使用语义化版本控制。）\n此包提供的基本分析功能与 golang.org/x/mod/semver 对语义化版本所提供的功能相同。\n\n应优先导入 go/version 包而非此包。\n注意，此包处理的是 \"1.21\" 格式，而 go/version 处理的是 \"go1.21\" 格式。",
  "internal/goversion": "[zh]包 goversion",
  "internal/itoa": "[zh]包 itoa",
  "internal/lazyregexp": "[zh]包 lazyregexp：lazyregexp 是对 regexp 的轻量封装，允许使用全局正则表达式变量，而无需在初始化时强制编译。",
  "internal/lazytemplate": "[zh]包 lazytemplate：lazytemplate 包是 text/template 的一个轻量封装，允许使用全局模板变量，同时避免在初始化时强制解析它们。",
  "internal/msan": "[zh]包 msan：msan 包包含用于为内存检测器手动插桩代码的辅助函数。\n此包无条件导出运行时中的私有 msan 例程，但在没有 \"msan\" 构建标签时，这些例程为空操作。",
  "internal/nettrace": "[zh]包 nettrace：nettrace 包包含用于跟踪 net 包中活动的内部钩子。此包仅供 net/http/httptrace 包内部使用，对最终用户不提供稳定的 API。",
  "internal/obscuretestdata": "[zh]包 obscuretestdata：obscuretestdata 包包含测试所用的功能，用于更方便地处理必须被模糊化的测试数据，主要原因是 golang.org/issue/34986。",
  "internal/oserror": "[zh]包 oserror：oserror 包定义了 os 包中使用的错误值。\n\n这些类型在此定义，以便 syscall 包能够引用它们。",
  "internal/pkgbits": "[zh]包 pkgbits：pkgbits 包实现了统一中间表示（UIR）二进制导出数据格式的低级编码抽象。\n\n在底层，包的导出对象被编码为字节数组。该数组包含基本类型的字节表示，这些类型可能是变长的，例如整数、布尔值、字符串和常量。\n\n此外，数组可能包含表示字节数组自身索引的值。这些值称为“重定位”，用于实现引用。\n\n将高级 Go 结构映射为基本类型的细节由其他包负责。",
  "internal/platform": "[zh]包 platform",
  "internal/poll": "[zh]包 poll：poll 包通过轮询支持文件描述符的非阻塞 I/O。\n它支持仅阻塞 goroutine 而非线程的 I/O 操作。\nnet 和 os 包使用此包。\n它使用运行时内置的轮询器，并得到运行时调度器的支持。",
  "internal/profile": "[zh]包 profile：Package profile 将 pprof 配置文件表示为有向图。\n\n此包是 github.com/google/pprof/internal/graph 的简化分支。",
  "internal/profilerecord": "[zh]包 profilerecord：profilerecord 包包含用于表示具有深层堆栈跟踪的性能分析记录的内部类型。\n\nTODO：考虑将其移至 internal/runtime，参见 golang.org/issue/65355。",
  "internal/race": "[zh]包 race：race 包包含用于手动为竞态检测器插桩代码的辅助函数。\n\nruntime 包仅在启用竞态检测构建时导出这些函数；此包无条件导出它们，但在没有 \"race\" 构建标签时，这些函数为空操作。",
  "internal/reflectlite": "[zh]包 reflectlite：包 reflectlite 实现了反射的轻量级版本，仅使用 \"runtime\"、\"unsafe\" 和 \"internal/abi\" 包。",
  "internal/routebsd": "[zh]包 routebsd：routebsd 包支持在 BSD 系统上读取接口地址。\n这是 x/net/route 的一个极简版本，供标准库中的 net 包使用。",
  "internal/runtime/atomic": "[zh]包 atomic：该包为运行时提供原子操作，独立于 sync/atomic。\n\n在大多数平台上，编译器知晓此包中定义的函数，并将其替换为特定于平台的内在函数。在其他平台上，则提供通用实现。\n\n除非另有说明，本包中定义的操作对于其所操作的值，在跨线程环境下具有顺序一致性。更具体地说，一个线程中按特定顺序发生的操作，总能被另一个线程观察到以完全相同的顺序发生。",
  "internal/runtime/cgroup": "[zh]包 cgroup",
  "internal/runtime/exithook": "[zh]包 exithook：exithook 包为退出时清理提供有限支持。\n\n注意！预期 Add 仅从安全上下文中调用（例如，非错误/恐慌路径或信号处理程序，允许抢占、分配和写屏障等），且退出函数 F 将在类似条件下被调用。也就是说，预期 F 使用普通的 / 高级别的 Go 代码，而非运行时中较复杂部分所使用的受限变体。",
  "internal/runtime/gc": "[zh]包 gc",
  "internal/runtime/maps": "[zh]包 maps：maps 包实现了 Go 内置的 map 类型。",
  "internal/runtime/math": "[zh]包 math",
  "internal/runtime/startlinetest": "[zh]包 startlinetest：startlinetest 包包含用于 runtime_test.TestStartLineAsm 的辅助函数。",
  "internal/runtime/strconv": "[zh]包 strconv",
  "internal/runtime/sys": "[zh]包 sys：sys 包包含运行时使用的系统、配置和架构特定的常量。",
  "internal/runtime/wasitest": "[zh]包 wasi",
  "internal/saferio": "[zh]包 saferio：saferio 包提供了一些 I/O 函数，可避免不必要地分配大量内存。该包适用于从 [io.Reader] 读取数据的场景，其中数据大小是输入数据的一部分，但输入可能已损坏，或由不可信的攻击者提供。",
  "internal/singleflight": "[zh]包 singleflight：singleflight 包提供了一种抑制重复函数调用的机制。",
  "internal/stringslite": "[zh]包 stringslite：stringslite 包实现了 strings 的一个子集，仅使用可被 \"os\" 导入的包。\n\n这些函数的测试位于 strings 包中。",
  "internal/sync": "[zh]包 sync：sync 包为内部包（包括依赖 sync 的包）提供基本的同步原语，例如互斥锁。\n\n测试在 sync 包中定义。",
  "internal/synctest": "[zh]包 synctest：synctest 包为测试并发代码提供支持。\n\n函数文档请参见 testing/synctest 包。",
  "internal/syscall/execenv": "[zh]包 execenv",
  "internal/syscall/unix": "[zh]包 unix",
  "internal/sysinfo": "[zh]包 sysinfo：sysinfo 包实现了用于调试或信息收集的高级硬件信息获取功能。",
  "internal/syslist": "[zh]包 syslist",
  "internal/testenv": "[zh]包 testenv：testenv 包提供了 Go 团队在不同测试环境中运行时可用功能的信息。\n\n这是一个内部包，因为这些细节特定于 Go 团队的测试环境（在 build.golang.org 上），并不适用于一般测试。",
  "internal/testhash": "[zh]包 testhash",
  "internal/testlog": "[zh]包 testlog：testlog 包在测试与 os 包之间提供了一条反向通信通道，使得 cmd/go 能够观察到测试访问了哪些环境变量和文件。",
  "internal/testpty": "[zh]包 testpty：testpty 包是 Unix 系统上的一个简单伪终端包，通过 cgo 调用 C 函数实现。",
  "internal/trace": "[zh]包 trace",
  "internal/trace/internal/testgen": "[zh]包 testgen",
  "internal/trace/internal/tracev1": "[zh]包 tracev1：tracev1 包实现了对 Go 1.11–1.21 版本执行轨迹的解析器。\n\n该包最初是 Go 1.19 版本中 internal/trace 的副本，但已优化为速度更快，内存占用更少，且分配更少。并进一步修改以支持将轨迹转换为新的 1.22+ 格式。",
  "internal/trace/raw": "[zh]包 raw：Package raw 提供了解析和生成 Go 执行跟踪的接口。\n它能够解析和生成执行跟踪的线格式（wire format）以及一种自定义但简单的文本格式。\n\n本包中的读取器和写入器不对输入进行任何验证或排序，\n因此通常不适合用于分析。然而，它们对于测试和调试运行时中的跟踪器以及更复杂的跟踪解析器非常有用。\n\n# 文本格式规范\n\n本包生成和解析的跟踪文本格式是一种基于行的格式。\n\n每个文本跟踪的第一行是头部行：\n\n\tTrace Go1.XX\n\n其后是一系列事件行。每个事件以事件名称开头，后跟零个或多个带名称的无符号整数参数。\n名称与其整数值之间用 '=' 分隔。名称可包含除 '=' 外的任意 UTF-8 字符。\n\n例如：\n\n\tEventName arg1=23 arg2=55 arg3=53\n\n各标记之间允许任意数量的空白字符。空白字符通过 unicode.IsSpace 识别。\n\n某些事件在后续行中包含附加数据。此类情况有两种特殊形式。\n\n第一种特殊情况是带有尾随字节数据的事件。该尾部数据从事件下一行开始。该行包含一个名为 'data' 的参数，以及一个表示字节数据的 Go 引号字符串。\n注意：长度参数被省略，因为它等于去引号后字符串的长度。\n\n例如：\n\n\tString id=5\n\t\tdata=\"hello world\\x00\"\n\n此类事件在其规范中通过 HasData 标志标识。\n\n第二种特殊情况是栈事件。此类事件通过 IsStack 标志标识。这些事件还带有一个尾随的无符号整数参数，用于描述后续栈帧描述符的数量。\n每个栈帧描述符位于事件之后的独立行上，包含四个有符号整数参数：PC、描述函数名的整数、描述文件名的整数，以及获取栈跟踪时该函数所在的文件行号。\n\n例如：\n\n\tStack id=5 n=2\n\t\tpc=1241251 func=3 file=6 line=124\n\t\tpc=7534345 func=6 file=3 line=64",
  "internal/trace/testtrace": "[zh]包 testtrace",
  "internal/trace/tracev2": "[zh]包 tracev2：tracev2 包包含 v2 执行跟踪线格式的定义。\n\n这些定义在跟踪解析器和运行时之间共享，因此不得依赖任何依赖于运行时的包（大多数包）。",
  "internal/trace/traceviewer": "[zh]包 traceviewer",
  "internal/trace/traceviewer/format": "[zh]包 format：包 traceviewer 提供了 Chrome 跟踪查看器所使用的 JSON 数据结构的定义。\n\n该格式的官方描述位于以下文件中：\nhttps://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview\n\n注意：此包不能作为父级 traceviewer 包的一部分，因为这会导致 go_bootstrap 在 ./make.bash 中依赖 cgo 版本的 net 包时出错。",
  "internal/trace/version": "[zh]包 version",
  "internal/txtar": "[zh]包 txtar：txtar 实现了一种简单的基于文本的文件归档格式。\n\n该格式的设计目标是：\n\n  - 足够简单，可手动创建和编辑。\n  - 能够存储用于描述 Go 命令测试用例的文本文件树。\n  - 在 Git 历史记录和代码审查中具有良好的 diff 效果。\n\n非目标包括成为一种完全通用的归档格式、存储二进制数据、存储文件模式、存储符号链接等特殊文件。\n\n# Txtar 格式\n\n一个 txtar 归档由零或多行注释行，后跟一系列文件条目组成。  \n每个文件条目以形如 \"-- FILENAME --\" 的文件标记行开始，随后是零或多行文件内容行，构成文件数据。  \n注释或文件内容在下一个文件标记行处结束。  \n文件标记行必须以三字节序列 \"-- \" 开头，并以三字节序列 \" --\" 结尾，但其中包含的文件名可以带有额外的空白字符，所有空白字符都会被去除。\n\n如果 txtar 文件的最后一行缺少换行符，解析器也应视作存在最终换行符。\n\ntxtar 归档中不存在可能的语法错误。",
  "internal/types/errors": "[zh]包 errors",
  "internal/unsafeheader": "[zh]包 unsafeheader：unsafeheader 包包含 Go 运行时切片和字符串实现的头声明。\n\n此包允许无法导入 \"reflect\" 的包使用经测试与 reflect.SliceHeader 和 reflect.StringHeader 等效的类型。",
  "internal/xcoff": "[zh]包 xcoff：包 xcoff 实现了对 XCOFF（扩展通用对象文件格式）文件的访问。",
  "internal/zstd": "[zh]包 zstd：zstd 包为 RFC 8878 中描述的 zstd 流提供解压缩功能，不支持字典。",
  "io": "[zh]包 io：io 包提供了 I/O 原语的基本接口。\n其主要功能是将此类原语的现有实现（例如 os 包中的实现）封装为抽象功能的共享公共接口，并提供一些其他相关原语。\n\n由于这些接口和原语封装了具有不同实现的底层操作，除非另有说明，客户端不应假定它们可安全地并行执行。",
  "io/fs": "[zh]包 fs：fs 包定义了文件系统的基本接口。\n文件系统可由宿主操作系统提供，也可由其他包提供。\n\n有关测试文件系统实现的支持，请参见 [testing/fstest] 包。",
  "io/ioutil": "[zh]包 ioutil：ioutil 包实现了一些 I/O 实用函数。\n\n已弃用：从 Go 1.16 开始，相同的功能现由包 [io] 或包 [os] 提供，新代码中应优先使用这些实现。\n具体细节请参见各个函数的文档。",
  "log": "[zh]包 log 实现了一个简单的日志记录包。它定义了一个 [Logger] 类型，包含用于格式化输出的方法。该包还提供了一个预定义的“标准” Logger，可通过辅助函数 Print[f|ln]、Fatal[f|ln] 和 Panic[f|ln] 访问，这些函数比手动创建 Logger 更易使用。该 Logger 写入标准错误流，并打印每条日志消息的日期和时间。\n\n每条日志消息均输出在单独的一行：如果被打印的消息末尾不含换行符，Logger 将自动添加一个。\n\nFatal 函数在写入日志消息后调用 [os.Exit](1)。  \nPanic 函数在写入日志消息后调用 panic。",
  "log/internal": "[zh]包 internal：internal 包包含 log 和 log/slog 共用的定义。",
  "log/slog/internal": "[zh]包 internal",
  "log/slog/internal/benchmarks": "[zh]包基准测试：benchmarks 包包含针对 slog 的基准测试。\n\n这些基准测试大致基于 github.com/uber-go/zap/benchmarks。  \n它们具有以下理想特性：\n\n  - 它们测试完整的日志事件，从用户的调用开始到返回结束。\n\n  - 被测代码在多个 goroutine 中并发运行，以更好地模拟真实服务器环境（结构化日志最常见的使用场景）。\n\n  - 某些处理器是真实处理器的乐观版本，尽可能快速地执行实际任务（有时甚至更快，因为实现可能不具备并发安全性）。这为我们提供了处理器性能的上限，使我们能够在端到端上下文中评估包的核心活动（与处理器无关），而不必担心缓慢的处理器实现会扭曲结果。\n\n  - 我们还测试了内置处理器，以便进行比较。",
  "log/slog/internal/buffer": "[zh]包 buffer：包 buffer 提供了一个池分配的字节缓冲区。",
  "log/syslog": "[zh]包 syslog：syslog 包为系统日志服务提供了简单的接口。它可以通过 UNIX 域套接字、UDP 或 TCP 向 syslog 守护进程发送消息。\n\n只需调用一次 Dial。在写入失败时，syslog 客户端会尝试重新连接服务器并再次写入。\n\nsyslog 包已冻结，不再接受新功能。一些外部包提供更多的功能。参见：\n\n\thttps://godoc.org/?q=syslog",
  "maps": "[zh]包 maps：maps 包定义了适用于任意类型映射的各种有用函数。\n\n该包对非自反键（即 k != k 的键，例如浮点数 NaN）没有任何特殊处理。",
  "math": "[zh]包 math：math 包提供了基本常量和数学函数。\n\n本包不保证在不同架构上产生完全相同的位结果。",
  "math/big": "[zh]包 big：包 big 实现任意精度的算术运算（大数）。\n支持以下数值类型：\n\n\tInt    有符号整数\n\tRat    有理数\n\tFloat  浮点数\n\n[Int]、[Rat] 或 [Float] 的零值均表示 0。因此，新值可以按常规方式声明，并在无需进一步初始化的情况下表示 0：\n\n\tvar x Int        // \u0026x 是值为 0 的 *Int\n\tvar r = \u0026Rat{}   // r 是值为 0 的 *Rat\n\ty := new(Float)  // y 是值为 0 的 *Float\n\n或者，可通过如下形式的工厂函数来分配并初始化新值：\n\n\tfunc NewT(v V) *T\n\n例如，[NewInt](x) 返回一个 *[Int]，其值设为 int64 参数 x 的值；[NewRat](a, b) 返回一个 *[Rat]，其值设为分数 a/b（其中 a 和 b 均为 int64 值）；[NewFloat](f) 返回一个 *[Float]，其值初始化为 float64 参数 f。更灵活的设置可通过显式的 setter 方法实现，例如：\n\n\tvar z1 Int\n\tz1.SetUint64(123)                 // z1 := 123\n\tz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\n\tz3 := new(Float).SetInt(z1)       // z3 := 123.0\n\nsetter 方法、数值运算和谓词以如下形式的方法表示：\n\n\tfunc (z *T) SetV(v V) *T          // z = v\n\tfunc (z *T) Unary(x *T) *T        // z = 一元 x\n\tfunc (z *T) Binary(x, y *T) *T    // z = x 二元 y\n\tfunc (x *T) Pred() P              // p = pred(x)\n\n其中 T 为 [Int]、[Rat] 或 [Float] 之一。对于一元和二元运算，结果为接收者（通常在此类情况下命名为 z；见下文）；若结果是操作数 x 或 y 之一，则可安全地被覆盖（并重用其内存）。\n\n算术表达式通常写作一系列独立的方法调用，每次调用对应一个操作。接收者表示结果，方法参数为操作的操作数。例如，给定三个 *Int 值 a、b 和 c，调用\n\n\tc.Add(a, b)\n\n将计算 a + b 的和，并将结果存入 c，覆盖 c 中原有的值。除非另有说明，运算允许参数别名化，因此编写如下代码完全合法：\n\n\tsum.Add(sum, x)\n\n用于将值 x 累加到 sum 中。\n\n（通过始终将结果值作为接收者传入，可更好地控制内存使用。无需为每个结果分配新内存，操作可重用为结果值分配的空间，并在过程中用新结果覆盖原值。）\n\n符号约定：API 中的方法参数（包括接收者）命名保持一致，以明确其用途。输入操作数通常命名为 x、y、a、b 等，但绝不会命名为 z。用于指定结果的参数命名为 z（通常为接收者）。\n\n例如，(*Int).Add 的参数命名为 x 和 y，由于接收者指定结果目标，故其命名为 z：\n\n\tfunc (z *Int) Add(x, y *Int) *Int\n\n此类方法通常也返回传入的接收者，以便支持链式调用。\n\n不需要传入结果值的方法（例如 [Int.Sign]）直接返回结果。此时，接收者通常为第一个操作数，命名为 x：\n\n\tfunc (x *Int) Sign() int\n\n多种方法支持字符串与对应数值之间的相互转换：*[Int]、*[Rat] 和 *[Float] 值实现了 Stringer 接口，提供值的（默认）字符串表示形式，同时也提供 SetString 方法，用于从字符串中以多种支持的格式初始化值（参见各 SetString 文档）。\n\n最后，*[Int]、*[Rat] 和 *[Float] 满足 [fmt.Scanner] 接口以支持扫描输入，且（除 *[Rat] 外）满足 Formatter 接口以支持格式化输出。",
  "math/big/internal/asmgen": "[zh]包 asmgen：Asmgen 生成 math/big 的汇编代码。\n\n用法：\n\n\tcd go/src/math/big\n\tgo test ./internal/asmgen -generate\n\n或者：\n\n\tgo generate math/big",
  "math/bits": "[zh]包 bits：包 bits 实现了预声明的无符号整数类型的位计数和操作函数。\n\n出于性能考虑，本包中的函数可能由编译器直接实现，此时本包中的代码将不会被使用。具体哪些函数由编译器实现，取决于架构和 Go 版本。",
  "math/cmplx": "[zh]包 cmplx：cmplx 包为复数提供了基本常量和数学函数。特殊情况的处理符合 C99 标准附录 G 中 IEC 60559 兼容的复数算术规范。",
  "math/rand": "[zh]包 rand：该包实现了适用于模拟等任务的伪随机数生成器，但不应在涉及安全敏感的场景中使用。\n\n随机数由 [Source] 生成，通常被封装在 [Rand] 中。\n这两种类型一次应由单个 goroutine 使用：在多个 goroutine 之间共享需要某种同步机制。\n\n顶层函数（如 [Float64] 和 [Int]）可安全地供多个 goroutine 并发使用。\n\n无论怎样设置种子，此包产生的输出可能容易被预测。对于适用于安全敏感工作的随机数，请参见 crypto/rand 包。",
  "math/rand/v2": "[zh]包 rand：本包实现了适用于模拟等任务的伪随机数生成器，但不应用于安全敏感的工作。\n\n随机数由 [Source] 生成，通常被封装在 [Rand] 中。这两种类型一次应由单个 goroutine 使用：在多个 goroutine 之间共享需要某种同步机制。\n\n顶层函数（如 [Float64] 和 [Int]）可安全地供多个 goroutine 并发使用。\n\n无论怎样设置种子，本包的输出可能容易被预测。对于适用于安全敏感工作的随机数，请参见 [crypto/rand] 包。",
  "mime": "[zh]包 mime：mime 包实现了 MIME 规范的部分内容。",
  "mime/multipart": "[zh]包 multipart：该包实现了 MIME 多部分解析，定义见 RFC 2046。\n\n此实现适用于 HTTP（RFC 2388）以及主流浏览器生成的多部分内容。\n\n# 限制\n\n为防止恶意输入，本包对所处理的 MIME 数据大小设置了限制。\n\n[Reader.NextPart] 和 [Reader.NextRawPart] 将每个部分的头部数量限制为 10000 个，[Reader.ReadForm] 将所有 FileHeader 中的总头部数量限制为 10000 个。  \n这些限制可通过 GODEBUG=multipartmaxheaders=\u003c值\u003e 进行调整。\n\nReader.ReadForm 还将表单中的部分数量限制为 1000 个。  \n此限制可通过 GODEBUG=multipartmaxparts=\u003c值\u003e 进行调整。",
  "mime/quotedprintable": "[zh]包 quotedprintable：Package quotedprintable 实现了 RFC 2045 规定的 quoted-printable 编码。",
  "net": "[zh]包 net：net 包提供了可移植的网络 I/O 接口，包括 TCP/IP、UDP、域名解析和 Unix 域套接字。\n\n尽管该包提供了对底层网络原语的访问，但大多数客户端只需使用由 [Dial]、[Listen] 和 Accept 函数提供的基本接口，以及相关的 [Conn] 和 [Listener] 接口。crypto/tls 包使用相同的接口以及类似的 Dial 和 Listen 函数。\n\nDial 函数用于连接到服务器：\n\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\t// 处理错误\n\t}\n\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n\t// ...\n\nListen 函数用于创建服务器：\n\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// 处理错误\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// 处理错误\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n\n# 名称解析\n\n解析域名的方法（无论是通过 Dial 等函数间接调用，还是通过 [LookupHost] 和 [LookupAddr] 等函数直接调用）因操作系统而异。\n\n在 Unix 系统上，解析器有两种解析名称的选项：可以使用纯 Go 解析器，它直接向 /etc/resolv.conf 中列出的服务器发送 DNS 请求；也可以使用基于 cgo 的解析器，调用 C 库函数如 getaddrinfo 和 getnameinfo。\n\n在 Unix 上，优先使用纯 Go 解析器而非 cgo 解析器，因为阻塞的 DNS 请求仅消耗一个 goroutine，而阻塞的 C 调用会消耗一个操作系统线程。当 cgo 可用时，在多种情况下仍会使用基于 cgo 的解析器：在不允许程序直接发起 DNS 请求的系统上（如 OS X）、存在 LOCALDOMAIN 环境变量时（即使为空）、RES_OPTIONS 或 HOSTALIASES 环境变量非空时、ASR_CONFIG 环境变量非空时（仅 OpenBSD）、/etc/resolv.conf 或 /etc/nsswitch.conf 指定了 Go 解析器未实现的功能时。\n\n在所有系统（除 Plan 9 外），当使用 cgo 解析器时，此包会对并发 cgo 查找施加限制，以防止系统耗尽操作系统线程。目前限制为最多 500 个并发查找。\n\n可通过设置 GODEBUG 环境变量的 netdns 值（参见 runtime 包）为 go 或 cgo 来覆盖解析器选择，例如：\n\n\texport GODEBUG=netdns=go    # 强制使用纯 Go 解析器\n\texport GODEBUG=netdns=cgo   # 强制使用本地解析器（cgo，win32）\n\n也可在构建 Go 源码树时通过设置 netgo 或 netcgo 构建标签来强制决定。netgo 构建标签完全禁用本地（CGO）解析器，意味着只能使用 Go 解析器。使用 netcgo 构建标签时，本地解析器和纯 Go 解析器都会被编译进二进制文件，但优先使用本地（CGO）解析器。使用 netcgo 时，仍可在运行时通过 GODEBUG=netdns=go 强制使用 Go 解析器。\n\n将 netdns 设为数值，如 GODEBUG=netdns=1，会使解析器打印其决策的调试信息。若要强制特定解析器的同时打印调试信息，可用加号连接两个设置，如 GODEBUG=netdns=go+1。\n\nGo 解析器会在 DNS 请求中发送 EDNS0 附加头部，表示愿意接受更大的 DNS 数据包大小。据报道，这可能导致某些调制解调器和路由器运行的 DNS 服务器偶尔失败。设置 GODEBUG=netedns0=0 将禁用发送该附加头部。\n\n在 macOS 上，如果使用 -buildmode=c-archive 构建包含 net 包的 Go 代码，则将生成的归档文件链接到 C 程序时，需在链接 C 代码时传入 -lresolv。\n\n在 Plan 9 上，解析器始终访问 /net/cs 和 /net/dns。\n\n在 Windows 上，Go 1.18.x 及更早版本中，解析器始终使用 C 库函数，如 GetAddrInfo 和 DnsQuery。",
  "net/http": "[zh]包 http：http 包提供了 HTTP 客户端和服务器的实现。\n\n[Get]、[Head]、[Post] 和 [PostForm] 用于发起 HTTP（或 HTTPS）请求：\n\n\tresp, err := http.Get(\"http://example.com/\")\n\t...\n\tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf)\n\t...\n\tresp, err := http.PostForm(\"http://example.com/form\",\n\t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\n调用者在使用完毕后必须关闭响应体：\n\n\tresp, err := http.Get(\"http://example.com/\")\n\tif err != nil {\n\t\t// 处理错误\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := io.ReadAll(resp.Body)\n\t// ...\n\n# 客户端与传输\n\n如需控制 HTTP 客户端的请求头、重定向策略及其他设置，可创建一个 [Client]：\n\n\tclient := \u0026http.Client{\n\t\tCheckRedirect: redirectPolicyFunc,\n\t}\n\n\tresp, err := client.Get(\"http://example.com\")\n\t// ...\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t// ...\n\treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n\tresp, err := client.Do(req)\n\t// ...\n\n如需控制代理、TLS 配置、长连接、压缩及其他设置，可创建一个 [Transport]：\n\n\ttr := \u0026http.Transport{\n\t\tMaxIdleConns:       10,\n\t\tIdleConnTimeout:    30 * time.Second,\n\t\tDisableCompression: true,\n\t}\n\tclient := \u0026http.Client{Transport: tr}\n\tresp, err := client.Get(\"https://example.com\")\n\nClient 和 Transport 均可安全地被多个 goroutine 并发使用，为提高效率，应仅创建一次并重复使用。\n\n# 服务器\n\nListenAndServe 使用指定地址和处理器启动一个 HTTP 服务器。处理器通常为 nil，表示使用 [DefaultServeMux]。[Handle] 和 [HandleFunc] 向 [DefaultServeMux] 添加处理器：\n\n\thttp.Handle(\"/foo\", fooHandler)\n\n\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\n通过创建自定义 Server，可对服务器行为进行更精细的控制：\n\n\ts := \u0026http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        myHandler,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t}\n\tlog.Fatal(s.ListenAndServe())\n\n# HTTP/2\n\n从 Go 1.6 开始，当使用 HTTPS 时，http 包对 HTTP/2 协议提供透明支持。需要禁用 HTTP/2 的程序可通过将 [Transport.TLSNextProto]（客户端）或 [Server.TLSNextProto]（服务器）设置为非 nil 的空 map 来实现。此外，当前支持以下 GODEBUG 设置：\n\n\tGODEBUG=http2client=0  # 禁用 HTTP/2 客户端支持\n\tGODEBUG=http2server=0  # 禁用 HTTP/2 服务器支持\n\tGODEBUG=http2debug=1   # 启用详细的 HTTP/2 调试日志\n\tGODEBUG=http2debug=2   # ... 更详细，包含帧转储\n\n在禁用 HTTP/2 支持前，请报告相关问题：https://golang.org/s/http2bug\n\nhttp 包的 [Transport] 和 [Server] 均会为简单配置自动启用 HTTP/2 支持。若要为更复杂的配置启用 HTTP/2，使用底层的 HTTP/2 特性，或使用更新版本的 Go http2 包，请直接导入 \"golang.org/x/net/http2\" 并使用其 ConfigureTransport 和/或 ConfigureServer 函数。通过 golang.org/x/net/http2 包手动配置 HTTP/2 将优先于 net/http 包内置的 HTTP/2 支持。",
  "net/http/cgi": "[zh]包 cgi：Package cgi 实现了 RFC 3875 中规定的 CGI（通用网关接口）。\n\n请注意，使用 CGI 意味着为每个请求启动一个新进程，通常比使用长连接服务器效率更低。此包主要用于与现有系统兼容。",
  "net/http/cookiejar": "[zh]包 cookiejar：cookiejar 包实现了符合 RFC 6265 的内存式 http.CookieJar。",
  "net/http/fcgi": "[zh]包 fcgi：fcgi 包实现了 FastCGI 协议。\n\n有关原始文档的非官方镜像，请访问 https://fast-cgi.github.io/。\n\n目前仅支持响应者角色。",
  "net/http/httptest": "[zh]包 httptest：httptest 包提供了用于 HTTP 测试的工具。",
  "net/http/httptrace": "[zh]包 httptrace：httptrace 包提供了追踪 HTTP 客户端请求中事件的机制。",
  "net/http/httputil": "[zh]包 httputil：httputil 包提供 HTTP 实用函数，补充 net/http 包中更常见的函数。",
  "net/http/internal": "[zh]包 internal：internal 包包含 net/http 和 net/http/httputil 共享的 HTTP 内部功能。",
  "net/http/internal/ascii": "[zh]包 ascii",
  "net/http/internal/httpcommon": "[zh]包 httpcommon",
  "net/http/internal/testcert": "[zh]包 testcert：testcert 包包含一个仅用于测试的本地主机证书。",
  "net/http/pprof": "[zh]包 pprof：该包通过其 HTTP 服务器提供运行时性能分析数据，数据格式符合 pprof 可视化工具的期望。\n\n此包通常仅出于注册其 HTTP 处理程序的副作用而被导入。所有处理路径均以 /debug/pprof/ 开头。自 Go 1.22 起，所有路径必须使用 GET 方法请求。\n\n要使用 pprof，请将此包链接到程序中：\n\n\timport _ \"net/http/pprof\"\n\n如果应用程序尚未运行 HTTP 服务器，则需要启动一个。在导入中添加 \"net/http\" 和 \"log\"，并在主函数中加入以下代码：\n\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n\t}()\n\n默认情况下，除本包定义的 [Cmdline]、[Profile]、[Symbol] 和 [Trace] 配置文件外，[runtime/pprof.Profile] 中列出的所有配置文件（通过 [Handler]）均可访问。若未使用 DefaultServeMux，则需向所用的 mux 注册处理程序。\n\n# 参数\n\n参数可通过 GET 查询参数传递：\n\n  - debug=N（所有配置文件）：响应格式：N = 0：二进制（默认），N \u003e 0：纯文本\n  - gc=N（堆配置文件）：N \u003e 0：在分析前执行一次垃圾回收周期\n  - seconds=N（allocs、block、goroutine、heap、mutex、threadcreate 配置文件）：返回增量配置文件\n  - seconds=N（cpu (profile)、trace 配置文件）：对指定持续时间进行分析\n\n# 使用示例\n\n使用 pprof 工具查看堆配置文件：\n\n\tgo tool pprof http://localhost:6060/debug/pprof/heap\n\n或查看 30 秒的 CPU 配置文件：\n\n\tgo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n\n或在程序中调用 [runtime.SetBlockProfileRate] 后查看 goroutine 阻塞配置文件：\n\n\tgo tool pprof http://localhost:6060/debug/pprof/block\n\n或在程序中调用 [runtime.SetMutexProfileFraction] 后查看竞争互斥锁的持有者：\n\n\tgo tool pprof http://localhost:6060/debug/pprof/mutex\n\n该包还导出一个处理程序，用于为 \"go tool trace\" 命令提供执行跟踪数据。收集 5 秒执行跟踪：\n\n\tcurl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5\n\tgo tool trace trace.out\n\n要在浏览器中查看所有可用配置文件，请访问 http://localhost:6060/debug/pprof/。\n\n有关该功能的实际应用研究，请访问\nhttps://blog.golang.org/2011/06/profiling-go-programs.html。",
  "net/internal/cgotest": "[zh]包 cgotest",
  "net/internal/socktest": "[zh]包 socktest：socktest 包提供用于套接字测试的工具。",
  "net/mail": "[zh]包 mail：mail 包实现了邮件消息的解析。\n\n在大多数情况下，此包遵循 RFC 5322 规定的语法，并由 RFC 6532 扩展。\n主要差异：\n  - 不解析过时的地址格式，包括包含嵌入式路由信息的地址。\n  - 不支持完整的空白字符间隔（CFWS 语法元素），例如跨行拆分地址。\n  - 不执行 Unicode 归一化。\n  - 允许以 From 行开头，如 mbox 格式（RFC 4155）所示。",
  "net/netip": "[zh]包 netip：包 netip 定义了一个小型值类型的 IP 地址类型。基于该 [Addr] 类型，此包还定义了 [AddrPort]（IP 地址和端口）以及 [Prefix]（IP 地址和位长度前缀）。\n\n与 [net.IP] 类型相比，[Addr] 类型占用更少内存，且不可变，并支持比较（支持 == 操作和作为 map 键）。",
  "net/rpc": "[zh]包 rpc：rpc 包提供了通过网络或其他 I/O 连接访问对象导出方法的能力。\n\nnet/rpc 包已冻结，不再接受新功能。\n\n服务器注册一个对象，使其作为服务可见，服务名称为该对象的类型名。注册后，该对象的导出方法将可被远程访问。服务器可以注册多个不同类型对象（服务），但注册多个相同类型的对象是错误的。\n\n只有满足以下条件的方法才会被提供用于远程访问；其他方法将被忽略：\n\n  - 方法所属的类型是导出的。\n  - 方法本身是导出的。\n  - 方法有两个参数，且均为导出类型或内置类型。\n  - 方法的第二个参数是指针类型。\n  - 方法的返回值类型为 error。\n\n实际上，方法必须形如：\n\n\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n\n其中 T1 和 T2 可由 encoding/gob 编码。即使使用不同的编解码器，这些要求仍然适用。（未来针对自定义编解码器，这些要求可能会放宽。）\n\n方法的第一个参数表示调用者提供的参数；第二个参数表示需返回给调用者的结果参数。若方法返回非 nil 的错误值，则该错误会以字符串形式传回，客户端看到的效果如同由 [errors.New] 创建。若返回错误，结果参数不会传回给客户端。\n\n服务器可通过调用 [ServeConn] 在单个连接上处理请求。更常见的情况是创建一个网络监听器并调用 [Accept]，或对 HTTP 监听器调用 [HandleHTTP] 和 [http.Serve]。\n\n希望使用该服务的客户端需先建立连接，然后在连接上调用 [NewClient]。便捷函数 [Dial]（[DialHTTP]）可完成原始网络连接（HTTP 连接）的这两个步骤。得到的 [Client] 对象具有两个方法：[Call] 和 Go，用于指定要调用的服务和方法、包含参数的指针以及接收结果参数的指针。\n\nCall 方法等待远程调用完成，而 Go 方法异步发起调用，并通过 Call 结构体的 Done 通道通知完成状态。\n\n除非显式设置编解码器，否则使用 [encoding/gob] 包传输数据。\n\n以下是一个简单示例。服务器希望导出 Arith 类型的对象：\n\n\tpackage server\n\n\timport \"errors\"\n\n\ttype Args struct {\n\t\tA, B int\n\t}\n\n\ttype Quotient struct {\n\t\tQuo, Rem int\n\t}\n\n\ttype Arith int\n\n\tfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t\t*reply = args.A * args.B\n\t\treturn nil\n\t}\n\n\tfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\t\tif args.B == 0 {\n\t\t\treturn errors.New(\"divide by zero\")\n\t\t}\n\t\tquo.Quo = args.A / args.B\n\t\tquo.Rem = args.A % args.B\n\t\treturn nil\n\t}\n\n服务器调用（用于 HTTP 服务）：\n\n\tarith := new(Arith)\n\trpc.Register(arith)\n\trpc.HandleHTTP()\n\tl, err := net.Listen(\"tcp\", \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"listen error:\", err)\n\t}\n\tgo http.Serve(l, nil)\n\n此时，客户端可以看到名为 \"Arith\" 的服务，其方法为 \"Arith.Multiply\" 和 \"Arith.Divide\"。要调用其中一个方法，客户端首先拨号连接服务器：\n\n\tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n\tif err != nil {\n\t\tlog.Fatal(\"dialing:\", err)\n\t}\n\n然后可以发起远程调用：\n\n\t// 同步调用\n\targs := \u0026server.Args{7,8}\n\tvar reply int\n\terr = client.Call(\"Arith.Multiply\", args, \u0026reply)\n\tif err != nil {\n\t\tlog.Fatal(\"arith error:\", err)\n\t}\n\tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\n或\n\n\t// 异步调用\n\tquotient := new(Quotient)\n\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n\treplyCall := \u003c-divCall.Done\t// 等于 divCall\n\t// 检查错误、打印等操作\n\n服务器实现通常会为客户端提供一个简单且类型安全的包装。",
  "net/rpc/jsonrpc": "[zh]包 jsonrpc：jsonrpc 包为 rpc 包实现了 JSON-RPC 1.0 的 ClientCodec 和 ServerCodec。\n如需 JSON-RPC 2.0 支持，请参见 https://godoc.org/?q=json-rpc+2.0",
  "net/smtp": "[zh]包 smtp：smtp 包实现了 RFC 5321 中定义的简单邮件传输协议（Simple Mail Transfer Protocol）。  \n它还实现了以下扩展：\n\n\t8BITMIME  RFC 1652  \n\tAUTH      RFC 2554  \n\tSTARTTLS  RFC 3207  \n\n其他扩展可由客户端自行处理。\n\nsmtp 包已冻结，不再接受新功能。  \n一些外部包提供了更多功能。参见：\n\n\thttps://godoc.org/?q=smtp",
  "net/textproto": "[zh]包 textproto：textproto 包为基于文本的请求/响应协议（如 HTTP、NNTP 和 SMTP）提供通用支持。\n\n本包对头部键和值强制使用 RFC 9112 定义的 HTTP/1.1 字符集。\n\n该包提供以下内容：\n\n[Error]，表示来自服务器的数字错误响应。\n\n[Pipeline]，用于在客户端管理流水线化的请求和响应。\n\n[Reader]，用于读取数字响应码行、key: value 格式的头部、以空格开头的续行以及以单独一行的句点结束的整个文本块。\n\n[Writer]，用于写入点编码的文本块。\n\n[Conn]，将 [Reader]、[Writer] 和 [Pipeline] 打包，便于单个网络连接使用。",
  "net/url": "[zh]包 url：解析 URL 并实现查询转义。\n\n参见 RFC 3986。本包通常遵循 RFC 3986，但出于兼容性原因存在一些偏离。\nIPv6 区域文字遵循 RFC 6874。",
  "os": "[zh]包 os：os 包提供了操作系统功能的平台无关接口。其设计类似 Unix，但错误处理方式采用 Go 风格；失败的调用返回 error 类型的值，而非错误码。通常，错误中包含更多信息。例如，接受文件名参数的调用（如 [Open] 或 [Stat]）失败时，打印错误会包含该文件名，且错误类型为 [*PathError]，可解包以获取更多详细信息。\n\nos 接口旨在所有操作系统上保持一致。不通用的功能位于系统特定的 syscall 包中。\n\n以下是一个简单的示例，打开文件并读取部分内容：\n\n\tfile, err := os.Open(\"file.go\") // 用于只读访问。\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n若打开失败，错误字符串将自解释，例如：\n\n\topen file.go: no such file or directory\n\n随后可将文件数据读入字节切片。Read 和 Write 方法根据参数切片的长度确定字节数量。\n\n\tdata := make([]byte, 100)\n\tcount, err := file.Read(data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n\n# 并发\n\n[File] 的方法对应文件系统操作。所有方法均支持并发使用。单个 File 上的最大并发操作数可能受操作系统或系统限制。该数值通常较高，但超出可能降低性能或引发其他问题。",
  "os/exec": "[zh]包 exec：exec 包用于运行外部命令。它封装了 os.StartProcess，以便更方便地重映射 stdin 和 stdout、通过管道连接 I/O，以及进行其他调整。\n\n与 C 和其他语言中的 \"system\" 库函数不同，os/exec 包有意不调用系统 shell，也不展开通配符模式或处理通常由 shell 完成的其他扩展、管道或重定向。该包的行为更类似于 C 的 \"exec\" 函数族。如需展开通配符模式，可直接调用 shell（注意转义任何危险输入），或使用 [path/filepath] 包的 Glob 函数。如需展开环境变量，请使用 os 包的 ExpandEnv 函数。\n\n请注意，本包中的示例假设运行在 Unix 系统上。它们可能无法在 Windows 上运行，且不会在 go.dev 和 pkg.go.dev 使用的 Go Playground 中运行。\n\n# 当前目录中的可执行文件\n\n[Command] 和 [LookPath] 函数会根据当前路径中列出的目录查找程序，遵循主机操作系统的约定。几十年来，操作系统通常会将当前目录包含在此搜索路径中，有时是隐式包含，有时是默认显式配置。现代实践认为，包含当前目录通常是意外的，并常常导致安全问题。\n\n为避免这些安全问题，从 Go 1.19 开始，此包不会使用相对于当前目录的隐式或显式路径项来解析程序。也就是说，如果你调用 [LookPath](\"go\")，无论路径如何配置，它都不会在 Unix 上成功返回 ./go，也不会在 Windows 上返回 .\\go.exe。相反，如果常规路径算法会导致此类结果，则这些函数将返回一个满足 [errors.Is](err, [ErrDot]) 的错误 err。\n\n例如，考虑以下两个代码片段：\n\n\tpath, err := exec.LookPath(\"prog\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tuse(path)\n\n和\n\n\tcmd := exec.Command(\"prog\")\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n无论当前路径如何配置，这些代码都不会找到并运行 ./prog 或 .\\prog.exe。\n\n始终希望从当前目录运行程序的代码可以改写为使用 \"./prog\" 而非 \"prog\"。\n\n坚持包含相对路径项结果的代码可通过 errors.Is 检查覆盖该错误：\n\n\tpath, err := exec.LookPath(\"prog\")\n\tif errors.Is(err, exec.ErrDot) {\n\t\terr = nil\n\t}\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tuse(path)\n\n和\n\n\tcmd := exec.Command(\"prog\")\n\tif errors.Is(cmd.Err, exec.ErrDot) {\n\t\tcmd.Err = nil\n\t}\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n设置环境变量 GODEBUG=execerrdot=0 可完全禁用 ErrDot 的生成，临时恢复 Go 1.19 之前的行为，适用于无法应用更精确修复的程序。未来版本的 Go 可能会移除对该变量的支持。\n\n在添加此类覆盖之前，请务必理解其带来的安全影响。更多信息请参见 https://go.dev/blog/path-security。",
  "os/exec/internal/fdtest": "[zh]包 fdtest：fdtest 包提供用于在 exec 期间处理文件描述符的测试辅助工具。",
  "os/user": "[zh]包 user：user 包支持通过名称或 ID 查找用户账户。\n\n对于大多数 Unix 系统，该包提供了两种内部实现，用于将用户和组 ID 解析为名称，以及列出附加组 ID。一种是纯 Go 实现，解析 /etc/passwd 和 /etc/group 文件；另一种基于 cgo，依赖标准 C 库（libc）中的函数，例如 getpwuid_r、getgrnam_r 和 getgrouplist。\n\n当 cgo 可用，并且特定平台的 libc 中实现了所需函数时，将使用基于 cgo（由 libc 支持）的代码。可通过使用 osusergo 构建标签来覆盖此行为，强制使用纯 Go 实现。",
  "path": "[zh]包 path：path 包实现了用于操作斜杠分隔路径的实用程序函数。\n\npath 包仅应用于以正斜杠分隔的路径，例如 URL 中的路径。本包不处理包含驱动器字母或反斜杠的 Windows 路径；如需操作操作系统路径，请使用 [path/filepath] 包。",
  "path/filepath": "[zh]包 filepath：filepath 包实现了用于操作文件名路径的实用程序例程，其方式与目标操作系统定义的文件路径兼容。\n\nfilepath 包根据操作系统使用正斜杠或反斜杠。若要处理始终使用正斜杠的路径（例如 URL），请参见 [path] 包。",
  "plugin": "[zh]包 plugin：plugin 包实现了 Go 插件的加载和符号解析。\n\n插件是一个 Go 主包，包含已导出的函数和变量，并通过以下命令构建：\n\n\tgo build -buildmode=plugin\n\n首次打开插件时，所有尚未包含在程序中的包的 init 函数将被调用。main 函数不会被执行。插件仅初始化一次，且无法关闭。\n\n# 警告\n\n在执行期间动态加载应用程序部分功能的能力（可能基于用户定义的配置）在某些设计中可能是一个有用的构建模块。特别是，由于应用程序与动态加载的函数可以直接共享数据结构，插件可能实现各组件间极高的性能集成。\n\n然而，插件机制存在许多重大缺陷，在设计时应仔细考虑。例如：\n\n  - 插件目前仅支持 Linux、FreeBSD 和 macOS，因此不适用于需要可移植性的应用程序。\n\n  - Go 竞态检测器对插件的支持较差。即使是简单的竞态条件也可能无法自动检测。更多信息见 https://go.dev/issue/24245。\n\n  - 使用插件的应用程序可能需要仔细配置，以确保程序各个部分在文件系统（或容器镜像）中位于正确位置。相比之下，部署一个单一静态可执行文件的应用程序则更为简单。\n\n  - 当某些包直到应用程序启动很久之后才初始化时，程序初始化逻辑的推理变得更加困难。\n\n  - 加载插件的应用程序中的漏洞可能被攻击者利用，以加载危险或不可信的库。\n\n  - 除非程序的所有部分（应用程序及其所有插件）均使用完全相同的工具链版本、相同的构建标签以及某些标志和环境变量的相同值进行编译，否则很可能发生运行时崩溃。\n\n  - 除非应用程序及其插件的所有公共依赖项均从完全相同的源代码构建，否则同样可能发生崩溃问题。\n\n  - 综上所述，实际上应用程序及其所有插件必须由单一个人或系统组件统一构建。在此情况下，该个人或组件可能更简单地生成空白导入所需插件集的 Go 源文件，然后以常规方式编译为静态可执行文件。\n\n由于这些原因，许多用户认为，尽管存在性能开销，传统的进程间通信（IPC）机制（如套接字、管道、远程过程调用（RPC）、共享内存映射或文件系统操作）可能是更合适的选择。",
  "reflect": "[zh]包 reflect：该包实现了运行时反射，允许程序操作任意类型的对象。典型用法是取一个静态类型为 interface{} 的值，并通过调用 TypeOf 提取其动态类型信息，TypeOf 返回一个 Type。\n\n调用 ValueOf 返回一个表示运行时数据的 Value。Zero 接收一个 Type 并返回代表该类型零值的 Value。\n\n有关 Go 语言反射的介绍，请参见《反射定律》：\nhttps://golang.org/doc/articles/laws_of_reflection.html",
  "reflect/internal/example1": "[zh]包 example1",
  "reflect/internal/example2": "[zh]包 example2",
  "regexp": "[zh]包 regexp：regexp 包实现了正则表达式搜索。\n\n所支持的正则表达式语法与 Perl、Python 等语言中使用的通用语法相同。更准确地说，它采用 RE2 所接受的语法，具体描述见 https://golang.org/s/re2syntax，但不包括 \\C。有关语法概览，请参见 [regexp/syntax] 包。\n\n本包提供的正则表达式实现保证在输入大小的线性时间内完成执行。（该特性大多数开源正则表达式实现并不具备。）有关此特性的更多信息，请参见 https://swtch.com/~rsc/regexp/regexp1.html 或任何关于自动机理论的书籍。\n\n所有字符均为 UTF-8 编码的码点。根据 [utf8.DecodeRune] 的规则，每个无效 UTF-8 序列的字节都被视为编码了 utf8.RuneError（U+FFFD）。\n\n[Regexp] 类型提供了 16 种方法用于匹配正则表达式并识别匹配的文本，其名称符合以下正则表达式：\n\n\tFind(All)?(String)?(Submatch)?(Index)?\n\n若名称中包含 'All'，则该函数匹配整个表达式的连续非重叠结果。紧邻前一个匹配的空匹配将被忽略。返回值是一个切片，包含对应非 'All' 版本函数的连续调用结果。这些函数额外接受一个整数参数 n。若 n \u003e= 0，则函数最多返回 n 个匹配/子匹配；否则返回全部结果。\n\n若名称中包含 'String'，则参数为字符串类型；否则为字节切片类型；返回值相应地进行调整。\n\n若名称中包含 'Submatch'，则返回值为一个切片，标识表达式的连续子匹配。子匹配是指正则表达式中括号分组子表达式（也称为捕获组）的匹配结果，按左括号从左到右的顺序编号。子匹配 0 表示整个表达式的匹配，子匹配 1 表示第一个括号子表达式的匹配，依此类推。\n\n若名称中包含 'Index'，则匹配和子匹配通过输入字符串中的字节索引对来标识：result[2*n:2*n+2] 标识第 n 个子匹配的索引范围。n==0 的索引对表示整个表达式的匹配。若不包含 'Index'，则通过匹配/子匹配的文本内容来标识匹配结果。若某个索引为负或文本为 nil，表示该子表达式在输入中未匹配任何字符串。对于 'String' 版本，空字符串表示无匹配或为空匹配。\n\n此外还有一组方法可用于从 [io.RuneReader] 读取的文本：[Regexp.MatchReader]、[Regexp.FindReaderIndex]、[Regexp.FindReaderSubmatchIndex]。\n\n该集合可能扩展。注意，正则表达式匹配可能需要检查匹配结果之后的文本，因此作用于 [io.RuneReader] 的方法在返回前可能会读取输入中的任意远位置。\n\n（还有少数其他方法不符合上述命名模式。）",
  "runtime/cgo": "[zh]包 cgo：cgo 包包含 cgo 工具生成代码所需的运行时支持。有关使用 cgo 的详细信息，请参阅 cgo 命令的文档。",
  "runtime/coverage": "[zh]包 coverage：coverage 包包含用于在运行时写入覆盖率 profile 数据的 API，适用于不通过 [os.Exit] 终止的长期运行和/或服务器程序。",
  "runtime/debug": "[zh]包 debug：包 debug 包含程序在运行时用于自调试的功能。",
  "runtime/pprof": "[zh]包 pprof：pprof 包以 pprof 可视化工具期望的格式写入运行时性能分析数据。\n\n# 分析 Go 程序\n\n对 Go 程序进行性能分析的第一步是启用分析功能。标准 testing 包构建的基准测试已内置支持分析功能。例如，以下命令运行当前目录中的基准测试，并将 CPU 和内存分析结果写入 cpu.prof 和 mem.prof 文件：\n\n\tgo test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n\n要为独立程序添加类似的分析支持，可在主函数中加入如下代码：\n\n\tvar cpuprofile = flag.String(\"cpuprofile\", \"\", \"将 CPU 分析结果写入 `文件`\")\n\tvar memprofile = flag.String(\"memprofile\", \"\", \"将内存分析结果写入 `文件`\")\n\n\tfunc main() {\n\t    flag.Parse()\n\t    if *cpuprofile != \"\" {\n\t        f, err := os.Create(*cpuprofile)\n\t        if err != nil {\n\t            log.Fatal(\"无法创建 CPU 分析文件：\", err)\n\t        }\n\t        defer f.Close() // 示例中省略错误处理\n\t        if err := pprof.StartCPUProfile(f); err != nil {\n\t            log.Fatal(\"无法启动 CPU 分析：\", err)\n\t        }\n\t        defer pprof.StopCPUProfile()\n\t    }\n\n\t    // ... 程序其余部分 ...\n\n\t    if *memprofile != \"\" {\n\t        f, err := os.Create(*memprofile)\n\t        if err != nil {\n\t            log.Fatal(\"无法创建内存分析文件：\", err)\n\t        }\n\t        defer f.Close() // 示例中省略错误处理\n\t        runtime.GC() // 获取最新的统计信息\n\t        // Lookup(\"allocs\") 创建的分析文件类似于 go test -memprofile。\n\t        // 或者使用 Lookup(\"heap\") 获取默认索引为 inuse_space 的分析文件。\n\t        if err := pprof.Lookup(\"allocs\").WriteTo(f, 0); err != nil {\n\t            log.Fatal(\"无法写入内存分析文件：\", err)\n\t        }\n\t    }\n\t}\n\n还提供了一个标准的 HTTP 接口用于访问分析数据。添加以下语句将在 /debug/pprof/ 路径下注册处理器，用于下载实时分析数据：\n\n\timport _ \"net/http/pprof\"\n\n更多细节请参见 net/http/pprof 包。\n\n随后可使用 pprof 工具可视化分析数据：\n\n\tgo tool pprof cpu.prof\n\npprof 命令行提供了多个可用命令。常用命令包括 \"top\"，用于打印程序热点的摘要；以及 \"web\"，用于打开热点及其调用图的交互式图形界面。输入 \"help\" 可查看所有 pprof 命令的帮助信息。\n\n有关 pprof 的更多信息，请参见\nhttps://github.com/google/pprof/blob/main/doc/README.md。",
  "runtime/race": "[zh]包 race：race 包实现数据竞争检测逻辑。\n不提供公开接口。\n有关竞态检测器的详细信息，请参见\nhttps://golang.org/doc/articles/race_detector.html",
  "runtime/race/internal/amd64v1": "[zh]包 amd64v1",
  "runtime/trace": "[zh]包 trace：trace 包提供了程序生成 Go 执行追踪器所需追踪数据的功能。\n\n# 追踪运行时活动\n\n执行追踪记录了多种执行事件，例如 goroutine 的创建/阻塞/解除阻塞、系统调用的进入/退出/阻塞、与垃圾回收相关的事件、堆大小变化、处理器的启动/停止等。当 CPU 分析处于激活状态时，执行追踪器会尽力包含这些采样数据。大多数事件都会记录精确到纳秒的时间戳和栈跟踪信息。生成的追踪数据可通过 `go tool trace` 工具进行解析。\n\n使用标准 testing 包构建的测试和基准测试的追踪支持已内建于 `go test` 命令中。例如，以下命令运行当前目录中的测试，并将追踪文件写入 trace.out：\n\n\tgo test -trace=trace.out\n\nruntime/trace 包提供了 API，可用于为独立程序添加类似的追踪支持。参见示例，了解如何使用此 API 启用追踪功能。\n\n此外，还提供了用于获取追踪数据的标准 HTTP 接口。添加以下代码行将在 /debug/pprof/trace URL 下注册一个处理器，用于下载实时追踪数据：\n\n\timport _ \"net/http/pprof\"\n\n有关此导入所安装的所有调试端点的更多细节，请参阅 [net/http/pprof] 包。\n\n# 用户注解\n\ntrace 包提供了用户注解 API，可用于在执行期间记录感兴趣的事件。\n\n用户注解分为三种类型：日志消息、区域和任务。\n\n[Log] 将一条带时间戳的消息写入执行追踪记录，同时附带额外信息，例如消息的类别以及调用 [Log] 的 goroutine。执行追踪器提供用户界面，可通过 [Log] 中提供的日志类别和消息对 goroutine 进行过滤和分组。\n\n区域用于记录 goroutine 执行过程中的一个时间区间。根据定义，一个区域的开始和结束必须在同一个 goroutine 中。区域可以嵌套，以表示子区间。例如，以下代码在执行追踪中记录了四个区域，用于追踪制作一杯卡布奇诺各个步骤的持续时间。\n\n\ttrace.WithRegion(ctx, \"makeCappuccino\", func() {\n\n\t   // orderID 用于从多个卡布奇诺订单区域记录中识别特定订单\n\t   trace.Log(ctx, \"orderID\", orderID)\n\n\t   trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n\t   trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n\t   trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n\t})\n\n任务是一种更高级别的组件，用于辅助追踪逻辑操作，例如 RPC 请求、HTTP 请求或可能需要多个 goroutine 协同完成的本地重要操作。由于任务可能涉及多个 goroutine，因此通过 [context.Context] 对象进行追踪。[NewTask] 创建一个新任务，并将其嵌入返回的 [context.Context] 对象中。日志消息和区域会关联到传给 [Log] 和 [WithRegion] 的上下文中的任务（如果存在）。\n\n例如，假设我们决定在独立的 goroutine 中分别执行打奶泡、萃取咖啡和混合牛奶与咖啡的操作。通过使用任务，追踪工具能够识别参与特定卡布奇诺订单的所有 goroutine。\n\n\tctx, task := trace.NewTask(ctx, \"makeCappuccino\")\n\ttrace.Log(ctx, \"orderID\", orderID)\n\n\tmilk := make(chan bool)\n\tespresso := make(chan bool)\n\n\tgo func() {\n\t        trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n\t        milk \u003c- true\n\t}()\n\tgo func() {\n\t        trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n\t        espresso \u003c- true\n\t}()\n\tgo func() {\n\t        defer task.End() // 当组装完成后，订单完成。\n\t        \u003c-espresso\n\t        \u003c-milk\n\t        trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n\t}()\n\n追踪工具通过测量任务创建到任务结束之间的时间来计算任务的延迟，并为追踪中发现的每种任务类型提供延迟分布。",
  "slices": "[zh]包 slices：slices 包定义了适用于任意类型切片的各种有用函数。",
  "sort": "[zh]包 sort：sort 包提供了用于对切片和用户定义集合进行排序的基本操作。",
  "strconv": "[zh]包 strconv：strconv 包实现了基本数据类型与字符串表示形式之间的相互转换。\n\n# 数值转换\n\n最常见的数值转换是 [Atoi]（字符串转整型）和 [Itoa]（整型转字符串）。\n\n\ti, err := strconv.Atoi(\"-42\")\n\ts := strconv.Itoa(-42)\n\n这些函数默认使用十进制和 Go 的 int 类型。\n\n[ParseBool]、[ParseFloat]、[ParseInt] 和 [ParseUint] 将字符串转换为对应值：\n\n\tb, err := strconv.ParseBool(\"true\")\n\tf, err := strconv.ParseFloat(\"3.1415\", 64)\n\ti, err := strconv.ParseInt(\"-42\", 10, 64)\n\tu, err := strconv.ParseUint(\"42\", 10, 64)\n\n解析函数返回最宽的类型（float64、int64 和 uint64），但如果大小参数指定了更窄的宽度，则结果可以在不丢失数据的情况下转换为该更窄的类型：\n\n\ts := \"2147483647\" // 最大的 int32\n\ti64, err := strconv.ParseInt(s, 10, 32)\n\t...\n\ti := int32(i64)\n\n[FormatBool]、[FormatFloat]、[FormatInt] 和 [FormatUint] 将值转换为字符串：\n\n\ts := strconv.FormatBool(true)\n\ts := strconv.FormatFloat(3.1415, 'E', -1, 64)\n\ts := strconv.FormatInt(-42, 16)\n\ts := strconv.FormatUint(42, 16)\n\n[AppendBool]、[AppendFloat]、[AppendInt] 和 [AppendUint] 功能类似，但将格式化后的值追加到目标切片中。\n\n# 字符串转换\n\n[Quote] 和 [QuoteToASCII] 将字符串转换为带引号的 Go 字符串字面量。后者通过将任何非 ASCII Unicode 使用 \\u 转义，保证结果为 ASCII 字符串：\n\n\tq := strconv.Quote(\"Hello, 世界\")\n\tq := strconv.QuoteToASCII(\"Hello, 世界\")\n\n[QuoteRune] 和 [QuoteRuneToASCII] 类似，但接受 rune 并返回带引号的 Go rune 字面量。\n\n[Unquote] 和 [UnquoteChar] 用于对 Go 字符串和字符字面量进行去引号操作。",
  "strings": "[zh]包 strings：strings 包实现了用于操作 UTF-8 编码字符串的简单函数。\n\n有关 Go 中 UTF-8 字符串的信息，请参见 https://blog.golang.org/strings。",
  "structs": "[zh]包 structs：包 structs 定义了可用作结构体字段的标记类型，以修改结构体的属性。\n\n按照约定，标记类型应作为名为 \"_\" 的字段的类型，置于结构体类型定义的开头。",
  "sync": "[zh]包 sync：sync 包提供了基本的同步原语，例如互斥锁。除了 [Once] 和 [WaitGroup] 类型之外，大多数类型供底层库例程使用。更高级别的同步应优先通过通道和通信来实现。\n\n包含该包中定义类型的值不应被复制。",
  "sync/atomic": "[zh]包 atomic：atomic 包提供了底层的原子内存原语，用于实现同步算法。\n\n正确使用这些函数需要格外谨慎。除非是特殊的低层应用，否则使用通道或 sync 包中的设施进行同步更为合适。通过通信来共享内存；不要通过共享内存来进行通信。\n\n由 SwapT 函数实现的交换操作，其原子等价形式为：\n\n\told = *addr\n\t*addr = new\n\treturn old\n\n由 CompareAndSwapT 函数实现的比较并交换操作，其原子等价形式为：\n\n\tif *addr == old {\n\t\t*addr = new\n\t\treturn true\n\t}\n\treturn false\n\n由 AddT 函数实现的加法操作，其原子等价形式为：\n\n\t*addr += delta\n\treturn *addr\n\n由 LoadT 和 StoreT 函数实现的加载与存储操作，其原子等价形式分别为 \"return *addr\" 和 \"*addr = val\"。\n\n根据 [Go 内存模型] 的术语，若一个原子操作 A 的效果被另一个原子操作 B 观察到，则 A “同步于” B 之前。此外，程序中所有原子操作的行为看起来如同以某种顺序一致性的方式执行。该定义提供的语义与 C++ 的顺序一致性原子操作以及 Java 的 volatile 变量相同。\n\n[the Go memory model]: https://go.dev/ref/mem",
  "syscall": "[zh]包 syscall：syscall 包提供了对底层操作系统原语的接口。具体细节因底层系统而异，默认情况下，godoc 会显示当前系统的 syscall 文档。若要让 godoc 显示其他系统的 syscall 文档，请设置 $GOOS 和 $GOARCH 为所需的目标系统。例如，若要在 linux/amd64 上查看 freebsd/arm 的文档，请将 $GOOS 设为 freebsd，$GOARCH 设为 arm。\n\nsyscall 包主要供其他提供更可移植系统接口的包（如 \"os\"、\"time\" 和 \"net\"）内部使用。在可能的情况下，应优先使用这些包而非 syscall 包。\n\n有关此包中函数和数据类型的详细信息，请参考相应操作系统的手册。\n\n这些调用通过返回 err == nil 表示成功；否则 err 为描述失败的操作系统错误。在大多数系统上，该错误的类型为 [Errno]。\n\n注意：此包中定义的大多数函数、类型和常量也在 [golang.org/x/sys] 包中提供。该包支持更多的系统调用，且大多数新代码应尽可能优先使用该包。更多信息请参见 https://golang.org/s/go1.4-syscall。",
  "testing/fstest": "[zh]包 fstest：fstest 包为测试文件系统的实现和使用者提供了支持。",
  "testing/internal/testdeps": "[zh]包 testdeps：testdeps 包提供测试执行所需依赖项的访问。\n\n该包由生成的主包导入，主包将 TestDeps 传递给 testing.Main。这使得测试可以在运行时使用其他包，而无需将这些包作为 testing 包的直接依赖。若作为 testing 包的直接依赖，则更难为这些包编写测试。",
  "testing/iotest": "[zh]包 iotest：iotest 包实现了主要用于测试的 Reader 和 Writer。",
  "testing/quick": "[zh]包 quick：quick 包实现了用于黑盒测试的实用函数。\n\ntesting/quick 包已冻结，不再接受新功能。",
  "testing/slogtest": "[zh]包 slogtest：slogtest 包提供了用于测试 log/slog.Handler 实现的支持。",
  "text/scanner": "[zh]包 scanner：scanner 包为 UTF-8 编码的文本提供扫描器和分词器。  \n它接收一个提供源数据的 io.Reader，然后通过重复调用 Scan 函数进行分词。为了与现有工具兼容，不允许出现 NUL 字符。如果源数据的第一个字符是 UTF-8 编码的字节顺序标记（BOM），则将其丢弃。\n\n默认情况下，[Scanner] 会跳过空白字符和 Go 注释，并识别 Go 语言规范中定义的所有字面量。可通过配置使其仅识别部分字面量，或识别不同的标识符和空白字符。",
  "text/tabwriter": "[zh]包 tabwriter：Package tabwriter 实现了一个写过滤器（tabwriter.Writer），可将输入中带制表符的列转换为正确对齐的文本。\n\n该包使用了 Elastic Tabstops 算法，描述见 http://nickgravgaard.com/elastictabstops/index.html。\n\ntext/tabwriter 包已冻结，不再接受新功能。",
  "text/template/parse": "[zh]包 parse：parse 包为 text/template 和 html/template 定义的模板构建解析树。客户端应使用这些包来构造模板，而不是使用本包，因为本包提供的是共享的内部数据结构，不供一般使用。",
  "time": "[zh]包 time：time 包提供了测量和显示时间的功能。\n\n日历计算始终假定使用公历，且不包含闰秒。\n\n# 单调时钟\n\n操作系统提供了一个“壁钟”（wall clock），其时间可能因时钟同步而发生变化，以及一个“单调时钟”（monotonic clock），其时间不会回退或跳跃。一般规则是，壁钟用于表示当前时间，而单调时钟用于测量时间间隔。为了不将 API 分离，本包中 [time.Now] 返回的 Time 同时包含壁钟读数和单调时钟读数；后续的时间表示操作使用壁钟读数，而后续的时间测量操作（特别是比较和减法）则使用单调时钟读数。\n\n例如，以下代码总是计算出大约 20 毫秒的正值经过时间，即使在被计时的操作期间壁钟被修改：\n\n\tstart := time.Now()\n\t... 耗时 20 毫秒的操作 ...\n\tt := time.Now()\n\telapsed := t.Sub(start)\n\n其他惯用形式，如 [time.Since](start)、[time.Until](deadline) 和 time.Now().Before(deadline)，同样对壁钟重置具有鲁棒性。\n\n本节其余部分详细说明了操作如何使用单调时钟，但理解这些细节并非使用此包所必需。\n\ntime.Now 返回的 Time 包含单调时钟读数。若 Time t 具有单调时钟读数，则 t.Add 将相同持续时间同时加到壁钟和单调时钟读数上以计算结果。由于 t.AddDate(y, m, d)、t.Round(d) 和 t.Truncate(d) 是基于壁面时间的计算，它们总是从结果中移除任何单调时钟读数。由于 t.In、t.Local 和 t.UTC 的作用在于改变壁面时间的解释方式，因此它们也会从结果中移除单调时钟读数。移除单调时钟读数的标准方法是使用 t = t.Round(0)。\n\n如果 Times t 和 u 都包含单调时钟读数，则操作 t.After(u)、t.Before(u)、t.Equal(u)、t.Compare(u) 和 t.Sub(u) 仅使用单调时钟读数进行计算，忽略壁钟读数。如果 t 或 u 中任一不包含单调时钟读数，则这些操作退回到使用壁钟读数。\n\n在某些系统上，当计算机进入睡眠状态时，单调时钟会停止。在此类系统上，t.Sub(u) 可能无法准确反映 t 和 u 之间实际经过的时间。此情况同样适用于其他涉及时间相减的函数和方法，例如 [Since]、[Until]、[Time.Before]、[Time.After]、[Time.Add]、[Time.Equal] 和 [Time.Compare]。在某些情况下，您可能需要移除单调时钟读数以获得准确结果。\n\n由于单调时钟读数在当前进程之外无意义，因此由 t.GobEncode、t.MarshalBinary、t.MarshalJSON 和 t.MarshalText 生成的序列化形式会省略单调时钟读数，且 t.Format 不提供格式化该读数的方式。类似地，构造函数 [time.Date]、[time.Parse]、[time.ParseInLocation] 和 [time.Unix]，以及反序列化方法 t.GobDecode、t.UnmarshalBinary、t.UnmarshalJSON 和 t.UnmarshalText 总是创建不含单调时钟读数的 Time 值。\n\n单调时钟读数仅存在于 [Time] 值中。它不是 [Duration] 值的一部分，也不是 t.Unix 等函数返回的 Unix 时间的一部分。\n\n注意，Go 的 == 操作符不仅比较时间点，还比较 [Location] 和单调时钟读数。有关 Time 值相等性比较的讨论，请参阅 Time 类型的文档。\n\n用于调试时，若存在单调时钟读数，t.String 的结果会包含该读数。如果 t != u 是由于单调时钟读数不同所致，则在打印 t.String() 和 u.String() 时可观察到这一差异。\n\n# 定时器分辨率\n\n[Timer] 的分辨率因 Go 运行时、操作系统及底层硬件而异。\n在 Unix 系统上，分辨率为 ~1ms。\n在 Windows 1803 及更高版本上，分辨率为 ~0.5ms。\n在较早版本的 Windows 上，默认分辨率为 ~16ms，但可通过 [golang.org/x/sys/windows.TimeBeginPeriod] 请求更高分辨率。",
  "time/tzdata": "[zh]包 tzdata：tzdata 包提供了时区数据库的嵌入副本。  \n如果程序中导入了此包，那么当 time 包无法在系统上找到 tzdata 文件时，将使用此嵌入的数据。\n\n导入此包会使程序大小增加约 450 KB。\n\n此包通常应由程序的 main 包导入，而不应由库导入。库通常不应决定是否在程序中包含时区数据库。\n\n如果使用 -tags timetzdata 构建，则会自动导入此包。",
  "unicode": "[zh]包 unicode：unicode 包提供了用于测试 Unicode 码点某些属性的数据和函数。",
  "unicode/utf16": "[zh]包 utf16：utf16 包实现了 UTF-16 序列的编码和解码。",
  "unicode/utf8": "[zh]包 utf8：utf8 包实现了用于支持 UTF-8 编码文本的函数和常量。包括在符文（rune）与 UTF-8 字节序列之间转换的函数。\n参见 https://zh.wikipedia.org/wiki/UTF-8",
  "unique": "[zh]包 unique：unique 包提供了对可比较值进行规范化（“驻留”）的功能。",
  "unsafe": "[zh]包 unsafe",
  "vendor/golang.org/x/crypto/chacha20": "[zh]包 chacha20：chacha20 包实现了 RFC 8439 和 draft-irtf-cfrg-xchacha-01 中规定的 ChaCha20 和 XChaCha20 加密算法。",
  "vendor/golang.org/x/crypto/chacha20poly1305": "[zh]包 chacha20poly1305：实现 ChaCha20-Poly1305 AEAD 及其扩展随机数变体 XChaCha20-Poly1305，如 RFC 8439 和 draft-irtf-cfrg-xchacha-01 所定义。",
  "vendor/golang.org/x/crypto/cryptobyte": "[zh]包 cryptobyte：该包包含有助于解析和构造带长度前缀的二进制消息（包括 ASN.1 DER）的类型。（asn1 子包包含有用的 ASN.1 常量。）\n\nString 类型用于解析。它封装了一个 []byte 切片，并提供了逐个消费结构和值的辅助函数。\n\nBuilder 类型用于构造消息。它提供了追加值的辅助函数，以及追加带长度前缀的子消息的辅助函数——无需预先计算长度前缀。\n\n请参阅 Builder 和 String 类型的文档和示例以开始使用。",
  "vendor/golang.org/x/crypto/cryptobyte/asn1": "[zh]包 asn1：asn1 包包含使用 cryptobyte 包解析和构建 ASN.1 消息的辅助类型。",
  "vendor/golang.org/x/crypto/internal/alias": "[zh]包别名：包 alias 实现了内存别名测试。",
  "vendor/golang.org/x/crypto/internal/poly1305": "[zh]包 poly1305：该包实现了 Poly1305 一次性消息认证码，具体规范见 https://cr.yp.to/mac/poly1305-20050329.pdf。\n\nPoly1305 是一种快速的一次性认证函数。攻击者在没有密钥的情况下无法为消息生成有效的认证码。但一个密钥只能用于单条消息。使用同一密钥认证两条不同消息时，攻击者可利用此构造其他消息的有效认证码。\n\nPoly1305 最初与 AES 结合使用，构成 Poly1305-AES。其中 AES 使用固定密钥，根据随机数（nonce）生成一次性密钥。但在本包中不使用 AES，而是一次性密钥直接指定。",
  "vendor/golang.org/x/net/dns/dnsmessage": "[zh]包 dnsmessage：dnsmessage 包提供了基本符合 RFC 1035 的 DNS 消息打包和解包实现。\n\n该包还支持 RFC 6891 定义的 DNS 扩展机制（EDNS(0)）消息。\n\n本实现旨在尽量减少堆分配，并尽可能避免不必要的打包和解包操作。",
  "vendor/golang.org/x/net/http/httpguts": "[zh]包 httpguts：httpguts 包提供了实现 HTTP 规范各个细节的函数。\n\n该包由标准库（通过 vendoring 引入）和 x/net/http2 共享。不提供 API 稳定性保证。",
  "vendor/golang.org/x/net/http/httpproxy": "[zh]包 httpproxy：httpproxy 包提供基于环境变量的 HTTP 代理判定支持，与 net/http 的 ProxyFromEnvironment 函数所提供的功能一致。\n\n本 API 不受 Go 1 兼容性承诺的约束，可能随时更改。",
  "vendor/golang.org/x/net/http2/hpack": "[zh]包 hpack：hpack 包实现了 HPACK，一种用于在 HTTP/2 环境中高效表示 HTTP 头字段的压缩格式。\n\n参见 http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09",
  "vendor/golang.org/x/net/idna": "[zh]包 idna：本包实现了 IDNA2008，采用 UTS（Unicode 技术标准）#46 定义的兼容性处理方式，该标准定义了从 IDNA2003 过渡的规范。\n\nIDNA2008（应用程序中的国际化域名）定义于 RFC 5890、RFC 5891、RFC 5892、RFC 5893 和 RFC 5894。  \nUTS #46 定义于 https://www.unicode.org/reports/tr46。  \n有关这两个标准之间差异的可视化，请参见 https://unicode.org/cldr/utility/idna.jsp。",
  "vendor/golang.org/x/net/nettest": "[zh]包 nettest：nettest 包提供用于网络测试的工具。",
  "vendor/golang.org/x/sys/cpu": "[zh]包 cpu：cpu 包为多种 CPU 架构实现处理器特性检测。",
  "vendor/golang.org/x/text/secure/bidirule": "[zh]包 bidirule：bidirule 包实现了 RFC 5893 定义的双向文本规则。\n\n此包处于开发阶段。API 可能在不通知的情况下变更，且不保证向后兼容性。",
  "vendor/golang.org/x/text/transform": "[zh]包 transform：transform 包提供了转换通过的字节的读取器和写入器包装器，以及各种转换功能。其他包提供的示例转换包括规范化和字符集之间的转换。",
  "vendor/golang.org/x/text/unicode/bidi": "[zh]包 bidi：bidi 包包含对双向文本支持的功能。\n\n参见 https://www.unicode.org/reports/tr9。\n\n注意：正在构建中。此 API 可能以不兼容的方式发生变更，且恕不另行通知。",
  "vendor/golang.org/x/text/unicode/norm": "[zh]包 norm：norm 包包含用于规范化 Unicode 字符串的类型和函数。",
  "weak": "[zh]包 weak：weak 包提供了安全地弱引用内存的方法，即在不阻止其被回收的情况下进行引用。"
}